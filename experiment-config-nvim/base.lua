local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
if not (vim.uv or vim.loop).fs_stat(lazypath) then
  vim.fn.system({ lazy = true,
    "git",
    "clone",
    "--filter=blob:none",
    "https://github.com/folke/lazy.nvim.git",
    "--branch=stable", -- latest stable release
    lazypath,
  })
end
vim.opt.rtp:prepend(lazypath)

require("lazy").setup({
{
  'NvChad/nvim-colorizer.lua',
  'ziontee113/color-picker.nvim',
  "utilyre/barbecue.nvim",
  'Bekaboo/dropbar.nvim',
  "SmiteshP/nvim-navic",
  'nvim-lualine/lualine.nvim',
  'b0o/incline.nvim',
 'lewis6991/gitsigns.nvim', -- OPTIONAL: for git status
  'romgrk/barbar.nvim',
 'RRethy/vim-illuminate',
   'nvim-tree/nvim-web-devicons', 
 'yaocccc/nvim-foldsign',
   'declancm/cinnamon.nvim',
 'vidocqh/auto-indent.nvim',
  "lukas-reineke/indent-blankline.nvim",
  'nvim-focus/focus.nvim',
   'otavioschwanck/tmux-awesome-manager.nvim',
 "CWood-sdf/pineapple",
 'Mofiqul/vscode.nvim',
  "tjdevries/colorbuddy.nvim",
  config = function()

    --colorizer
    require("colorizer").setup {
      filetypes = { "*" },
      user_default_options = {
        RGB = true, -- #RGB hex codes
        RRGGBB = true, -- #RRGGBB hex codes
        names = true, -- "Name" codes like Blue or blue
        RRGGBBAA = false, -- #RRGGBBAA hex codes
        AARRGGBB = false, -- 0xAARRGGBB hex codes
        rgb_fn = false, -- CSS rgb() and rgba() functions
        hsl_fn = false, -- CSS hsl() and hsla() functions
        css = false, -- Enable all CSS features: rgb_fn, hsl_fn, names, RGB, RRGGBB
        css_fn = false, -- Enable all CSS *functions*: rgb_fn, hsl_fn
        -- Available modes for `mode`: foreground, background,  virtualtext
        mode = "background", -- Set the display mode.
        -- Available methods are false / true / "normal" / "lsp" / "both"
        -- True is same as normal
        tailwind = false, -- Enable tailwind colors
        -- parsers can contain values used in |user_default_options|
        sass = { enable = false, parsers = { "css" }, }, -- Enable sass colors
        virtualtext = "■",
        -- update color values even if buffer is not focused
        -- example use: cmp_menu, cmp_docs
        always_update = false
      },
      -- all the sub-options of filetypes apply to buftypes
      buftypes = {},
    }
    -- Alwyas update the color values in cmp_docs even if it not focused
    require("colorizer").setup({
      filetypes = {
        '*'; -- Highlight all files, but customize some others.
        cmp_docs = {always_update = true}
      },
    })




    --color-picker
    local opts = { noremap = true, silent = true }

    vim.keymap.set("n", "<C-c>", "<cmd>PickColor<cr>", opts)
    vim.keymap.set("i", "<C-c>", "<cmd>PickColorInsert<cr>", opts)

    -- vim.keymap.set("n", "your_keymap", "<cmd>ConvertHEXandRGB<cr>", opts)
    -- vim.keymap.set("n", "your_keymap", "<cmd>ConvertHEXandHSL<cr>", opts)

    require("color-picker").setup({ -- for changing icons & mappings
      -- ["icons"] = { "ﱢ", "" },
      -- ["icons"] = { "ﮊ", "" },
      -- ["icons"] = { "", "ﰕ" },
      -- ["icons"] = { "", "" },
      -- ["icons"] = { "", "" },
      ["icons"] = { "ﱢ", "" },
      ["border"] = "rounded", -- none | single | double | rounded | solid | shadow
      ["keymap"] = { -- mapping example:
        ["U"] = "<Plug>ColorPickerSlider5Decrease",
        ["O"] = "<Plug>ColorPickerSlider5Increase",
      },
      ["background_highlight_group"] = "Normal", -- default
      ["border_highlight_group"] = "FloatBorder", -- default
      ["text_highlight_group"] = "Normal", --default
    })

    vim.cmd([[hi FloatBorder guibg=NONE]]) -- if you don't want weird border background colors around the popup.








    --barbecue,dropbar,nvim-navic
    -- triggers CursorHold event faster
    vim.opt.updatetime = 200

    require("barbecue").setup({
      create_autocmd = false, -- prevent barbecue from updating itself automatically
    })

    vim.api.nvim_create_autocmd({
      "WinScrolled", -- or WinResized on NVIM-v0.9 and higher
      "BufWinEnter",
      "CursorHold",
      "InsertLeave",

      -- include this if you have set `show_modified` to `true`
      "BufModifiedSet",
    }, {
      group = vim.api.nvim_create_augroup("barbecue.updater", {}),
      callback = function()
        require("barbecue.ui").update()
      end,
    })

    require("barbecue").setup({
      theme = {
        -- this highlight is used to override other highlights
        -- you can take advantage of its `bg` and set a background throughout your winbar
        -- (e.g. basename will look like this: { fg = "#c0caf5", bold = true })
        normal = { fg = "#c0caf5" },

        -- these highlights correspond to symbols table from config
        ellipsis = { fg = "#737aa2" },
        separator = { fg = "#737aa2" },
        modified = { fg = "#737aa2" },

        -- these highlights represent the _text_ of three main parts of barbecue
        dirname = { fg = "#737aa2" },
        basename = { bold = true },
        context = {},

        -- these highlights are used for context/navic icons
        context_file = { fg = "#ac8fe4" },
        context_module = { fg = "#ac8fe4" },
        context_namespace = { fg = "#ac8fe4" },
        context_package = { fg = "#ac8fe4" },
        context_class = { fg = "#ac8fe4" },
        context_method = { fg = "#ac8fe4" },
        context_property = { fg = "#ac8fe4" },
        context_field = { fg = "#ac8fe4" },
        context_constructor = { fg = "#ac8fe4" },
        context_enum = { fg = "#ac8fe4" },
        context_interface = { fg = "#ac8fe4" },
        context_function = { fg = "#ac8fe4" },
        context_variable = { fg = "#ac8fe4" },
        context_constant = { fg = "#ac8fe4" },
        context_string = { fg = "#ac8fe4" },
        context_number = { fg = "#ac8fe4" },
        context_boolean = { fg = "#ac8fe4" },
        context_array = { fg = "#ac8fe4" },
        context_object = { fg = "#ac8fe4" },
        context_key = { fg = "#ac8fe4" },
        context_null = { fg = "#ac8fe4" },
        context_enum_member = { fg = "#ac8fe4" },
        context_struct = { fg = "#ac8fe4" },
        context_event = { fg = "#ac8fe4" },
        context_operator = { fg = "#ac8fe4" },
        context_type_parameter = { fg = "#ac8fe4" },
      },
    })

    require("barbecue").setup({
      ---Whether to attach navic to language servers automatically.
      ---
      ---@type boolean
      attach_navic = true,

      ---Whether to create winbar updater autocmd.
      ---
      ---@type boolean
      create_autocmd = true,

      ---Buftypes to enable winbar in.
      ---
      ---@type string[]
      include_buftypes = { "" },

      ---Filetypes not to enable winbar in.
      ---
      ---@type string[]
      exclude_filetypes = { "netrw", "toggleterm" },

      modifiers = {
        ---Filename modifiers applied to dirname.
        ---
        ---See: `:help filename-modifiers`
        ---
        ---@type string
        dirname = ":~:.",

        ---Filename modifiers applied to basename.
        ---
        ---See: `:help filename-modifiers`
        ---
        ---@type string
        basename = "",
      },

      ---Whether to display path to file.
      ---
      ---@type boolean
      show_dirname = true,

      ---Whether to display file name.
      ---
      ---@type boolean
      show_basename = true,

      ---Whether to replace file icon with the modified symbol when buffer is
      ---modified.
      ---
      ---@type boolean
      show_modified = false,

      ---Get modified status of file.
      ---
      ---NOTE: This can be used to get file modified status from SCM (e.g. git)
      ---
      ---@type fun(bufnr: number): boolean
      modified = function(bufnr) return vim.bo[bufnr].modified end,

      ---Whether to show/use navic in the winbar.
      ---
      ---@type boolean
      show_navic = true,

      ---Get leading custom section contents.
      ---
      ---NOTE: This function shouldn't do any expensive actions as it is run on each
      ---render.
      ---
      ---@type fun(bufnr: number, winnr: number): barbecue.Config.custom_section
      lead_custom_section = function() return " " end,

      ---@alias barbecue.Config.custom_section
      ---|string # Literal string.
      ---|{ [1]: string, [2]: string? }[] # List-like table of `[text, highlight?]` tuples in which `highlight` is optional.
      ---
      ---Get custom section contents.
      ---
      ---NOTE: This function shouldn't do any expensive actions as it is run on each
      ---render.
      ---
      ---@type fun(bufnr: number, winnr: number): barbecue.Config.custom_section
      custom_section = function() return " " end,

      ---@alias barbecue.Config.theme
      ---|'"auto"' # Use your current colorscheme's theme or generate a theme based on it.
      ---|string # Theme located under `barbecue.theme` module.
      ---|barbecue.Theme # Same as '"auto"' but override it with the given table.
      ---
      ---Theme to be used for generating highlight groups dynamically.
      ---
      ---@type barbecue.Config.theme
      theme = "auto",

      ---Whether context text should follow its icon's color.
      ---
      ---@type boolean
      context_follow_icon_color = false,

      symbols = {
        ---Modification indicator.
        ---
        ---@type string
        modified = "●",

        ---Truncation indicator.
        ---
        ---@type string
        ellipsis = "…",

        ---Entry separator.
        ---
        ---@type string
        separator = "",
      },

      ---@alias barbecue.Config.kinds
      ---|false # Disable kind icons.
      ---|table<string, string> # Type to icon mapping.
      ---
      ---Icons for different context entry kinds.
      ---
      ---@type barbecue.Config.kinds
      kinds = {
        File = "",
        Module = "",
        Namespace = "",
        Package = "",
        Class = "",
        Method = "",
        Property = "",
        Field = "",
        Constructor = "",
        Enum = "",
        Interface = "",
        Function = "",
        Variable = "",
        Constant = "",
        String = "",
        Number = "",
        Boolean = "",
        Array = "",
        Object = "",
        Key = "",
        Null = "",
        EnumMember = "",
        Struct = "",
        Event = "",
        Operator = "",
        TypeParameter = "",
      },
    })
    local M = require("dropbar")
    ---@class dropbar_configs_t
    M.opts = {
      general = {
        ---@type boolean|fun(buf: integer, win: integer, info: table?): boolean
        enable = function(buf, win, _)
          return vim.fn.win_gettype(win) == ''
            and vim.wo[win].winbar == ''
            and vim.bo[buf].bt == ''
            and (
            vim.bo[buf].ft == 'markdown'
            or (
            buf
            and vim.api.nvim_buf_is_valid(buf)
            and (pcall(vim.treesitter.get_parser, buf, vim.bo[buf].ft))
            and true
            or false
            )
            )
        end,
        attach_events = {
          'OptionSet',
          'BufWinEnter',
          'BufWritePost',
        },
        -- Wait for a short time before updating the winbar, if another update
        -- request is received within this time, the previous request will be
        -- cancelled, this improves the performance when the user is holding
        -- down a key (e.g. 'j') to scroll the window, default to 0 ms
        -- If you encounter performance issues when scrolling the window, try
        -- setting this option to a number slightly larger than
        -- 1000 / key_repeat_rate
        update_interval = 0,
        update_events = {
          win = {
            'CursorMoved',
            'CursorMovedI',
            'WinEnter',
            'WinResized',
          },
          buf = {
            'BufModifiedSet',
            'FileChangedShellPost',
            'TextChanged',
            'TextChangedI',
          },
          global = {
            'DirChanged',
            'VimResized',
          },
        },
      },
      icons = {
        enable = true,
        kinds = {
          use_devicons = true,
          symbols = {
            Array = '󰅪 ',
            Boolean = ' ',
            BreakStatement = '󰙧 ',
            Call = '󰃷 ',
            CaseStatement = '󱃙 ',
            Class = ' ',
            Color = '󰏘 ',
            Constant = '󰏿 ',
            Constructor = ' ',
            ContinueStatement = '→ ',
            Copilot = ' ',
            Declaration = '󰙠 ',
            Delete = '󰩺 ',
            DoStatement = '󰑖 ',
            Enum = ' ',
            EnumMember = ' ',
            Event = ' ',
            Field = ' ',
            File = '󰈔 ',
            Folder = '󰉋 ',
            ForStatement = '󰑖 ',
            Function = '󰊕 ',
            H1Marker = '󰉫 ', -- Used by markdown treesitter parser
            H2Marker = '󰉬 ',
            H3Marker = '󰉭 ',
            H4Marker = '󰉮 ',
            H5Marker = '󰉯 ',
            H6Marker = '󰉰 ',
            Identifier = '󰀫 ',
            IfStatement = '󰇉 ',
            Interface = ' ',
            Keyword = '󰌋 ',
            List = '󰅪 ',
            Log = '󰦪 ',
            Lsp = ' ',
            Macro = '󰁌 ',
            MarkdownH1 = '󰉫 ', -- Used by builtin markdown source
            MarkdownH2 = '󰉬 ',
            MarkdownH3 = '󰉭 ',
            MarkdownH4 = '󰉮 ',
            MarkdownH5 = '󰉯 ',
            MarkdownH6 = '󰉰 ',
            Method = '󰆧 ',
            Module = '󰏗 ',
            Namespace = '󰅩 ',
            Null = '󰢤 ',
            Number = '󰎠 ',
            Object = '󰅩 ',
            Operator = '󰆕 ',
            Package = '󰆦 ',
            Pair = '󰅪 ',
            Property = ' ',
            Reference = '󰦾 ',
            Regex = ' ',
            Repeat = '󰑖 ',
            Scope = '󰅩 ',
            Snippet = '󰩫 ',
            Specifier = '󰦪 ',
            Statement = '󰅩 ',
            String = '󰉾 ',
            Struct = ' ',
            SwitchStatement = '󰺟 ',
            Terminal = ' ',
            Text = ' ',
            Type = ' ',
            TypeParameter = '󰆩 ',
            Unit = ' ',
            Value = '󰎠 ',
            Variable = '󰀫 ',
            WhileStatement = '󰑖 ',
          },
        },
        ui = {
          bar = {
            separator = ' ',
            extends = '…',
          },
          menu = {
            separator = ' ',
            indicator = ' ',
          },
        },
      },
      symbol = {
        preview = {
          ---Reorient the preview window on previewing a new symbol
          ---@param _ integer source window id, ignored
          ---@param range {start: {line: integer}, end: {line: integer}} 0-indexed
          reorient = function(_, range)
            local invisible = range['end'].line - vim.fn.line('w$') + 1
            if invisible > 0 then
              local view = vim.fn.winsaveview() --[[@as vim.fn.winrestview.dict]]
              view.topline = math.min(
                view.topline + invisible,
                math.max(1, range.start.line - vim.wo.scrolloff + 1)
              )
              vim.fn.winrestview(view)
            end
          end,
        },
        jump = {
          ---@param win integer source window id
          ---@param range {start: {line: integer}, end: {line: integer}} 0-indexed
          reorient = function(win, range)
            local view = vim.fn.winsaveview()
            local win_height = vim.api.nvim_win_get_height(win)
            local topline = range.start.line - math.floor(win_height / 4)
            if
              topline > view.topline
              and topline + win_height < vim.fn.line('$')
            then
              view.topline = topline
              vim.fn.winrestview(view)
            end
          end,
        },
      },
      bar = {
        hover = true,
        ---@type dropbar_source_t[]|fun(buf: integer, win: integer): dropbar_source_t[]
        sources = function(buf, _)
          local sources = require('dropbar.sources')
          if vim.bo[buf].ft == 'markdown' then
            return {
              sources.path,
              sources.markdown,
            }
          end
          if vim.bo[buf].buftype == 'terminal' then
            return {
              sources.terminal,
            }
          end
          return {
            sources.path,
            utils.source.fallback({
              sources.lsp,
              sources.treesitter,
            }),
          }
        end,
        padding = {
          left = 1,
          right = 1,
        },
        pick = {
          pivots = 'abcdefghijklmnopqrstuvwxyz',
        },
        truncate = true,
      },
      menu = {
        -- When on, preview the symbol under the cursor on CursorMoved
        preview = true,
        -- When on, automatically set the cursor to the closest previous/next
        -- clickable component in the direction of cursor movement on CursorMoved
        quick_navigation = true,
        entry = {
          padding = {
            left = 1,
            right = 1,
          },
        },
        -- Menu scrollbar options
        scrollbar = {
          enable = true,
          -- The background / gutter of the scrollbar
          -- When false, only the scrollbar thumb is shown.
          background = true
        },
        ---@type table<string, string|function|table<string, string|function>>
        keymaps = {
          ['q'] = '<C-w>q',
          ['<Esc>'] = '<C-w>q',
          ['<LeftMouse>'] = function()
            local menu = utils.menu.get_current()
            if not menu then
              return
            end
            local mouse = vim.fn.getmousepos()
            local clicked_menu = utils.menu.get({ win = mouse.winid })
            -- If clicked on a menu, invoke the corresponding click action,
            -- else close all menus and set the cursor to the clicked window
            if clicked_menu then
              clicked_menu:click_at({ mouse.line, mouse.column - 1 }, nil, 1, 'l')
              return
            end
            utils.menu.exec('close')
            utils.bar.exec('update_current_context_hl')
            if vim.api.nvim_win_is_valid(mouse.winid) then
              vim.api.nvim_set_current_win(mouse.winid)
            end
          end,
          ['<CR>'] = function()
            local menu = utils.menu.get_current()
            if not menu then
              return
            end
            local cursor = vim.api.nvim_win_get_cursor(menu.win)
            local component = menu.entries[cursor[1]]:first_clickable(cursor[2])
            if component then
              menu:click_on(component, nil, 1, 'l')
            end
          end,
          ['<MouseMove>'] = function()
            local menu = utils.menu.get_current()
            if not menu then
              return
            end
            local mouse = vim.fn.getmousepos()
            utils.menu.update_hover_hl(mouse)
            if M.opts.menu.preview then
              utils.menu.update_preview(mouse)
            end
          end,
          ['i'] = function()
            local menu = utils.menu.get_current()
            if not menu then
              return
            end
            menu:fuzzy_find_open()
          end,
        },
        ---@alias dropbar_menu_win_config_opts_t any|fun(menu: dropbar_menu_t):any
        ---@type table<string, dropbar_menu_win_config_opts_t>
        ---@see vim.api.nvim_open_win
        win_configs = {
          border = 'none',
          style = 'minimal',
          row = function(menu)
            return menu.prev_menu
              and menu.prev_menu.clicked_at
              and menu.prev_menu.clicked_at[1] - vim.fn.line('w0')
              or 0
          end,
          ---@param menu dropbar_menu_t
          col = function(menu)
            if menu.prev_menu then
              return menu.prev_menu._win_configs.width
                + (
                menu.prev_menu.scrollbar
                and menu.prev_menu.scrollbar.background
                and 1
                or 0
                )
            end
            local mouse = vim.fn.getmousepos()
            local bar = utils.bar.get({ win = menu.prev_win })
            if not bar then
              return mouse.wincol
            end
            local _, range = bar:get_component_at(math.max(0, mouse.wincol - 1))
            return range and range.start or mouse.wincol
          end,
          relative = 'win',
          win = function(menu)
            return menu.prev_menu and menu.prev_menu.win
              or vim.fn.getmousepos().winid
          end,
          height = function(menu)
            return math.max(
              1,
              math.min(
                #menu.entries,
                vim.go.pumheight ~= 0 and vim.go.pumheight
                or math.ceil(vim.go.lines / 4)
              )
            )
          end,
          width = function(menu)
            local min_width = vim.go.pumwidth ~= 0 and vim.go.pumwidth or 8
            if vim.tbl_isempty(menu.entries) then
              return min_width
            end
            return math.max(
              min_width,
              math.max(unpack(vim.tbl_map(function(entry)
                return entry:displaywidth()
              end, menu.entries)))
            )
          end,
          zindex = function(menu)
            if menu.prev_menu then
              if menu.prev_menu.scrollbar and menu.prev_menu.scrollbar.thumb then
                return vim.api.nvim_win_get_config(menu.prev_menu.scrollbar.thumb).zindex
              end
              return vim.api.nvim_win_get_config(menu.prev_win).zindex
            end
          end,
        },
      },
      fzf = {
        ---@type table<string, string | fun()>
        keymaps = {
          ['<LeftMouse>'] = function()
            ---@type dropbar_menu_t
            local menu = utils.menu.get_current()
            if not menu then
              return
            end
            local mouse = vim.fn.getmousepos()
            if not mouse then
              return
            end
            if mouse.winid ~= menu.win then
              local default_func = M.opts.menu.keymaps['<LeftMouse>']
              if type(default_func) == 'function' then
                default_func()
              end
              menu:fuzzy_find_close()
              return
            elseif mouse.winrow > vim.api.nvim_buf_line_count(menu.buf) then
              return
            end
            vim.api.nvim_win_set_cursor(menu.win, { mouse.line, mouse.column - 1 })
            menu:fuzzy_find_click_on_entry(function(entry)
              return entry:get_component_at(mouse.column - 1, true)
            end)
          end,
          ['<MouseMove>'] = function()
            ---@type dropbar_menu_t
            local menu = utils.menu.get_current()
            if not menu then
              return
            end
            local mouse = vim.fn.getmousepos()
            if not mouse then
              return
            end
            -- If mouse is not in the menu window or on the border, end preview
            -- and clear hover highlights
            if
              mouse.winid ~= menu.win
              or mouse.line <= 0
              or mouse.column <= 0
              or mouse.winrow > (#menu.entries + 1)
            then
              -- Find the root menu
              while menu and menu.prev_menu do
                menu = menu.prev_menu
              end
              if menu then
                menu:finish_preview(true)
                menu:update_hover_hl()
              end
              return
            end
            if M.opts.menu.preview then
              menu:preview_symbol_at({ mouse.line, mouse.column - 1 }, true)
            end
            menu:update_hover_hl({ mouse.line, mouse.column - 1 })
          end,
          ['<Up>'] = api.fuzzy_find_prev,
          ['<Down>'] = api.fuzzy_find_next,
          ['<C-k>'] = api.fuzzy_find_prev,
          ['<C-j>'] = api.fuzzy_find_next,
          ['<C-p>'] = api.fuzzy_find_prev,
          ['<C-n>'] = api.fuzzy_find_next,
          ['<Enter>'] = api.fuzzy_find_click,
          ['<S-Enter>'] = function()
            api.fuzzy_find_click(-1)
          end,
        },
        win_configs = {
          relative = 'win',
          anchor = 'NW',
          height = 1,
          win = function(menu)
            return menu.win
          end,
          width = function(menu)
            local function border_width(border)
              if type(border) == 'string' then
                if border == 'none' or border == 'shadow' then
                  return 0
                end
                return 2 -- left and right border
              end

              local left, right = 1, 1
              if
                (#border == 1 and border[1] == '')
                or (#border == 4 and border[4] == '')
                or (#border == 8 and border[8] == '')
              then
                left = 0
              end
              if
                (#border == 1 and border[1] == '')
                or (#border == 4 and border[4] == '')
                or (#border == 8 and border[4] == '')
              then
                right = 0
              end
              return left + right
            end
            local menu_width = menu._win_configs.width
              + border_width(menu._win_configs.border)
            local self_width = menu._win_configs.width
            local self_border = border_width(
              (
              M.opts.fzf.win_configs
              and M.eval(M.opts.fzf.win_configs.border, menu)
              )
              or (menu.fzf_win_configs and M.eval(
                menu.fzf_win_configs.border,
                menu
              ))
              or menu._win_configs.border
            )

            if self_width + self_border > menu_width then
              return self_width - self_border
            else
              return menu_width - self_border
            end
          end,
          row = function(menu)
            local menu_border = menu._win_configs.border
            if
              type(menu_border) == 'string'
              and menu_border ~= 'shadow'
              and menu_border ~= 'none'
            then
              return menu._win_configs.height + 1
            elseif menu_border == 'none' then
              return menu._win_configs.height
            end
            local len_menu_border = #menu_border
            if
              len_menu_border == 1 and menu_border[1] ~= ''
              or (len_menu_border == 2 or len_menu_border == 4) and menu_border[2] ~= ''
              or len_menu_border == 8 and menu_border[8] ~= ''
            then
              return menu._win_configs.height + 1
            else
              return menu._win_configs.height
            end
          end,
          col = function(menu)
            local menu_border = menu._win_configs.border
            if
              type(menu_border) == 'string'
              and menu_border ~= 'shadow'
              and menu_border ~= 'none'
            then
              return -1
            end
            if
              type(menu_border) == 'table' and menu_border[#menu_border] ~= ''
            then
              return -1
            end
            return 0
          end,
        },
        prompt = '%#htmlTag# ',
        char_pattern = '[%w%p]',
        retain_inner_spaces = true,
        fuzzy_find_on_click = true,
      },
      sources = {
        path = {
          ---@type string|fun(buf: integer, win: integer): string
          relative_to = function(_, win)
            -- Workaround for Vim:E5002: Cannot find window number
            local ok, cwd = pcall(vim.fn.getcwd, win)
            return ok and cwd or vim.fn.getcwd()
          end,
          ---Can be used to filter out files or directories
          ---based on their name
          ---@type fun(name: string): boolean
          filter = function(_)
            return true
          end,
          ---Last symbol from path source when current buf is modified
          ---@param sym dropbar_symbol_t
          ---@return dropbar_symbol_t
          modified = function(sym)
            return sym
          end,
          ---@type boolean|fun(path: string): boolean?|nil
          preview = function(path)
            local stat = vim.uv.fs_stat(path)
            if not stat or stat.type ~= 'file' then
              return false
            end
            if stat.size > 524288 then
              vim.notify(
                string.format(
                  '[dropbar.nvim] file "%s" too large to preview',
                  path
                ),
                vim.log.levels.WARN
              )
              return false
            end
            return true
          end,
        },
        treesitter = {
          -- Lua pattern used to extract a short name from the node text
          name_pattern = '[#~%*%w%._%->!@:]+%s*'
          .. string.rep('[#~%*%w%._%->!@:]*', 3, '%s*'),
          -- The order matters! The first match is used as the type
          -- of the treesitter symbol and used to show the icon
          -- Types listed below must have corresponding icons
          -- in the `icons.kinds.symbols` table for the icon to be shown
          valid_types = {
            'array',
            'boolean',
            'break_statement',
            'call',
            'case_statement',
            'class',
            'constant',
            'constructor',
            'continue_statement',
            'delete',
            'do_statement',
            'enum',
            'enum_member',
            'event',
            'for_statement',
            'function',
            'h1_marker',
            'h2_marker',
            'h3_marker',
            'h4_marker',
            'h5_marker',
            'h6_marker',
            'if_statement',
            'interface',
            'keyword',
            'list',
            'macro',
            'method',
            'module',
            'namespace',
            'null',
            'number',
            'operator',
            'package',
            'pair',
            'property',
            'reference',
            'repeat',
            'scope',
            'specifier',
            'string',
            'struct',
            'switch_statement',
            'type',
            'type_parameter',
            'unit',
            'value',
            'variable',
            'while_statement',
            'declaration',
            'field',
            'identifier',
            'object',
            'statement',
            'text',
          },
        },
        lsp = {
          request = {
            -- Times to retry a request before giving up
            ttl_init = 60,
            interval = 1000, -- in ms
          },
        },
        markdown = {
          parse = {
            -- Number of lines to update when cursor moves out of the parsed range
            look_ahead = 200,
          },
        },
        terminal = {
          ---@type string|fun(buf: integer): string
          icon = function(buf)
            local icon = M.opts.icons.kinds.symbols.Terminal
            if M.opts.icons.kinds.use_devicons then
              icon = require('nvim-web-devicons').get_icon_by_filetype(
                vim.bo[buf].filetype
              ) or icon
            end
            return icon
          end,
          ---@type string|fun(buf: integer): string
          name = vim.api.nvim_buf_get_name,
          ---@type boolean
          ---Show the current terminal buffer in the menu
          show_current = true,
        },
      },
    }

    -- M.opts.sources.treesitter.valid_types = {
    --   'array',
    --   'boolean',
    --   'break_statement',
    --   'call',
    --   'case_statement',
    --   'class',
    --   'constant',
    --   'constructor',
    --   'continue_statement',
    --   'delete',
    --   'do_statement',
    --   'enum',
    --   'enum_member',
    --   'event',
    --   'for_statement',
    --   'function',
    --   'h1_marker',
    --   'h2_marker',
    --   'h3_marker',
    --   'h4_marker',
    --   'h5_marker',
    --   'h6_marker',
    --   'if_statement',
    --   'interface',
    --   'keyword',
    --   'list',
    --   'macro',
    --   'method',
    --   'module',
    --   'namespace',
    --   'null',
    --   'number',
    --   'operator',
    --   'package',
    --   'pair',
    --   'property',
    --   'reference',
    --   'repeat',
    --   'scope',
    --   'specifier',
    --   'string',
    --   'struct',
    --   'switch_statement',
    --   'type',
    --   'type_parameter',
    --   'unit',
    --   'value',
    --   'variable',
    --   'while_statement',
    --   'declaration',
    --   'field',
    --   'identifier',
    --   'object',
    --   'statement',
    --   'text',
    -- }
    local navic = require("nvim-navic")
    navic.setup {
      icons = {
        File          = "󰈙 ",
        Module        = " ",
        Namespace     = "󰌗 ",
        Package       = " ",
        Class         = "󰌗 ",
        Method        = "󰆧 ",
        Property      = " ",
        Field         = " ",
        Constructor   = " ",
        Enum          = "󰕘",
        Interface     = "󰕘",
        Function      = "󰊕 ",
        Variable      = "󰆧 ",
        Constant      = "󰏿 ",
        String        = "󰀬 ",
        Number        = "󰎠 ",
        Boolean       = "◩ ",
        Array         = "󰅪 ",
        Object        = "󰅩 ",
        Key           = "󰌋 ",
        Null          = "󰟢 ",
        EnumMember    = " ",
        Struct        = "󰌗 ",
        Event         = " ",
        Operator      = "󰆕 ",
        TypeParameter = "󰊄 ",
      },
      lsp = {
        auto_attach = false,
        preference = nil,
      },
      highlight = false,
      separator = " > ",
      depth_limit = 0,
      depth_limit_indicator = "..",
      safe_output = true,
      lazy_update_context = false,
      click = false,
      format_text = function(text)
        return text
      end,
    }



--lualine
require('lualine').setup {
  options = {
    icons_enabled = true,
    theme = 'auto',
    component_separators = { left = '', right = ''},
    section_separators = { left = '', right = ''},
    disabled_filetypes = {
      statusline = {},
      winbar = {},
    },
    ignore_focus = {},
    always_divide_middle = true,
    globalstatus = false,
    refresh = {
      statusline = 1000,
      tabline = 1000,
      winbar = 1000,
    }
  },
  sections = {
    lualine_a = {'mode'},
    lualine_b = {'branch', 'diff', 'diagnostics'},
    lualine_c = {'filename'},
    lualine_x = {'encoding', 'fileformat', 'filetype'},
    lualine_y = {'progress'},
    lualine_z = {'location'}
  },
  inactive_sections = {
    lualine_a = {},
    lualine_b = {},
    lualine_c = {'filename'},
    lualine_x = {'location'},
    lualine_y = {},
    lualine_z = {}
  },
  tabline = {},
  winbar = {},
  inactive_winbar = {},
  extensions = {}
}

local lualine = require("lualine")
require("lualine").setup({
  sections = {
    lualine_x = { require("action-hints").statusline },
  },
})

local navic = require("nvim-navic")

require("lualine").setup({
    sections = {
        lualine_c = {
            {
                "navic",
    
                -- Component specific options
                color_correction = nil, -- Can be nil, "static" or "dynamic". This option is useful only when you have highlights enabled.
                                        -- Many colorschemes don't define same backgroud for nvim-navic as their lualine statusline backgroud.
                                        -- Setting it to "static" will perform a adjustment once when the component is being setup. This should
                                        --   be enough when the lualine section isn't changing colors based on the mode.
                                        -- Setting it to "dynamic" will keep updating the highlights according to the current modes colors for
                                        --   the current section.
    
                navic_opts = nil  -- lua table with same format as setup's option. All options except "lsp" options take effect when set here.
            }
        }
    },
    -- OR in winbar
    winbar = {
        lualine_c = {
            {
                "navic",
                color_correction = nil,
                navic_opts = nil
            }
        }
    }
})

-- OR a more hands on approach
require("lualine").setup({
    sections = {
        lualine_c = {
            {
              function()
                  return navic.get_location()
              end,
              cond = function()
                  return navic.is_available()
              end
            },
        }
    },
    -- OR in winbar
    winbar = {
        lualine_c = {
            {
              function()
                  return navic.get_location()
              end,
              cond = function()
                  return navic.is_available()
              end
            },
        }
    }
})

require("lualine").setup({
  sections = {
    lualine_x = { "aerial" },

    -- Or you can customize it
    lualine_y = {
      {
        "aerial",
        -- The separator to be used to separate symbols in status line.
        sep = " ) ",

        -- The number of symbols to render top-down. In order to render only 'N' last
        -- symbols, negative numbers may be supplied. For instance, 'depth = -1' can
        -- be used in order to render only current symbol.
        depth = nil,

        -- When 'dense' mode is on, icons are not rendered near their symbols. Only
        -- a single icon that represents the kind of current symbol is rendered at
        -- the beginning of status line.
        dense = false,

        -- The separator to be used to separate symbols in dense mode.
        dense_sep = ".",

        -- Color the symbol icons.
        colored = true,
      },
    },
  },
})



require("lualine").setup({
  sections = {
    -- Other Status Line components
    -- lualine_a = { ... },
    -- lualine_b = { ... },

    lualine_c = {
      function()
        -- invoke `progress` here.
        return require('lsp-progress').progress()
      end,
    },
  }
})

-- listen lsp-progress event and refresh lualine
vim.api.nvim_create_augroup("lualine_augroup", { clear = true })
vim.api.nvim_create_autocmd("User", {
  group = "lualine_augroup",
  pattern = "LspProgressStatusUpdated",
  callback = require("lualine").refresh,
})


lualine.setup({
    options = {
        icons_enabled = true,
        -- theme = cozynight,
        component_separators = { left = '', right = '' },
        section_separators = { left = '', right = '' },
        disabled_filetypes = {},
        always_divide_middle = true
    },
    sections = {
        lualine_a = { 'mode' },
        lualine_b = { 'branch', 'diff',
            {
                'diagnostics',
                sources = { "nvim_diagnostic" },
                symbols = { error = ' ', warn = ' ', info = ' ', hint = ' ' }
            }
        },
        lualine_c = { 'filename' },
        lualine_x = { 'copilot' ,'encoding', 'fileformat', 'filetype' }, -- I added copilot here
        lualine_y = { 'progress' },
        lualine_z = { 'location' }
    },
    inactive_sections = {
        lualine_a = {},
        lualine_b = {},
        lualine_c = { 'filename' },
        lualine_x = { 'location' },
        lualine_y = {},
        lualine_z = {}
    },
    tabline = {},
    extensions = {}
})
require("lualine").setup({
    sections = {
        lualine_b = {
            {
                function()
                    return require("grapple").name_or_index()
                end,
                cond = function()
                    return package.loaded["grapple"] and require("grapple").exists()
                end
            }
        }
    }
})




--incline
require('incline').setup {
  debounce_threshold = {
    falling = 50,
    rising = 10
  },
  hide = {
    cursorline = false,
    focused_win = false,
    only_win = false
  },
  highlight = { use_languagetree = true,
    groups = {
      InclineNormal = {
        default = true,
        group = "NormalFloat"
      },
      InclineNormalNC = {
        default = true,
        group = "NormalFloat"
      }
    }
  },
  ignore = {
    buftypes = "special",
    filetypes = {},
    floating_wins = true,
    unlisted_buffers = true,
    wintypes = "special"
  },
  render = "basic",
  window = {
    margin = {
      horizontal = 1,
      vertical = 1
    },
    options = {
      signcolumn = "no",
      wrap = false
    },
    overlap = {
      borders = true,
      statusline = false,
      tabline = false,
      winbar = false
    },
    padding = 1,
    padding_char = " ",
    placement = {
      horizontal = "right",
      vertical = "top"
    },
    width = "fit",
    winhighlight = {
      active = {
        EndOfBuffer = "None",
        Normal = "InclineNormal",
        Search = "None"
      },
      inactive = {
        EndOfBuffer = "None",
        Normal = "InclineNormalNC",
        Search = "None"
      }
    },
    zindex = 50
  }
}
local devicons = require 'nvim-web-devicons'
require('incline').setup {
  render = function(props)
    local filename = vim.fn.fnamemodify(vim.api.nvim_buf_get_name(props.buf), ':t')
    if filename == '' then
      filename = '[No Name]'
    end
    local ft_icon, ft_color = devicons.get_icon_color(filename)

    local function get_git_diff()
      local icons = { removed = '', changed = '', added = '' }
      local signs = vim.b[props.buf].gitsigns_status_dict
      local labels = {}
      if signs == nil then
        return labels
      end
      for name, icon in pairs(icons) do
        if tonumber(signs[name]) and signs[name] > 0 then
          table.insert(labels, { icon .. signs[name] .. ' ', group = 'Diff' .. name })
        end
      end
      if #labels > 0 then
        table.insert(labels, { '┊ ' })
      end
      return labels
    end

    local function get_diagnostic_label()
      local icons = { error = '', warn = '', info = '', hint = '' }
      local label = {}

      for severity, icon in pairs(icons) do
        local n = #vim.diagnostic.get(props.buf, { severity = vim.diagnostic.severity[string.upper(severity)] })
        if n > 0 then
          table.insert(label, { icon .. n .. ' ', group = 'DiagnosticSign' .. severity })
        end
      end
      if #label > 0 then
        table.insert(label, { '┊ ' })
      end
      return label
    end

    return {
      { get_diagnostic_label() },
      { get_git_diff() },
      { (ft_icon or '') .. ' ', guifg = ft_color, guibg = 'none' },
      { filename .. ' ', gui = vim.bo[props.buf].modified and 'bold,italic' or 'bold' },
      { '┊  ' .. vim.api.nvim_win_get_number(props.win), group = 'DevIconWindows' },
    }
  end,
}




--barbar
vim.g.barbar_auto_setup = false -- disable auto-setup

require("barbar").setup {
  -- WARN: do not copy everything below into your config!
  --       It is just an example of what configuration options there are.
  --       The defaults are suitable for most people.

  -- Enable/disable animations
  animation = true,

  -- Automatically hide the tabline when there are this many buffers left.
  -- Set to any value >=0 to enable.
  auto_hide = false,

  -- Enable/disable current/total tabpages indicator (top right corner)
  tabpages = true,

  -- Enables/disable clickable tabs
  --  - left-click: go to buffer
  --  - middle-click: delete buffer
  clickable = true,

  -- Excludes buffers from the tabline
  exclude_ft = {'javascript'},
  exclude_name = {'package.json'},

  -- A buffer to this direction will be focused (if it exists) when closing the current buffer.
  -- Valid options are 'left' (the default), 'previous', and 'right'
  focus_on_close = 'left',

  -- Hide inactive buffers and file extensions. Other options are `alternate`, `current`, and `visible`.
  hide = {extensions = true, inactive = true},

  -- Disable highlighting alternate buffers
  highlight_alternate = false,

  -- Disable highlighting file icons in inactive buffers
  highlight_inactive_file_icons = false,

  -- Enable highlighting visible buffers
  highlight_visible = true,

  icons = {
    -- Configure the base icons on the bufferline.
    -- Valid options to display the buffer index and -number are `true`, 'superscript' and 'subscript'
    buffer_index = false,
    buffer_number = false,
    button = '',
    -- Enables / disables diagnostic symbols
    diagnostics = {
      [vim.diagnostic.severity.ERROR] = {enabled = true, icon = 'ﬀ'},
      [vim.diagnostic.severity.WARN] = {enabled = false},
      [vim.diagnostic.severity.INFO] = {enabled = false},
      [vim.diagnostic.severity.HINT] = {enabled = true},
    },
    gitsigns = {
      added = {enabled = true, icon = '+'},
      changed = {enabled = true, icon = '~'},
      deleted = {enabled = true, icon = '-'},
    },
    filetype = {
      -- Sets the icon's highlight group.
      -- If false, will use nvim-web-devicons colors
      custom_colors = false,

      -- Requires `nvim-web-devicons` if `true`
      enabled = true,
    },
    separator = {left = '▎', right = ''},

    -- If true, add an additional separator at the end of the buffer list
    separator_at_end = true,

    -- Configure the icons on the bufferline when modified or pinned.
    -- Supports all the base icon options.
    modified = {button = '●'},
    pinned = {button = '', filename = true},

    -- Use a preconfigured buffer appearance— can be 'default', 'powerline', or 'slanted'
    preset = 'default',

    -- Configure the icons on the bufferline based on the visibility of a buffer.
    -- Supports all the base icon options, plus `modified` and `pinned`.
    alternate = {filetype = {enabled = false}},
    current = {buffer_index = true},
    inactive = {button = '×'},
    visible = {modified = {buffer_number = false}},
  },

  -- If true, new buffers will be inserted at the start/end of the list.
  -- Default is to insert after current buffer.
  insert_at_end = false,
  insert_at_start = false,

  -- Sets the maximum padding width with which to surround each tab
  maximum_padding = 1,

  -- Sets the minimum padding width with which to surround each tab
  minimum_padding = 1,

  -- Sets the maximum buffer name length.
  maximum_length = 30,

  -- Sets the minimum buffer name length.
  minimum_length = 0,

  -- If set, the letters for each buffer in buffer-pick mode will be
  -- assigned based on their name. Otherwise or in case all letters are
  -- already assigned, the behavior is to assign letters in order of
  -- usability (see order below)
  semantic_letters = true,

  -- Set the filetypes which barbar will offset itself for
  sidebar_filetypes = {
    -- Use the default values: {event = 'BufWinLeave', text = '', align = 'left'}
    NvimTree = true,
    -- Or, specify the text used for the offset:
    undotree = {
      text = 'undotree',
      align = 'center', -- *optionally* specify an alignment (either 'left', 'center', or 'right')
    },
    -- Or, specify the event which the sidebar executes when leaving:
    ['neo-tree'] = {event = 'BufWipeout'},
    -- Or, specify all three
    Outline = {event = 'BufWinLeave', text = 'symbols-outline', align = 'right'},
  },

  -- New buffer letters are assigned in this order. This order is
  -- optimal for the qwerty keyboard layout but might need adjustment
  -- for other layouts.
  letters = 'asdfjkl;ghnmxcvbziowerutyqpASDFJKLGHNMXCVBZIOWERUTYQP',

  -- Sets the name of unnamed buffers. By default format is "[Buffer X]"
  -- where X is the buffer number. But only a static string is accepted here.
  no_name_title = nil,
}
local map = vim.api.nvim_set_keymap
local opts = { noremap = true, silent = true }

-- Move to previous/next
map('n', '<A-,>', '<Cmd>BufferPrevious<CR>', opts)
map('n', '<A-.>', '<Cmd>BufferNext<CR>', opts)
-- Re-order to previous/next
map('n', '<A-<>', '<Cmd>BufferMovePrevious<CR>', opts)
map('n', '<A->>', '<Cmd>BufferMoveNext<CR>', opts)
-- Goto buffer in position...
map('n', '<A-1>', '<Cmd>BufferGoto 1<CR>', opts)
map('n', '<A-2>', '<Cmd>BufferGoto 2<CR>', opts)
map('n', '<A-3>', '<Cmd>BufferGoto 3<CR>', opts)
map('n', '<A-4>', '<Cmd>BufferGoto 4<CR>', opts)
map('n', '<A-5>', '<Cmd>BufferGoto 5<CR>', opts)
map('n', '<A-6>', '<Cmd>BufferGoto 6<CR>', opts)
map('n', '<A-7>', '<Cmd>BufferGoto 7<CR>', opts)
map('n', '<A-8>', '<Cmd>BufferGoto 8<CR>', opts)
map('n', '<A-9>', '<Cmd>BufferGoto 9<CR>', opts)
map('n', '<A-0>', '<Cmd>BufferLast<CR>', opts)
-- Pin/unpin buffer
map('n', '<A-p>', '<Cmd>BufferPin<CR>', opts)
-- Close buffer
map('n', '<A-c>', '<Cmd>BufferClose<CR>', opts)
-- Wipeout buffer
--                 :BufferWipeout
-- Close commands
--                 :BufferCloseAllButCurrent
--                 :BufferCloseAllButPinned
--                 :BufferCloseAllButCurrentOrPinned
--                 :BufferCloseBuffersLeft
--                 :BufferCloseBuffersRight
-- Magic buffer-picking mode
map('n', '<C-p>', '<Cmd>BufferPick<CR>', opts)
-- Sort automatically by...
map('n', '<Space>bb', '<Cmd>BufferOrderByBufferNumber<CR>', opts)
map('n', '<Space>bn', '<Cmd>BufferOrderByName<CR>', opts)
map('n', '<Space>bd', '<Cmd>BufferOrderByDirectory<CR>', opts)
map('n', '<Space>bl', '<Cmd>BufferOrderByLanguage<CR>', opts)
map('n', '<Space>bw', '<Cmd>BufferOrderByWindowNumber<CR>', opts)

-- Other:
-- :BarbarEnable - enables barbar (enabled by default)
-- :BarbarDisable - very bad command, should never be used




--vim-illuminate
-- default configuration
require('illuminate').configure({
    -- providers: provider used to get references in the buffer, ordered by priority
    providers = {
        'lsp',
        'treesitter',
        'regex',
    },
    -- delay: delay in milliseconds
    delay = 100,
    -- filetype_overrides: filetype specific overrides.
    -- The keys are strings to represent the filetype while the values are tables that
    -- supports the same keys passed to .configure except for filetypes_denylist and filetypes_allowlist
    filetype_overrides = {},
    -- filetypes_denylist: filetypes to not illuminate, this overrides filetypes_allowlist
    filetypes_denylist = {
        'dirbuf',
        'dirvish',
        'fugitive',
    },
    -- filetypes_allowlist: filetypes to illuminate, this is overridden by filetypes_denylist
    -- You must set filetypes_denylist = {} to override the defaults to allow filetypes_allowlist to take effect
    filetypes_allowlist = {},
    -- modes_denylist: modes to not illuminate, this overrides modes_allowlist
    -- See `:help mode()` for possible values
    modes_denylist = {},
    -- modes_allowlist: modes to illuminate, this is overridden by modes_denylist
    -- See `:help mode()` for possible values
    modes_allowlist = {},
    -- providers_regex_syntax_denylist: syntax to not illuminate, this overrides providers_regex_syntax_allowlist
    -- Only applies to the 'regex' provider
    -- Use :echom synIDattr(synIDtrans(synID(line('.'), col('.'), 1)), 'name')
    providers_regex_syntax_denylist = {},
    -- providers_regex_syntax_allowlist: syntax to illuminate, this is overridden by providers_regex_syntax_denylist
    -- Only applies to the 'regex' provider
    -- Use :echom synIDattr(synIDtrans(synID(line('.'), col('.'), 1)), 'name')
    providers_regex_syntax_allowlist = {},
    -- under_cursor: whether or not to illuminate under the cursor
    under_cursor = true,
    -- large_file_cutoff: number of lines at which to use large_file_config
    -- The `under_cursor` option is disabled when this cutoff is hit
    large_file_cutoff = nil,
    -- large_file_config: config to use for large files (based on large_file_cutoff).
    -- Supports the same keys passed to .configure
    -- If nil, vim-illuminate will be disabled for large files.
    large_file_overrides = nil,
    -- min_count_to_highlight: minimum number of matches required to perform highlighting
    min_count_to_highlight = 1,
    -- should_enable: a callback that overrides all other settings to
    -- enable/disable illumination. This will be called a lot so don't do
    -- anything expensive in it.
    should_enable = function(bufnr) return true end,
    -- case_insensitive_regex: sets regex case sensitivity
    case_insensitive_regex = false,
})


--nvim-devicons
require("nvim-web-devicons").setup {
 -- your personnal icons can go here (to override)
 -- you can specify color or cterm_color instead of specifying both of them
 -- DevIcon will be appended to `name`
 override = {
  zsh = {
    icon = "",
    color = "#428850",
    cterm_color = "65",
    name = "Zsh"
  }
 };
 -- globally enable different highlight colors per icon (default to true)
 -- if set to false all icons will have the default icon's color
 color_icons = true;
 -- globally enable default icons (default to false)
 -- will get overriden by `get_icons` option
 default = true;
 -- globally enable "strict" selection of icons - icon will be looked up in
 -- different tables, first by filename, and if not found by extension; this
 -- prevents cases when file doesn't have any extension but still gets some icon
 -- because its name happened to match some extension (default to false)
 strict = true;
 -- same as `override` but specifically for overrides by filename
 -- takes effect when `strict` is true
 override_by_filename = {
  [".gitignore"] = {
    icon = "",
    color = "#f1502f",
    name = "Gitignore"
  }
 };
 -- same as `override` but specifically for overrides by extension
 -- takes effect when `strict` is true
 override_by_extension = {
  ["log"] = {
    icon = "",
    color = "#81e043",
    name = "Log"
  }
 };
 -- same as `override` but specifically for operating system
 -- takes effect when `strict` is true
 override_by_operating_system = {
  ["apple"] = {
    icon = "",
    color = "#A2AAAD",
    cterm_color = "248",
    name = "Apple",
  },
 };
}

    require('nvim-foldsign').setup({
        offset = -2,
        foldsigns = {
            open = '-',          -- mark the beginning of a fold
            close = '+',         -- show a closed fold
            seps = { '│', '┃' }, -- open fold middle marker
        }
    })


--cinnamon
-- DEFAULT_KEYMAPS:

-- Half-window movements:
vim.keymap.set({ 'n', 'x' }, '<C-u>', "<Cmd>lua Scroll('<C-u>', 1, 1)<CR>")
vim.keymap.set({ 'n', 'x' }, '<C-d>', "<Cmd>lua Scroll('<C-d>', 1, 1)<CR>")

-- Page movements:
vim.keymap.set({ 'n', 'x' }, '<C-b>', "<Cmd>lua Scroll('<C-b>', 1, 1)<CR>")
vim.keymap.set({ 'n', 'x' }, '<C-f>', "<Cmd>lua Scroll('<C-f>', 1, 1)<CR>")
vim.keymap.set({ 'n', 'x' }, '<PageUp>', "<Cmd>lua Scroll('<C-b>', 1, 1)<CR>")
vim.keymap.set({ 'n', 'x' }, '<PageDown>', "<Cmd>lua Scroll('<C-f>', 1, 1)<CR>")

-- EXTRA_KEYMAPS:

-- Start/end of file and line number movements:
vim.keymap.set({ 'n', 'x' }, 'gg', "<Cmd>lua Scroll('gg')<CR>")
vim.keymap.set({ 'n', 'x' }, 'G', "<Cmd>lua Scroll('G', 0, 1)<CR>")

-- Start/end of line:
vim.keymap.set({ 'n', 'x' }, '0', "<Cmd>lua Scroll('0')<CR>")
vim.keymap.set({ 'n', 'x' }, '^', "<Cmd>lua Scroll('^')<CR>")
vim.keymap.set({ 'n', 'x' }, '$', "<Cmd>lua Scroll('$', 0, 1)<CR>")

-- Paragraph movements:
vim.keymap.set({ 'n', 'x' }, '{', "<Cmd>lua Scroll('{')<CR>")
vim.keymap.set({ 'n', 'x' }, '}', "<Cmd>lua Scroll('}')<CR>")

-- Previous/next search result:
vim.keymap.set('n', 'n', "<Cmd>lua Scroll('n', 1)<CR>")
vim.keymap.set('n', 'N', "<Cmd>lua Scroll('N', 1)<CR>")
vim.keymap.set('n', '*', "<Cmd>lua Scroll('*', 1)<CR>")
vim.keymap.set('n', '#', "<Cmd>lua Scroll('#', 1)<CR>")
vim.keymap.set('n', 'g*', "<Cmd>lua Scroll('g*', 1)<CR>")
vim.keymap.set('n', 'g#', "<Cmd>lua Scroll('g#', 1)<CR>")

-- Previous/next cursor location:
vim.keymap.set('n', '<C-o>', "<Cmd>lua Scroll('<C-o>', 1)<CR>")
vim.keymap.set('n', '<C-i>', "<Cmd>lua Scroll('1<C-i>', 1)<CR>")

-- Screen scrolling:
vim.keymap.set('n', 'zz', "<Cmd>lua Scroll('zz', 0, 1)<CR>")
vim.keymap.set('n', 'zt', "<Cmd>lua Scroll('zt', 0, 1)<CR>")
vim.keymap.set('n', 'zb', "<Cmd>lua Scroll('zb', 0, 1)<CR>")
vim.keymap.set('n', 'z.', "<Cmd>lua Scroll('z.', 0, 1)<CR>")
vim.keymap.set('n', 'z<CR>', "<Cmd>lua Scroll('zt^', 0, 1)<CR>")
vim.keymap.set('n', 'z-', "<Cmd>lua Scroll('z-', 0, 1)<CR>")
vim.keymap.set('n', 'z^', "<Cmd>lua Scroll('z^', 0, 1)<CR>")
vim.keymap.set('n', 'z+', "<Cmd>lua Scroll('z+', 0, 1)<CR>")
vim.keymap.set('n', '<C-y>', "<Cmd>lua Scroll('<C-y>', 0, 1)<CR>")
vim.keymap.set('n', '<C-e>', "<Cmd>lua Scroll('<C-e>', 0, 1)<CR>")

-- Horizontal screen scrolling:
vim.keymap.set('n', 'zH', "<Cmd>lua Scroll('zH')<CR>")
vim.keymap.set('n', 'zL', "<Cmd>lua Scroll('zL')<CR>")
vim.keymap.set('n', 'zs', "<Cmd>lua Scroll('zs')<CR>")
vim.keymap.set('n', 'ze', "<Cmd>lua Scroll('ze')<CR>")
vim.keymap.set('n', 'zh', "<Cmd>lua Scroll('zh', 0, 1)<CR>")
vim.keymap.set('n', 'zl', "<Cmd>lua Scroll('zl', 0, 1)<CR>")

-- EXTENDED_KEYMAPS:

-- Up/down movements:
vim.keymap.set({ 'n', 'x' }, 'k', "<Cmd>lua Scroll('k', 0, 1)<CR>")
vim.keymap.set({ 'n', 'x' }, 'j', "<Cmd>lua Scroll('j', 0, 1)<CR>")
vim.keymap.set({ 'n', 'x' }, '<Up>', "<Cmd>lua Scroll('k', 0, 1)<CR>")
vim.keymap.set({ 'n', 'x' }, '<Down>', "<Cmd>lua Scroll('j', 0, 1)<CR>")

-- Left/right movements:
vim.keymap.set({ 'n', 'x' }, 'h', "<Cmd>lua Scroll('h', 0, 1)<CR>")
vim.keymap.set({ 'n', 'x' }, 'l', "<Cmd>lua Scroll('l', 0, 1)<CR>")
vim.keymap.set({ 'n', 'x' }, '<Left>', "<Cmd>lua Scroll('h', 0, 1)<CR>")
vim.keymap.set({ 'n', 'x' }, '<Right>', "<Cmd>lua Scroll('l', 0, 1)<CR>")

-- SCROLL_WHEEL_KEYMAPS:

vim.keymap.set({ 'n', 'x' }, '<ScrollWheelUp>', "<Cmd>lua Scroll('<ScrollWheelUp>')<CR>")
vim.keymap.set({ 'n', 'x' }, '<ScrollWheelDown>', "<Cmd>lua Scroll('<ScrollWheelDown>')<CR>")

-- LSP_KEYMAPS:

-- LSP go-to-definition:
vim.keymap.set('n', 'gd', "<Cmd>lua Scroll('definition')<CR>")

-- LSP go-to-declaration:
vim.keymap.set('n', 'gD', "<Cmd>lua Scroll('declaration')<CR>")
require('cinnamon').setup { extra_keymaps = true }



--indentation
require("ibl").setup()
local highlight = {
    "RainbowRed",
    "RainbowYellow",
    "RainbowBlue",
    "RainbowOrange",
    "RainbowGreen",
    "RainbowViolet",
    "RainbowCyan",
}

local hooks = require "ibl.hooks"
-- create the highlight groups in the highlight setup hook, so they are reset
-- every time the colorscheme changes
hooks.register(hooks.type.HIGHLIGHT_SETUP, function()
    vim.api.nvim_set_hl(0, "RainbowRed", { fg = "#E06C75" })
    vim.api.nvim_set_hl(0, "RainbowYellow", { fg = "#E5C07B" })
    vim.api.nvim_set_hl(0, "RainbowBlue", { fg = "#61AFEF" })
    vim.api.nvim_set_hl(0, "RainbowOrange", { fg = "#D19A66" })
    vim.api.nvim_set_hl(0, "RainbowGreen", { fg = "#98C379" })
    vim.api.nvim_set_hl(0, "RainbowViolet", { fg = "#C678DD" })
    vim.api.nvim_set_hl(0, "RainbowCyan", { fg = "#56B6C2" })
end)

require("ibl").setup { indent = { highlight = highlight } }
local highlight = {
    "CursorColumn",
    "Whitespace",
}
require("ibl").setup {
    indent = { highlight = highlight, char = "" },
    whitespace = {
        highlight = highlight,
        remove_blankline_trail = false,
    },
    scope = { enabled = false },
}
require("auto-indent").setup({
  lightmode = true,        -- Lightmode assumes tabstop and indentexpr not change within buffer's lifetime
  indentexpr = nil,        -- Use vim.bo.indentexpr by default, see 'Custom Indent Evaluate Method'
  ignore_filetype = {},    -- Disable plugin for specific filetypes, e.g. ignore_filetype = { 'javascript' }
})




--focus
require("focus").setup({
    enable = true, -- Enable module
    commands = true, -- Create Focus commands
    autoresize = {
        enable = true, -- Enable or disable auto-resizing of splits
        width = 0, -- Force width for the focused window
        height = 0, -- Force height for the focused window
        minwidth = 0, -- Force minimum width for the unfocused window
        minheight = 0, -- Force minimum height for the unfocused window
        height_quickfix = 10, -- Set the height of quickfix panel
    },
    split = {
        bufnew = false, -- Create blank buffer for new split windows
        tmux = false, -- Create tmux splits instead of neovim splits
    },
    ui = {
        number = false, -- Display line numbers in the focussed window only
        relativenumber = false, -- Display relative line numbers in the focussed window only
        hybridnumber = false, -- Display hybrid line numbers in the focussed window only
        absolutenumber_unfocussed = false, -- Preserve absolute numbers in the unfocussed windows

        cursorline = true, -- Display a cursorline in the focussed window only
        cursorcolumn = false, -- Display cursorcolumn in the focussed window only
        colorcolumn = {
            enable = false, -- Display colorcolumn in the foccused window only
            list = '+1', -- Set the comma-saperated list for the colorcolumn
        },
        signcolumn = true, -- Display signcolumn in the focussed window only
        winhighlight = false, -- Auto highlighting for focussed/unfocussed windows
    }
})
local focusmap = function(direction)
    vim.keymap.set('n', '<Leader>'..direction, function()
        require('focus').split_command(direction)
    end, { desc = string.format('Create or move to split (%s)', direction) })
end

-- Use `<Leader>h` to split the screen to the left, same as command FocusSplitLeft etc
focusmap('h')
focusmap('j')
focusmap('k')
focusmap('l')




--tmux
require('tmux-awesome-manager').setup({
  per_project_commands = { -- Configure your per project servers with
  -- project name = { { cmd, name } }
    api = { { cmd = 'rails server', name = 'Rails Server' } },
    front = { { cmd = 'yarn dev', name = 'react server' } },
  },
  session_name = 'Neovim Terminals',
  use_icon = false, -- use prefix icon
  icon = ' ', -- Prefix icon to use
  -- project_open_as = 'window', -- Open per_project_commands as.  Default: separated_session
  -- default_size = '30%', -- on panes, the default size
  -- open_new_as = 'window', -- open new command as.  options: pane, window, separated_session.
  -- default_orientation = 'vertical' -- Can also be horizontal
})
local tmux_term = require('tmux-awesome-manager.src.term')
local wk = require("which-key")

wk.register({
  r = {
    name = "+rails",
    R = tmux_term.run_wk({ cmd = 'rails s', name = 'Rails Server', visit_first_call = false, open_as = 'separated_session', session_name = 'My Terms' }),
    r = tmux_term.run_wk({ cmd = 'rails s', name = 'Rails Console', open_as = 'window' }),
    b = tmux_term.run_wk({ cmd = 'bundle install', name = 'Bundle Install', open_as = 'pane', close_on_timer = 2, visit_first_call = false, focus_when_call = false }),
    g = tmux_term.run_wk({ cmd = 'rails generate %1', name = 'Rails Generate',
      questions = { { question = "Rails generate: ", required = true, open_as = 'pane', close_on_timer = 4,
        visit_first_call = false, focus_when_call = false } } }),
    d = tmux_term.run_wk({ cmd = 'rails destroy %1', name = 'Rails Destroy',
      questions = { { question = "Rails destroy: ", required = true, open_as = 'pane', close_on_timer = 4,
        visit_first_call = false, focus_when_call = false } } }),
  },
}, { prefix = "<leader>", silent = true })
require('tmux-awesome-manager.src.integrations.status').status_with_icons()




--pineapple
require('telescope').load_extension('pineapple')
require('telescope').extensions.pineapple.colorschemes()

--colorscheme
vim.opt.background = 'dark'
local c = require('vscode.colors').get_colors()
require('vscode').setup({
    -- Alternatively set style in setup
    -- style = 'light'

    -- Enable transparent background
    transparent = true,

    -- Enable italic comment
    italic_comments = true,

    -- Underline `@markup.link.*` variants
    underline_links = true,

    -- Disable nvim-tree background color
    disable_nvimtree_bg = true,

    -- Override colors (see ./lua/vscode/colors.lua)
    color_overrides = {
        vscLineNumber = '#FFFFFF',
    },

    -- Override highlight groups (see ./lua/vscode/theme.lua)
    group_overrides = {
        -- this supports the same val table as vim.api.nvim_set_hl
        -- use colors from this colorscheme by requiring vscode.colors!
        Cursor = { fg=c.vscDarkBlue, bg=c.vscLightGreen, bold=true },
    }
})
-- require('vscode').load()

-- load the theme without affecting devicon colors.
vim.cmd.colorscheme="vscode"


-- file: colors/my-colorscheme-name.lua

local colorbuddy = require('colorbuddy')

-- Set up your custom colorscheme if you want
colorbuddy.colorscheme("vscode")

-- And then modify as you like
local Color = colorbuddy.Color
local colors = colorbuddy.colors
local Group = colorbuddy.Group
local groups = colorbuddy.groups
local styles = colorbuddy.styles

-- Use Color.new(<name>, <#rrggbb>) to create new colors
-- They can be accessed through colors.<name>
Color.new('background',  '#282c34')
Color.new('red',         '#cc6666')
Color.new('green',       '#99cc99')
Color.new('yellow',      '#f0c674')

-- Define highlights in terms of `colors` and `groups`
Group.new('Function'        , colors.yellow      , colors.background , styles.bold)
Group.new('luaFunctionCall' , groups.Function    , groups.Function   , groups.Function)

-- Define highlights in relative terms of other colors
Group.new('Error'           , colors.red:light() , nil               , styles.bold)

-- If you want multiple styles, just add them!
Group.new('italicBoldFunction', colors.green, groups.Function, styles.bold + styles.italic)

-- If you want the same style as a different group, but without a style: just subtract it!
Group.new('boldFunction', colors.yellow, colors.background, groups.italicBoldFunction - styles.italic)
  end
},





{

  'VonHeikemen/lsp-zero.nvim',
  dependencies  = {
    -- LSP Support
    {'neovim/nvim-lspconfig'},
    {'williamboman/mason.nvim'},
    {'williamboman/mason-lspconfig.nvim'},

    -- Autocompletion
    {'hrsh7th/nvim-cmp'},
    {'hrsh7th/cmp-buffer'},
    {'hrsh7th/cmp-path'},
    {'saadparwaiz1/cmp_luasnip'},
    {'hrsh7th/cmp-nvim-lsp'},
    {'hrsh7th/cmp-nvim-lua'},

    -- Snippets
    {'L3MON4D3/LuaSnip'},
    {'rafamadriz/friendly-snippets'},
    'nvim-lua/lsp-status.nvim',
    'RishabhRD/popfix',
    'RishabhRD/nvim-lsputils',
    'nvimdev/lspsaga.nvim',
    'kosayoda/nvim-lightbulb',
    'roobert/action-hints.nvim',
    'saadparwaiz1/cmp_luasnip',
    'onsails/lspkind.nvim',
    'ojroques/nvim-lspfuzzy',
    'gfanto/fzf-lsp.nvim',
    'ray-x/lsp_signature.nvim',
    'smjonas/inc-rename.nvim',
    'rmagatti/goto-preview',
    'ray-x/navigator.lua',
    'simrat39/symbols-outline.nvim',
    'stevearc/aerial.nvim',
    "neovim/nvim-lspconfig",
    "SmiteshP/nvim-navic",
    "MunifTanjim/nui.nvim",
    "numToStr/Comment.nvim",
    "nvim-telescope/telescope.nvim" ,
    "SmiteshP/nvim-navbuddy",
    "aznhe21/actions-preview.nvim",
    'mfussenegger/nvim-lint',
    "j-hui/fidget.nvim",
    'dnlhc/glance.nvim',
    'linrongbin16/lsp-progress.nvim',
    "jinzhongjia/LspUI.nvim",
    "hinell/lsp-timeout.nvim",
    "williamboman/mason.nvim",
    "folke/trouble.nvim",
    'folke/lsp-colors.nvim',
    'neovim/nvim-lspconfig',
    'hrsh7th/cmp-nvim-lsp',
    'hrsh7th/cmp-buffer',
    'hrsh7th/cmp-path',
    'hrsh7th/cmp-cmdline',
    'hrsh7th/nvim-cmp',
    'hrsh7th/cmp-vsnip',
    'hrsh7th/vim-vsnip',
    'SirVer/ultisnips',
    'quangnguyen30192/cmp-nvim-ultisnips',
    'dcampos/nvim-snippy',
    'dcampos/cmp-snippy',
    "zbirenbaum/copilot.lua",
    "zbirenbaum/copilot-cmp",
    'AndreM222/copilot-lualine',
    { "rafamadriz/friendly-snippets" },
    'dcampos/cmp-snippy',
    'windwp/nvim-autopairs',
    'monaqa/dial.nvim',
    'windwp/nvim-ts-autotag',
    'willothy/moveline.nvim',
    'numToStr/Comment.nvim',
    'lukas-reineke/lsp-format.nvim',
    "https://git.sr.ht/~nedia/auto-format.nvim",
    "https://git.sr.ht/~nedia/auto-save.nvim",
    'stevearc/conform.nvim',
    'nvim-treesitter/nvim-treesitter',
      "nvim-treesitter/nvim-treesitter-textobjects"
  },
  build = {"make install_jsregexp", "make", "TSUpdate"},
  config = function()



--lsp-zero
local lsp_zero = require('lsp-zero')

lsp_zero.on_attach(function(client, bufnr)
  -- see :help lsp-zero-keybindings
  -- to learn the available actions
  lsp_zero.default_keymaps({buffer = bufnr})
end)

-- to learn how to use mason.nvim
-- read this: https://github.com/VonHeikemen/lsp-zero.nvim/blob/v3.x/doc/md/guide/integrate-with-mason-nvim.md
require('mason').setup({})
require('mason-lspconfig').setup({
  ensure_installed = {},
  handlers = {
    function(server_name)
      require('lspconfig')[server_name].setup({})
    end,
  },
})

local lsp_zero = require('lsp-zero')

lsp_zero.on_attach(function(client, bufnr)
  lsp_zero.default_keymaps({buffer = bufnr})
end)

-- don't add this function in the `on_attach` callback.
-- `format_on_save` should run only once, before the language servers are active.
lsp_zero.format_on_save({
  format_opts = {
    async = false,
    timeout_ms = 10000,
  },
  servers = {
    ['tsserver'] = {'javascript', 'typescript'},
    ['rust_analyzer'] = {'rust'},
  }
})
vim.g.lsp_zero_extend_cmp = 0
vim.g.lsp_zero_extend_lspconfig = 0
vim.g.lsp_zero_extend_capabilities = 0
vim.g.lsp_zero_ui_float_border = 'rounded'
vim.g.lsp_zero_ui_signcolumn = 0
vim.g.lsp_zero_api_warnings = 0
vim.b.lsp_zero_enable_autoformat = 0
local lsp_zero = require('lsp-zero')

lsp_zero.set_server_config({
  single_file_support = false,
  capabilities = {
    textDocument = {
      foldingRange = {
        dynamicRegistration = false,
        lineFoldingOnly = true
      }
    }
  }
})

lsp_zero.on_attach(function(client, bufnr)
  lsp_zero.default_keymaps({buffer = bufnr})
  lsp_zero.buffer_autoformat()
end)
require('lspconfig').tsserver.setup({
  on_attach = function(client, bufnr)
    lsp_zero.async_autoformat(client, bufnr)
  end
})
lsp_zero.set_sign_icons({
  error = '✘',
  warn = '▲',
  hint = '⚑',
  info = '»'
})
lsp_zero.on_attach(function(client, bufnr)
  lsp_zero.highlight_symbol(client, bufnr)
end)
require('lsp-zero').extend_cmp()
local cmp_action = require('lsp-zero').cmp_action()
local cmp = require('cmp')
cmp.setup({
  mapping = cmp.mapping.preset.insert({
    ['<C-Space>'] = cmp.mapping.complete(),
    ['<C-f>'] = cmp_action.luasnip_jump_forward(),
    ['<C-b>'] = cmp_action.luasnip_jump_backward(),
  }),
  snippet = {
    expand = function(args)
      require('luasnip').lsp_expand(args.body)
    end,
  },
})
lsp_zero.omnifunc.setup({
  tabcomplete = true,
  use_fallback = true,
  update_on_delete = true,
})
lsp_zero.omnifunc.setup({
  autocomplete = true,
  use_fallback = true,
  update_on_delete = true,
  trigger = '<C-Space>',
})






    --lspconfig
    local on_windows = vim.loop.os_uname().version:match 'Windows'

    local function join_paths(...)
      local path_sep = on_windows and '\\' or '/'
      local result = table.concat({ ... }, path_sep)
      return result
    end

    vim.cmd [[set runtimepath=$VIMRUNTIME]]

    local temp_dir = vim.loop.os_getenv 'TEMP' or '/tmp'

    vim.cmd('set packpath=' .. join_paths(temp_dir, 'nvim', 'site'))

    local package_root = join_paths(temp_dir, 'nvim', 'site', 'pack')
    local lspconfig_path = join_paths(package_root, 'test', 'start', 'nvim-lspconfig')

    if vim.fn.isdirectory(lspconfig_path) ~= 1 then
      vim.fn.system { 'git', 'clone', 'https://github.com/neovim/nvim-lspconfig', lspconfig_path }
    end

    vim.lsp.set_log_level 'trace'
    require('vim.lsp.log').set_format_func(vim.inspect)
    local nvim_lsp = require 'lspconfig'
    local on_attach = function(_, bufnr)
      local function buf_set_option(...)
        vim.api.nvim_buf_set_option(bufnr, ...)
      end

      buf_set_option('omnifunc', 'v:lua.vim.lsp.omnifunc')

      -- Mappings.
      local opts = { buffer = bufnr, noremap = true, silent = true }
      vim.keymap.set('n', 'gD', vim.lsp.buf.declaration, opts)
      vim.keymap.set('n', 'gd', vim.lsp.buf.definition, opts)
      vim.keymap.set('n', 'K', vim.lsp.buf.hover, opts)
      vim.keymap.set('n', 'gi', vim.lsp.buf.implementation, opts)
      vim.keymap.set('n', '<C-k>', vim.lsp.buf.signature_help, opts)
      vim.keymap.set('n', '<space>wa', vim.lsp.buf.add_workspace_folder, opts)
      vim.keymap.set('n', '<space>wr', vim.lsp.buf.remove_workspace_folder, opts)
      vim.keymap.set('n', '<space>wl', function()
        print(vim.inspect(vim.lsp.buf.list_workspace_folders()))
      end, opts)
      vim.keymap.set('n', '<space>D', vim.lsp.buf.type_definition, opts)
      vim.keymap.set('n', '<space>rn', vim.lsp.buf.rename, opts)
      vim.keymap.set('n', 'gr', vim.lsp.buf.references, opts)
      vim.keymap.set('n', '<space>e', vim.diagnostic.open_float, opts)
      vim.keymap.set('n', '[d', vim.diagnostic.goto_prev, opts)
      vim.keymap.set('n', ']d', vim.diagnostic.goto_next, opts)
      vim.keymap.set('n', '<space>q', vim.diagnostic.setloclist, opts)
    end

    -- Add the server that troubles you here
    local name = 'pyright'
    local cmd = { 'pyright-langserver', '--stdio' } -- needed for elixirls, lua_ls, omnisharp
    if not name then
      print 'You have not defined a server name, please edit minimal_init.lua'
    end
    if not nvim_lsp[name].document_config.default_config.cmd and not cmd then
      print [[You have not defined a server default cmd for a server



    that requires it please edit minimal_init.lua]]
    end

    nvim_lsp[name].setup {
      cmd = cmd,
      on_attach = on_attach,
    }






    --nvim-cmp
    -- Set up nvim-cmp.
    local cmp = require("cmp")

    cmp.setup({
      snippet = {
        -- REQUIRED - you must specify a snippet engine
        expand = function(args)
          vim.fn["vsnip#anonymous"](args.body) -- For `vsnip` users.
          -- require('luasnip').lsp_expand(args.body) -- For `luasnip` users.
          -- require('snippy').expand_snippet(args.body) -- For `snippy` users.
          -- vim.fn["UltiSnips#Anon"](args.body) -- For `ultisnips` users.
          -- vim.snippet.expand(args.body) -- For native neovim snippets (Neovim v0.10+)
        end,
      },
      window = {
      -- completion = cmp.config.window.bordered(),
      -- documentation = cmp.config.window.bordered(),
      },
      mapping = cmp.mapping.preset.insert({
        ['<C-b>'] = cmp.mapping.scroll_docs(-4),
        ['<C-f>'] = cmp.mapping.scroll_docs(4),
        ['<C-Space>'] = cmp.mapping.complete(),
        ['<C-e>'] = cmp.mapping.abort(),
        ['<CR>'] = cmp.mapping.confirm({ select = true }), -- Accept currently selected item. Set `select` to `false` to only confirm explicitly selected items.
      }),
      sources = cmp.config.sources({
        { name = 'nvim_lsp' },
        -- { name = 'vsnip' }, -- For vsnip users.
        { name = 'luasnip' }, -- For luasnip users.
        -- { name = 'ultisnips' }, -- For ultisnips users.
        { name = 'snippy' }, -- For snippy users.
      }, {
        { name = 'buffer' },
      })
    })

    -- To use git you need to install the plugin petertriho/cmp-git and uncomment lines below
    -- Set configuration for specific filetype.
    --[[ cmp.setup.filetype('gitcommit', {
    sources = cmp.config.sources({
      { name = 'git' },
    }, {
      { name = 'buffer' },
    })
 })
 require("cmp_git").setup() ]]-- 

    -- Use buffer source for `/` and `?` (if you enabled `native_menu`, this won't work anymore).
    cmp.setup.cmdline({ '/', '?' }, {
      mapping = cmp.mapping.preset.cmdline(),
      sources = {
        { name = 'buffer' }
      }
    })

    -- Use cmdline & path source for ':' (if you enabled `native_menu`, this won't work anymore).
    cmp.setup.cmdline(':', {
      mapping = cmp.mapping.preset.cmdline(),
      sources = cmp.config.sources({
        { name = 'path' }
      }, {
        { name = 'cmdline' }
      }),
      matching = { disallow_symbol_nonprefix_matching = false }
    })

    -- cmp.lua
    cmp.setup {
      formatting = {
        format = lspkind.cmp_format({
          mode = "symbol",
          max_width = 50,
          symbol_map = { Copilot = "" }
        })
      }
    }
    -- -- Set up lspconfig.
    -- local capabilities = require('cmp_nvim_lsp').default_capabilities()
    -- -- Replace <YOUR_LSP_SERVER> with each lsp server you've enabled.
    -- require('lspconfig')['<YOUR_LSP_SERVER>'].setup {
    --   capabilities = capabilities
    -- }





    --lsp-status
    local lsp_status = require('lsp-status')
    lsp_status.register_progress()

    local lspconfig = require('lspconfig')

    -- Some arbitrary servers
    lspconfig.clangd.setup({
      handlers = lsp_status.extensions.clangd.setup(),
      init_options = {
        clangdFileStatus = true
      },
      on_attach = lsp_status.on_attach,
      capabilities = lsp_status.capabilities
    })

    lspconfig.pyls_ms.setup({
      handlers = lsp_status.extensions.pyls_ms.setup(),
      settings = { python = { workspaceSymbols = { enabled = true }}},
      on_attach = lsp_status.on_attach,
      capabilities = lsp_status.capabilities
    })

    lspconfig.ghcide.setup({
      on_attach = lsp_status.on_attach,
      capabilities = lsp_status.capabilities
    })
    lspconfig.rust_analyzer.setup({
      on_attach = lsp_status.on_attach,
      capabilities = lsp_status.capabilities
    })


    --copilot
    require('copilot').setup({
      panel = {
        enabled = true,
        auto_refresh = false,
        keymap = {
          jump_prev = "[[",
          jump_next = "]]",
          accept = "<CR>",
          refresh = "gr",
          open = "<M-CR>"
        },
        layout = {
          position = "bottom", -- | top | left | right
          ratio = 0.4
        },
      },
      suggestion = {
        enabled = true,
        auto_trigger = false,
        debounce = 75,
        keymap = {
          accept = "<M-l>",
          accept_word = false,
          accept_line = false,
          next = "<M-]>",
          prev = "<M-[>",
          dismiss = "<C-]>",
        },
      },
      filetypes = {
        yaml = false,
        markdown = false,
        help = false,
        gitcommit = false,
        gitrebase = false,
        hgcommit = false,
        svn = false,
        cvs = false,
        ["."] = false,
      },
      copilot_node_command = 'node', -- Node.js version must be > 18.x
      server_opts_overrides = {},
    })
    lspkind.init({
      symbol_map = {
        Copilot = "",
      },
    })

    vim.api.nvim_set_hl(0, "CmpItemKindCopilot", {fg ="#6CC644"})

    local has_words_before = function()
      if vim.api.nvim_buf_get_option(0, "buftype") == "prompt" then return false end
      local line, col = unpack(vim.api.nvim_win_get_cursor(0))
      return col ~= 0 and vim.api.nvim_buf_get_text(0, line-1, 0, line-1, col, {})[1]:match("^%s*$") == nil
    end
    cmp.setup({
      mapping = {
        ["<Tab>"] = vim.schedule_wrap(function(fallback)
          if cmp.visible() and has_words_before() then
            cmp.select_next_item({ behavior = cmp.SelectBehavior.Select })
          else
            fallback()
          end
        end),
      },
    })





    --lsputils
    if vim.fn.has('nvim-0.10.0') == 1 then
      vim.lsp.handlers['textDocument/codeAction'] = require'lsputil.codeAction'.code_action_handler
      vim.lsp.handlers['textDocument/references'] = require'lsputil.locations'.references_handler
      vim.lsp.handlers['textDocument/definition'] = require'lsputil.locations'.definition_handler
      vim.lsp.handlers['textDocument/declaration'] = require'lsputil.locations'.declaration_handler
      vim.lsp.handlers['textDocument/typeDefinition'] = require'lsputil.locations'.typeDefinition_handler
      vim.lsp.handlers['textDocument/implementation'] = require'lsputil.locations'.implementation_handler
      vim.lsp.handlers['textDocument/documentSymbol'] = require'lsputil.symbols'.document_handler
      vim.lsp.handlers['workspace/symbol'] = require'lsputil.symbols'.workspace_handler
    else
      local bufnr = vim.api.nvim_buf_get_number(0)

      vim.lsp.handlers['textDocument/codeAction'] = function(_, _, actions)
        require('lsputil.codeAction').code_action_handler(nil, actions, nil, nil, nil)
      end

      vim.lsp.handlers['textDocument/references'] = function(_, _, result)
        require('lsputil.locations').references_handler(nil, result, { bufnr = bufnr }, nil)
      end

      vim.lsp.handlers['textDocument/definition'] = function(_, method, result)
        require('lsputil.locations').definition_handler(nil, result, { bufnr = bufnr, method = method }, nil)
      end

      vim.lsp.handlers['textDocument/declaration'] = function(_, method, result)
        require('lsputil.locations').declaration_handler(nil, result, { bufnr = bufnr, method = method }, nil)
      end

      vim.lsp.handlers['textDocument/typeDefinition'] = function(_, method, result)
        require('lsputil.locations').typeDefinition_handler(nil, result, { bufnr = bufnr, method = method }, nil)
      end

      vim.lsp.handlers['textDocument/implementation'] = function(_, method, result)
        require('lsputil.locations').implementation_handler(nil, result, { bufnr = bufnr, method = method }, nil)
      end

      vim.lsp.handlers['textDocument/documentSymbol'] = function(_, _, result, _, bufn)
        require('lsputil.symbols').document_handler(nil, result, { bufnr = bufn }, nil)
      end

      vim.lsp.handlers['textDocument/symbol'] = function(_, _, result, _, bufn)
        require('lsputil.symbols').workspace_handler(nil, result, { bufnr = bufn }, nil)
      end
    end
    local border_chars = {
      TOP_LEFT = '┌',
      TOP_RIGHT = '┐',
      MID_HORIZONTAL = '─',
      MID_VERTICAL = '│',
      BOTTOM_LEFT = '└',
      BOTTOM_RIGHT = '┘',
    }
    vim.g.lsp_utils_location_opts = {
      height = 24,
      mode = 'editor',
      preview = {
        title = 'Location Preview',
        border = true,
        border_chars = border_chars
      },
      keymaps = {
        n = {
          ['<C-n>'] = 'j',
          ['<C-p>'] = 'k',
        }
      }
    }
    vim.g.lsp_utils_symbols_opts = {
      height = 24,
      mode = 'editor',
      preview = {
        title = 'Symbols Preview',
        border = true,
        border_chars = border_chars
      },
      prompt = {},
    }




    --lspsaga
    local saga = require 'lspsaga'

    saga.init_lsp_saga {
      error_sign = '',
      warn_sign = '',
      hint_sign = '',
      infor_sign = '',
      border_style = "round",
    }





    --nvim-lightbulb
    require("nvim-lightbulb").setup({
      autocmd = { enabled = true }
    })

    local default_config = {
      -- Priority of the lightbulb for all handlers except float.
      priority = 10,

      -- Whether or not to hide the lightbulb when the buffer is not focused.
      -- Only works if configured during NvimLightbulb.setup
      hide_in_unfocused_buffer = true,

      -- Whether or not to link the highlight groups automatically.
      -- Default highlight group links:
      --   LightBulbSign -> DiagnosticSignInfo
      --   LightBulbFloatWin -> DiagnosticFloatingInfo
      --   LightBulbVirtualText -> DiagnosticVirtualTextInfo
      --   LightBulbNumber -> DiagnosticSignInfo
      --   LightBulbLine -> CursorLine
      -- Only works if configured during NvimLightbulb.setup
      link_highlights = true,

      -- Perform full validation of configuration.
      -- Available options: "auto", "always", "never"
      --   "auto" only performs full validation in NvimLightbulb.setup.
      --   "always" performs full validation in NvimLightbulb.update_lightbulb as well.
      --   "never" disables config validation.
      validate_config = "auto",

      -- Code action kinds to observe.
      -- To match all code actions, set to `nil`.
      -- Otherwise, set to a table of kinds.
      -- Example: { "quickfix", "refactor.rewrite" }
      -- See: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#codeActionKind
      action_kinds = nil,

      -- Configuration for various handlers:
      -- 1. Sign column.
      sign = {
        enabled = true,
        -- Text to show in the sign column.
        -- Must be between 1-2 characters.
        text = "💡",
        -- Highlight group to highlight the sign column text.
        hl = "LightBulbSign",
      },

      -- 2. Virtual text.
      virtual_text = {
        enabled = false,
        -- Text to show in the virt_text.
        text = "💡",
        -- Position of virtual text given to |nvim_buf_set_extmark|.
        -- Can be a number representing a fixed column (see `virt_text_pos`).
        -- Can be a string representing a position (see `virt_text_win_col`).
        pos = "eol",
        -- Highlight group to highlight the virtual text.
        hl = "LightBulbVirtualText",
        -- How to combine other highlights with text highlight.
        -- See `hl_mode` of |nvim_buf_set_extmark|.
        hl_mode = "combine",
      },

      -- 3. Floating window.
      float = {
        enabled = false,
        -- Text to show in the floating window.
        text = "💡",
        -- Highlight group to highlight the floating window.
        hl = "LightBulbFloatWin",
        -- Window options.
        -- See |vim.lsp.util.open_floating_preview| and |nvim_open_win|.
        -- Note that some options may be overridden by |open_floating_preview|.
        win_opts = {
          focusable = false,
        },
      },

      -- 4. Status text.
      -- When enabled, will allow using |NvimLightbulb.get_status_text|
      -- to retrieve the configured text.
      status_text = {
        enabled = false,
        -- Text to set if a lightbulb is available.
        text = "💡",
        -- Text to set if a lightbulb is unavailable.
        text_unavailable = "",
      },

      -- 5. Number column.
      number = {
        enabled = false,
        -- Highlight group to highlight the number column if there is a lightbulb.
        hl = "LightBulbNumber",
      },

      -- 6. Content line.
      line = {
        enabled = false,
        -- Highlight group to highlight the line if there is a lightbulb.
        hl = "LightBulbLine",
      },

      -- Autocmd configuration.
      -- If enabled, automatically defines an autocmd to show the lightbulb.
      -- If disabled, you will have to manually call |NvimLightbulb.update_lightbulb|.
      -- Only works if configured during NvimLightbulb.setup
      autocmd = {
        -- Whether or not to enable autocmd creation.
        enabled = false,
        -- See |updatetime|.
        -- Set to a negative value to avoid setting the updatetime.
        updatetime = 200,
        -- See |nvim_create_autocmd|.
        events = { "CursorHold", "CursorHoldI" },
        -- See |nvim_create_autocmd| and |autocmd-pattern|.
        pattern = { "*" },
      },

      -- Scenarios to not show a lightbulb.
      ignore = {
        -- LSP client names to ignore.
        -- Example: {"null-ls", "lua_ls"}
        clients = {},
        -- Filetypes to ignore.
        -- Example: {"neo-tree", "lua"}
        ft = {},
        -- Ignore code actions without a `kind` like refactor.rewrite, quickfix.
        actions_without_kind = false,
      },
    }





    --action-hints
    require("action-hints").setup({
      template = {
        definition = { text = " ⊛", color = "#add8e6" },
        references = { text = " ↱%s", color = "#ff6666" },
      },
      use_virtual_text = true,
    })




    --lspkind
    require('lspkind').init({
      -- DEPRECATED (use mode instead): enables text annotations
      --
      -- default: true
      -- with_text = true,

      -- defines how annotations are shown
      -- default: symbol
      -- options: 'text', 'text_symbol', 'symbol_text', 'symbol'
      mode = 'symbol_text',

      -- default symbol map
      -- can be either 'default' (requires nerd-fonts font) or
      -- 'codicons' for codicon preset (requires vscode-codicons font)
      --
      -- default: 'default'
      preset = 'codicons',

      -- override preset symbols
      --
      -- default: {}
      symbol_map = {
        Text = "󰉿",
        Method = "󰆧",
        Function = "󰊕",
        Constructor = "",
        Field = "󰜢",
        Variable = "󰀫",
        Class = "󰠱",
        Interface = "",
        Module = "",
        Property = "󰜢",
        Unit = "󰑭",
        Value = "󰎠",
        Enum = "",
        Keyword = "󰌋",
        Snippet = "",
        Color = "󰏘",
        File = "󰈙",
        Reference = "󰈇",
        Folder = "󰉋",
        EnumMember = "",
        Constant = "󰏿",
        Struct = "󰙅",
        Event = "",
        Operator = "󰆕",
        TypeParameter = "",
      },
    })

    local lspkind = require('lspkind')
    cmp.setup {
      formatting = {
        format = lspkind.cmp_format({
          mode = 'symbol', -- show only symbol annotations
          maxwidth = 50, -- prevent the popup from showing more than provided characters (e.g 50 will not show more than 50 characters)
          -- can also be a function to dynamically calculate max width such as
          -- maxwidth = function() return math.floor(0.45 * vim.o.columns) end,
          ellipsis_char = '...', -- when popup menu exceed maxwidth, the truncated part would show ellipsis_char instead (must define maxwidth first)
          show_labelDetails = true, -- show labelDetails in menu. Disabled by default

          -- The function below will be called before any actual modifications from lspkind
          -- so that you can provide more controls on popup customization. (See [#30](https://github.com/onsails/lspkind-nvim/pull/30))
          before = function (entry, vim_item)
            return vim_item
          end
        })
      }
    }





    --lspfuzzy
    require('lspfuzzy').setup {
      methods = 'all',         -- either 'all' or a list of LSP methods (see below)
      jump_one = true,         -- jump immediately if there is only one location
      save_last = false,       -- save last location results for the :LspFuzzyLast command
      callback = nil,          -- callback called after jumping to a location
      fzf_preview = {          -- arguments to the FZF '--preview-window' option
        'right:+{2}-/2'          -- preview on the right and centered on entry
      },
      fzf_action = {               -- FZF actions
        ['ctrl-t'] = 'tab split',  -- go to location in a new tab
        ['ctrl-v'] = 'vsplit',     -- go to location in a vertical split
        ['ctrl-x'] = 'split',      -- go to location in a horizontal split
      },
      fzf_modifier = ':~:.',   -- format FZF entries, see |filename-modifiers|
      fzf_trim = true,         -- trim FZF entries
    }

    vim.lsp.handlers["textDocument/codeAction"] = require'fzf_lsp'.code_action_handler
    vim.lsp.handlers["textDocument/definition"] = require'fzf_lsp'.definition_handler
    vim.lsp.handlers["textDocument/declaration"] = require'fzf_lsp'.declaration_handler
    vim.lsp.handlers["textDocument/typeDefinition"] = require'fzf_lsp'.type_definition_handler
    vim.lsp.handlers["textDocument/implementation"] = require'fzf_lsp'.implementation_handler
    vim.lsp.handlers["textDocument/references"] = require'fzf_lsp'.references_handler
    vim.lsp.handlers["textDocument/documentSymbol"] = require'fzf_lsp'.document_symbol_handler
    vim.lsp.handlers["workspace/symbol"] = require'fzf_lsp'.workspace_symbol_handler
    vim.lsp.handlers["callHierarchy/incomingCalls"] = require'fzf_lsp'.incoming_calls_handler
    vim.lsp.handlers["callHierarchy/outgoingCalls"] = require'fzf_lsp'.outgoing_calls_handler



    --lsp-signature
    local  cfg = {
      debug = false, -- set to true to enable debug logging
      log_path = vim.fn.stdpath("cache") .. "/lsp_signature.log", -- log dir when debug is on
      -- default is  ~/.cache/nvim/lsp_signature.log
      verbose = false, -- show debug line number

      bind = true, -- This is mandatory, otherwise border config won't get registered.
      -- If you want to hook lspsaga or other signature handler, pls set to false
      doc_lines = 10, -- will show two lines of comment/doc(if there are more than two lines in doc, will be truncated);
      -- set to 0 if you DO NOT want any API comments be shown
      -- This setting only take effect in insert mode, it does not affect signature help in normal
      -- mode, 10 by default

      max_height = 12, -- max height of signature floating_window
      max_width = 80, -- max_width of signature floating_window, line will be wrapped if exceed max_width
      -- the value need >= 40
      wrap = true, -- allow doc/signature text wrap inside floating_window, useful if your lsp return doc/sig is too long
      floating_window = true, -- show hint in a floating window, set to false for virtual text only mode

      floating_window_above_cur_line = true, -- try to place the floating above the current line when possible Note:
      -- will set to true when fully tested, set to false will use whichever side has more space
      -- this setting will be helpful if you do not want the PUM and floating win overlap

      floating_window_off_x = 5, -- adjust float windows x position.
      -- can be either a number or function
      floating_window_off_y = function() -- adjust float windows y position. e.g. set to -2 can make floating window move up 2 lines
        local linenr = vim.api.nvim_win_get_cursor(0)[1] -- buf line number
        local pumheight = vim.o.pumheight
        local winline = vim.fn.winline() -- line number in the window
        local winheight = vim.fn.winheight(0)

        -- window top
        if winline - 1 < pumheight then
          return pumheight
        end

        -- window bottom
        if winheight - winline < pumheight then
          return -pumheight
        end
        return 0
      end, -- adjust float windows y position. e.g -2 move window up 2 lines; 2 move down 2 lines
      -- can be either number or function, see examples
      close_timeout = 4000, -- close floating window after ms when laster parameter is entered
      fix_pos = false,  -- set to true, the floating window will not auto-close until finish all parameters
      hint_enable = true, -- virtual hint enable
      hint_prefix = "🐼 ",  -- Panda for parameter, NOTE: for the terminal not support emoji, might crash
      hint_scheme = "String",
      hint_inline = function() return false end,  -- should the hint be inline(nvim 0.10 only)?  default false
      -- return true | 'inline' to show hint inline, return 'eol' to show hint at end of line, return false to disable
      -- return 'right_align' to display hint right aligned in the current line
      hi_parameter = "LspSignatureActiveParameter", -- how your parameter will be highlight
      handler_opts = {
        border = "rounded"   -- double, rounded, single, shadow, none, or a table of borders
      },

      always_trigger = false, -- sometime show signature on new line or in middle of parameter can be confusing, set it to false for #58

      auto_close_after = nil, -- autoclose signature float win after x sec, disabled if nil.
      extra_trigger_chars = {}, -- Array of extra characters that will trigger signature completion, e.g., {"(", ","}
      zindex = 200, -- by default it will be on top of all floating windows, set to <= 50 send it to bottom

      padding = '', -- character to pad on left and right of signature can be ' ', or '|'  etc

      transparency = nil, -- disabled by default, allow floating win transparent value 1~100
      shadow_blend = 36, -- if you using shadow as border use this set the opacity
      shadow_guibg = 'Black', -- if you using shadow as border use this set the color e.g. 'Green' or '#121315'
      timer_interval = 200, -- default timer check interval set to lower value if you want to reduce latency
      toggle_key = nil, -- toggle signature on and off in insert mode,  e.g. toggle_key = '<M-x>'
      toggle_key_flip_floatwin_setting = false, -- true: toggle floating_windows: true|false setting after toggle key pressed
      -- false: floating_windows setup will not change, toggle_key will pop up signature helper, but signature
      -- may not popup when typing depends on floating_window setting

      select_signature_key = nil, -- cycle to next signature, e.g. '<M-n>' function overloading
      move_cursor_key = nil, -- imap, use nvim_set_current_win to move cursor between current win and floating window
      -- e.g. move_cursor_key = '<M-p>',
      -- once moved to floating window, you can use <M-d>, <M-u> to move cursor up and down
      keymaps = {}  -- relate to move_cursor_key; the keymaps inside floating window
    -- e.g. keymaps = { 'j', '<C-o>j' } this map j to <C-o>j in floating window
    -- <M-d> and <M-u> are default keymaps to move cursor up and down
    }

    -- recommended:
    require'lsp_signature'.setup(cfg) -- no need to specify bufnr if you don't use toggle_key

    -- You can also do this inside lsp on_attach
    -- note: on_attach deprecated
    require'lsp_signature'.on_attach(cfg, bufnr) -- no need to specify bufnr if you don't use toggle_key
    require("lsp_signature").status_line(max_width)





    --increname
    require("inc_rename").setup {
      -- the name of the command
      cmd_name = "IncRename",
      -- the highlight group used for highlighting the identifier's new name
      hl_group = "Substitute",
      -- whether an empty new name should be previewed; if false the command preview will be cancelled instead
      preview_empty_name = false,
      -- whether to display a `Renamed m instances in n files` message after a rename operation
      show_message = true,
      -- whether to save the "IncRename" command in the commandline history (set to false to prevent issues with
      -- navigating to older entries that may arise due to the behavior of command preview)
      save_in_cmdline_history = true,
      -- the type of the external input buffer to use (the only supported value is currently "dressing")
      input_buffer_type = nil,
      -- callback to run after renaming, receives the result table (from LSP handler) as an argument
      post_hook = nil,
    }

    vim.keymap.set("n", "<leader>rn", ":IncRename ")

    -- require("noice").setup {
    --   presets = { inc_rename = true }
    -- }

    -- require("inc_rename").setup {
    --   input_buffer_type = "dressing",
    -- }



    --goto-preview
    require('goto-preview').setup {
      width = 120; -- Width of the floating window
      height = 15; -- Height of the floating window
      border = {"↖", "─" ,"┐", "│", "┘", "─", "└", "│"}; -- Border characters of the floating window
      default_mappings = false; -- Bind default mappings
      debug = false; -- Print debug information
      opacity = nil; -- 0-100 opacity level of the floating window where 100 is fully transparent.
      resizing_mappings = false; -- Binds arrow keys to resizing the floating window.
      post_open_hook = nil; -- A function taking two arguments, a buffer and a window to be ran as a hook.
      post_close_hook = nil; -- A function taking two arguments, a buffer and a window to be ran as a hook.
      references = { -- Configure the telescope UI for slowing the references cycling window.
        telescope = require("telescope.themes").get_dropdown({ hide_preview = false })
      };
      -- These two configs can also be passed down to the goto-preview definition and implementation calls for one off "peak" functionality.
      focus_on_open = true; -- Focus the floating window when opening it.
      dismiss_on_move = false; -- Dismiss the floating window when moving the cursor.
      force_close = true, -- passed into vim.api.nvim_win_close's second argument. See :h nvim_win_close
      bufhidden = "wipe", -- the bufhidden option to set on the floating window. See :h bufhidden
      stack_floating_preview_windows = true, -- Whether to nest floating windows
      preview_window_title = { enable = true, position = "left" }, -- Whether to set the preview window title as the filename
    }
    vim.api.nvim_set_keymap('n', 'gpd', '<cmd>lua require("goto-preview").goto_preview_definition()<CR>', { noremap = true, silent = true })
    vim.api.nvim_set_keymap('n', 'gpt', '<cmd>lua require("goto-preview").goto_preview_type_definition()<CR>', { noremap = true, silent = true })
    vim.api.nvim_set_keymap('n', 'gpi', '<cmd>lua require("goto-preview").goto_preview_implementation()<CR>', { noremap = true, silent = true })
    vim.api.nvim_set_keymap('n', 'gpD', '<cmd>lua require("goto-preview").goto_preview_declaration()<CR>', { noremap = true, silent = true })
    vim.api.nvim_set_keymap('n', 'gP', '<cmd>lua require("goto-preview").close_all_win()<CR>', { noremap = true, silent = true })
    vim.api.nvim_set_keymap('n', 'gpr', '<cmd>lua require("goto-preview").goto_preview_references()<CR>', { noremap = true, silent = true })





    --navigator

    require'navigator'.setup({
      debug = false, -- log output, set to true and log path: ~/.cache/nvim/gh.log
      -- slowdownd startup and some actions
      width = 0.75, -- max width ratio (number of cols for the floating window) / (window width)
      height = 0.3, -- max list window height, 0.3 by default
      preview_height = 0.35, -- max height of preview windows
      border = {"╭", "─", "╮", "│", "╯", "─", "╰", "│"}, -- border style, can be one of 'none', 'single', 'double',
      -- 'shadow', or a list of chars which defines the border
      on_attach = function(client, bufnr)
      -- your hook
      end,
      -- put a on_attach of your own here, e.g
      -- function(client, bufnr)
      --   -- the on_attach will be called at end of navigator on_attach
      -- end,
      -- The attach code will apply to all LSP clients

      ts_fold = {
        enable = false,
        comment_fold = true, -- fold with comment string
        max_lines_scan_comments = 20, -- only fold when the fold level higher than this value
        disable_filetypes = {'help', 'guihua', 'text'}, -- list of filetypes which doesn't fold using treesitter
      },  -- modified version of treesitter folding
      default_mapping = true,  -- set to false if you will remap every key
      keymaps = {{key = "gK", func = vim.lsp.declaration, desc = 'declaration'}}, -- a list of key maps
      -- this kepmap gK will override "gD" mapping function declaration()  in default kepmap
      -- please check mapping.lua for all keymaps
      -- rule of overriding: if func and mode ('n' by default) is same
      -- the key will be overridden
      treesitter_analysis = true, -- treesitter variable context
      treesitter_navigation = true, -- bool|table false: use lsp to navigate between symbol ']r/[r', table: a list of
      --lang using TS navigation
      treesitter_analysis_max_num = 100, -- how many items to run treesitter analysis
      treesitter_analysis_condense = true, -- condense form for treesitter analysis
      -- this value prevent slow in large projects, e.g. found 100000 reference in a project
      transparency = 50, -- 0 ~ 100 blur the main window, 100: fully transparent, 0: opaque,  set to nil or 100 to disable it

      lsp_signature_help = true, -- if you would like to hook ray-x/lsp_signature plugin in navigator
      -- setup here. if it is nil, navigator will not init signature help
      signature_help_cfg = nil, -- if you would like to init ray-x/lsp_signature plugin in navigator, and pass in your own config to signature help
      icons = { -- refer to lua/navigator.lua for more icons config
        -- requires nerd fonts or nvim-web-devicons
        icons = true,
        -- Code action
        code_action_icon = "🏏", -- note: need terminal support, for those not support unicode, might crash
        -- Diagnostics
        diagnostic_head = '🐛',
        diagnostic_head_severity_1 = "🈲",
        fold = {
          prefix = '⚡',  -- icon to show before the folding need to be 2 spaces in display width
          separator = '',  -- e.g. shows   3 lines 
        },
      },
      mason = false, -- set to true if you would like use the lsp installed by williamboman/mason
      lsp = {
        enable = true,  -- skip lsp setup, and only use treesitter in navigator.
        -- Use this if you are not using LSP servers, and only want to enable treesitter support.
        -- If you only want to prevent navigator from touching your LSP server configs,
        -- use `disable_lsp = "all"` instead.
        -- If disabled, make sure add require('navigator.lspclient.mapping').setup({bufnr=bufnr, client=client}) in your
        -- own on_attach
        code_action = {enable = true, sign = true, sign_priority = 40, virtual_text = true},
        code_lens_action = {enable = true, sign = true, sign_priority = 40, virtual_text = true},
        document_highlight = true, -- LSP reference highlight,
        -- it might already supported by you setup, e.g. LunarVim
        format_on_save = true, -- {true|false} set to false to disasble lsp code format on save (if you are using prettier/efm/formater etc)
        -- table: {enable = {'lua', 'go'}, disable = {'javascript', 'typescript'}} to enable/disable specific language
        -- enable: a whitelist of language that will be formatted on save
        -- disable: a blacklist of language that will not be formatted on save
        -- function: function(bufnr) return true end to enable/disable lsp format on save
        format_options = {async=false}, -- async: disable by default, the option used in vim.lsp.buf.format({async={true|false}, name = 'xxx'})
        disable_format_cap = {"sqlls", "lua_ls", "gopls"},  -- a list of lsp disable format capacity (e.g. if you using efm or vim-codeformat etc), empty {} by default
        -- If you using null-ls and want null-ls format your code
        -- you should disable all other lsp and allow only null-ls.
        -- disable_lsp = {'pylsd', 'sqlls'},  -- prevents navigator from setting up this list of servers.
        -- if you use your own LSP setup, and don't want navigator to setup
        -- any LSP server for you, use `disable_lsp = "all"`.
        -- you may need to add this to your own on_attach hook:
        -- require('navigator.lspclient.mapping').setup({bufnr=bufnr, client=client})
        -- for e.g. denols and tsserver you may want to enable one lsp server at a time.
        -- default value: {}
        diagnostic = {
          underline = true,
          virtual_text = true, -- show virtual for diagnostic message
          update_in_insert = false, -- update diagnostic message in insert mode
          float = {                 -- setup for floating windows style
            focusable = false,
            sytle = 'minimal',
            border = 'rounded',
            source = 'always',
            header = '',
            prefix = '',
          },
        },

        hover = {
          enable = true,
          keymap = {
            ['<C-k>'] = {
              go = function()
                local w = vim.fn.expand('<cWORD>')
                vim.cmd('GoDoc ' .. w)
              end,
              default = function()
                local w = vim.fn.expand('<cWORD>')
                vim.lsp.buf.workspace_symbol(w)
              end,
            },
          },

          diagnostic_scrollbar_sign = {'▃', '▆', '█'}, -- experimental:  diagnostic status in scroll bar area; set to false to disable the diagnostic sign,
          --                for other style, set to {'╍', 'ﮆ'} or {'-', '='}
          diagnostic_virtual_text = true,  -- show virtual for diagnostic message
          diagnostic_update_in_insert = false, -- update diagnostic message in insert mode
          display_diagnostic_qf = true, -- always show quickfix if there are diagnostic errors, set to false if you want to ignore it
          -- set to 'trouble' to show diagnostcs in Trouble
          tsserver = {
            filetypes = {'typescript'} -- disable javascript etc,
          -- set to {} to disable the lspclient for all filetypes
          },
          ctags ={
            cmd = 'ctags',
            tagfile = 'tags',
            options = '-R --exclude=.git --exclude=node_modules --exclude=test --exclude=vendor --excmd=number',
          },
          -- gopls = {   -- gopls setting
          --   on_attach = function(client, bufnr)  -- on_attach for gopls
          --     -- your special on attach here
          --     -- e.g. disable gopls format because a known issue https://github.com/golang/go/issues/45732
          --     print("i am a hook, I will disable document format")
          --     client.resolved_capabilities.document_formatting = false
          --   end,
          --   settings = {
          --     gopls = {gofumpt = false} -- disable gofumpt etc,
          --   }
          -- },
          -- the lsp setup can be a function, .e.g
          gopls = function()
            local go = pcall(require, "go")
            if go then
              local cfg = require("go.lsp").config()
              cfg.on_attach = function(client)
                client.server_capabilities.documentFormattingProvider = false -- efm/null-ls
              end
              return cfg
            end
          end,

          lua_ls = {
            sumneko_root_path = vim.fn.expand("$HOME") .. "/github/sumneko/lua-language-server",
            sumneko_binary = vim.fn.expand("$HOME") .. "/github/sumneko/lua-language-server/bin/macOS/lua-language-server",
          },
          servers = {'cmake', 'ltex'}, -- by default empty, and it should load all LSP clients available based on filetype
        -- but if you want navigator load  e.g. `cmake` and `ltex` for you , you
        -- can put them in the `servers` list and navigator will auto load them.
        -- you could still specify the custom config  like this
        -- cmake = {filetypes = {'cmake', 'makefile'}, single_file_support = false},
        }
      }
    })






    --symbols-outline
    local opts = {
      highlight_hovered_item = true,
      show_guides = true,
      auto_preview = false,
      position = 'right',
      relative_width = true,
      width = 25,
      auto_close = false,
      show_numbers = false,
      show_relative_numbers = false,
      show_symbol_details = true,
      preview_bg_highlight = 'Pmenu',
      autofold_depth = nil,
      auto_unfold_hover = true,
      fold_markers = { '', '' },
      wrap = false,
      keymaps = { -- These keymaps can be a string or a table for multiple keys
        close = {"<Esc>", "q"},
        goto_location = "<Cr>",
        focus_location = "o",
        hover_symbol = "<C-space>",
        toggle_preview = "K",
        rename_symbol = "r",
        code_actions = "a",
        fold = "h",
        unfold = "l",
        fold_all = "W",
        unfold_all = "E",
        fold_reset = "R",
      },
      lsp_blacklist = {},
      symbol_blacklist = {},
      symbols = {
        File = { icon = "", hl = "@text.uri" },
        Module = { icon = "", hl = "@namespace" },
        Namespace = { icon = "", hl = "@namespace" },
        Package = { icon = "", hl = "@namespace" },
        Class = { icon = "𝓒", hl = "@type" },
        Method = { icon = "ƒ", hl = "@method" },
        Property = { icon = "", hl = "@method" },
        Field = { icon = "", hl = "@field" },
        Constructor = { icon = "", hl = "@constructor" },
        Enum = { icon = "ℰ", hl = "@type" },
        Interface = { icon = "ﰮ", hl = "@type" },
        Function = { icon = "", hl = "@function" },
        Variable = { icon = "", hl = "@constant" },
        Constant = { icon = "", hl = "@constant" },
        String = { icon = "𝓐", hl = "@string" },
        Number = { icon = "#", hl = "@number" },
        Boolean = { icon = "⊨", hl = "@boolean" },
        Array = { icon = "", hl = "@constant" },
        Object = { icon = "⦿", hl = "@type" },
        Key = { icon = "🔐", hl = "@type" },
        Null = { icon = "NULL", hl = "@type" },
        EnumMember = { icon = "", hl = "@field" },
        Struct = { icon = "𝓢", hl = "@type" },
        Event = { icon = "🗲", hl = "@type" },
        Operator = { icon = "+", hl = "@operator" },
        TypeParameter = { icon = "𝙏", hl = "@parameter" },
        Component = { icon = "", hl = "@function" },
        Fragment = { icon = "", hl = "@constant" },
      },
    }
    require("symbols-outline").setup(opts)



    -- aerial
    require("aerial").setup({
      -- optionally use on_attach to set keymaps when aerial has attached to a buffer
      on_attach = function(bufnr)
        -- Jump forwards/backwards with '{' and '}'
        vim.keymap.set("n", "{", "<cmd>AerialPrev<CR>", { buffer = bufnr })
        vim.keymap.set("n", "}", "<cmd>AerialNext<CR>", { buffer = bufnr })
      end,
    })
    -- You probably also want to set a keymap to toggle aerial
    vim.keymap.set("n", "<leader>a", "<cmd>AerialToggle!<CR>")


    -- Call the setup function to change the default behavior
    require("aerial").setup({
      -- Priority list of preferred backends for aerial.
      -- This can be a filetype map (see :help aerial-filetype-map)
      backends = { "treesitter", "lsp", "markdown", "asciidoc", "man" },

      layout = {
        -- These control the width of the aerial window.
        -- They can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
        -- min_width and max_width can be a list of mixed types.
        -- max_width = {40, 0.2} means "the lesser of 40 columns or 20% of total"
        max_width = { 40, 0.2 },
        width = nil,
        min_width = 10,

        -- key-value pairs of window-local options for aerial window (e.g. winhl)
        win_opts = {},

        -- Determines the default direction to open the aerial window. The 'prefer'
        -- options will open the window in the other direction *if* there is a
        -- different buffer in the way of the preferred direction
        -- Enum: prefer_right, prefer_left, right, left, float
        default_direction = "prefer_right",

        -- Determines where the aerial window will be opened
        --   edge   - open aerial at the far right/left of the editor
        --   window - open aerial to the right/left of the current window
        placement = "window",

        -- When the symbols change, resize the aerial window (within min/max constraints) to fit
        resize_to_content = true,

        -- Preserve window size equality with (:help CTRL-W_=)
        preserve_equality = false,
      },

      -- Determines how the aerial window decides which buffer to display symbols for
      --   window - aerial window will display symbols for the buffer in the window from which it was opened
      --   global - aerial window will display symbols for the current window
      attach_mode = "window",

      -- List of enum values that configure when to auto-close the aerial window
      --   unfocus       - close aerial when you leave the original source window
      --   switch_buffer - close aerial when you change buffers in the source window
      --   unsupported   - close aerial when attaching to a buffer that has no symbol source
      close_automatic_events = {},

      -- Keymaps in aerial window. Can be any value that `vim.keymap.set` accepts OR a table of keymap
      -- options with a `callback` (e.g. { callback = function() ... end, desc = "", nowait = true })
      -- Additionally, if it is a string that matches "actions.<name>",
      -- it will use the mapping at require("aerial.actions").<name>
      -- Set to `false` to remove a keymap
      keymaps = {
        ["?"] = "actions.show_help",
        ["g?"] = "actions.show_help",
        ["<CR>"] = "actions.jump",
        ["<2-LeftMouse>"] = "actions.jump",
        ["<C-v>"] = "actions.jump_vsplit",
        ["<C-s>"] = "actions.jump_split",
        ["p"] = "actions.scroll",
        ["<C-j>"] = "actions.down_and_scroll",
        ["<C-k>"] = "actions.up_and_scroll",
        ["{"] = "actions.prev",
        ["}"] = "actions.next",
        ["[["] = "actions.prev_up",
        ["]]"] = "actions.next_up",
        ["q"] = "actions.close",
        ["o"] = "actions.tree_toggle",
        ["za"] = "actions.tree_toggle",
        ["O"] = "actions.tree_toggle_recursive",
        ["zA"] = "actions.tree_toggle_recursive",
        ["l"] = "actions.tree_open",
        ["zo"] = "actions.tree_open",
        ["L"] = "actions.tree_open_recursive",
        ["zO"] = "actions.tree_open_recursive",
        ["h"] = "actions.tree_close",
        ["zc"] = "actions.tree_close",
        ["H"] = "actions.tree_close_recursive",
        ["zC"] = "actions.tree_close_recursive",
        ["zr"] = "actions.tree_increase_fold_level",
        ["zR"] = "actions.tree_open_all",
        ["zm"] = "actions.tree_decrease_fold_level",
        ["zM"] = "actions.tree_close_all",
        ["zx"] = "actions.tree_sync_folds",
        ["zX"] = "actions.tree_sync_folds",
      },

      -- When true, don't load aerial until a command or function is called
      -- Defaults to true, unless `on_attach` is provided, then it defaults to false
      lazy_load = true,

      -- Disable aerial on files with this many lines
      disable_max_lines = 10000,

      -- Disable aerial on files this size or larger (in bytes)
      disable_max_size = 2000000, -- Default 2MB

      -- A list of all symbols to display. Set to false to display all symbols.
      -- This can be a filetype map (see :help aerial-filetype-map)
      -- To see all available values, see :help SymbolKind
      filter_kind = {
        "Class",
        "Constructor",
        "Enum",
        "Function",
        "Interface",
        "Module",
        "Method",
        "Struct",
      },

      -- Determines line highlighting mode when multiple splits are visible.
      -- split_width   Each open window will have its cursor location marked in the
      --               aerial buffer. Each line will only be partially highlighted
      --               to indicate which window is at that location.
      -- full_width    Each open window will have its cursor location marked as a
      --               full-width highlight in the aerial buffer.
      -- last          Only the most-recently focused window will have its location
      --               marked in the aerial buffer.
      -- none          Do not show the cursor locations in the aerial window.
      highlight_mode = "split_width",

      -- Highlight the closest symbol if the cursor is not exactly on one.
      highlight_closest = true,

      -- Highlight the symbol in the source buffer when cursor is in the aerial win
      highlight_on_hover = false,

      -- When jumping to a symbol, highlight the line for this many ms.
      -- Set to false to disable
      highlight_on_jump = 300,

      -- Jump to symbol in source window when the cursor moves
      autojump = false,

      -- Define symbol icons. You can also specify "<Symbol>Collapsed" to change the
      -- icon when the tree is collapsed at that symbol, or "Collapsed" to specify a
      -- default collapsed icon. The default icon set is determined by the
      -- "nerd_font" option below.
      -- If you have lspkind-nvim installed, it will be the default icon set.
      -- This can be a filetype map (see :help aerial-filetype-map)
      icons = {},

      -- Control which windows and buffers aerial should ignore.
      -- Aerial will not open when these are focused, and existing aerial windows will not be updated
      ignore = {
        -- Ignore unlisted buffers. See :help buflisted
        unlisted_buffers = false,

        -- Ignore diff windows (setting to false will allow aerial in diff windows)
        diff_windows = true,

        -- List of filetypes to ignore.
        filetypes = {},

        -- Ignored buftypes.
        -- Can be one of the following:
        -- false or nil - No buftypes are ignored.
        -- "special"    - All buffers other than normal, help and man page buffers are ignored.
        -- table        - A list of buftypes to ignore. See :help buftype for the
        --                possible values.
        -- function     - A function that returns true if the buffer should be
        --                ignored or false if it should not be ignored.
        --                Takes two arguments, `bufnr` and `buftype`.
        buftypes = "special",

        -- Ignored wintypes.
        -- Can be one of the following:
        -- false or nil - No wintypes are ignored.
        -- "special"    - All windows other than normal windows are ignored.
        -- table        - A list of wintypes to ignore. See :help win_gettype() for the
        --                possible values.
        -- function     - A function that returns true if the window should be
        --                ignored or false if it should not be ignored.
        --                Takes two arguments, `winid` and `wintype`.
        wintypes = "special",
      },

      -- Use symbol tree for folding. Set to true or false to enable/disable
      -- Set to "auto" to manage folds if your previous foldmethod was 'manual'
      -- This can be a filetype map (see :help aerial-filetype-map)
      manage_folds = false,

      -- When you fold code with za, zo, or zc, update the aerial tree as well.
      -- Only works when manage_folds = true
      link_folds_to_tree = false,

      -- Fold code when you open/collapse symbols in the tree.
      -- Only works when manage_folds = true
      link_tree_to_folds = true,

      -- Set default symbol icons to use patched font icons (see https://www.nerdfonts.com/)
      -- "auto" will set it to true if nvim-web-devicons or lspkind-nvim is installed.
      nerd_font = "auto",

      -- Call this function when aerial attaches to a buffer.
      on_attach = function(bufnr) end,

      -- Call this function when aerial first sets symbols on a buffer.
      on_first_symbols = function(bufnr) end,

      -- Automatically open aerial when entering supported buffers.
      -- This can be a function (see :help aerial-open-automatic)
      open_automatic = false,

      -- Run this command after jumping to a symbol (false will disable)
      post_jump_cmd = "normal! zz",

      -- Invoked after each symbol is parsed, can be used to modify the parsed item,
      -- or to filter it by returning false.
      --
      -- bufnr: a neovim buffer number
      -- item: of type aerial.Symbol
      -- ctx: a record containing the following fields:
      --   * backend_name: treesitter, lsp, man...
      --   * lang: info about the language
      --   * symbols?: specific to the lsp backend
      --   * symbol?: specific to the lsp backend
      --   * syntax_tree?: specific to the treesitter backend
      --   * match?: specific to the treesitter backend, TS query match
      post_parse_symbol = function(bufnr, item, ctx)
        return true
      end,

      -- Invoked after all symbols have been parsed and post-processed,
      -- allows to modify the symbol structure before final display
      --
      -- bufnr: a neovim buffer number
      -- items: a collection of aerial.Symbol items, organized in a tree,
      --        with 'parent' and 'children' fields
      -- ctx: a record containing the following fields:
      --   * backend_name: treesitter, lsp, man...
      --   * lang: info about the language
      --   * symbols?: specific to the lsp backend
      --   * syntax_tree?: specific to the treesitter backend
      post_add_all_symbols = function(bufnr, items, ctx)
        return items
      end,

      -- When true, aerial will automatically close after jumping to a symbol
      close_on_select = false,

      -- The autocmds that trigger symbols update (not used for LSP backend)
      update_events = "TextChanged,InsertLeave",

      -- Show box drawing characters for the tree hierarchy
      show_guides = false,

      -- Customize the characters used when show_guides = true
      guides = {
        -- When the child item has a sibling below it
        mid_item = "├─",
        -- When the child item is the last in the list
        last_item = "└─",
        -- When there are nested child guides to the right
        nested_top = "│ ",
        -- Raw indentation
        whitespace = "  ",
      },

      -- Set this function to override the highlight groups for certain symbols
      get_highlight = function(symbol, is_icon, is_collapsed)
      -- return "MyHighlight" .. symbol.kind
      end,

      -- Options for opening aerial in a floating win
      float = {
        -- Controls border appearance. Passed to nvim_open_win
        border = "rounded",

        -- Determines location of floating window
        --   cursor - Opens float on top of the cursor
        --   editor - Opens float centered in the editor
        --   win    - Opens float centered in the window
        relative = "cursor",

        -- These control the height of the floating window.
        -- They can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
        -- min_height and max_height can be a list of mixed types.
        -- min_height = {8, 0.1} means "the greater of 8 rows or 10% of total"
        max_height = 0.9,
        height = nil,
        min_height = { 8, 0.1 },

        override = function(conf, source_winid)
          -- This is the config that will be passed to nvim_open_win.
          -- Change values here to customize the layout
          return conf
        end,
      },

      -- Options for the floating nav windows
      nav = {
        border = "rounded",
        max_height = 0.9,
        min_height = { 10, 0.1 },
        max_width = 0.5,
        min_width = { 0.2, 20 },
        win_opts = {
          cursorline = true,
          winblend = 10,
        },
        -- Jump to symbol in source window when the cursor moves
        autojump = false,
        -- Show a preview of the code in the right column, when there are no child symbols
        preview = false,
        -- Keymaps in the nav window
        keymaps = {
          ["<CR>"] = "actions.jump",
          ["<2-LeftMouse>"] = "actions.jump",
          ["<C-v>"] = "actions.jump_vsplit",
          ["<C-s>"] = "actions.jump_split",
          ["h"] = "actions.left",
          ["l"] = "actions.right",
          ["<C-c>"] = "actions.close",
        },
      },

      lsp = {
        -- If true, fetch document symbols when LSP diagnostics update.
        diagnostics_trigger_update = false,

        -- Set to false to not update the symbols when there are LSP errors
        update_when_errors = true,

        -- How long to wait (in ms) after a buffer change before updating
        -- Only used when diagnostics_trigger_update = false
        update_delay = 300,

        -- Map of LSP client name to priority. Default value is 10.
        -- Clients with higher (larger) priority will be used before those with lower priority.
        -- Set to -1 to never use the client.
        priority = {
        -- pyright = 10,
        },
      },

      treesitter = {
        -- How long to wait (in ms) after a buffer change before updating
        update_delay = 300,
      },

      markdown = {
        -- How long to wait (in ms) after a buffer change before updating
        update_delay = 300,
      },

      asciidoc = {
        -- How long to wait (in ms) after a buffer change before updating
        update_delay = 300,
      },

      man = {
        -- How long to wait (in ms) after a buffer change before updating
        update_delay = 300,
      },
    })





    --nvim-navbuddy
    local navbuddy = require("nvim-navbuddy")
    local actions = require("nvim-navbuddy.actions")

    navbuddy.setup {
      window = {
        border = "single",  -- "rounded", "double", "solid", "none"
        -- or an array with eight chars building up the border in a clockwise fashion
        -- starting with the top-left corner. eg: { "╔", "═" ,"╗", "║", "╝", "═", "╚", "║" }.
        size = "60%",       -- Or table format example: { height = "40%", width = "100%"}
        position = "50%",   -- Or table format example: { row = "100%", col = "0%"}
        scrolloff = nil,    -- scrolloff value within navbuddy window
        sections = {
          left = {
            size = "20%",
            border = nil, -- You can set border style for each section individually as well.
          },
          mid = {
            size = "40%",
            border = nil,
          },
          right = {
            -- No size option for right most section. It fills to
            -- remaining area.
            border = nil,
            preview = "leaf",  -- Right section can show previews too.
          -- Options: "leaf", "always" or "never"
          }
        },
      },
      node_markers = {
        enabled = true,
        icons = {
          leaf = "  ",
          leaf_selected = " → ",
          branch = " ",
        },
      },
      icons = {
        File          = "󰈙 ",
        Module        = " ",
        Namespace     = "󰌗 ",
        Package       = " ",
        Class         = "󰌗 ",
        Method        = "󰆧 ",
        Property      = " ",
        Field         = " ",
        Constructor   = " ",
        Enum          = "󰕘",
        Interface     = "󰕘",
        Function      = "󰊕 ",
        Variable      = "󰆧 ",
        Constant      = "󰏿 ",
        String        = " ",
        Number        = "󰎠 ",
        Boolean       = "◩ ",
        Array         = "󰅪 ",
        Object        = "󰅩 ",
        Key           = "󰌋 ",
        Null          = "󰟢 ",
        EnumMember    = " ",
        Struct        = "󰌗 ",
        Event         = " ",
        Operator      = "󰆕 ",
        TypeParameter = "󰊄 ",
      },
      use_default_mappings = true,            -- If set to false, only mappings set
      -- by user are set. Else default
      -- mappings are used for keys
      -- that are not set by user
      mappings = {
        ["<esc>"] = actions.close(),        -- Close and cursor to original location
        ["q"] = actions.close(),

        ["j"] = actions.next_sibling(),     -- down
        ["k"] = actions.previous_sibling(), -- up

        ["h"] = actions.parent(),           -- Move to left panel
        ["l"] = actions.children(),         -- Move to right panel
        ["0"] = actions.root(),             -- Move to first panel

        ["v"] = actions.visual_name(),      -- Visual selection of name
        ["V"] = actions.visual_scope(),     -- Visual selection of scope

        ["y"] = actions.yank_name(),        -- Yank the name to system clipboard "+
        ["Y"] = actions.yank_scope(),       -- Yank the scope to system clipboard "+

        ["i"] = actions.insert_name(),      -- Insert at start of name
        ["I"] = actions.insert_scope(),     -- Insert at start of scope

        ["a"] = actions.append_name(),      -- Insert at end of name
        ["A"] = actions.append_scope(),     -- Insert at end of scope

        ["r"] = actions.rename(),           -- Rename currently focused symbol

        ["d"] = actions.delete(),           -- Delete scope

        ["f"] = actions.fold_create(),      -- Create fold of current scope
        ["F"] = actions.fold_delete(),      -- Delete fold of current scope

        ["c"] = actions.comment(),          -- Comment out current scope

        ["<enter>"] = actions.select(),     -- Goto selected symbol
        ["o"] = actions.select(),

        ["J"] = actions.move_down(),        -- Move focused node down
        ["K"] = actions.move_up(),          -- Move focused node up

        ["s"] = actions.toggle_preview(),   -- Show preview of current node

        ["<C-v>"] = actions.vsplit(),       -- Open selected node in a vertical split
        ["<C-s>"] = actions.hsplit(),       -- Open selected node in a horizontal split

        ["t"] = actions.telescope({         -- Fuzzy finder at current level.
          layout_config = {               -- All options that can be
            height = 0.60,              -- passed to telescope.nvim's
            width = 0.60,               -- default can be passed here.
            prompt_position = "top",
            preview_width = 0.50
          },
          layout_strategy = "horizontal"
        }),

        ["g?"] = actions.help(),            -- Open mappings help window
      },
      lsp = {
        auto_attach = false,   -- If set to true, you don't need to manually use attach function
        preference = nil,      -- list of lsp server names in order of preference
      },
      source_buffer = {
        follow_node = true,    -- Keep the current node in focus on the source buffer
        highlight = true,      -- Highlight the currently focused node
        reorient = "smart",    -- "smart", "top", "mid" or "none"
        scrolloff = nil        -- scrolloff value when navbuddy is open
      },
      custom_hl_group = nil,     -- "Visual" or any other hl group to use instead of inverted colors
    }






    --actions-preview
    require("actions-preview").setup {
      -- options for vim.diff(): https://neovim.io/doc/user/lua.html#vim.diff()
      diff = {
        ctxlen = 3,
      },

      -- priority list of external command to highlight diff
      -- disabled by defalt, must be set by yourself
      highlight_command = {
      -- require("actions-preview.highlight").delta(),
      -- require("actions-preview.highlight").diff_so_fancy(),
      -- require("actions-preview.highlight").diff_highlight(),
      },

      -- priority list of preferred backend
      backend = { "telescope", "nui" },

      -- options related to telescope.nvim
      telescope = vim.tbl_extend(
        "force",
        -- telescope theme: https://github.com/nvim-telescope/telescope.nvim#themes
        require("telescope.themes").get_dropdown(),
        -- a table for customizing content
        {
          -- a function to make a table containing the values to be displayed.
          -- fun(action: Action): { title: string, client_name: string|nil }
          make_value = nil,

          -- a function to make a function to be used in `display` of a entry.
          -- see also `:h telescope.make_entry` and `:h telescope.pickers.entry_display`.
          -- fun(values: { index: integer, action: Action, title: string, client_name: string }[]): function
          make_make_display = nil,
        }
      ),

      -- options for nui.nvim components
      nui = {
        -- component direction. "col" or "row"
        dir = "col",
        -- keymap for selection component: https://github.com/MunifTanjim/nui.nvim/tree/main/lua/nui/menu#keymap
        keymap = nil,
        -- options for nui Layout component: https://github.com/MunifTanjim/nui.nvim/tree/main/lua/nui/layout
        layout = {
          position = "50%",
          size = {
            width = "60%",
            height = "90%",
          },
          min_width = 40,
          min_height = 10,
          relative = "editor",
        },
        -- options for preview area: https://github.com/MunifTanjim/nui.nvim/tree/main/lua/nui/popup
        preview = {
          size = "60%",
          border = {
            style = "rounded",
            padding = { 0, 1 },
          },
        },
        -- options for selection area: https://github.com/MunifTanjim/nui.nvim/tree/main/lua/nui/menu
        select = {
          size = "40%",
          border = {
            style = "rounded",
            padding = { 0, 1 },
          },
        },
      },
    }
    require("actions-preview").setup {
      diff = {
        algorithm = "patience",
        ignore_whitespace = true,
      },
      telescope = require("telescope.themes").get_dropdown { winblend = 10 },
    }
    local hl = require("actions-preview.highlight")
    require("actions-preview").setup {
      highlight_command = {
        -- Highlight diff using delta: https://github.com/dandavison/delta
        -- The argument is optional, in which case "delta" is assumed to be
        -- specified.
        hl.delta("path/to/delta --option1 --option2"),
        -- You may need to specify "--no-gitconfig" since it is dependent on
        -- the gitconfig of the project by default.
        -- hl.delta("delta --no-gitconfig --side-by-side"),

        -- Highlight diff using diff-so-fancy: https://github.com/so-fancy/diff-so-fancy
        -- The arguments are optional, in which case ("diff-so-fancy", "less -R")
        -- is assumed to be specified. The existence of less is optional.
        hl.diff_so_fancy("path/to/diff-so-fancy --option1 --option2"),

        -- Highlight diff using diff-highlight included in git-contrib.
        -- The arguments are optional; the first argument is assumed to be
        -- "diff-highlight" and the second argument is assumed to be
        -- `{ colordiff = "colordiff", pager = "less -R" }`. The existence of
        -- colordiff and less is optional.
        hl.diff_highlight(
          "path/to/diff-highlight",
          { colordiff = "path/to/colordiff" }
        ),

        -- And, you can use any command to highlight diff.
        -- Define the pipeline by `hl.commands`.
        hl.commands({
          { cmd = "command-to-diff-highlight" },
          -- `optional` can be used to define that the command is optional.
          { cmd = "less -R", optional = true },
        }),
        -- If you use optional `less -R` (or similar command), you can also use `hl.with_pager`.
        hl.with_pager("command-to-diff-highlight"),
      -- hl.with_pager("command-to-diff-highlight", "custom-pager"),
      },
    }
    require("actions-preview").setup {
      telescope = {
        sorting_strategy = "ascending",
        layout_strategy = "vertical",
        layout_config = {
          width = 0.8,
          height = 0.9,
          prompt_position = "top",
          preview_cutoff = 20,
          preview_height = function(_, _, max_lines)
            return max_lines - 15
          end,
        },
      },
    }




    --fidget
    require("fidget").setup(
      {
        -- Options related to LSP progress subsystem
        progress = {
          poll_rate = 0,                -- How and when to poll for progress messages
          suppress_on_insert = false,   -- Suppress new messages while in insert mode
          ignore_done_already = false,  -- Ignore new tasks that are already complete
          ignore_empty_message = false, -- Ignore new tasks that don't contain a message
          clear_on_detach =             -- Clear notification group when LSP server detaches
          function(client_id)
            local client = vim.lsp.get_client_by_id(client_id)
            return client and client.name or nil
          end,
          notification_group =          -- How to get a progress message's notification group key
          function(msg) return msg.lsp_client.name end,
          ignore = {},                  -- List of LSP servers to ignore

          -- Options related to how LSP progress messages are displayed as notifications
          display = {
            render_limit = 16,          -- How many LSP messages to show at once
            done_ttl = 3,               -- How long a message should persist after completion
            done_icon = "✔",            -- Icon shown when all LSP progress tasks are complete
            done_style = "Constant",    -- Highlight group for completed LSP tasks
            progress_ttl = math.huge,   -- How long a message should persist when in progress
            progress_icon =             -- Icon shown when LSP progress tasks are in progress
            { pattern = "dots", period = 1 },
            progress_style =            -- Highlight group for in-progress LSP tasks
            "WarningMsg",
            group_style = "Title",      -- Highlight group for group name (LSP server name)
            icon_style = "Question",    -- Highlight group for group icons
            priority = 30,              -- Ordering priority for LSP notification group
            skip_history = true,        -- Whether progress notifications should be omitted from history
            format_message =            -- How to format a progress message
            require("fidget.progress.display").default_format_message,
            format_annote =             -- How to format a progress annotation
            function(msg) return msg.title end,
            format_group_name =         -- How to format a progress notification group's name
            function(group) return tostring(group) end,
            overrides = {               -- Override options from the default notification config
              rust_analyzer = { name = "rust-analyzer" },
            },
          },

          -- Options related to Neovim's built-in LSP client
          lsp = {
            progress_ringbuf_size = 0,  -- Configure the nvim's LSP progress ring buffer size
            log_handler = false,        -- Log `$/progress` handler invocations (for debugging)
          },
        },

        -- Options related to notification subsystem
        notification = {
          poll_rate = 10,               -- How frequently to update and render notifications
          filter = vim.log.levels.INFO, -- Minimum notifications level
          history_size = 128,           -- Number of removed messages to retain in history
          override_vim_notify = false,  -- Automatically override vim.notify() with Fidget
          configs =                     -- How to configure notification groups when instantiated
          { default = require("fidget.notification").default_config },
          redirect =                    -- Conditionally redirect notifications to another backend
          function(msg, level, opts)
            if opts and opts.on_open then
              return require("fidget.integration.nvim-notify").delegate(msg, level, opts)
            end
          end,

          -- Options related to how notifications are rendered as text
          view = {
            stack_upwards = true,       -- Display notification items from bottom to top
            icon_separator = " ",       -- Separator between group name and icon
            group_separator = "---",    -- Separator between notification groups
            group_separator_hl =        -- Highlight group used for group separator
            "Comment",
            render_message =            -- How to render notification messages
            function(msg, cnt)
              return cnt == 1 and msg or string.format("(%dx) %s", cnt, msg)
            end,
          },

          -- Options related to the notification window and buffer
          window = {
            normal_hl = "Comment",      -- Base highlight group in the notification window
            winblend = 100,             -- Background color opacity in the notification window
            border = "none",            -- Border around the notification window
            zindex = 45,                -- Stacking priority of the notification window
            max_width = 0,              -- Maximum width of the notification window
            max_height = 0,             -- Maximum height of the notification window
            x_padding = 1,              -- Padding from right edge of window boundary
            y_padding = 0,              -- Padding from bottom edge of window boundary
            align = "bottom",           -- How to align the notification window
            relative = "editor",        -- What the notification window position is relative to
          },
        },

        -- Options related to integrating with other plugins
        integration = {
          ["nvim-tree"] = {
            enable = true,              -- Integrate with nvim-tree/nvim-tree.lua (if installed)
          },
          ["xcodebuild-nvim"] = {
            enable = true,              -- Integrate with wojciech-kulik/xcodebuild.nvim (if installed)
          },
        },

        -- Options related to logging
        logger = {
          level = vim.log.levels.WARN,  -- Minimum logging level
          max_size = 10000,             -- Maximum log file size, in KB
          float_precision = 0.01,       -- Limit the number of decimals displayed for floats
          path =                        -- Where Fidget writes its logs to
          string.format("%s/fidget.nvim.log", vim.fn.stdpath("cache")),
        },
      }
    )





    -- Lua configuration
    local glance = require('glance')
    local actions = glance.actions

    glance.setup({
      height = 18, -- Height of the window
      zindex = 45,

      -- By default glance will open preview "embedded" within your active window
      -- when `detached` is enabled, glance will render above all existing windows
      -- and won't be restiricted by the width of your active window
      -- detached = true,

      -- Or use a function to enable `detached` only when the active window is too small
      -- (default behavior)
      detached = function(winid)
        return vim.api.nvim_win_get_width(winid) < 100
      end,

      preview_win_opts = { -- Configure preview window options
        cursorline = true,
        number = true,
        wrap = true,
      },
      border = {
        enable = false, -- Show window borders. Only horizontal borders allowed
        top_char = '―',
        bottom_char = '―',
      },
      list = {
        position = 'right', -- Position of the list window 'left'|'right'
        width = 0.33, -- 33% width relative to the active window, min 0.1, max 0.5
      },
      theme = { -- This feature might not work properly in nvim-0.7.2
        enable = true, -- Will generate colors for the plugin based on your current colorscheme
        mode = 'auto', -- 'brighten'|'darken'|'auto', 'auto' will set mode based on the brightness of your colorscheme
      },
      mappings = {
        list = {
          ['j'] = actions.next, -- Bring the cursor to the next item in the list
          ['k'] = actions.previous, -- Bring the cursor to the previous item in the list
          ['<Down>'] = actions.next,
          ['<Up>'] = actions.previous,
          ['<Tab>'] = actions.next_location, -- Bring the cursor to the next location skipping groups in the list
          ['<S-Tab>'] = actions.previous_location, -- Bring the cursor to the previous location skipping groups in the list
          ['<C-u>'] = actions.preview_scroll_win(5),
          ['<C-d>'] = actions.preview_scroll_win(-5),
          ['v'] = actions.jump_vsplit,
          ['s'] = actions.jump_split,
          ['t'] = actions.jump_tab,
          ['<CR>'] = actions.jump,
          ['o'] = actions.jump,
          ['l'] = actions.open_fold,
          ['h'] = actions.close_fold,
          ['<leader>l'] = actions.enter_win('preview'), -- Focus preview window
          ['q'] = actions.close,
          ['Q'] = actions.close,
          ['<Esc>'] = actions.close,
          ['<C-q>'] = actions.quickfix,
        -- ['<Esc>'] = false -- disable a mapping
        },
        preview = {
          ['Q'] = actions.close,
          ['<Tab>'] = actions.next_location,
          ['<S-Tab>'] = actions.previous_location,
          ['<leader>l'] = actions.enter_win('list'), -- Focus list window
        },
      },
      hooks = {},
      folds = {
        fold_closed = '',
        fold_open = '',
        folded = true, -- Automatically fold list on startup
      },
      indent_lines = {
        enable = true,
        icon = '│',
      },
      winbar = {
        enable = true, -- Available strating from nvim-0.8+
      },
      use_trouble_qf = false -- Quickfix action will open trouble.nvim instead of built-in quickfix list window
    })
    -- Lua
    vim.keymap.set('n', 'GD', '<CMD>Glance definitions<CR>')
    vim.keymap.set('n', 'GR', '<CMD>Glance references<CR>')
    vim.keymap.set('n', 'GY', '<CMD>Glance type_definitions<CR>')
    vim.keymap.set('n', 'GM', '<CMD>Glance implementations<CR>')






    --lsp-progress
    require("lsp-progress").setup({
      client_format = function(client_name, spinner, series_messages)
        if #series_messages == 0 then
          return nil
        end
        return {
          name = client_name,
          body = spinner .. " " .. table.concat(series_messages, ", "),
        }
      end,
      format = function(client_messages)
        --- @param name string
        --- @param msg string?
        --- @return string
        local function stringify(name, msg)
          return msg and string.format("%s %s", name, msg) or name
        end

        local sign = "" -- nf-fa-gear \uf013
        local lsp_clients = vim.lsp.get_active_clients()
        local messages_map = {}
        for _, climsg in ipairs(client_messages) do
          messages_map[climsg.name] = climsg.body
        end

        if #lsp_clients > 0 then
          table.sort(lsp_clients, function(a, b)
            return a.name < b.name
          end)
          local builder = {}
          for _, cli in ipairs(lsp_clients) do
            if
              type(cli) == "table"
              and type(cli.name) == "string"
              and string.len(cli.name) > 0
            then
              if messages_map[cli.name] then
                table.insert(builder, stringify(cli.name, messages_map[cli.name]))
              else
                table.insert(builder, stringify(cli.name))
              end
            end
          end
          if #builder > 0 then
            return sign .. " " .. table.concat(builder, ", ")
          end
        end
        return ""
      end,
    })






    --LSPUI
    local LspUI = require("LspUI")
    LspUI.setup()





    --mason
    require("mason").setup({
      ui = {
        icons = {
          package_installed = "✓",
          package_pending = "➜",
          package_uninstalled = "✗"
        }
      }
    })

    ---@class MasonSettings
    local DEFAULT_SETTINGS = {
      ---@since 1.0.0
      -- The directory in which to install packages.
      install_root_dir = path.concat { vim.fn.stdpath "data", "mason" },

      ---@since 1.0.0
      -- Where Mason should put its bin location in your PATH. Can be one of:
      -- - "prepend" (default, Mason's bin location is put first in PATH)
      -- - "append" (Mason's bin location is put at the end of PATH)
      -- - "skip" (doesn't modify PATH)
      ---@type '"prepend"' | '"append"' | '"skip"'
      PATH = "prepend",

      ---@since 1.0.0
      -- Controls to which degree logs are written to the log file. It's useful to set this to vim.log.levels.DEBUG when
      -- debugging issues with package installations.
      log_level = vim.log.levels.INFO,

      ---@since 1.0.0
      -- Limit for the maximum amount of packages to be installed at the same time. Once this limit is reached, any further
      -- packages that are requested to be installed will be put in a queue.
      max_concurrent_installers = 4,

      ---@since 1.0.0
      -- [Advanced setting]
      -- The registries to source packages from. Accepts multiple entries. Should a package with the same name exist in
      -- multiple registries, the registry listed first will be used.
      registries = {
        "github:mason-org/mason-registry",
      },

      ---@since 1.0.0
      -- The provider implementations to use for resolving supplementary package metadata (e.g., all available versions).
      -- Accepts multiple entries, where later entries will be used as fallback should prior providers fail.
      -- Builtin providers are:
      --   - mason.providers.registry-api  - uses the https://api.mason-registry.dev API
      --   - mason.providers.client        - uses only client-side tooling to resolve metadata
      providers = {
        "mason.providers.registry-api",
        "mason.providers.client",
      },

      github = {
        ---@since 1.0.0
        -- The template URL to use when downloading assets from GitHub.
        -- The placeholders are the following (in order):
        -- 1. The repository (e.g. "rust-lang/rust-analyzer")
        -- 2. The release version (e.g. "v0.3.0")
        -- 3. The asset name (e.g. "rust-analyzer-v0.3.0-x86_64-unknown-linux-gnu.tar.gz")
        download_url_template = "https://github.com/%s/releases/download/%s/%s",
      },

      pip = {
        ---@since 1.0.0
        -- Whether to upgrade pip to the latest version in the virtual environment before installing packages.
        upgrade_pip = false,

        ---@since 1.0.0
        -- These args will be added to `pip install` calls. Note that setting extra args might impact intended behavior
        -- and is not recommended.
        --
        -- Example: { "--proxy", "https://proxyserver" }
        install_args = {},
      },

      ui = {
        ---@since 1.0.0
        -- Whether to automatically check for new versions when opening the :Mason window.
        check_outdated_packages_on_open = true,

        ---@since 1.0.0
        -- The border to use for the UI window. Accepts same border values as |nvim_open_win()|.
        border = "none",

        ---@since 1.0.0
        -- Width of the window. Accepts:
        -- - Integer greater than 1 for fixed width.
        -- - Float in the range of 0-1 for a percentage of screen width.
        width = 0.8,

        ---@since 1.0.0
        -- Height of the window. Accepts:
        -- - Integer greater than 1 for fixed height.
        -- - Float in the range of 0-1 for a percentage of screen height.
        height = 0.9,

        icons = {
          ---@since 1.0.0
          -- The list icon to use for installed packages.
          package_installed = "◍",
          ---@since 1.0.0
          -- The list icon to use for packages that are installing, or queued for installation.
          package_pending = "◍",
          ---@since 1.0.0
          -- The list icon to use for packages that are not installed.
          package_uninstalled = "◍",
        },

        keymaps = {
          ---@since 1.0.0
          -- Keymap to expand a package
          toggle_package_expand = "<CR>",
          ---@since 1.0.0
          -- Keymap to install the package under the current cursor position
          install_package = "i",
          ---@since 1.0.0
          -- Keymap to reinstall/update the package under the current cursor position
          update_package = "u",
          ---@since 1.0.0
          -- Keymap to check for new version for the package under the current cursor position
          check_package_version = "c",
          ---@since 1.0.0
          -- Keymap to update all installed packages
          update_all_packages = "U",
          ---@since 1.0.0
          -- Keymap to check which installed packages are outdated
          check_outdated_packages = "C",
          ---@since 1.0.0
          -- Keymap to uninstall a package
          uninstall_package = "X",
          ---@since 1.0.0
          -- Keymap to cancel a package installation
          cancel_installation = "<C-c>",
          ---@since 1.0.0
          -- Keymap to apply language filter
          apply_language_filter = "<C-f>",
          ---@since 1.1.0
          -- Keymap to toggle viewing package installation log
          toggle_package_install_log = "<CR>",
          ---@since 1.8.0
          -- Keymap to toggle the help view
          toggle_help = "g?",
        },
      },
    }

    require("mason").setup({DEFAULT_SETTINGS})




    --trouble
    require("trouble").setup({
      position = "bottom", -- position of the list can be: bottom, top, left, right
      height = 10, -- height of the trouble list when position is top or bottom
      width = 50, -- width of the list when position is left or right
      icons = true, -- use devicons for filenames
      mode = "workspace_diagnostics", -- "workspace_diagnostics", "document_diagnostics", "quickfix", "lsp_references", "loclist"
      severity = nil, -- nil (ALL) or vim.diagnostic.severity.ERROR | WARN | INFO | HINT
      fold_open = "", -- icon used for open folds
      fold_closed = "", -- icon used for closed folds
      group = true, -- group results by file
      padding = true, -- add an extra new line on top of the list
      cycle_results = true, -- cycle item list when reaching beginning or end of list
      action_keys = { -- key mappings for actions in the trouble list
        -- map to {} to remove a mapping, for example:
        -- close = {},
        close = "q", -- close the list
        cancel = "<esc>", -- cancel the preview and get back to your last window / buffer / cursor
        refresh = "r", -- manually refresh
        jump = { "<cr>", "<tab>", "<2-leftmouse>" }, -- jump to the diagnostic or open / close folds
        open_split = { "<c-x>" }, -- open buffer in new split
        open_vsplit = { "<c-v>" }, -- open buffer in new vsplit
        open_tab = { "<c-t>" }, -- open buffer in new tab
        jump_close = {"o"}, -- jump to the diagnostic and close the list
        toggle_mode = "m", -- toggle between "workspace" and "document" diagnostics mode
        switch_severity = "s", -- switch "diagnostics" severity filter level to HINT / INFO / WARN / ERROR
        toggle_preview = "P", -- toggle auto_preview
        hover = "K", -- opens a small popup with the full multiline message
        preview = "p", -- preview the diagnostic location
        open_code_href = "c", -- if present, open a URI with more information about the diagnostic error
        close_folds = {"zM", "zm"}, -- close all folds
        open_folds = {"zR", "zr"}, -- open all folds
        toggle_fold = {"zA", "za"}, -- toggle fold of current file
        previous = "k", -- previous item
        next = "j", -- next item
        help = "?", -- help menu
      },
      multiline = true, -- render multi-line messages
      indent_lines = true, -- add an indent guide below the fold icons
      win_config = { border = "single" }, -- window configuration for floating windows. See |nvim_open_win()|.
      auto_open = false, -- automatically open the list when you have diagnostics
      auto_close = false, -- automatically close the list when you have no diagnostics
      auto_preview = true, -- automatically preview the location of the diagnostic. <esc> to close preview and go back to last window
      auto_fold = false, -- automatically fold a file trouble list at creation
      auto_jump = {"lsp_definitions"}, -- for the given modes, automatically jump if there is only a single result
      include_declaration = { "lsp_references", "lsp_implementations", "lsp_definitions"  }, -- for the given modes, include the declaration of the current symbol in the results
      signs = {
        -- icons / text used for a diagnostic
        error = "",
        warning = "",
        hint = "",
        information = "",
        other = "",
      },
      use_diagnostic_signs = false -- enabling this will use the signs defined in your lsp client
    })
    -- Lua
    vim.keymap.set("n", "<leader>xx", function() require("trouble").toggle() end)
    vim.keymap.set("n", "<leader>xw", function() require("trouble").toggle("workspace_diagnostics") end)
    vim.keymap.set("n", "<leader>xd", function() require("trouble").toggle("document_diagnostics") end)
    vim.keymap.set("n", "<leader>xq", function() require("trouble").toggle("quickfix") end)
    vim.keymap.set("n", "<leader>xl", function() require("trouble").toggle("loclist") end)
    vim.keymap.set("n", "gR", function() require("trouble").toggle("lsp_references") end)




    --lsp-colors
    require("lsp-colors").setup({
      Error = "#db4b4b",
      Warning = "#e0af68",
      Information = "#0db9d7",
      Hint = "#10B981"
    })




    --snippets
    require("luasnip.loaders.from_vscode").lazy_load()
    require('snippy').setup({
      mappings = {
        is = {
          ['<Tab>'] = 'expand_or_advance',
          ['<S-Tab>'] = 'previous',
        },
        nx = {
          ['<leader>x'] = 'cut_text',
        },
      },
    })



    --nvim-autopairs

    require("nvim-autopairs").setup {
      disable_filetype = { "TelescopePrompt", "spectre_panel" },
      disable_in_macro = true , -- disable when recording or executing a macro
      disable_in_visualblock = false ,-- disable when insert after visual block mode
      disable_in_replace_mode = true,
      ignored_next_char = [=[[%w%%%'%[%"%.%`%$]]=],
      enable_moveright = true,
      enable_afterquote = true ,-- add bracket pairs after quote
      enable_check_bracket_line = true , --- check bracket in same line
      enable_bracket_in_quote = true ,--
      enable_abbr = false, -- trigger abbreviation
      break_undo = true, -- switch for basic rule break undo sequence
      check_ts = false,
      map_cr = true,
      map_bs = true ,-- map the <BS> key
      map_c_h = false ,-- Map the <C-h> key to delete a pair
      map_c_w = false -- map <c-w> to delete a pair if possible
    }
    local handlers = require('nvim-autopairs.completion.handlers')

    cmp.event:on(
      'confirm_done',
      cmp_autopairs.on_confirm_done({
        filetypes = {
          -- "*" is a alias to all filetypes
          ["*"] = {
            ["("] = {
              kind = {
                cmp.lsp.CompletionItemKind.Function,
                cmp.lsp.CompletionItemKind.Method,
              },
              handler = handlers["*"]
            }
          },
          lua = {
            ["("] = {
              kind = {
                cmp.lsp.CompletionItemKind.Function,
                cmp.lsp.CompletionItemKind.Method
              },
              ---@param char string
              ---@param item table item completion
              ---@param bufnr number buffer number
              ---@param rules table
              ---@param commit_character table<string>
              handler = function(char, item, bufnr, rules, commit_character)
              -- Your handler function. Inspect with print(vim.inspect{char, item, bufnr, rules, commit_character})
              end
            }
          },
          -- Disable for tex
          tex = false
        }
      })
    )

    local Rule = require('nvim-autopairs.rule')
    local npairs = require('nvim-autopairs')

    npairs.add_rule(Rule("$$","$$","tex"))

    -- you can use some built-in conditions

    local cond = require('nvim-autopairs.conds')
    print(vim.inspect(cond))

    npairs.add_rules({
      Rule("$", "$",{"tex", "latex"})
        -- don't add a pair if the next character is %
        :with_pair(cond.not_after_regex("%%"))
        -- don't add a pair if  the previous character is xxx
        :with_pair(cond.not_before_regex("xxx", 3))
        -- don't move right when repeat character
        :with_move(cond.none())
        -- don't delete if the next character is xx
        :with_del(cond.not_after_regex("xx"))
        -- disable adding a newline when you press <cr>
        :with_cr(cond.none())
    },
    -- disable for .vim files, but it work for another filetypes
    Rule("a","a","-vim")
    )

    npairs.add_rules({
      Rule("$$","$$","tex")
        :with_pair(function(opts)
          print(vim.inspect(opts))
          if opts.line=="aa $$" then
            -- don't add pair on that line
            return false
          end
        end)
    }
    )

    -- you can use regex
    -- press u1234 => u1234number
    npairs.add_rules({
      Rule("u%d%d%d%d$", "number", "lua")
        :use_regex(true)
    })



    -- press x1234 => x12341234
    npairs.add_rules({
      Rule("x%d%d%d%d$", "number", "lua")
        :use_regex(true)
        :replace_endpair(function(opts)
          -- print(vim.inspect(opts))
          return opts.prev_char:sub(#opts.prev_char - 3,#opts.prev_char)
        end)
    })


    -- you can do anything with regex +special key
    -- example press tab to uppercase text:
    -- press b1234s<tab> => B1234S1234S

    npairs.add_rules({
      Rule("b%d%d%d%d%w$", "", "vim")
        :use_regex(true,"<tab>")
        :replace_endpair(function(opts)
          return
            opts.prev_char:sub(#opts.prev_char - 4,#opts.prev_char)
            .."<esc>viwU"
        end)
    })

    -- you can exclude filetypes
    npairs.add_rule(
      Rule("$$","$$")
        :with_pair(cond.not_filetypes({"lua"}))
    )
    --- check ./lua/nvim-autopairs/rules/basic.lua


    --dial
    vim.keymap.set("n", "<C-a>", function()
      require("dial.map").manipulate("increment", "normal")
    end)
    vim.keymap.set("n", "<C-x>", function()
      require("dial.map").manipulate("decrement", "normal")
    end)
    vim.keymap.set("n", "g<C-a>", function()
      require("dial.map").manipulate("increment", "gnormal")
    end)
    vim.keymap.set("n", "g<C-x>", function()
      require("dial.map").manipulate("decrement", "gnormal")
    end)
    vim.keymap.set("v", "<C-a>", function()
      require("dial.map").manipulate("increment", "visual")
    end)
    vim.keymap.set("v", "<C-x>", function()
      require("dial.map").manipulate("decrement", "visual")
    end)
    vim.keymap.set("v", "g<C-a>", function()
      require("dial.map").manipulate("increment", "gvisual")
    end)
    vim.keymap.set("v", "g<C-x>", function()
      require("dial.map").manipulate("decrement", "gvisual")
    end)
    local augend = require("dial.augend")
    require("dial.config").augends:register_group{
      default = {
        augend.integer.alias.decimal,
        augend.integer.alias.hex,
        augend.date.alias["%Y/%m/%d"],
      },
      typescript = {
        augend.integer.alias.decimal,
        augend.integer.alias.hex,
        augend.constant.new{ elements = {"let", "const"} },
      },
      visual = {
        augend.integer.alias.decimal,
        augend.integer.alias.hex,
        augend.date.alias["%Y/%m/%d"],
        augend.constant.alias.alpha,
        augend.constant.alias.Alpha,
      },
    }

    -- change augends in VISUAL mode
    vim.keymap.set("v", "<C-a>", require("dial.map").inc_visual("visual"), {noremap = true})
    vim.keymap.set("v", "<C-x>", require("dial.map").dec_visual("visual"), {noremap = true})

    require("dial.config").augends:register_group{
      default = {
        -- uppercase hex number (0x1A1A, 0xEEFE, etc.)
        augend.integer.new{
          radix = 16,
          prefix = "0x",
          natural = true,
          case = "upper",
        },
      },
    }

    require("dial.config").augends:register_group{
      default = {
        -- date with format `yyyy/mm/dd`
        augend.date.new{
          pattern = "%Y/%m/%d",
          default_kind = "day",
          -- if true, it does not match dates which does not exist, such as 2022/05/32
          only_valid = true,
          -- if true, it only matches dates with word boundary
          word = false,
        },
      },
    }

    require("dial.config").augends:register_group{
      default = {
        -- uppercase hex number (0x1A1A, 0xEEFE, etc.)
        augend.hexcolor.new{
          case = "lower",
        },
      },
    }


    require("dial.config").augends:register_group{
      default = {
        -- uppercase hex number (0x1A1A, 0xEEFE, etc.)
        augend.constant.new{
          elements = {"and", "or"},
          word = true, -- if false, "sand" is incremented into "sor", "doctor" into "doctand", etc.
          cyclic = true,  -- "or" is incremented into "and".
        },
        augend.constant.new{
          elements = {"&&", "||"},
          word = false,
          cyclic = true,
        },
      },
    }





    require('nvim-ts-autotag').setup({
      opts = {
        -- Defaults
        enable_close = true, -- Auto close tags
        enable_rename = true, -- Auto rename pairs of tags
        enable_close_on_slash = false -- Auto close on trailing </
      },
      -- Also override individual filetype configs, these take priority.
      -- Empty by default, useful if one of the "opts" global settings
      -- doesn't work well in a specific filetype
      per_filetype = {
        ["html"] = {
          enable_close = false
        }
      }
    })

    vim.lsp.handlers['textDocument/publishDiagnostics'] = vim.lsp.with(
      vim.lsp.diagnostic.on_publish_diagnostics,
      {
        underline = true,
        virtual_text = {
          spacing = 5,
          severity_limit = 'Warning',
        },
        update_in_insert = true,
      }
    )

    local moveline = require('moveline')
    vim.keymap.set('n', '<M-k>', moveline.up)
    vim.keymap.set('n', '<M-j>', moveline.down)
    vim.keymap.set('v', '<M-k>', moveline.block_up)
    vim.keymap.set('v', '<M-j>', moveline.block_down)


    --Comment
    require('Comment').setup()



    --lsp-format
    require("lsp-format").setup {}


    --auto-save and auto-format
    require("auto-save").setup({
      -- The name of the augroup.
      augroup_name = "AutoSavePlug",

      -- The events in which to trigger an auto save.
      events = { "InsertLeave", "TextChanged" },

      -- If you'd prefer to silence the output of `save_fn`.
      silent = true,

      -- If you'd prefer to write a vim command.
      save_cmd = nil,

      -- What to do after checking if auto save conditions have been met.
      save_fn = function()
        local config = require("auto-save.config")
        if config.save_cmd ~= nil then
          vim.cmd(config.save_cmd)
        elseif config.silent then
          vim.cmd("silent! w")
        else
          vim.cmd("w")
        end
      end,

      -- May define a timeout, or a duration to defer the save for - this allows
      -- for formatters to run, for example if they're configured via an autocmd
      -- that listens for `BufWritePre` event.
      timeout = nil,

      -- Define some filetypes to explicitly not save, in case our existing conditions
      -- don't quite catch all the buffers we'd prefer not to write to.
      exclude_ft = {},
    })

    require("auto-format").setup({
      -- The name of the augroup.
      augroup_name = "AutoFormat",

      -- If formatting takes longer than this amount of time, it will fail. Having no
      -- timeout at all tends to be ugly - larger files, complex or poor formatters
      -- will struggle to format within whatever the default timeout
      -- `vim.lsp.buf.format` uses.
      timeout = 2000,

      -- These filetypes will not be formatted automatically.
      exclude_ft = {},

      -- Prefer formatting via LSP for these filetypes.
      prefer_lsp = {},
    })




--conform
require("conform").setup({
  -- Map of filetype to formatters
  formatters_by_ft = {
    lua = { "stylua" },
    -- Conform will run multiple formatters sequentially
    go = { "goimports", "gofmt" },
    -- Use a sub-list to run only the first available formatter
    javascript = { { "prettierd", "prettier" } },
    -- You can use a function here to determine the formatters dynamically
    python = function(bufnr)
      if require("conform").get_formatter_info("ruff_format", bufnr).available then
        return { "ruff_format" }
      else
        return { "isort", "black" }
      end
    end,
    -- Use the "*" filetype to run formatters on all filetypes.
    ["*"] = { "codespell" },
    -- Use the "_" filetype to run formatters on filetypes that don't
    -- have other formatters configured.
    ["_"] = { "trim_whitespace" },
  },
  -- If this is set, Conform will run the formatter on save.
  -- It will pass the table to conform.format().
  -- This can also be a function that returns the table.
  format_on_save = {
    -- I recommend these options. See :help conform.format for details.
    lsp_fallback = true,
    timeout_ms = 500,
  },
  -- If this is set, Conform will run the formatter asynchronously after save.
  -- It will pass the table to conform.format().
  -- This can also be a function that returns the table.
  format_after_save = {
    lsp_fallback = true,
  },
  -- Set the log level. Use `:ConformInfo` to see the location of the log file.
  log_level = vim.log.levels.ERROR,
  -- Conform will notify you when a formatter errors
  notify_on_error = true,
  -- Custom formatters and overrides for built-in formatters
  formatters = {
    my_formatter = {
      -- This can be a string or a function that returns a string.
      -- When defining a new formatter, this is the only field that is required
      command = "my_cmd",
      -- A list of strings, or a function that returns a list of strings
      -- Return a single string instead of a list to run the command in a shell
      args = { "--stdin-from-filename", "$FILENAME" },
      -- If the formatter supports range formatting, create the range arguments here
      range_args = function(self, ctx)
        return { "--line-start", ctx.range.start[1], "--line-end", ctx.range["end"][1] }
      end,
      -- Send file contents to stdin, read new contents from stdout (default true)
      -- When false, will create a temp file (will appear in "$FILENAME" args). The temp
      -- file is assumed to be modified in-place by the format command.
      stdin = true,
      -- A function that calculates the directory to run the command in
      cwd = require("conform.util").root_file({ ".editorconfig", "package.json" }),
      -- When cwd is not found, don't run the formatter (default false)
      require_cwd = true,
      -- When stdin=false, use this template to generate the temporary file that gets formatted
      tmpfile_format = ".conform.$RANDOM.$FILENAME",
      -- When returns false, the formatter will not be used
      condition = function(self, ctx)
        return vim.fs.basename(ctx.filename) ~= "README.md"
      end,
      -- Exit codes that indicate success (default { 0 })
      exit_codes = { 0, 1 },
      -- Environment variables. This can also be a function that returns a table.
      env = {
        VAR = "value",
      },
      -- Set to false to disable merging the config with the base definition
      inherit = true,
      -- When inherit = true, add these additional arguments to the command.
      -- This can also be a function, like args
      prepend_args = { "--use-tabs" },
    },
    -- These can also be a function that returns the formatter
    other_formatter = function(bufnr)
      return {
        command = "my_cmd",
      }
    end,
  },
})

-- You can set formatters_by_ft and formatters directly
require("conform").formatters_by_ft.lua = { "stylua" }
require("conform").formatters.my_formatter = {
  command = "my_cmd",
}
require("conform").setup({
  formatters_by_ft = {
    lua = { "stylua" },
    -- Conform will run multiple formatters sequentially
    python = { "isort", "black" },
    -- Use a sub-list to run only the first available formatter
    javascript = { { "prettierd", "prettier" } },
  },
})

--treesitter
require'nvim-treesitter.configs'.setup {
  -- A list of parser names, or "all" (the five listed parsers should always be installed)
  ensure_installed = "community",

  -- Install parsers synchronously (only applied to `ensure_installed`)
  sync_install = true,

  -- Automatically install missing parsers when entering buffer
  -- Recommendation: set to false if you don't have `tree-sitter` CLI installed locally
  auto_install = true,

  -- List of parsers to ignore installing (or "all")
  -- ignore_install = { "javascript" },

  ---- If you need to change the installation directory of the parsers (see -> Advanced Setup)
  -- parser_install_dir = "/some/path/to/store/parsers", -- Remember to run vim.opt.runtimepath:append("/some/path/to/store/parsers")!

  highlight = {
    enable = true,

    -- NOTE: these are the names of the parsers and not the filetype. (for example if you want to
    -- disable highlighting for the `tex` filetype, you need to include `latex` in this list as this is
    -- the name of the parser)
    -- list of language that will be disabled
    -- Or use a function for more flexibility, e.g. to disable slow treesitter highlight for large files
    disable = function(lang, buf)
        local max_filesize = 100 * 1024 -- 100 KB
        local ok, stats = pcall(vim.loop.fs_stat, vim.api.nvim_buf_get_name(buf))
        if ok and stats and stats.size > max_filesize then
            return true
        end
    end,

    -- Setting this to true will run `:h syntax` and tree-sitter at the same time.
    -- Set this to `true` if you depend on 'syntax' being enabled (like for indentation).
    -- Using this option may slow down your editor, and you may see some duplicate highlights.
    -- Instead of true it can also be a list of languages
    additional_vim_regex_highlighting = false,
  },
}

require'nvim-treesitter.configs'.setup {
  textobjects = {
    select = {
      enable = true,

      -- Automatically jump forward to textobj, similar to targets.vim
      lookahead = true,

      keymaps = {
        -- You can use the capture groups defined in textobjects.scm
        ["af"] = "@function.outer",
        ["if"] = "@function.inner",
        ["ac"] = "@class.outer",
        -- You can optionally set descriptions to the mappings (used in the desc parameter of
        -- nvim_buf_set_keymap) which plugins like which-key display
        ["ic"] = { query = "@class.inner", desc = "Select inner part of a class region" },
        -- You can also use captures from other query groups like `locals.scm`
        ["as"] = { query = "@scope", query_group = "locals", desc = "Select language scope" },
      },
      -- You can choose the select mode (default is charwise 'v')
      --
      -- Can also be a function which gets passed a table with the keys
      -- * query_string: eg '@function.inner'
      -- * method: eg 'v' or 'o'
      -- and should return the mode ('v', 'V', or '<c-v>') or a table
      -- mapping query_strings to modes.
      selection_modes = {
        ['@parameter.outer'] = 'v', -- charwise
        ['@function.outer'] = 'V', -- linewise
        ['@class.outer'] = '<c-v>', -- blockwise
      },
      -- If you set this to `true` (default is `false`) then any textobject is
      -- extended to include preceding or succeeding whitespace. Succeeding
      -- whitespace has priority in order to act similarly to eg the built-in
      -- `ap`.
      --
      -- Can also be a function which gets passed a table with the keys
      -- * query_string: eg '@function.inner'
      -- * selection_mode: eg 'v'
      -- and should return true or false
      include_surrounding_whitespace = true,
    },
  },
}
require'nvim-treesitter.configs'.setup {
  textobjects = {
    swap = {
      enable = true,
      swap_next = {
        ["<leader>a"] = "@parameter.inner",
      },
      swap_previous = {
        ["<leader>A"] = "@parameter.inner",
      },
    },
  },
}
require'nvim-treesitter.configs'.setup {
  textobjects = {
    move = {
      enable = true,
      set_jumps = true, -- whether to set jumps in the jumplist
      goto_next_start = {
        ["]m"] = "@function.outer",
        ["]]"] = { query = "@class.outer", desc = "Next class start" },
        --
        -- You can use regex matching (i.e. lua pattern) and/or pass a list in a "query" key to group multiple queires.
        ["]o"] = "@loop.*",
        -- ["]o"] = { query = { "@loop.inner", "@loop.outer" } }
        --
        -- You can pass a query group to use query from `queries/<lang>/<query_group>.scm file in your runtime path.
        -- Below example nvim-treesitter's `locals.scm` and `folds.scm`. They also provide highlights.scm and indent.scm.
        ["]s"] = { query = "@scope", query_group = "locals", desc = "Next scope" },
        ["]z"] = { query = "@fold", query_group = "folds", desc = "Next fold" },
      },
      goto_next_end = {
        ["]M"] = "@function.outer",
        ["]["] = "@class.outer",
      },
      goto_previous_start = {
        ["[m"] = "@function.outer",
        ["[["] = "@class.outer",
      },
      goto_previous_end = {
        ["[M"] = "@function.outer",
        ["[]"] = "@class.outer",
      },
      -- Below will go to either the start or the end, whichever is closer.
      -- Use if you want more granular movements
      -- Make it even more gradual by adding multiple queries and regex.
      goto_next = {
        ["]d"] = "@conditional.outer",
      },
      goto_previous = {
        ["[d"] = "@conditional.outer",
      }
    },
  },
}

  end,

},


{
'gaborvecsei/usage-tracker.nvim',
 'matbme/JABS.nvim',
'doctorfree/cheatsheet.nvim',
'nvim-lua/popup.nvim',
'nvim-lua/plenary.nvim',
'nvim-telescope/telescope.nvim',
'code-biscuits/nvim-biscuits',
 'rcarriga/nvim-notify',
 "folke/noice.nvim",
  'MunifTanjim/nui.nvim',
   'stevearc/dressing.nvim',
 'crusj/bookmarks.nvim',
   'AckslD/messages.nvim',
 'LukasPietzschmann/telescope-tabs',
   "yutkat/confirm-quit.nvim",
 'mfussenegger/nvim-dap',
 'rcarriga/nvim-dap-ui',
  'Weissle/persistent-breakpoints.nvim',
 'ofirgall/goto-breakpoints.nvim',
 'theHamsta/nvim-dap-virtual-text',
  'MarcHamamji/runner.nvim',
 "folke/neodev.nvim",
 "nvim-lua/plenary.nvim",
 'nvim-lua/popup.nvim',
   'piersolenski/telescope-import.nvim',
 "aPeoplesCalendar/apc.nvim",
  'pwntester/octo.nvim',
 "kdheepak/lazygit.nvim",
 "lewis6991/gitsigns.nvim",
 'gen740/SmoothCursor.nvim',
 "folke/which-key.nvim",
  'gorbit99/codewindow.nvim',
  "folke/zen-mode.nvim",
  config = function()

--usage-tracker
require('usage-tracker').setup({
  keep_eventlog_days = 14,
  cleanup_freq_days = 7,
  event_wait_period_in_sec = 5,
  inactivity_threshold_in_min = 5,
  inactivity_check_freq_in_sec = 5,
  verbose = 0,
  telemetry_endpoint = "" -- you'll need to start the restapi for this feature
})


--JABS
require 'jabs'.setup {
  -- Options for the main window
  position = {'center', 'top'}, -- position = {'<position_x>', '<position_y>'} | <position_x> left, center, right,
  --                                             <position_y> top, center, bottom
  -- Default {'right', 'bottom'}

  relative = 'editor', -- win, editor, cursor. Default win
  clip_popup_size = false, -- clips the popup size to the win (or editor) size. Default true

  width = 80, -- default 50
  height = 20, -- default 10
  border = 'single', -- none, single, double, rounded, solid, shadow, (or an array or chars). Default shadow

  offset = { -- window position offset
    top = 2, -- default 0
    bottom = 2, -- default 0
    left = 2, -- default 0
    right = 2, -- default 0
  },

  sort_mru = true, -- Sort buffers by most recently used (true or false). Default false
  split_filename = true, -- Split filename into separate components for name and path. Default false
  split_filename_path_width = 20, -- If split_filename is true, how wide the column for the path is supposed to be, Default 0 (don't show path)

  -- Options for preview window
  preview_position = 'left', -- top, bottom, left, right. Default top
  preview = {
    width = 40, -- default 70
    height = 60, -- default 30
    border = 'single', -- none, single, double, rounded, solid, shadow, (or an array or chars). Default double
  },

  -- Default highlights (must be a valid :highlight)
  highlight = {
    current = "Title", -- default StatusLine
    hidden = "StatusLineNC", -- default ModeMsg
    split = "WarningMsg", -- default StatusLine
    alternate = "StatusLine" -- default WarningMsg
  },

  -- Default symbols
  symbols = {
    current = "C", -- default 
    split = "S", -- default 
    alternate = "A", -- default 
    hidden = "H", -- default ﬘
    locked = "L", -- default 
    ro = "R", -- default 
    edited = "E", -- default 
    terminal = "T", -- default 
    default_file = "D", -- Filetype icon if not present in nvim-web-devicons. Default 
    terminal_symbol = ">_" -- Filetype icon for a terminal split. Default 
  },

  -- Keymaps
  keymap = {
    close = "<c-d>", -- Close buffer. Default D
    jump = "<space>", -- Jump to buffer. Default <cr>
    h_split = "h", -- Horizontally split buffer. Default s
    v_split = "v", -- Vertically split buffer. Default v
    preview = "p", -- Open buffer preview. Default P
  },

  -- Whether to use nvim-web-devicons next to filenames
  use_devicons = false -- true or false. Default true
}





--cheatsheet
require("cheatsheet").setup({
    -- Whether to show bundled cheatsheets

    -- For generic cheatsheets like default, unicode, nerd-fonts, etc
    -- bundled_cheatsheets = {
    --     enabled = {},
    --     disabled = {},
    -- },
    bundled_cheatsheets = true,

    -- For plugin specific cheatsheets
    -- bundled_plugin_cheatsheets = {
    --     enabled = {},
    --     disabled = {},
    -- }
    bundled_plugin_cheatsheets = true,

    -- For bundled plugin cheatsheets, do not show a sheet if you
    -- don't have the plugin installed (searches runtimepath for
    -- same directory name)
    include_only_installed_plugins = true,

    -- Key mappings bound inside the telescope window
    telescope_mappings = {
        ['<CR>'] = require('cheatsheet.telescope.actions').select_or_fill_commandline,
        ['<A-CR>'] = require('cheatsheet.telescope.actions').select_or_execute,
        ['<C-Y>'] = require('cheatsheet.telescope.actions').copy_cheat_value,
        ['<C-E>'] = require('cheatsheet.telescope.actions').edit_user_cheatsheet,
    }
})




--biscuits
require('nvim-biscuits').setup({
  default_config = {
    max_length = 12,
    min_distance = 5,
    prefix_string = " 📎 "
  },
  language_config = {
    html = {
      prefix_string = " 🌐 "
    },
    javascript = {
      prefix_string = " ✨ ",
      max_length = 80
    },
    python = {
      disabled = true
    }
  }
})
require('nvim-biscuits').setup({
  cursor_line_only = true
})




--notify
--noice
require("noice").setup({
  cmdline = {
    enabled = true, -- enables the Noice cmdline UI
    view = "cmdline_popup", -- view for rendering the cmdline. Change to `cmdline` to get a classic cmdline at the bottom
    opts = {}, -- global options for the cmdline. See section on views
    ---@type table<string, CmdlineFormat>
    format = {
      -- conceal: (default=true) This will hide the text in the cmdline that matches the pattern.
      -- view: (default is cmdline view)
      -- opts: any options passed to the view
      -- icon_hl_group: optional hl_group for the icon
      -- title: set to anything or empty string to hide
      cmdline = { pattern = "^:", icon = "", lang = "vim" },
      search_down = { kind = "search", pattern = "^/", icon = " ", lang = "regex" },
      search_up = { kind = "search", pattern = "^%?", icon = " ", lang = "regex" },
      filter = { pattern = "^:%s*!", icon = "$", lang = "bash" },
      lua = { pattern = { "^:%s*lua%s+", "^:%s*lua%s*=%s*", "^:%s*=%s*" }, icon = "", lang = "lua" },
      help = { pattern = "^:%s*he?l?p?%s+", icon = "" },
      input = {}, -- Used by input()
      -- lua = false, -- to disable a format, set to `false`
    },
  },
  messages = {
    -- NOTE: If you enable messages, then the cmdline is enabled automatically.
    -- This is a current Neovim limitation.
    enabled = true, -- enables the Noice messages UI
    view = "notify", -- default view for messages
    view_error = "notify", -- view for errors
    view_warn = "notify", -- view for warnings
    view_history = "messages", -- view for :messages
    view_search = "virtualtext", -- view for search count messages. Set to `false` to disable
  },
  popupmenu = {
    enabled = true, -- enables the Noice popupmenu UI
    ---@type 'nui'|'cmp'
    backend = "nui", -- backend to use to show regular cmdline completions
    ---@type NoicePopupmenuItemKind|false
    -- Icons for completion item kinds (see defaults at noice.config.icons.kinds)
    kind_icons = {}, -- set to `false` to disable icons
  },
  -- default options for require('noice').redirect
  -- see the section on Command Redirection
  ---@type NoiceRouteConfig
  redirect = {
    view = "popup",
    filter = { event = "msg_show" },
  },
  -- You can add any custom commands below that will be available with `:Noice command`
  ---@type table<string, NoiceCommand>
  commands = {
    history = {
      -- options for the message history that you get with `:Noice`
      view = "split",
      opts = { enter = true, format = "details" },
      filter = {
        any = {
          { event = "notify" },
          { error = true },
          { warning = true },
          { event = "msg_show", kind = { "" } },
          { event = "lsp", kind = "message" },
        },
      },
    },
    -- :Noice last
    last = {
      view = "popup",
      opts = { enter = true, format = "details" },
      filter = {
        any = {
          { event = "notify" },
          { error = true },
          { warning = true },
          { event = "msg_show", kind = { "" } },
          { event = "lsp", kind = "message" },
        },
      },
      filter_opts = { count = 1 },
    },
    -- :Noice errors
    errors = {
      -- options for the message history that you get with `:Noice`
      view = "popup",
      opts = { enter = true, format = "details" },
      filter = { error = true },
      filter_opts = { reverse = true },
    },
    all = {
      -- options for the message history that you get with `:Noice`
      view = "split",
      opts = { enter = true, format = "details" },
      filter = {},
    },
  },
  notify = {
    -- Noice can be used as `vim.notify` so you can route any notification like other messages
    -- Notification messages have their level and other properties set.
    -- event is always "notify" and kind can be any log level as a string
    -- The default routes will forward notifications to nvim-notify
    -- Benefit of using Noice for this is the routing and consistent history view
    enabled = true,
    view = "notify",
  },
  lsp = {
    progress = {
      enabled = true,
      -- Lsp Progress is formatted using the builtins for lsp_progress. See config.format.builtin
      -- See the section on formatting for more details on how to customize.
      --- @type NoiceFormat|string
      format = "lsp_progress",
      --- @type NoiceFormat|string
      format_done = "lsp_progress_done",
      throttle = 1000 / 30, -- frequency to update lsp progress message
      view = "mini",
    },
    override = {
      -- override the default lsp markdown formatter with Noice
      ["vim.lsp.util.convert_input_to_markdown_lines"] = false,
      -- override the lsp markdown formatter with Noice
      ["vim.lsp.util.stylize_markdown"] = false,
      -- override cmp documentation with Noice (needs the other options to work)
      ["cmp.entry.get_documentation"] = false,
    },
    hover = {
      enabled = true,
      silent = false, -- set to true to not show a message if hover is not available
      view = nil, -- when nil, use defaults from documentation
      ---@type NoiceViewOptions
      opts = {}, -- merged with defaults from documentation
    },
    signature = {
      enabled = true,
      auto_open = {
        enabled = true,
        trigger = true, -- Automatically show signature help when typing a trigger character from the LSP
        luasnip = true, -- Will open signature help when jumping to Luasnip insert nodes
        throttle = 50, -- Debounce lsp signature help request by 50ms
      },
      view = nil, -- when nil, use defaults from documentation
      ---@type NoiceViewOptions
      opts = {}, -- merged with defaults from documentation
    },
    message = {
      -- Messages shown by lsp servers
      enabled = true,
      view = "notify",
      opts = {},
    },
    -- defaults for hover and signature help
    documentation = {
      view = "hover",
      ---@type NoiceViewOptions
      opts = {
        lang = "markdown",
        replace = true,
        render = "plain",
        format = { "{message}" },
        win_options = { concealcursor = "n", conceallevel = 3 },
      },
    },
  },
  markdown = {
    hover = {
      ["|(%S-)|"] = vim.cmd.help, -- vim help links
      ["%[.-%]%((%S-)%)"] = require("noice.util").open, -- markdown links
    },
    highlights = {
      ["|%S-|"] = "@text.reference",
      ["@%S+"] = "@parameter",
      ["^%s*(Parameters:)"] = "@text.title",
      ["^%s*(Return:)"] = "@text.title",
      ["^%s*(See also:)"] = "@text.title",
      ["{%S-}"] = "@parameter",
    },
  },
  health = {
    checker = true, -- Disable if you don't want health checks to run
  },
  smart_move = {
    -- noice tries to move out of the way of existing floating windows.
    enabled = true, -- you can disable this behaviour here
    -- add any filetypes here, that shouldn't trigger smart move.
    excluded_filetypes = { "cmp_menu", "cmp_docs", "notify" },
  },
  ---@type NoicePresets
  presets = {
    -- you can enable a preset by setting it to true, or a table that will override the preset config
    -- you can also add custom presets that you can enable/disable with enabled=true
    bottom_search = false, -- use a classic bottom cmdline for search
    command_palette = false, -- position the cmdline and popupmenu together
    long_message_to_split = false, -- long messages will be sent to a split
    inc_rename = false, -- enables an input dialog for inc-rename.nvim
    lsp_doc_border = false, -- add a border to hover docs and signature help
  },
  throttle = 1000 / 30, -- how frequently does Noice need to check for ui updates? This has no effect when in blocking mode.
  ---@type NoiceConfigViews
  views = {}, ---@see section on views
  ---@type NoiceRouteConfig[]
  routes = {}, --- @see section on routes
  ---@type table<string, NoiceFilter>
  status = {}, --- @see section on statusline components
  ---@type NoiceFormatOptions
  format = {}, --- @see section on formatting
})
vim.keymap.set({ "n", "i", "s" }, "<c-f>", function()
  if not require("noice.lsp").scroll(4) then
    return "<c-f>"
  end
end, { silent = true, expr = true })

vim.keymap.set({ "n", "i", "s" }, "<c-b>", function()
  if not require("noice.lsp").scroll(-4) then
    return "<c-b>"
  end
end, { silent = true, expr = true })



--nui
local Popup = require("nui.popup")
local Layout = require("nui.layout")
local event = require("nui.utils.autocmd").event
local Input = require("nui.input")
local Menu = require("nui.menu")
local popup_one, popup_two = Popup({
  enter = true,
  border = "single",
}), Popup({
  border = "double",
})

local layout = Layout(
  {
    position = "50%",
    size = {
      width = 80,
      height = "60%",
    },
  },
  Layout.Box({
    Layout.Box(popup_one, { size = "40%" }),
    Layout.Box(popup_two, { size = "60%" }),
  }, { dir = "row" })
)

local current_dir = "row"

popup_one:map("n", "r", function()
  if current_dir == "col" then
    layout:update(Layout.Box({
      Layout.Box(popup_one, { size = "40%" }),
      Layout.Box(popup_two, { size = "60%" }),
    }, { dir = "row" }))

    current_dir = "row"
  else
    layout:update(Layout.Box({
      Layout.Box(popup_two, { size = "60%" }),
      Layout.Box(popup_one, { size = "40%" }),
    }, { dir = "col" }))

    current_dir = "col"
  end
end, {})

layout:mount()

local popup = Popup({
  enter = true,
  focusable = true,
  border = {
    style = "rounded",
  },
  position = "50%",
  size = {
    width = "80%",
    height = "60%",
  },
})

-- mount/open the component
popup:mount()

-- unmount component when cursor leaves buffer
popup:on(event.BufLeave, function()
  popup:unmount()
end)
local input = Input({
  position = "50%",
  size = {
    width = 20,
  },
  border = {
    style = "single",
    text = {
      top = "[Howdy?]",
      top_align = "center",
    },
  },
  win_options = {
    winhighlight = "Normal:Normal,FloatBorder:Normal",
  },
}, {
  prompt = "> ",
  default_value = "Hello",
  on_close = function()
    print("Input Closed!")
  end,
  on_submit = function(value)
    print("Input Submitted: " .. value)
  end,
})

-- mount/open the component
input:mount()

-- unmount component when cursor leaves buffer
input:on(event.BufLeave, function()
  input:unmount()
end)


local menu = Menu({
  position = "50%",
  size = {
    width = 25,
    height = 5,
  },
  border = {
    style = "single",
    text = {
      top = "[Choose-an-Element]",
      top_align = "center",
    },
  },
  win_options = {
    winhighlight = "Normal:Normal,FloatBorder:Normal",
  },
}, {
  lines = {
    Menu.item("Hydrogen (H)"),
    Menu.item("Carbon (C)"),
    Menu.item("Nitrogen (N)"),
    Menu.separator("Noble-Gases", {
      char = "-",
      text_align = "right",
    }),
    Menu.item("Helium (He)"),
    Menu.item("Neon (Ne)"),
    Menu.item("Argon (Ar)"),
  },
  max_width = 20,
  keymap = {
    focus_next = { "j", "<Down>", "<Tab>" },
    focus_prev = { "k", "<Up>", "<S-Tab>" },
    close = { "<Esc>", "<C-c>" },
    submit = { "<CR>", "<Space>" },
  },
  on_close = function()
    print("Menu Closed!")
  end,
  on_submit = function(item)
    print("Menu Submitted: ", item.text)
  end,
})

-- mount the component
menu:mount()



--dressing
require("dressing").setup({
  input = {
    -- Set to false to disable the vim.ui.input implementation
    enabled = true,

    -- Default prompt string
    default_prompt = "Input",

    -- Trim trailing `:` from prompt
    trim_prompt = true,

    -- Can be 'left', 'right', or 'center'
    title_pos = "left",

    -- When true, <Esc> will close the modal
    insert_only = true,

    -- When true, input will start in insert mode.
    start_in_insert = true,

    -- These are passed to nvim_open_win
    border = "rounded",
    -- 'editor' and 'win' will default to being centered
    relative = "cursor",

    -- These can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
    prefer_width = 40,
    width = nil,
    -- min_width and max_width can be a list of mixed types.
    -- min_width = {20, 0.2} means "the greater of 20 columns or 20% of total"
    max_width = { 140, 0.9 },
    min_width = { 20, 0.2 },

    buf_options = {},
    win_options = {
      -- Disable line wrapping
      wrap = false,
      -- Indicator for when text exceeds window
      list = true,
      listchars = "precedes:…,extends:…",
      -- Increase this for more context when text scrolls off the window
      sidescrolloff = 0,
    },

    -- Set to `false` to disable
    mappings = {
      n = {
        ["<Esc>"] = "Close",
        ["<CR>"] = "Confirm",
      },
      i = {
        ["<C-c>"] = "Close",
        ["<CR>"] = "Confirm",
        ["<Up>"] = "HistoryPrev",
        ["<Down>"] = "HistoryNext",
      },
    },

    override = function(conf)
      -- This is the config that will be passed to nvim_open_win.
      -- Change values here to customize the layout
      return conf
    end,

    -- see :help dressing_get_config
    get_config = nil,
  },
  select = {
    -- Set to false to disable the vim.ui.select implementation
    enabled = true,

    -- Priority list of preferred vim.select implementations
    backend = { "telescope", "fzf_lua", "fzf", "builtin", "nui" },

    -- Trim trailing `:` from prompt
    trim_prompt = true,

    -- Options for telescope selector
    -- These are passed into the telescope picker directly. Can be used like:
    -- telescope = require('telescope.themes').get_ivy({...})
    telescope = nil,

    -- Options for fzf selector
    fzf = {
      window = {
        width = 0.5,
        height = 0.4,
      },
    },

    -- Options for fzf-lua
    fzf_lua = {
      -- winopts = {
      --   height = 0.5,
      --   width = 0.5,
      -- },
    },

    -- Options for nui Menu
    nui = {
      position = "50%",
      size = nil,
      relative = "editor",
      border = {
        style = "rounded",
      },
      buf_options = {
        swapfile = false,
        filetype = "DressingSelect",
      },
      win_options = {
        winblend = 0,
      },
      max_width = 80,
      max_height = 40,
      min_width = 40,
      min_height = 10,
    },

    -- Options for built-in selector
    builtin = {
      -- Display numbers for options and set up keymaps
      show_numbers = true,
      -- These are passed to nvim_open_win
      border = "rounded",
      -- 'editor' and 'win' will default to being centered
      relative = "editor",

      buf_options = {},
      win_options = {
        cursorline = true,
        cursorlineopt = "both",
      },

      -- These can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
      -- the min_ and max_ options can be a list of mixed types.
      -- max_width = {140, 0.8} means "the lesser of 140 columns or 80% of total"
      width = nil,
      max_width = { 140, 0.8 },
      min_width = { 40, 0.2 },
      height = nil,
      max_height = 0.9,
      min_height = { 10, 0.2 },

      -- Set to `false` to disable
      mappings = {
        ["<Esc>"] = "Close",
        ["<C-c>"] = "Close",
        ["<CR>"] = "Confirm",
      },

      override = function(conf)
        -- This is the config that will be passed to nvim_open_win.
        -- Change values here to customize the layout
        return conf
      end,
    },

    -- Used to override format_item. See :help dressing-format
    format_item_override = {},

    -- see :help dressing_get_config
    get_config = nil,
  },
})



--bookmarks
require("bookmarks").setup({
    storage_dir = "",  -- Default path: vim.fn.stdpath("data").."/bookmarks,  if not the default directory, should be absolute path",
    mappings_enabled = true, -- If the value is false, only valid for global keymaps: toggle、add、delete_on_virt、show_desc
    keymap = {
        toggle = "<tab><tab>", -- Toggle bookmarks(global keymap)
        close = "q", -- close bookmarks (buf keymap)
        add = "\\z", -- Add bookmarks(global keymap)
        add_global = "\\g", -- Add global bookmarks(global keymap), global bookmarks will appear in all projects. Identified with the symbol '󰯾'
        jump = "<CR>", -- Jump from bookmarks(buf keymap)
        delete = "dd", -- Delete bookmarks(buf keymap)
        order = "<space><space>", -- Order bookmarks by frequency or updated_time(buf keymap)
        delete_on_virt = "\\dd", -- Delete bookmark at virt text line(global keymap)
        show_desc = "\\sd", -- show bookmark desc(global keymap)
        focus_tags = "<c-j>",      -- focus tags window
        focus_bookmarks = "<c-k>", -- focus bookmarks window
        toogle_focus = "<S-Tab>", -- toggle window focus (tags-window <-> bookmarks-window)
    },
    width = 0.8, -- Bookmarks window width:  (0, 1]
    height = 0.7, -- Bookmarks window height: (0, 1]
    preview_ratio = 0.45, -- Bookmarks preview window ratio (0, 1]
    tags_ratio = 0.1, -- Bookmarks tags window ratio
    fix_enable = false, -- If true, when saving the current file, if the bookmark line number of the current file changes, try to fix it.

    virt_text = "", -- Show virt text at the end of bookmarked lines, if it is empty, use the description of bookmarks instead.
    sign_icon = "󰃃",                                           -- if it is not empty, show icon in signColumn.
    virt_pattern = { "*.go", "*.lua", "*.sh", "*.php", "*.rs" }, -- Show virt text only on matched pattern
    virt_ignore_pattern = {}, -- Ignore showing virt text on matched pattern, this works after virt_pattern
    border_style = "single", -- border style: "single", "double", "rounded" 
    hl = {
        border = "TelescopeBorder", -- border highlight
        cursorline = "guibg=Gray guifg=White", -- cursorline highlight
    }
})



--messages
require('messages').setup({
  command_name = 'Messages',
  -- should prepare a new buffer and return the winid
  -- by default opens a floating window
  -- provide a different callback to change this behaviour
  -- @param opts: the return value from float_opts
  prepare_buffer = function(opts)
    local buf = vim.api.nvim_create_buf(false, true)
    return vim.api.nvim_open_win(buf, true, opts)
  end,
  -- should return options passed to prepare_buffer
  -- @param lines: a list of the lines of text
  buffer_opts = function(lines)
    local gheight = vim.api.nvim_list_uis()[1].height
    local gwidth = vim.api.nvim_list_uis()[1].width
    return {
      relative = 'editor',
      width = gwidth - 2,
      height = clip_val(1, #lines, gheight * 0.5),
      anchor = 'SW',
      row = gheight - 1,
      col = 0,
      style = 'minimal',
      border = 'rounded',
      zindex = 1,
    }
  end,
  -- what to do after opening the float
  post_open_float = function(winnr)
  end
})

require "confirm-quit".confirm_quit()     -- :ConfirmQuit
require "confirm-quit".confirm_quit_all() -- :ConfirmQuitAll

require "confirm-quit".confirm_quit { bang = true }     -- ConfirmQuit!
require "confirm-quit".confirm_quit_all { bang = true } -- ConfirmQuitAll!





--dap
local opts = { noremap = true, silent = true }
local keymap = vim.api.nvim_set_keymap
-- Save breakpoints to file automatically.
keymap("n", "<YourKey1>", "<cmd>lua require('persistent-breakpoints.api').toggle_breakpoint()<cr>", opts)
keymap("n", "<YourKey2>", "<cmd>lua require('persistent-breakpoints.api').set_conditional_breakpoint()<cr>", opts)
keymap("n", "<YourKey3>", "<cmd>lua require('persistent-breakpoints.api').clear_all_breakpoints()<cr>", opts)
require('persistent-breakpoints').setup{
	save_dir = vim.fn.stdpath('data') .. '/nvim_checkpoints',
	-- when to load the breakpoints? "BufReadPost" is recommanded.
	load_breakpoints_event = nil,
	-- record the performance of different function. run :lua require('persistent-breakpoints.api').print_perf_data() to see the result.
	perf_record = false,
	-- perform callback when loading a persisted breakpoint
	--- @param opts DAPBreakpointOptions options used to create the breakpoint ({condition, logMessage, hitCondition})
	--- @param buf_id integer the buffer the breakpoint was set on
	--- @param line integer the line the breakpoint was set on
	on_load_breakpoint = nil,
} 
local map = vim.keymap.set
map('n', ']d', require('goto-breakpoints').next, {})
map('n', '[d', require('goto-breakpoints').prev, {})
map('n', ']S', require('goto-breakpoints').stopped, {})
require("nvim-dap-virtual-text").setup {
    enabled = true,                        -- enable this plugin (the default)
    enabled_commands = true,               -- create commands DapVirtualTextEnable, DapVirtualTextDisable, DapVirtualTextToggle, (DapVirtualTextForceRefresh for refreshing when debug adapter did not notify its termination)
    highlight_changed_variables = true,    -- highlight changed values with NvimDapVirtualTextChanged, else always NvimDapVirtualText
    highlight_new_as_changed = false,      -- highlight new variables in the same way as changed variables (if highlight_changed_variables)
    show_stop_reason = true,               -- show stop reason when stopped for exceptions
    commented = false,                     -- prefix virtual text with comment string
    only_first_definition = true,          -- only show virtual text at first definition (if there are multiple)
    all_references = false,                -- show virtual text on all all references of the variable (not only definitions)
    clear_on_continue = false,             -- clear virtual text on "continue" (might cause flickering when stepping)
    --- A callback that determines how a variable is displayed or whether it should be omitted
    --- @param variable Variable https://microsoft.github.io/debug-adapter-protocol/specification#Types_Variable
    --- @param buf number
    --- @param stackframe dap.StackFrame https://microsoft.github.io/debug-adapter-protocol/specification#Types_StackFrame
    --- @param node userdata tree-sitter node identified as variable definition of reference (see `:h tsnode`)
    --- @param options nvim_dap_virtual_text_options Current options for nvim-dap-virtual-text
    --- @return string|nil A text how the virtual text should be displayed or nil, if this variable shouldn't be displayed
    display_callback = function(variable, buf, stackframe, node, options)
      if options.virt_text_pos == 'inline' then
        return ' = ' .. variable.value
      else
        return variable.name .. ' = ' .. variable.value
      end
    end,
    -- position of virtual text, see `:h nvim_buf_set_extmark()`, default tries to inline the virtual text. Use 'eol' to set to end of line
    virt_text_pos = vim.fn.has 'nvim-0.10' == 1 and 'inline' or 'eol',

    -- experimental features:
    all_frames = false,                    -- show virtual text for all stack frames not only current. Only works for debugpy on my machine.
    virt_lines = false,                    -- show virtual lines instead of virtual text (will flicker!)
    virt_text_win_col = nil                -- position the virtual text at a fixed window column (starting from the first text column) ,
                                           -- e.g. 80 to position at column 80, see `:h nvim_buf_set_extmark()`
}



--runner
vim.keymap.set('n', '<leader>r', require('runner').run)
require('runner').setup({
  position = 'right', -- position of the terminal window when using the shell_handler
                      -- can be: top, left, right, bottom
                      -- will be overwritten when using the telescope mapping to open horizontally or vertically

  width = 80,         -- width of window when position is left or right
  height = 10,        -- height of window when position is top or bottom

  handlers = {} -- discussed in the next section
})





--neodev
require("neodev").setup({
  library = {
    enabled = true, -- when not enabled, neodev will not change any settings to the LSP server
    -- these settings will be used for your Neovim config directory
    runtime = true, -- runtime path
    types = true, -- full signature, docs and completion of vim.api, vim.treesitter, vim.lsp and others
    plugins = true, -- installed opt or start plugins in packpath
    -- you can also specify the list of plugins to make available as a workspace library
    -- plugins = { "nvim-treesitter", "plenary.nvim", "telescope.nvim" },
  },
  setup_jsonls = true, -- configures jsonls to provide completion for project specific .luarc.json files
  -- for your Neovim config directory, the config.library settings will be used as is
  -- for plugin directories (root_dirs having a /lua directory), config.library.plugins will be disabled
  -- for any other directory, config.library.enabled will be set to false
  override = function(root_dir, options) end,
  -- With lspconfig, Neodev will automatically setup your lua-language-server
  -- If you disable this, then you have to set {before_init=require("neodev.lsp").before_init}
  -- in your lsp start options
  lspconfig = true,
  -- much faster, but needs a recent built of lua-language-server
  -- needs lua-language-server >= 3.6.0
  pathStrict = true,
})






--octo
require"octo".setup({
  use_local_fs = false,                    -- use local files on right side of reviews
  enable_builtin = false,                  -- shows a list of builtin actions when no action is provided
  default_remote = {"upstream", "origin"}; -- order to try remotes
  default_merge_method = "commit",         -- default merge method which should be used when calling `Octo pr merge`, could be `commit`, `rebase` or `squash`
  ssh_aliases = {},                        -- SSH aliases. e.g. `ssh_aliases = {["github.com-work"] = "github.com"}`
  picker = "telescope",                    -- or "fzf-lua"
  picker_config = {
    use_emojis = false,                    -- only used by "fzf-lua" picker for now
    mappings = {                           -- mappings for the pickers
      open_in_browser = { lhs = "<C-b>", desc = "open issue in browser" },
      copy_url = { lhs = "<C-y>", desc = "copy url to system clipboard" },
      checkout_pr = { lhs = "<C-o>", desc = "checkout pull request" },
      merge_pr = { lhs = "<C-r>", desc = "merge pull request" },
    },
  },
  comment_icon = "▎",                      -- comment marker
  outdated_icon = "󰅒 ",                    -- outdated indicator
  resolved_icon = " ",                    -- resolved indicator
  reaction_viewer_hint_icon = " ";        -- marker for user reactions
  user_icon = " ";                        -- user icon
  timeline_marker = " ";                  -- timeline marker
  timeline_indent = "2";                   -- timeline indentation
  right_bubble_delimiter = "";            -- bubble delimiter
  left_bubble_delimiter = "";             -- bubble delimiter
  github_hostname = "";                    -- GitHub Enterprise host
  snippet_context_lines = 4;               -- number or lines around commented lines
  gh_cmd = "gh",                           -- Command to use when calling Github CLI
  gh_env = {},                             -- extra environment variables to pass on to GitHub CLI, can be a table or function returning a table
  timeout = 5000,                          -- timeout for requests between the remote server
  default_to_projects_v2 = false,          -- use projects v2 for the `Octo card ...` command by default. Both legacy and v2 commands are available under `Octo cardlegacy ...` and `Octo cardv2 ...` respectively.
  ui = {
    use_signcolumn = true,                 -- show "modified" marks on the sign column
  },
  issues = {
    order_by = {                           -- criteria to sort results of `Octo issue list`
      field = "CREATED_AT",                -- either COMMENTS, CREATED_AT or UPDATED_AT (https://docs.github.com/en/graphql/reference/enums#issueorderfield)
      direction = "DESC"                   -- either DESC or ASC (https://docs.github.com/en/graphql/reference/enums#orderdirection)
    }
  },
  pull_requests = {
    order_by = {                           -- criteria to sort the results of `Octo pr list`
      field = "CREATED_AT",                -- either COMMENTS, CREATED_AT or UPDATED_AT (https://docs.github.com/en/graphql/reference/enums#issueorderfield)
      direction = "DESC"                   -- either DESC or ASC (https://docs.github.com/en/graphql/reference/enums#orderdirection)
    },
    always_select_remote_on_create = false -- always give prompt to select base remote repo when creating PRs
  },
  file_panel = {
    size = 10,                             -- changed files panel rows
    use_icons = true                       -- use web-devicons in file panel (if false, nvim-web-devicons does not need to be installed)
  },
  colors = {                               -- used for highlight groups (see Colors section below)
    white = "#ffffff",
    grey = "#2A354C",
    black = "#000000",
    red = "#fdb8c0",
    dark_red = "#da3633",
    green = "#acf2bd",
    dark_green = "#238636",
    yellow = "#d3c846",
    dark_yellow = "#735c0f",
    blue = "#58A6FF",
    dark_blue = "#0366d6",
    purple = "#6f42c1",
  },
  mappings_disable_default = false,        -- disable default mappings if true, but will still adapt user mappings
  mappings = {
    issue = {
      close_issue = { lhs = "<space>ic", desc = "close issue" },
      reopen_issue = { lhs = "<space>io", desc = "reopen issue" },
      list_issues = { lhs = "<space>il", desc = "list open issues on same repo" },
      reload = { lhs = "<C-r>", desc = "reload issue" },
      open_in_browser = { lhs = "<C-b>", desc = "open issue in browser" },
      copy_url = { lhs = "<C-y>", desc = "copy url to system clipboard" },
      add_assignee = { lhs = "<space>aa", desc = "add assignee" },
      remove_assignee = { lhs = "<space>ad", desc = "remove assignee" },
      create_label = { lhs = "<space>lc", desc = "create label" },
      add_label = { lhs = "<space>la", desc = "add label" },
      remove_label = { lhs = "<space>ld", desc = "remove label" },
      goto_issue = { lhs = "<space>gi", desc = "navigate to a local repo issue" },
      add_comment = { lhs = "<space>ca", desc = "add comment" },
      delete_comment = { lhs = "<space>cd", desc = "delete comment" },
      next_comment = { lhs = "]c", desc = "go to next comment" },
      prev_comment = { lhs = "[c", desc = "go to previous comment" },
      react_hooray = { lhs = "<space>rp", desc = "add/remove 🎉 reaction" },
      react_heart = { lhs = "<space>rh", desc = "add/remove ❤️ reaction" },
      react_eyes = { lhs = "<space>re", desc = "add/remove 👀 reaction" },
      react_thumbs_up = { lhs = "<space>r+", desc = "add/remove 👍 reaction" },
      react_thumbs_down = { lhs = "<space>r-", desc = "add/remove 👎 reaction" },
      react_rocket = { lhs = "<space>rr", desc = "add/remove 🚀 reaction" },
      react_laugh = { lhs = "<space>rl", desc = "add/remove 😄 reaction" },
      react_confused = { lhs = "<space>rc", desc = "add/remove 😕 reaction" },
    },
    pull_request = {
      checkout_pr = { lhs = "<space>po", desc = "checkout PR" },
      merge_pr = { lhs = "<space>pm", desc = "merge commit PR" },
      squash_and_merge_pr = { lhs = "<space>psm", desc = "squash and merge PR" },
      rebase_and_merge_pr = { lhs = "<space>prm", desc = "rebase and merge PR" },
      list_commits = { lhs = "<space>pc", desc = "list PR commits" },
      list_changed_files = { lhs = "<space>pf", desc = "list PR changed files" },
      show_pr_diff = { lhs = "<space>pd", desc = "show PR diff" },
      add_reviewer = { lhs = "<space>va", desc = "add reviewer" },
      remove_reviewer = { lhs = "<space>vd", desc = "remove reviewer request" },
      close_issue = { lhs = "<space>ic", desc = "close PR" },
      reopen_issue = { lhs = "<space>io", desc = "reopen PR" },
      list_issues = { lhs = "<space>il", desc = "list open issues on same repo" },
      reload = { lhs = "<C-r>", desc = "reload PR" },
      open_in_browser = { lhs = "<C-b>", desc = "open PR in browser" },
      copy_url = { lhs = "<C-y>", desc = "copy url to system clipboard" },
      goto_file = { lhs = "gf", desc = "go to file" },
      add_assignee = { lhs = "<space>aa", desc = "add assignee" },
      remove_assignee = { lhs = "<space>ad", desc = "remove assignee" },
      create_label = { lhs = "<space>lc", desc = "create label" },
      add_label = { lhs = "<space>la", desc = "add label" },
      remove_label = { lhs = "<space>ld", desc = "remove label" },
      goto_issue = { lhs = "<space>gi", desc = "navigate to a local repo issue" },
      add_comment = { lhs = "<space>ca", desc = "add comment" },
      delete_comment = { lhs = "<space>cd", desc = "delete comment" },
      next_comment = { lhs = "]c", desc = "go to next comment" },
      prev_comment = { lhs = "[c", desc = "go to previous comment" },
      react_hooray = { lhs = "<space>rp", desc = "add/remove 🎉 reaction" },
      react_heart = { lhs = "<space>rh", desc = "add/remove ❤️ reaction" },
      react_eyes = { lhs = "<space>re", desc = "add/remove 👀 reaction" },
      react_thumbs_up = { lhs = "<space>r+", desc = "add/remove 👍 reaction" },
      react_thumbs_down = { lhs = "<space>r-", desc = "add/remove 👎 reaction" },
      react_rocket = { lhs = "<space>rr", desc = "add/remove 🚀 reaction" },
      react_laugh = { lhs = "<space>rl", desc = "add/remove 😄 reaction" },
      react_confused = { lhs = "<space>rc", desc = "add/remove 😕 reaction" },
      review_start = { lhs = "<space>vs", desc = "start a review for the current PR" },
      review_resume = { lhs = "<space>vr", desc = "resume a pending review for the current PR" },
    },
    review_thread = {
      goto_issue = { lhs = "<space>gi", desc = "navigate to a local repo issue" },
      add_comment = { lhs = "<space>ca", desc = "add comment" },
      add_suggestion = { lhs = "<space>sa", desc = "add suggestion" },
      delete_comment = { lhs = "<space>cd", desc = "delete comment" },
      next_comment = { lhs = "]c", desc = "go to next comment" },
      prev_comment = { lhs = "[c", desc = "go to previous comment" },
      select_next_entry = { lhs = "]q", desc = "move to previous changed file" },
      select_prev_entry = { lhs = "[q", desc = "move to next changed file" },
      select_first_entry = { lhs = "[Q", desc = "move to first changed file" },
      select_last_entry = { lhs = "]Q", desc = "move to last changed file" },
      close_review_tab = { lhs = "<C-c>", desc = "close review tab" },
      react_hooray = { lhs = "<space>rp", desc = "add/remove 🎉 reaction" },
      react_heart = { lhs = "<space>rh", desc = "add/remove ❤️ reaction" },
      react_eyes = { lhs = "<space>re", desc = "add/remove 👀 reaction" },
      react_thumbs_up = { lhs = "<space>r+", desc = "add/remove 👍 reaction" },
      react_thumbs_down = { lhs = "<space>r-", desc = "add/remove 👎 reaction" },
      react_rocket = { lhs = "<space>rr", desc = "add/remove 🚀 reaction" },
      react_laugh = { lhs = "<space>rl", desc = "add/remove 😄 reaction" },
      react_confused = { lhs = "<space>rc", desc = "add/remove 😕 reaction" },
    },
    submit_win = {
      approve_review = { lhs = "<C-a>", desc = "approve review" },
      comment_review = { lhs = "<C-m>", desc = "comment review" },
      request_changes = { lhs = "<C-r>", desc = "request changes review" },
      close_review_tab = { lhs = "<C-c>", desc = "close review tab" },
    },
    review_diff = {
      submit_review = { lhs = "<leader>vs", desc = "submit review" },
      discard_review = { lhs = "<leader>vd", desc = "discard review" },
      add_review_comment = { lhs = "<space>ca", desc = "add a new review comment" },
      add_review_suggestion = { lhs = "<space>sa", desc = "add a new review suggestion" },
      focus_files = { lhs = "<leader>e", desc = "move focus to changed file panel" },
      toggle_files = { lhs = "<leader>b", desc = "hide/show changed files panel" },
      next_thread = { lhs = "]t", desc = "move to next thread" },
      prev_thread = { lhs = "[t", desc = "move to previous thread" },
      select_next_entry = { lhs = "]q", desc = "move to previous changed file" },
      select_prev_entry = { lhs = "[q", desc = "move to next changed file" },
      select_first_entry = { lhs = "[Q", desc = "move to first changed file" },
      select_last_entry = { lhs = "]Q", desc = "move to last changed file" },
      close_review_tab = { lhs = "<C-c>", desc = "close review tab" },
      toggle_viewed = { lhs = "<leader><space>", desc = "toggle viewer viewed state" },
      goto_file = { lhs = "gf", desc = "go to file" },
    },
    file_panel = {
      submit_review = { lhs = "<leader>vs", desc = "submit review" },
      discard_review = { lhs = "<leader>vd", desc = "discard review" },
      next_entry = { lhs = "j", desc = "move to next changed file" },
      prev_entry = { lhs = "k", desc = "move to previous changed file" },
      select_entry = { lhs = "<cr>", desc = "show selected changed file diffs" },
      refresh_files = { lhs = "R", desc = "refresh changed files panel" },
      focus_files = { lhs = "<leader>e", desc = "move focus to changed file panel" },
      toggle_files = { lhs = "<leader>b", desc = "hide/show changed files panel" },
      select_next_entry = { lhs = "]q", desc = "move to previous changed file" },
      select_prev_entry = { lhs = "[q", desc = "move to next changed file" },
      select_first_entry = { lhs = "[Q", desc = "move to first changed file" },
      select_last_entry = { lhs = "]Q", desc = "move to last changed file" },
      close_review_tab = { lhs = "<C-c>", desc = "close review tab" },
      toggle_viewed = { lhs = "<leader><space>", desc = "toggle viewer viewed state" },
    },
  },
})




--lazygit
vim.g.lazygit_floating_window_winblend = 0 -- transparency of floating window
vim.g.lazygit_floating_window_scaling_factor = 0.9 -- scaling factor for floating window
vim.g.lazygit_floating_window_border_chars = {'╭','─', '╮', '│', '╯','─', '╰', '│'} -- customize lazygit popup window border characters
vim.g.lazygit_floating_window_use_plenary = 0 -- use plenary.nvim to manage floating window if available
vim.g.lazygit_use_neovim_remote = 1 -- fallback to 0 if neovim-remote is not installed

vim.g.lazygit_use_custom_config_file_path = 0 -- config file path is evaluated if this value is 1
vim.g.lazygit_config_file_path = '' -- custom config file path
-- OR
vim.g.lazygit_config_file_path = {} -- table of custom config file paths
-- Key binding to open LazyGit in Neovim
vim.api.nvim_set_keymap('n', '<leader>gg', ':LazyGit<CR>', { noremap = true, silent = true })







--gitsigns
require('gitsigns').setup {
  signs = {
    add          = { text = '┃' },
    change       = { text = '┃' },
    delete       = { text = '_' },
    topdelete    = { text = '‾' },
    changedelete = { text = '~' },
    untracked    = { text = '┆' },
  },
  signcolumn = true,  -- Toggle with `:Gitsigns toggle_signs`
  numhl      = false, -- Toggle with `:Gitsigns toggle_numhl`
  linehl     = false, -- Toggle with `:Gitsigns toggle_linehl`
  word_diff  = false, -- Toggle with `:Gitsigns toggle_word_diff`
  watch_gitdir = {
    follow_files = true
  },
  auto_attach = true,
  attach_to_untracked = false,
  current_line_blame = false, -- Toggle with `:Gitsigns toggle_current_line_blame`
  current_line_blame_opts = {
    virt_text = true,
    virt_text_pos = 'eol', -- 'eol' | 'overlay' | 'right_align'
    delay = 1000,
    ignore_whitespace = false,
    virt_text_priority = 100,
  },
  current_line_blame_formatter = '<author>, <author_time:%Y-%m-%d> - <summary>',
  current_line_blame_formatter_opts = {
    relative_time = false,
  },
  sign_priority = 6,
  update_debounce = 100,
  status_formatter = nil, -- Use default
  max_file_length = 40000, -- Disable if file is longer than this (in lines)
  preview_config = {
    -- Options passed to nvim_open_win
    border = 'single',
    style = 'minimal',
    relative = 'cursor',
    row = 0,
    col = 1
  },
}
require('gitsigns').setup{
  on_attach = function(bufnr)
    local gitsigns = require('gitsigns')

    local function map(mode, l, r, opts)
      opts = opts or {}
      opts.buffer = bufnr
      vim.keymap.set(mode, l, r, opts)
    end

    -- Navigation
    map('n', ']c', function()
      if vim.wo.diff then
        vim.cmd.normal({']c', bang = true})
      else
        gitsigns.nav_hunk('next')
      end
    end)

    map('n', '[c', function()
      if vim.wo.diff then
        vim.cmd.normal({'[c', bang = true})
      else
        gitsigns.nav_hunk('prev')
      end
    end)

    -- Actions
    map('n', '<leader>hs', gitsigns.stage_hunk)
    map('n', '<leader>hr', gitsigns.reset_hunk)
    map('v', '<leader>hs', function() gitsigns.stage_hunk {vim.fn.line('.'), vim.fn.line('v')} end)
    map('v', '<leader>hr', function() gitsigns.reset_hunk {vim.fn.line('.'), vim.fn.line('v')} end)
    map('n', '<leader>hS', gitsigns.stage_buffer)
    map('n', '<leader>hu', gitsigns.undo_stage_hunk)
    map('n', '<leader>hR', gitsigns.reset_buffer)
    map('n', '<leader>hp', gitsigns.preview_hunk)
    map('n', '<leader>hb', function() gitsigns.blame_line{full=true} end)
    map('n', '<leader>tb', gitsigns.toggle_current_line_blame)
    map('n', '<leader>hd', gitsigns.diffthis)
    map('n', '<leader>hD', function() gitsigns.diffthis('~') end)
    map('n', '<leader>td', gitsigns.toggle_deleted)

    -- Text object
    map({'o', 'x'}, 'ih', ':<C-U>Gitsigns select_hunk<CR>')
  end
}




--Smoothcursor
require('smoothcursor').setup({
    type = "default",           -- Cursor movement calculation method, choose "default", "exp" (exponential) or "matrix".

    cursor = "",              -- Cursor shape (requires Nerd Font). Disabled in fancy mode.
    texthl = "SmoothCursor",   -- Highlight group. Default is { bg = nil, fg = "#FFD400" }. Disabled in fancy mode.
    linehl = nil,              -- Highlights the line under the cursor, similar to 'cursorline'. "CursorLine" is recommended. Disabled in fancy mode.

    fancy = {
        enable = true,        -- enable fancy mode
        head = { cursor = "▷", texthl = "SmoothCursor", linehl = nil }, -- false to disable fancy head
        body = {
            { cursor = "󰝥", texthl = "SmoothCursorRed" },
            { cursor = "󰝥", texthl = "SmoothCursorOrange" },
            { cursor = "●", texthl = "SmoothCursorYellow" },
            { cursor = "●", texthl = "SmoothCursorGreen" },
            { cursor = "•", texthl = "SmoothCursorAqua" },
            { cursor = ".", texthl = "SmoothCursorBlue" },
            { cursor = ".", texthl = "SmoothCursorPurple" },
        },
        tail = { cursor = nil, texthl = "SmoothCursor" } -- false to disable fancy tail
    },

    matrix = {  -- Loaded when 'type' is set to "matrix"
        head = {
            -- Picks a random character from this list for the cursor text
            cursor = require('smoothcursor.matrix_chars'),
            -- Picks a random highlight from this list for the cursor text
            texthl = {
                'SmoothCursor',
            },
            linehl = nil,  -- No line highlight for the head
        },
        body = {
            length = 6,  -- Specifies the length of the cursor body
            -- Picks a random character from this list for the cursor body text
            cursor = require('smoothcursor.matrix_chars'),
            -- Picks a random highlight from this list for each segment of the cursor body
            texthl = {
                'SmoothCursorGreen',
            },
        },
        tail = {
            -- Picks a random character from this list for the cursor tail (if any)
            cursor = nil,
            -- Picks a random highlight from this list for the cursor tail
            texthl = {
                'SmoothCursor',
            },
        },
        unstop = false,  -- Determines if the cursor should stop or not (false means it will stop)
    },

    autostart = true,           -- Automatically start SmoothCursor
    always_redraw = true,       -- Redraw the screen on each update
    flyin_effect = nil,         -- Choose "bottom" or "top" for flying effect
    speed = 25,                 -- Max speed is 100 to stick with your current position
    intervals = 35,             -- Update intervals in milliseconds
    priority = 10,              -- Set marker priority
    timeout = 3000,             -- Timeout for animations in milliseconds
    threshold = 3,              -- Animate only if cursor moves more than this many lines
    max_threshold = nil,         -- If you move more than this many lines, don't animate (if `nil`, deactivate check)
    disable_float_win = false,  -- Disable in floating windows
    enabled_filetypes = nil,    -- Enable only for specific file types, e.g., { "lua", "vim" }
    disabled_filetypes = nil,   -- Disable for these file types, ignored if enabled_filetypes is set. e.g., { "TelescopePrompt", "NvimTree" }
    -- Show the position of the latest input mode positions. 
    -- A value of "enter" means the position will be updated when entering the mode.
    -- A value of "leave" means the position will be updated when leaving the mode.
    -- `nil` = disabled
    show_last_positions = nil,  
})





--which-key
    require("which-key").setup({
  plugins = {
    marks = true, -- shows a list of your marks on ' and `
    registers = true, -- shows your registers on " in NORMAL or <C-r> in INSERT mode
    -- the presets plugin, adds help for a bunch of default keybindings in Neovim
    -- No actual key bindings are created
    spelling = {
      enabled = true, -- enabling this will show WhichKey when pressing z= to select spelling suggestions
      suggestions = 20, -- how many suggestions should be shown in the list?
    },
    presets = {
      operators = true, -- adds help for operators like d, y, ...
      motions = true, -- adds help for motions
      text_objects = true, -- help for text objects triggered after entering an operator
      windows = true, -- default bindings on <c-w>
      nav = true, -- misc bindings to work with windows
      z = true, -- bindings for folds, spelling and others prefixed with z
      g = true, -- bindings for prefixed with g
    },
  },
  -- add operators that will trigger motion and text object completion
  -- to enable all native operators, set the preset / operators plugin above
  operators = { gc = "Comments" },
  key_labels = {
    -- override the label used to display some keys. It doesn't effect WK in any other way.
    -- For example:
    -- ["<space>"] = "SPC",
    -- ["<cr>"] = "RET",
    -- ["<tab>"] = "TAB",
  },
  motions = {
    count = true,
  },
  icons = {
    breadcrumb = "»", -- symbol used in the command line area that shows your active key combo
    separator = "➜", -- symbol used between a key and it's label
    group = "+", -- symbol prepended to a group
  },
  popup_mappings = {
    scroll_down = "<c-d>", -- binding to scroll down inside the popup
    scroll_up = "<c-u>", -- binding to scroll up inside the popup
  },
  window = {
    border = "none", -- none, single, double, shadow
    position = "bottom", -- bottom, top
    margin = { 1, 0, 1, 0 }, -- extra window margin [top, right, bottom, left]. When between 0 and 1, will be treated as a percentage of the screen size.
    padding = { 1, 2, 1, 2 }, -- extra window padding [top, right, bottom, left]
    winblend = 0, -- value between 0-100 0 for fully opaque and 100 for fully transparent
    zindex = 1000, -- positive value to position WhichKey above other floating windows.
  },
  layout = {
    height = { min = 4, max = 25 }, -- min and max height of the columns
    width = { min = 20, max = 50 }, -- min and max width of the columns
    spacing = 3, -- spacing between columns
    align = "left", -- align columns left, center or right
  },
  ignore_missing = false, -- enable this to hide mappings for which you didn't specify a label
  hidden = { "<silent>", "<cmd>", "<Cmd>", "<CR>", "^:", "^ ", "^call ", "^lua " }, -- hide mapping boilerplate
  show_help = true, -- show a help message in the command line for using WhichKey
  show_keys = true, -- show the currently pressed key and its label as a message in the command line
  triggers = "auto", -- automatically setup triggers
  -- triggers = {"<leader>"} -- or specifiy a list manually
  -- list of triggers, where WhichKey should not wait for timeoutlen and show immediately
  triggers_nowait = {
    -- marks
    "`",
    "'",
    "g`",
    "g'",
    -- registers
    '"',
    "<c-r>",
    -- spelling
    "z=",
  },
  triggers_blacklist = {
    -- list of mode / prefixes that should never be hooked by WhichKey
    -- this is mostly relevant for keymaps that start with a native binding
    i = { "j", "k" },
    v = { "j", "k" },
  },
  -- disable the WhichKey popup for certain buf types and file types.
  -- Disabled by default for Telescope
  disable = {
    buftypes = {},
    filetypes = {},
  },
})
vim.opt.timeout = true
vim.opt.timeoutlen = 300






--codewindow
    local codewindow = require('codewindow')
    codewindow.setup({
  active_in_terminals = false, -- Should the minimap activate for terminal buffers
  auto_enable = false, -- Automatically open the minimap when entering a (non-excluded) buffer (accepts a table of filetypes)
  exclude_filetypes = { 'help' }, -- Choose certain filetypes to not show minimap on
  max_minimap_height = nil, -- The maximum height the minimap can take (including borders)
  max_lines = nil, -- If auto_enable is true, don't open the minimap for buffers which have more than this many lines.
  minimap_width = 20, -- The width of the text part of the minimap
  use_lsp = true, -- Use the builtin LSP to show errors and warnings
  use_treesitter = true, -- Use nvim-treesitter to highlight the code
  use_git = true, -- Show small dots to indicate git additions and deletions
  width_multiplier = 4, -- How many characters one dot represents
  z_index = 1, -- The z-index the floating window will be on
  show_cursor = true, -- Show the cursor position in the minimap
  screen_bounds = 'lines', -- How the visible area is displayed, "lines": lines above and below, "background": background color
  window_border = 'single', -- The border style of the floating window (accepts all usual options)
  relative = 'win', -- What will be the minimap be placed relative to, "win": the current window, "editor": the entire editor
  events = { 'TextChanged', 'InsertLeave', 'DiagnosticChanged', 'FileWritePost' } -- Events that update the code window
})





--zenmode
vim.api.nvim_set_keymap('n', '<leader>z', ':ZenMode<CR>', { noremap = true, silent = true })
require('zen-mode').setup({
  window = {
    backdrop = 0.95, -- shade the backdrop of the Zen window. Set to 1 to keep the same as Normal
    -- height and width can be:
    -- * an absolute number of cells when > 1
    -- * a percentage of the width / height of the editor when <= 1
    -- * a function that returns the width or the height
    width = 120, -- width of the Zen window
    height = 1, -- height of the Zen window
    -- by default, no options are changed for the Zen window
    -- uncomment any of the options below, or add other vim.wo options you want to apply
    options = {
      -- signcolumn = "no", -- disable signcolumn
      -- number = false, -- disable number column
      -- relativenumber = false, -- disable relative numbers
      -- cursorline = false, -- disable cursorline
      -- cursorcolumn = false, -- disable cursor column
      -- foldcolumn = "0", -- disable fold column
      -- list = false, -- disable whitespace characters
    },
  },
  plugins = {
    -- disable some global vim options (vim.o...)
    -- comment the lines to not apply the options
    options = {
      enabled = true,
      ruler = false, -- disables the ruler text in the cmd line area
      showcmd = false, -- disables the command in the last line of the screen
      -- you may turn on/off statusline in zen mode by setting 'laststatus' 
      -- statusline will be shown only if 'laststatus' == 3
      laststatus = 0, -- turn off the statusline in zen mode
    },
    twilight = { enabled = true }, -- enable to start Twilight when zen mode opens
    gitsigns = { enabled = false }, -- disables git signs
    tmux = { enabled = false }, -- disables the tmux statusline
    -- this will change the font size on kitty when in zen mode
    -- to make this work, you need to set the following kitty options:
    -- - allow_remote_control socket-only
    -- - listen_on unix:/tmp/kitty
    kitty = {
      enabled = false,
      font = "+4", -- font size increment
    },
    -- this will change the font size on alacritty when in zen mode
    -- requires  Alacritty Version 0.10.0 or higher
    -- uses `alacritty msg` subcommand to change font size
    alacritty = {
      enabled = false,
      font = "14", -- font size
    },
    -- this will change the font size on wezterm when in zen mode
    -- See alse also the Plugins/Wezterm section in this projects README
    wezterm = {
      enabled = false,
      -- can be either an absolute font size or the number of incremental steps
      font = "+4", -- (10% increase per step)
    },
  },
  -- callback where you can add custom code when the Zen window opens
  on_open = function(win)
  end,
  -- callback where you can add custom code when the Zen window closes
  on_close = function()
  end,
})







--telescope
-- First, make sure you have telescope and plenary installed
local telescope = require('telescope')

-- Keymap function for ease of use
local map = function(mode, lhs, rhs, opts)
  local options = { noremap = true, silent = true }
  if opts then
    options = vim.tbl_extend('force', options, opts)
  end
  vim.api.nvim_set_keymap(mode, lhs, rhs, options)
end

-- Telescope Keymaps

-- File Pickers
map('n', '<leader>ff', '<cmd>Telescope find_files<cr>')
map('n', '<leader>fg', '<cmd>Telescope live_grep<cr>')
map('n', '<leader>fb', '<cmd>Telescope buffers<cr>')
map('n', '<leader>fh', '<cmd>Telescope help_tags<cr>')
map('n', '<leader>fo', '<cmd>Telescope oldfiles<cr>')
map('n', '<leader>fc', '<cmd>Telescope commands<cr>')
map('n', '<leader>fk', '<cmd>Telescope keymaps<cr>')
map('n', '<leader>fr', '<cmd>Telescope registers<cr>')
map('n', '<leader>fm', '<cmd>Telescope marks<cr>')
map('n', '<leader>fq', '<cmd>Telescope quickfix<cr>')
map('n', '<leader>fl', '<cmd>Telescope loclist<cr>')
map('n', '<leader>ft', '<cmd>Telescope treesitter<cr>')
map('n', '<leader>fs', '<cmd>Telescope spell_suggest<cr>')
map('n', '<leader>fd', '<cmd>Telescope diagnostics<cr>')

-- Vim Pickers
map('n', '<leader>vc', '<cmd>Telescope commands<cr>')
map('n', '<leader>vh', '<cmd>Telescope command_history<cr>')
map('n', '<leader>vs', '<cmd>Telescope search_history<cr>')
map('n', '<leader>vm', '<cmd>Telescope marks<cr>')
map('n', '<leader>vr', '<cmd>Telescope registers<cr>')
map('n', '<leader>vk', '<cmd>Telescope keymaps<cr>')
map('n', '<leader>vo', '<cmd>Telescope vim_options<cr>')
map('n', '<leader>va', '<cmd>Telescope autocommands<cr>')
map('n', '<leader>vc', '<cmd>Telescope colorscheme<cr>')

-- LSP Pickers
map('n', '<leader>lr', '<cmd>Telescope lsp_references<cr>')
map('n', '<leader>ld', '<cmd>Telescope lsp_definitions<cr>')
map('n', '<leader>li', '<cmd>Telescope lsp_implementations<cr>')
map('n', '<leader>lt', '<cmd>Telescope lsp_type_definitions<cr>')
map('n', '<leader>ls', '<cmd>Telescope lsp_document_symbols<cr>')
map('n', '<leader>lw', '<cmd>Telescope lsp_workspace_symbols<cr>')
map('n', '<leader>lc', '<cmd>Telescope lsp_code_actions<cr>')
map('n', '<leader>ll', '<cmd>Telescope lsp_range_code_actions<cr>')
map('n', '<leader>ld', '<cmd>Telescope diagnostics<cr>')

-- Git Pickers
map('n', '<leader>gb', '<cmd>Telescope git_branches<cr>')
map('n', '<leader>gc', '<cmd>Telescope git_commits<cr>')
map('n', '<leader>gs', '<cmd>Telescope git_status<cr>')
map('n', '<leader>gf', '<cmd>Telescope git_files<cr>')
map('n', '<leader>gC', '<cmd>Telescope git_bcommits<cr>') -- Buffer commits
map('n', '<leader>gt', '<cmd>Telescope git_stash<cr>')

-- Treesitter Pickers
map('n', '<leader>ts', '<cmd>Telescope treesitter<cr>')
map('n', '<leader>ta', '<cmd>Telescope treesitter playground<cr>') -- If playground extension is enabled

-- Lists Pickers
map('n', '<leader>lq', '<cmd>Telescope quickfix<cr>')
map('n', '<leader>ll', '<cmd>Telescope loclist<cr>')
require('telescope').setup{
  defaults = {
    -- Default configuration for telescope goes here:
    -- config_key = value,
    layout_strategy = 'horizontal', -- layout strategy: 'horizontal', 'vertical', 'center', 'flex'
    layout_config = {
      horizontal = {
        prompt_position = 'top',  -- position of the prompt: 'top' or 'bottom'
        preview_width = 0.55,     -- percentage of screen to use for the preview window
        results_width = 0.8,      -- percentage of screen to use for the results window
      },
      vertical = {
        mirror = false,           -- set to true if you want the preview and results to be mirrored
      },
      width = 0.87,               -- width of the Telescope window
      height = 0.80,              -- height of the Telescope window
      preview_cutoff = 120,       -- preview window cutoff if previewer is larger than this value
    },
    sorting_strategy = 'ascending',  -- sorting order: 'ascending' or 'descending'
    prompt_position = 'top',          -- prompt position: 'top' or 'bottom'
    winblend = 0,                     -- transparency of the Telescope window
    border = {},                      -- border configuration for Telescope window
    borderchars = { '─', '│', '─', '│', '╭', '╮', '╯', '╰' }, -- characters used for the borders
    color_devicons = true,            -- whether or not to color devicons
  },
  pickers = {
    -- Default configuration for builtin pickers goes here:
    -- picker_name = {
    --   picker_config_key = value,
    --   ...
    -- }
    find_files = {
      theme = "dropdown",            -- dropdown theme for find_files picker
    },
    live_grep = {
      theme = "ivy",                 -- ivy theme for live_grep picker
    },
  },
  extensions = {
    -- Your extension configuration goes here:
    -- extension_name = {
    --   extension_config_key = value,
    -- }
  }
}

-- Optionally, you can load extensions
-- require('telescope').load_extension('fzf')

require("telescope").load_extension("import")
require("telescope").load_extension("aerial")
require('telescope').load_extension('neoclip')
require("telescope").load_extension("grapple")
require("telescope").load_extension("workspaces")

require("telescope").setup({
  extensions = {
    aerial = {
      -- Display symbols as <root>.<parent>.<symbol>
      show_nesting = {
        ["_"] = false, -- This key will be the default
        json = true, -- You can set the option for specific filetypes
        yaml = true,
      },
    },
  },
})


local actions = require("telescope.actions")
local trouble = require("trouble.providers.telescope")

local telescope = require("telescope")

telescope.setup {
  defaults = {
    mappings = {
      i = { ["<c-t>"] = trouble.open_with_trouble },
      n = { ["<c-t>"] = trouble.open_with_trouble },
    },
  },
}



require("telescope").setup({
  extensions = {
    workspaces = {
      -- keep insert mode after selection in the picker, default is false
      keep_insert = true,
    }
  }
})
require("workspaces").setup({
  hooks = {
    open = "NvimTreeOpen",
  }
})

require("telescope").setup({
  extensions = {
    import = {
      -- Add imports to the top of the file keeping the cursor in place
      insert_at_top = true,
      -- Support additional languages
      custom_languages = {
        {
          -- The regex pattern for the import statement
          regex = [[^(?:import(?:[\"'\s]*([\w*{}\n, ]+)from\s*)?[\"'\s](.*?)[\"'\s].*)]],
          -- The Vim filetypes
          filetypes = { "typescript", "typescriptreact", "javascript", "react" },
          -- The filetypes that ripgrep supports (find these via `rg --type-list`)
          extensions = { "js", "ts" },
        },
      },
    },
  },
})
require("telescope").setup({
    extensions = {
        package_info = {
            -- Optional theme (the extension doesn't set a default theme)
            theme = "ivy",
        },
    },
})

require("telescope").load_extension("package_info")
require('package-info').show()
require("telescope").load_extension("lazygit")

--peoplecalender
 require("apeoplescalendar").setup()
  end
},




 {
 'akinsho/toggleterm.nvim',
 'kevinhwang91/nvim-bqf',
'nvim-lua/plenary.nvim',
'antoinemadec/FixCursorHold.nvim',
'nvim-treesitter/nvim-treesitter',
'nvim-neotest/nvim-nio',
'nvim-neotest/neotest',
 'edluffy/hologram.nvim',
  "potamides/pantran.nvim",
  "AckslD/nvim-neoclip.lua",
  'kkharji/sqlite.lua',
  "tversteeg/registers.nvim",
  "cbochs/grapple.nvim",
  'nvim-pack/nvim-spectre',
  "FabianWirth/search.nvim",
  'stevearc/oil.nvim',
  'nvim-tree/nvim-tree.lua',
  'natecraddock/workspaces.nvim',
 'nvim-orgmode/orgmode',
  'nvimdev/dashboard-nvim',
 'xiyaowong/transparent.nvim',
 'gaborvecsei/cryptoprice.nvim',
 'alanfortlink/blackjack.nvim',
 'rktjmp/playtime.nvim',
 'seandewar/nvimesweeper',
 'alec-gibson/nvim-tetris',
  'jim-fx/sudoku.nvim',
    "kawre/leetcode.nvim",
  "folke/flash.nvim",
  config = function()

--bqf
vim.cmd([[
    hi BqfPreviewBorder guifg=#3e8e2d ctermfg=71
    hi BqfPreviewTitle guifg=#3e8e2d ctermfg=71
    hi BqfPreviewThumb guibg=#3e8e2d ctermbg=71
    hi link BqfPreviewRange Search
]])

require('bqf').setup({
  auto_enable = true,
  auto_resize_height = true, -- highly recommended enable
  preview = {
    win_height = 12,
    win_vheight = 12,
    delay_syntax = 80,
    border = {'┏', '━', '┓', '┃', '┛', '━', '┗', '┃'},
    show_title = false,
    should_preview_cb = function(bufnr, qwinid)
      local ret = true
      local bufname = vim.api.nvim_buf_get_name(bufnr)
      local fsize = vim.fn.getfsize(bufname)
      if fsize > 100 * 1024 then
        -- skip file size greater than 100k
        ret = false
      elseif bufname:match('^fugitive://') then
        -- skip fugitive buffer
        ret = false
      end
      return ret
    end
  },
  -- make `drop` and `tab drop` to become preferred
  func_map = {
    drop = 'o',
    openc = 'O',
    split = '<C-s>',
    tabdrop = '<C-t>',
    -- set to empty string to disable
    tabc = '',
    ptogglemode = 'z,',
  },
  filter = {
    fzf = {
      action_for = {['ctrl-s'] = 'split', ['ctrl-t'] = 'tab drop'},
      extra_opts = {'--bind', 'ctrl-o:toggle-all', '--prompt', '> '}
    }
  }
})





--neotest
require("neotest").setup({
  adapters = {
    require("neotest-python")({
      dap = { justMyCode = false },
    }),
    require("neotest-plenary"),
    require("neotest-vim-test")({
      ignore_file_types = { "python", "vim", "lua" },
    }),
  },
})




--hologram
require('hologram').setup{
  auto_display = true -- WIP automatic markdown image display, may be prone to breaking
}








--translate
local opts = {noremap = true, silent = true, expr = true}
vim.keymap.set("n", "<leader>tr", pantran.motion_translate, opts)
vim.keymap.set("n", "<leader>trr", function() return pantran.motion_translate() .. "_" end, opts)
vim.keymap.set("x", "<leader>tr", pantran.motion_translate, opts)
require("pantran").setup{
  -- Default engine to use for translation. To list valid engine names run
  -- `:lua =vim.tbl_keys(require("pantran.engines"))`.
  default_engine = "argos",
  -- Configuration for individual engines goes here.
  engines = {
    yandex = {
      -- Default languages can be defined on a per engine basis. In this case
      -- `:lua require("pantran.async").run(function()
      -- vim.pretty_print(require("pantran.engines").yandex:languages()) end)`
      -- can be used to list available language identifiers.
      default_source = "auto",
      default_target = "en"
    },
  },
  controls = {
    mappings = {
      edit = {
        n = {
          -- Use this table to add additional mappings for the normal mode in
          -- the translation window. Either strings or function references are
          -- supported.
          ["j"] = "gj",
          ["k"] = "gk"
        },
        i = {
          -- Similar table but for insert mode. Using 'false' disables
          -- existing keybindings.
          ["<C-y>"] = false,
          ["<C-a>"] = require("pantran.ui.actions").yank_close_translation
        }
      },
      -- Keybindings here are used in the selection window.
      select = {
        n = {
        -- ...
        }
      }
    }
  }
}




--neoclip
require('neoclip').setup({
  history = 1000,
  enable_persistent_history = false,
  length_limit = 1048576,
  continuous_sync = false,
  db_path = vim.fn.stdpath("data") .. "/databases/neoclip.sqlite3",
  filter = nil,
  preview = true,
  prompt = nil,
  default_register = '"',
  default_register_macros = 'q',
  enable_macro_history = true,
  content_spec_column = false,
  disable_keycodes_parsing = false,
  on_select = {
    move_to_front = false,
    close_telescope = true,
  },
  on_paste = {
    set_reg = false,
    move_to_front = false,
    close_telescope = true,
  },
  on_replay = {
    set_reg = false,
    move_to_front = false,
    close_telescope = true,
  },
  on_custom_action = {
    close_telescope = true,
  },
  keys = {
    telescope = {
      i = {
        select = '<cr>',
        paste = '<c-p>',
        paste_behind = '<c-k>',
        replay = '<c-q>',  -- replay a macro
        delete = '<c-d>',  -- delete an entry
        edit = '<c-e>',  -- edit an entry
        custom = {},
      },
      n = {
        select = '<cr>',
        paste = 'p',
        --- It is possible to map to more than one key.
        -- paste = { 'p', '<c-p>' },
        paste_behind = 'P',
        replay = 'q',
        delete = 'd',
        edit = 'e',
        custom = {},
      },
    },
    fzf = {
      select = 'default',
      paste = 'ctrl-p',
      paste_behind = 'ctrl-k',
      custom = {},
    },
  },
})
local function is_whitespace(line)
  return vim.fn.match(line, [[^\s*$]]) ~= -1
end

local function all(tbl, check)
  for _, entry in ipairs(tbl) do
    if not check(entry) then
      return false
    end
  end
  return true
end

require('neoclip').setup{
  filter = function(data)
    return not all(data.event.regcontents, is_whitespace)
  end,
}




--registers
local registers = require("registers")
registers.setup({
  -- Show these registers in the order of the string
  show = "*+\"-/_=#%.0123456789abcdefghijklmnopqrstuvwxyz:",
  -- Show a line at the bottom with registers that aren't filled
  show_empty = true,
  -- Expose the :Registers user command
  register_user_command = true,
  -- Always transfer all selected registers to the system clipboard
  system_clipboard = true,
  -- Don't show whitespace at the begin and end of the register's content
  trim_whitespace = true,
  -- Don't show registers which are exclusively filled with whitespace
  hide_only_whitespace = true,
  -- Show a character next to the register name indicating how the register will be applied
  show_register_types = true,
  bind_keys = {
    -- Show the window when pressing " in normal mode, applying the selected register as part of a motion, which is the default behavior of Neovim
    normal    = registers.show_window({ mode = "motion" }),
    -- Show the window when pressing " in visual mode, applying the selected register as part of a motion, which is the default behavior of Neovim
    visual    = registers.show_window({ mode = "motion" }),
    -- Show the window when pressing <C-R> in insert mode, inserting the selected register, which is the default behavior of Neovim
    insert    = registers.show_window({ mode = "insert" }),

    -- When pressing the key of a register, apply it with a very small delay, which will also highlight the selected register
    registers = registers.apply_register({ delay = 0.1 }),
    -- Immediately apply the selected register line when pressing the return key
    ["<CR>"]  = registers.apply_register(),
    -- Close the registers window when pressing the Esc key
    ["<Esc>"] = registers.close_window(),

    -- Move the cursor in the registers window down when pressing <C-n>
    ["<C-n>"] = registers.move_cursor_down(),
    -- Move the cursor in the registers window up when pressing <C-p>
    ["<C-p>"] = registers.move_cursor_up(),
    -- Move the cursor in the registers window down when pressing <C-j>
    ["<C-j>"] = registers.move_cursor_down(),
    -- Move the cursor in the registers window up when pressing <C-k>
    ["<C-k>"] = registers.move_cursor_up(),
    -- Clear the register of the highlighted line when pressing <DeL>
    ["<Del>"] = registers.clear_highlighted_register(),
    -- Clear the register of the highlighted line when pressing <BS>
    ["<BS>"]  = registers.clear_highlighted_register(),
  },
  events = {
    -- When a register line is highlighted, show a preview in the main buffer with how the register will be applied, but only if the register will be inserted or pasted
    on_register_highlighted = registers.preview_highlighted_register({ if_mode = { "insert", "paste" } }),
  },
  symbols = {
    -- Show a special character for line breaks
    newline = "⏎",
    -- Show space characters without changes
    space = " ",
    -- Show a special character for tabs
    tab = "·",
    -- The character to show when a register will be applied in a char-wise fashion
    register_type_charwise = "ᶜ",
    -- The character to show when a register will be applied in a line-wise fashion
    register_type_linewise = "ˡ",
    -- The character to show when a register will be applied in a block-wise fashion
    register_type_blockwise = "ᵇ",
  },
  window = {
    -- The window can't be wider than 100 characters
    max_width = 100,
    -- Show a small highlight in the sign column for the line the cursor is on
    highlight_cursorline = true,
    -- Don't draw a border around the registers window
    border = "none",
    -- Apply a tiny bit of transparency to the the window, letting some characters behind it bleed through
    transparency = 10,
  },
  -- Highlight the sign registers as regular Neovim highlights
  sign_highlights = {
    cursorlinesign = "CursorLine",
    signcolumn = "SignColumn",
    cursorline = "Visual",
    selection = "Constant",
    default = "Function",
    unnamed = "Statement",
    read_only = "Type",
    expression = "Exception",
    black_hole = "Error",
    alternate_buffer = "Operator",
    last_search = "Tag",
    delete = "Special",
    yank = "Delimiter",
    history = "Number",
    named = "Todo",
  },
})


--grapple
-- Lua
vim.keymap.set("n", "<leader>m", require("grapple").toggle)
vim.keymap.set("n", "<leader>M", require("grapple").toggle_tags)
vim.keymap.set("n", "<leader>1", "<cmd>Grapple select index=1<cr>")

--spectre
vim.keymap.set('n', '<leader>S', '<cmd>lua require("spectre").toggle()<CR>', {
  desc = "Toggle Spectre"
})
vim.keymap.set('n', '<leader>sw', '<cmd>lua require("spectre").open_visual({select_word=true})<CR>', {
  desc = "Search current word"
})
vim.keymap.set('v', '<leader>sw', '<esc><cmd>lua require("spectre").open_visual()<CR>', {
  desc = "Search current word"
})
vim.keymap.set('n', '<leader>sp', '<cmd>lua require("spectre").open_file_search({select_word=true})<CR>', {
  desc = "Search on current file"
})



--search
local builtin = require('telescope.builtin')
require("search").setup({
  mappings = { -- optional: configure the mappings for switching tabs (will be set in normal and insert mode(!))
    next = "<Tab>",
    prev = "<S-Tab>"
  },
  append_tabs = { -- append_tabs will add the provided tabs to the default ones
    {
      "Commits", -- or name = "Commits"
      builtin.git_commits, -- or tele_func = require('telescope.builtin').git_commits
      available = function() -- optional
        return vim.fn.isdirectory(".git") == 1
      end
  }
  },
  -- its also possible to overwrite the default tabs using the tabs key instead of append_tabs
  tabs = {
    {
      "Files",
      function(opts)
        opts = opts or {}
        if vim.fn.isdirectory(".git") == 1 then
          builtin.git_files(opts)
        else
          builtin.find_files(opts)
        end
      end
    }
  },
})




--oil
require("oil").setup({
  -- Oil will take over directory buffers (e.g. `vim .` or `:e src/`)
  -- Set to false if you still want to use netrw.
  default_file_explorer = true,
  -- Id is automatically added at the beginning, and name at the end
  -- See :help oil-columns
  columns = {
    "icon",
  -- "permissions",
  -- "size",
  -- "mtime",
  },
  -- Buffer-local options to use for oil buffers
  buf_options = {
    buflisted = false,
    bufhidden = "hide",
  },
  -- Window-local options to use for oil buffers
  win_options = {
    wrap = false,
    signcolumn = "no",
    cursorcolumn = false,
    foldcolumn = "0",
    spell = false,
    list = false,
    conceallevel = 3,
    concealcursor = "nvic",
  },
  -- Send deleted files to the trash instead of permanently deleting them (:help oil-trash)
  delete_to_trash = false,
  -- Skip the confirmation popup for simple operations (:help oil.skip_confirm_for_simple_edits)
  skip_confirm_for_simple_edits = false,
  -- Selecting a new/moved/renamed file or directory will prompt you to save changes first
  -- (:help prompt_save_on_select_new_entry)
  prompt_save_on_select_new_entry = true,
  -- Oil will automatically delete hidden buffers after this delay
  -- You can set the delay to false to disable cleanup entirely
  -- Note that the cleanup process only starts when none of the oil buffers are currently displayed
  cleanup_delay_ms = 2000,
  lsp_file_methods = {
    -- Time to wait for LSP file operations to complete before skipping
    timeout_ms = 1000,
    -- Set to true to autosave buffers that are updated with LSP willRenameFiles
    -- Set to "unmodified" to only save unmodified buffers
    autosave_changes = false,
  },
  -- Constrain the cursor to the editable parts of the oil buffer
  -- Set to `false` to disable, or "name" to keep it on the file names
  constrain_cursor = "editable",
  -- Set to true to watch the filesystem for changes and reload oil
  experimental_watch_for_changes = false,
  -- Keymaps in oil buffer. Can be any value that `vim.keymap.set` accepts OR a table of keymap
  -- options with a `callback` (e.g. { callback = function() ... end, desc = "", mode = "n" })
  -- Additionally, if it is a string that matches "actions.<name>",
  -- it will use the mapping at require("oil.actions").<name>
  -- Set to `false` to remove a keymap
  -- See :help oil-actions for a list of all available actions
  keymaps = {
    ["g?"] = "actions.show_help",
    ["<CR>"] = "actions.select",
    ["<C-s>"] = "actions.select_vsplit",
    ["<C-h>"] = "actions.select_split",
    ["<C-t>"] = "actions.select_tab",
    ["<C-p>"] = "actions.preview",
    ["<C-c>"] = "actions.close",
    ["<C-l>"] = "actions.refresh",
    ["-"] = "actions.parent",
    ["_"] = "actions.open_cwd",
    ["`"] = "actions.cd",
    ["~"] = "actions.tcd",
    ["gs"] = "actions.change_sort",
    ["gx"] = "actions.open_external",
    ["g."] = "actions.toggle_hidden",
    ["g\\"] = "actions.toggle_trash",
  },
  -- Set to false to disable all of the above keymaps
  use_default_keymaps = true,
  view_options = {
    -- Show files and directories that start with "."
    show_hidden = false,
    -- This function defines what is considered a "hidden" file
    is_hidden_file = function(name, bufnr)
      return vim.startswith(name, ".")
    end,
    -- This function defines what will never be shown, even when `show_hidden` is set
    is_always_hidden = function(name, bufnr)
      return false
    end,
    -- Sort file names in a more intuitive order for humans. Is less performant,
    -- so you may want to set to false if you work with large directories.
    natural_order = true,
    sort = {
      -- sort order can be "asc" or "desc"
      -- see :help oil-columns to see which columns are sortable
      { "type", "asc" },
      { "name", "asc" },
    },
  },
  -- Extra arguments to pass to SCP when moving/copying files over SSH
  extra_scp_args = {},
  -- EXPERIMENTAL support for performing file operations with git
  git = {
    -- Return true to automatically git add/mv/rm files
    add = function(path)
      return false
    end,
    mv = function(src_path, dest_path)
      return false
    end,
    rm = function(path)
      return false
    end,
  },
  -- Configuration for the floating window in oil.open_float
  float = {
    -- Padding around the floating window
    padding = 2,
    max_width = 0,
    max_height = 0,
    border = "rounded",
    win_options = {
      winblend = 0,
    },
    -- This is the config that will be passed to nvim_open_win.
    -- Change values here to customize the layout
    override = function(conf)
      return conf
    end,
  },
  -- Configuration for the actions floating preview window
  preview = {
    -- Width dimensions can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
    -- min_width and max_width can be a single value or a list of mixed integer/float types.
    -- max_width = {100, 0.8} means "the lesser of 100 columns or 80% of total"
    max_width = 0.9,
    -- min_width = {40, 0.4} means "the greater of 40 columns or 40% of total"
    min_width = { 40, 0.4 },
    -- optionally define an integer/float for the exact width of the preview window
    width = nil,
    -- Height dimensions can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
    -- min_height and max_height can be a single value or a list of mixed integer/float types.
    -- max_height = {80, 0.9} means "the lesser of 80 columns or 90% of total"
    max_height = 0.9,
    -- min_height = {5, 0.1} means "the greater of 5 columns or 10% of total"
    min_height = { 5, 0.1 },
    -- optionally define an integer/float for the exact height of the preview window
    height = nil,
    border = "rounded",
    win_options = {
      winblend = 0,
    },
    -- Whether the preview window is automatically updated when the cursor is moved
    update_on_cursor_moved = true,
  },
  -- Configuration for the floating progress window
  progress = {
    max_width = 0.9,
    min_width = { 40, 0.4 },
    width = nil,
    max_height = { 10, 0.9 },
    min_height = { 5, 0.1 },
    height = nil,
    border = "rounded",
    minimized_border = "none",
    win_options = {
      winblend = 0,
    },
  },
  -- Configuration for the floating SSH window
  ssh = {
    border = "rounded",
  },
  -- Configuration for the floating keymaps help window
  keymaps_help = {
    border = "rounded",
  },
})



--nvim-tree
-- disable netrw at the very start of your init.lua
vim.g.loaded_netrw = 1
vim.g.loaded_netrwPlugin = 1

-- optionally enable 24-bit colour
vim.opt.termguicolors = true

-- empty setup using defaults
require("nvim-tree").setup()

-- OR setup with some options
require("nvim-tree").setup({
  sort = {
    sorter = "case_sensitive",
  },
  view = {
    width = 30,
  },
  renderer = {
    group_empty = true,
  },
  filters = {
    dotfiles = true,
  },
})
vim.cmd([[
    :hi      NvimTreeExecFile    guifg=#ffa0a0
    :hi      NvimTreeSpecialFile guifg=#ff80ff gui=underline
    :hi      NvimTreeSymlink     guifg=Yellow  gui=italic
    :hi link NvimTreeImageFile   Title
]])



--workspaces
require("workspaces").setup({
  -- path to a file to store workspaces data in
  -- on a unix system this would be ~/.local/share/nvim/workspaces
  path = vim.fn.stdpath("data") .. "/workspaces",

  -- to change directory for nvim (:cd), or only for window (:lcd)
  -- deprecated, use cd_type instead
  -- global_cd = true,

  -- controls how the directory is changed. valid options are "global", "local", and "tab"
  --   "global" changes directory for the neovim process. same as the :cd command
  --   "local" changes directory for the current window. same as the :lcd command
  --   "tab" changes directory for the current tab. same as the :tcd command
  --
  -- if set, overrides the value of global_cd
  cd_type = "global",

  -- sort the list of workspaces by name after loading from the workspaces path.
  sort = true,

  -- sort by recent use rather than by name. requires sort to be true
  mru_sort = true,

  -- option to automatically activate workspace when opening neovim in a workspace directory
  auto_open = false,

  -- enable info-level notifications after adding or removing a workspace
  notify_info = true,

  -- lists of hooks to run after specific actions
  -- hooks can be a lua function or a vim command (string)
  -- lua hooks take a name, a path, and an optional state table
  -- if only one hook is needed, the list may be omitted
  hooks = {
    add = {},
    remove = {},
    rename = {},
    open_pre = {},
    open = {},
  },
})


--orgmode
-- init.lua

require('orgmode').setup({
  org_agenda_files = {'~/Dropbox/org/*', '~/my-orgs/**/*'},
  org_default_notes_file = '~/Dropbox/org/refile.org',
})
require('cmp').setup({
  sources = {
    { name = 'orgmode' }
  }
})




--dashboard
local db = require("dashbard")
db.setup({
  theme = '',
  config = {
    header = {}, --your header
    center = {
      {
        icon = ' ',
        icon_hl = 'Title',
        desc = 'Find File           ',
        desc_hl = 'String',
        key = 'b',
        keymap = 'SPC f f',
        key_hl = 'Number',
        key_format = ' %s', -- remove default surrounding `[]`
        action = 'lua print(2)'
      },
      {
        icon = ' ',
        desc = 'Find Dotfiles',
        key = 'f',
        keymap = 'SPC f d',
        key_format = ' %s', -- remove default surrounding `[]`
        action = 'lua print(3)'
      },
    },
    footer = {}  --your footer
  }
})




--transparent
vim.cmd([[
:TransparentEnable
]])
require("transparent").setup({ -- Optional, you don't have to run setup.
  groups = { -- table: default groups
    'Normal', 'NormalNC', 'Comment', 'Constant', 'Special', 'Identifier',
    'Statement', 'PreProc', 'Type', 'Underlined', 'Todo', 'String', 'Function',
    'Conditional', 'Repeat', 'Operator', 'Structure', 'LineNr', 'NonText',
    'SignColumn', 'CursorLine', 'CursorLineNr', 'StatusLine', 'StatusLineNC',
    'EndOfBuffer',
  },
  extra_groups = {}, -- table: additional groups that should be cleared
  exclude_groups = {}, -- table: groups you don't want to clear
})
require('transparent').clear_prefix('lualine')



--crypto
vim.g.cryptoprice_base_currency = "usd"
vim.g.cryptoprice_crypto_list = {"bitcoin", "ethereum"} 
vim.g.cryptoprice_window_width = 60
vim.g.cryptoprice_window_height = 10
require("cryptoprice").setup{
    base_currency="usd",
    crypto_list={"bitcoin", "ethereum"},
    window_height=10,
    window_width=60
}
vim.api.nvim_set_keymap('n', '<leader>cy', '<cmd>lua require("cryptoprice").toggle()<CR>', { noremap = true, silent = true })


--toggleterm
-- Add this to your init.lua or a separate keymap file
vim.api.nvim_set_keymap('n', '`', '<cmd>ToggleTerm<CR>', { noremap = true, silent = true })





--games
require("blackjack").setup({
  card_style = "mini", -- Can be "mini" or "large".
  suit_style = "black", -- Can be "black" or "white".
  scores_path = "/home/foo/blackjack_scores.json", -- Default location to store the scores.json file.
  keybindings = {
    ["next"] = "j",
    ["finish"] = "k",
    ["quit"] = "q",
  },
})
-- These are the defaults for the settings
require("sudoku").setup({
  persist_settings = true, -- safe the settings under vim.fn.stdpath("data"), usually ~/.local/share/nvim,
  persist_games = true, -- persist a history of all played games
  default_mappings = true, -- if set to false you need to set your own, like the following:
  mappings = {
      { key = "x",     action = "clear_cell" },
      { key = "r1",    action = "insert=1" },
      { key = "r2",    action = "insert=2" },
      { key = "r3",    action = "insert=3" },
      -- ...
      { key = "r9",    action = "insert=9" },
      { key = "gn",    action = "new_game" },
      { key = "gr",    action = "reset_game" },
      { key = "gs",    action = "view=settings" },
      { key = "gt",    action = "view=tip" },
      { key = "gz",    action = "view=zen" },
      { key = "gh",    action = "view=help" },
      { key = "u",     action = "undo" },
      { key = "<C-r>", action = "redo" },
      { key = "+",     action = "increment" },
      { key = "-",     action = "decrement" },
  },
  custom_highlights = {
      board = { fg = "#7d7d7d" },
      number = { fg = "white", bg = "black" },
      active_menu = { fg = "white", bg = "black", gui = "bold" },
      hint_cell = { fg = "white", bg = "yellow" },
      square = { bg = "#292b35", fg = "white" },
      column = { bg = "#14151a", fg = "#d5d5d5" },
      row = { bg = "#14151a", fg = "#d5d5d5" },
      settings_disabled = { fg = "#8e8e8e", gui = "italic" },
      same_number = { fg = "white", gui = "bold" },
      set_number = { fg = "white", gui = "italic" },
      error = { fg = "white", bg = "#843434" },
  }
})



--leetcode
require("leetcode").setup({
    ---@type string
    arg = "leetcode.nvim",

    ---@type lc.lang
    lang = "cpp",

    cn = { -- leetcode.cn
        enabled = false, ---@type boolean
        translator = true, ---@type boolean
        translate_problems = true, ---@type boolean
    },

    ---@type lc.storage
    storage = {
        home = vim.fn.stdpath("data") .. "/leetcode",
        cache = vim.fn.stdpath("cache") .. "/leetcode",
    },

    ---@type table<string, boolean>
    plugins = {
        non_standalone = false,
    },

    ---@type boolean
    logging = true,

    injector = {}, ---@type table<lc.lang, lc.inject>

    cache = {
        update_interval = 60 * 60 * 24 * 7, ---@type integer 7 days
    },

    console = {
        open_on_runcode = true, ---@type boolean

        dir = "row", ---@type lc.direction

        size = { ---@type lc.size
            width = "90%",
            height = "75%",
        },

        result = {
            size = "60%", ---@type lc.size
        },

        testcase = {
            virt_text = true, ---@type boolean

            size = "40%", ---@type lc.size
        },
    },

    description = {
        position = "left", ---@type lc.position

        width = "40%", ---@type lc.size

        show_stats = true, ---@type boolean
    },

    hooks = {
        ---@type fun()[]
        ["enter"] = {},

        ---@type fun(question: lc.ui.Question)[]
        ["question_enter"] = {},

        ---@type fun()[]
        ["leave"] = {},
    },

    keys = {
        toggle = { "q" }, ---@type string|string[]
        confirm = { "<CR>" }, ---@type string|string[]

        reset_testcases = "r", ---@type string
        use_testcase = "U", ---@type string
        focus_testcases = "H", ---@type string
        focus_result = "L", ---@type string
    },

    ---@type lc.highlights
    theme = {},

    ---@type boolean
    image_support = false,
})




--flash 
require("flash").setup({
  -- labels = "abcdefghijklmnopqrstuvwxyz",
  labels = "asdfghjklqwertyuiopzxcvbnm",
  search = {
    -- search/jump in all windows
    multi_window = true,
    -- search direction
    forward = true,
    -- when `false`, find only matches in the given direction
    wrap = true,
    ---@type Flash.Pattern.Mode
    -- Each mode will take ignorecase and smartcase into account.
    -- * exact: exact match
    -- * search: regular search
    -- * fuzzy: fuzzy search
    -- * fun(str): custom function that returns a pattern
    --   For example, to only match at the beginning of a word:
    --   mode = function(str)
    --     return "\\<" .. str
    --   end,
    mode = "exact",
    -- behave like `incsearch`
    incremental = false,
    -- Excluded filetypes and custom window filters
    ---@type (string|fun(win:window))[]
    exclude = {
      "notify",
      "cmp_menu",
      "noice",
      "flash_prompt",
      function(win)
        -- exclude non-focusable windows
        return not vim.api.nvim_win_get_config(win).focusable
      end,
    },
    -- Optional trigger character that needs to be typed before
    -- a jump label can be used. It's NOT recommended to set this,
    -- unless you know what you're doing
    trigger = "",
    -- max pattern length. If the pattern length is equal to this
    -- labels will no longer be skipped. When it exceeds this length
    -- it will either end in a jump or terminate the search
    max_length = false, ---@type number|false
  },
  jump = {
    -- save location in the jumplist
    jumplist = true,
    -- jump position
    pos = "start", ---@type "start" | "end" | "range"
    -- add pattern to search history
    history = false,
    -- add pattern to search register
    register = false,
    -- clear highlight after jump
    nohlsearch = false,
    -- automatically jump when there is only one match
    autojump = false,
    -- You can force inclusive/exclusive jumps by setting the
    -- `inclusive` option. By default it will be automatically
    -- set based on the mode.
    inclusive = nil, ---@type boolean?
    -- jump position offset. Not used for range jumps.
    -- 0: default
    -- 1: when pos == "end" and pos < current position
    offset = nil, ---@type number
  },
  label = {
    -- allow uppercase labels
    uppercase = true,
    -- add any labels with the correct case here, that you want to exclude
    exclude = "",
    -- add a label for the first match in the current window.
    -- you can always jump to the first match with `<CR>`
    current = true,
    -- show the label after the match
    after = true, ---@type boolean|number[]
    -- show the label before the match
    before = false, ---@type boolean|number[]
    -- position of the label extmark
    style = "overlay", ---@type "eol" | "overlay" | "right_align" | "inline"
    -- flash tries to re-use labels that were already assigned to a position,
    -- when typing more characters. By default only lower-case labels are re-used.
    reuse = "lowercase", ---@type "lowercase" | "all" | "none"
    -- for the current window, label targets closer to the cursor first
    distance = true,
    -- minimum pattern length to show labels
    -- Ignored for custom labelers.
    min_pattern_length = 0,
    -- Enable this to use rainbow colors to highlight labels
    -- Can be useful for visualizing Treesitter ranges.
    rainbow = {
      enabled = false,
      -- number between 1 and 9
      shade = 5,
    },
    -- With `format`, you can change how the label is rendered.
    -- Should return a list of `[text, highlight]` tuples.
    ---@class Flash.Format
    ---@field state Flash.State
    ---@field match Flash.Match
    ---@field hl_group string
    ---@field after boolean
    ---@type fun(opts:Flash.Format): string[][]
    format = function(opts)
      return { { opts.match.label, opts.hl_group } }
    end,
  },
  highlight = {
    -- show a backdrop with hl FlashBackdrop
    backdrop = true,
    -- Highlight the search matches
    matches = true,
    -- extmark priority
    priority = 5000,
    groups = {
      match = "FlashMatch",
      current = "FlashCurrent",
      backdrop = "FlashBackdrop",
      label = "FlashLabel",
    },
  },
  -- action to perform when picking a label.
  -- defaults to the jumping logic depending on the mode.
  ---@type fun(match:Flash.Match, state:Flash.State)|nil
  action = nil,
  -- initial pattern to use when opening flash
  pattern = "",
  -- When `true`, flash will try to continue the last search
  continue = false,
  -- Set config to a function to dynamically change the config
  config = nil, ---@type fun(opts:Flash.Config)|nil
  -- You can override the default options for a specific mode.
  -- Use it with `require("flash").jump({mode = "forward"})`
  ---@type table<string, Flash.Config>
  modes = {
    -- options used when flash is activated through
    -- a regular search with `/` or `?`
    search = {
      -- when `true`, flash will be activated during regular search by default.
      -- You can always toggle when searching with `require("flash").toggle()`
      enabled = false,
      highlight = { backdrop = false },
      jump = { history = true, register = true, nohlsearch = true },
      search = {
        -- `forward` will be automatically set to the search direction
        -- `mode` is always set to `search`
        -- `incremental` is set to `true` when `incsearch` is enabled
      },
    },
    -- options used when flash is activated through
    -- `f`, `F`, `t`, `T`, `;` and `,` motions
    char = {
      enabled = true,
      -- dynamic configuration for ftFT motions
      config = function(opts)
        -- autohide flash when in operator-pending mode
        opts.autohide = opts.autohide or (vim.fn.mode(true):find("no") and vim.v.operator == "y")

        -- disable jump labels when not enabled, when using a count,
        -- or when recording/executing registers
        opts.jump_labels = opts.jump_labels
          and vim.v.count == 0
          and vim.fn.reg_executing() == ""
          and vim.fn.reg_recording() == ""

        -- Show jump labels only in operator-pending mode
        -- opts.jump_labels = vim.v.count == 0 and vim.fn.mode(true):find("o")
      end,
      -- hide after jump when not using jump labels
      autohide = false,
      -- show jump labels
      jump_labels = false,
      -- set to `false` to use the current line only
      multi_line = true,
      -- When using jump labels, don't use these keys
      -- This allows using those keys directly after the motion
      label = { exclude = "hjkliardc" },
      -- by default all keymaps are enabled, but you can disable some of them,
      -- by removing them from the list.
      -- If you rather use another key, you can map them
      -- to something else, e.g., { [";"] = "L", [","] = H }
      keys = { "f", "F", "t", "T", ";", "," },
      ---@alias Flash.CharActions table<string, "next" | "prev" | "right" | "left">
      -- The direction for `prev` and `next` is determined by the motion.
      -- `left` and `right` are always left and right.
      char_actions = function(motion)
        return {
          [";"] = "next", -- set to `right` to always go right
          [","] = "prev", -- set to `left` to always go left
          -- clever-f style
          [motion:lower()] = "next",
          [motion:upper()] = "prev",
          -- jump2d style: same case goes next, opposite case goes prev
          -- [motion] = "next",
          -- [motion:match("%l") and motion:upper() or motion:lower()] = "prev",
        }
      end,
      search = { wrap = false },
      highlight = { backdrop = true },
      jump = { register = false },
    },
    -- options used for treesitter selections
    -- `require("flash").treesitter()`
    treesitter = {
      labels = "abcdefghijklmnopqrstuvwxyz",
      jump = { pos = "range" },
      search = { incremental = false },
      label = { before = true, after = true, style = "inline" },
      highlight = {
        backdrop = false,
        matches = false,
      },
    },
    treesitter_search = {
      jump = { pos = "range" },
      search = { multi_window = true, wrap = true, incremental = false },
      remote_op = { restore = true },
      label = { before = true, after = true, style = "inline" },
    },
    -- options used for remote flash
    remote = {
      remote_op = { restore = true, motion = true },
    },
  },
  -- options for the floating window that shows the prompt,
  -- for regular jumps
  prompt = {
    enabled = true,
    prefix = { { "⚡", "FlashPromptIcon" } },
    win_config = {
      relative = "editor",
      width = 1, -- when <=1 it's a percentage of the editor width
      height = 1,
      row = -1, -- when negative it's an offset from the bottom
      col = 0, -- when negative it's an offset from the right
      zindex = 1000,
    },
  },
  -- options for remote operator pending mode
  remote_op = {
    -- restore window views and cursor position
    -- after doing a remote operation
    restore = false,
    -- For `jump.pos = "range"`, this setting is ignored.
    -- `true`: always enter a new motion when doing a remote operation
    -- `false`: use the window's cursor position and jump target
    -- `nil`: act as `true` for remote windows, `false` for the current window
    motion = false,
  },
})

      local function flash(prompt_bufnr)
        require("flash").jump({
          pattern = "^",
          label = { after = { 0, 0 } },
          search = {
            mode = "search",
            exclude = {
              function(win)
                return vim.bo[vim.api.nvim_win_get_buf(win)].filetype ~= "TelescopeResults"
              end,
            },
          },
          action = function(match)
            local picker = require("telescope.actions.state").get_current_picker(prompt_bufnr)
            picker:set_selection(match.pos[1] - 1)
          end,
        })
      end
      opts.defaults = vim.tbl_deep_extend("force", opts.defaults or {}, {
        mappings = {
          n = { s = flash },
          i = { ["<c-s>"] = flash },
        },
      })
  end
},

{
  {
    "sindresorhus/awesome",
  },
  {
    "lewis6991/pckr.nvim",
    config = function()
      
      local function bootstrap_pckr()
        local pckr_path = vim.fn.stdpath("data") .. "/pckr/pckr.nvim"
      
        if not (vim.uv or vim.loop).fs_stat(pckr_path) then
          vim.fn.system({
            'git',
            'clone',
            "--filter=blob:none",
            'https://github.com/lewis6991/pckr.nvim',
            pckr_path
          })
        end
      
        vim.opt.rtp:prepend(pckr_path)
      end
      
      bootstrap_pckr()
      
      require('pckr').add{
        -- My plugins here
        -- 'foo1/bar1.nvim';
        -- 'foo2/bar2.nvim';
      }
      
      
      -- This file can be loaded by calling `lua require('plugins')` from your init.vim
      
      local cmd = require('pckr.loader.cmd')
      local keys = require('pckr.loader.keys')
      
      require('pckr').add{
        -- Simple plugins can be specified as strings
        '9mm/vim-closer';
      
        -- Lazy loading:
        -- Load on a specific command
        {'tpope/vim-dispatch',
          cond = {
            cmd('Dispatch'),
          }
        };
      
        -- Load on specific keymap
        {'tpope/vim-commentary', cond = keys('n', 'gc') },
      
        -- Load on specific commands
        -- Also run code after load (see the "config" key)
        { 'w0rp/ale',
          cond = cmd('ALEEnable'),
          config = function()
            vim.cmd[[ALEEnable]]
          end
        };
      
        -- Local plugins can be included
        '~/projects/personal/hover.nvim';
      
        -- Plugins can have post-install/update hooks
        {'iamcco/markdown-preview.nvim', run = 'cd app && yarn install', cond = cmd('MarkdownPreview')};
      
        -- Post-install/update hook with neovim command
        { 'nvim-treesitter/nvim-treesitter', run = ':TSUpdate' };
      
        -- Post-install/update hook with call of vimscript function with argument
        { 'glacambre/firenvim', run = function()
          vim.fn['firenvim#install'](0)
        end };
      
        -- Use specific branch, dependency and run lua file after load
        { 'glepnir/galaxyline.nvim',
          branch = 'main',
          requires = {'kyazdani42/nvim-web-devicons'},
          config = function()
            require'statusline'
          end
        };
      
        -- Run config *before* the plugin is loaded
        {'whatyouhide/vim-lengthmatters', config_pre = function()
          vim.g.lengthmatters_highlight_one_column = 1
          vim.g.lengthmatters_excluded = {'pckr'}
        end},
      }
      
      
      require('pckr').setup{
        pack_dir            = util.join_paths(vim.fn.stdpath('data'), 'site'),
        max_jobs            = nil, -- Limit the number of simultaneous jobs. nil means no limit
        autoremove          = false, -- Remove unused plugins
        autoinstall         = true, -- Auto install plugins
        git = {
          cmd = 'git', -- The base command for git operations
          clone_timeout = 60, -- Timeout, in seconds, for git clones
          default_url_format = 'https://github.com/%s' -- Lua format string used for "aaa/bbb" style plugins
        },
        log = { level = 'warn' }, -- The default print log level. One of: "trace", "debug", "info", "warn", "error", "fatal".
        opt_dir = ...,
        start_dir = ...,
        lockfile = {
          path = util.join_paths(vim.fn.stdpath('config', 'pckr', 'lockfile.lua'))
        }
      }
      
      
      {
        'myusername/example',    -- The plugin location string
      
        -- The following keys are all optional
      
        -- Specifies a git branch to use
        branch: string?,
      
        -- Specifies a git tag to use. Supports '*' for "latest tag"
        tag: string?,
      
        -- Specifies a git commit to use
        commit: string?,
      
        -- Skip updating this plugin in updates/syncs. Still cleans.
        lock: boolean?,
      
        -- Post-update/install hook. See "update/install hooks".
        run: string|function,
      
        -- Specifies plugin dependencies. See "dependencies".
        requires: string|string[],
      
        -- Specifies code to run after this plugin is loaded. If string then require it.
        -- E.g:
        --   config = function() require('mod') end
        -- is equivalent to:
        --   config = 'mod'
        config: string|function,
      
        -- Specifies code to run before this plugin is loaded. If string then require it.
        config_pre: string|function,
      
        cond: function|function[],    -- Specifies custom loader
      }
      
      
      pckr.add{
        {"my/plugin", cond = function(load_plugin)
          vim.keymap.set('n', 'ga', function()
            vim.keymap.del('n', 'ga')
            load_plugin()
            vim.api.nvim_input('ga')
          end)
        end}
      }
      
        -- equivalent to --
      
      local keys = require('pckr.loader.keys')
      pckr.add{
        {"my/plugin", cond = keys('n', 'ga') },
      }
      
      
      local local_plugin_dir = vim.env.HOME..'/projects/'
      
      local function resolve(x)
        if type(x) == 'string' and x:sub(1, 1) ~= '/' then
          local name = vim.split(x, '/')[2]
          local loc_install = vim.fs.join_paths(local_plugin_dir, name)
          if name ~= '' and vim.fn.isdirectory(loc_install) == 1 then
            return loc_install
          end
        end
      end
      
      local function try_get_local(spec)
        if type(spec) == 'string' then
          return resolve(spec) or spec
        end
      
        if not spec or type(spec[1]) ~= 'string' then
          return spec
        end
      
        return resolve(spec[1]) or spec[1]
      end
      
      local function walk_spec(spec, field, fn)
        if type(spec[field]) == 'table' then
          for j in ipairs(spec[field]) do
            walk_spec(spec[field], j, fn)
          end
          walk_spec(spec[field], 'requires', fn)
        end
        spec[field] = fn(spec[field])
      end
      
      local init {
        'nvim-treesitter/nvim-treesitter'
        -- plugins spec
      }
      
      walk_spec({init}, 1, try_get_local)
      
      require('pckr').add(init)
      
    end,
  },
  {
    "savq/paq-nvim",
    config = function()
      
      require "paq" {
          "savq/paq-nvim", -- Let Paq manage itself
          "neovim/nvim-lspconfig",
          { "lervag/vimtex", opt = true }, -- Use braces when passing options
          { 'nvim-treesitter/nvim-treesitter', build = ':TSUpdate' },
      }
      
    end,
  },
  {
    "NTBBloodbath/cheovim",
    config = function()
      
      --[[
            ___           ___           ___           ___                                    ___     
           /  /\         /__/\         /  /\         /  /\          ___        ___          /__/\    
          /  /:/         \  \:\       /  /:/_       /  /::\        /__/\      /  /\        |  |::\   
         /  /:/           \__\:\     /  /:/ /\     /  /:/\:\       \  \:\    /  /:/        |  |:|:\  
        /  /:/  ___   ___ /  /::\   /  /:/ /:/_   /  /:/  \:\       \  \:\  /__/::\      __|__|:|\:\ 
       /__/:/  /  /\ /__/\  /:/\:\ /__/:/ /:/ /\ /__/:/ \__\:\  ___  \__\:\ \__\/\:\__  /__/::::| \:\
       \  \:\ /  /:/ \  \:\/:/__\/ \  \:\/:/ /:/ \  \:\ /  /:/ /__/\ |  |:|    \  \:\/\ \  \:\~~\__\/
        \  \:\  /:/   \  \::/       \  \::/ /:/   \  \:\  /:/  \  \:\|  |:|     \__\::/  \  \:\      
         \  \:\/:/     \  \:\        \  \:\/:/     \  \:\/:/    \  \:\__|:|     /__/:/    \  \:\     
          \  \::/       \  \:\        \  \::/       \  \::/      \__\::::/      \__\/      \  \:\    
           \__\/         \__\/         \__\/         \__\/           ~~~~                   \__\/    
      
      	A config switcher written in Lua by NTBBloodbath and Vhyrro.
      --]]
      
      -- Defines the profiles you want to use
      local profiles = {
          --[[
          Here's an example:
      
      	<name_of_config> = { <path_or_url_to_config>, {
                  -- Where to install plugins under site/pack
      	        plugins = "packer",
                  -- Whether or not to preconfigure a plugin manager for you
                  preconfigure = "packer:opt",
      		}
      	}
      
          More in-depth information can be found in cheovim's README on GitHub.
          --]]
          my_config = { "<path_or_url>", {
          		plugins = "packer",
          		preconfigure = "packer",
      	    }
          },
      }
      
      -- return <name_of_config>, <list_of_profiles>
      return "my_config", profiles
      
      
      local profiles = {
      	my_config = { "/my/path", {
      			setup = function()
      				os.remove("some_important_file")
      			end,
      			config = "PackerSync",
      			plugins = "<plugin_location>",
      			preconfigure = "{packer|paq-nvim}:{start|opt}:<branch>",
      		}
      	}
      }
      
      return "my_config", profiles
      
    end,
  },
  {
    "folke/lazy.nvim",
  },
  {
    "alex-popov-tech/store.nvim",
    config = function()
      
      {
        "alex-popov-tech/store.nvim",
        dependencies = { "OXY2DEV/markview.nvim" },
        cmd = "Store"
      }
      
    end,
  },
  {
    "roobert/activate.nvim",
    config = function()
      
      return {
        "roobert/tabtree.nvim",
        config = function()
          require("tabtree").setup()
        end,
      }
      
      
      -- No example configuration was found for this plugin.
      --
      -- For detailed information on configuring this plugin, please refer to its
      -- official documentation:
      --
      --   https://github.com/cbochs/grapple.nvim
      --
      -- If you wish to use this plugin, you can optionally modify and then uncomment
      -- the configuration below.
      
      return {
        -- "cbochs/grapple.nvim"
      }
      
      
      return {
        "roobert/activate.nvim",
        keys = {
          {
            "<leader>P",
            '<CMD>lua require("activate").list_plugins()<CR>',
            desc = "Plugins",
          },
        },
        dependencies = {
          { 'nvim-telescope/telescope.nvim', branch = '0.1.x', dependencies = { 'nvim-lua/plenary.nvim' } }
        }
      }
      
    end,
  },
  {
    "nvim-neorocks/rocks.nvim",
    config = function()
      
      dependencies = {
        "neotest",
        "tree-sitter-haskell"
      }
      
      
      do
          -- Specifies where to install/use rocks.nvim
          local install_location = vim.fs.joinpath(vim.fn.stdpath("data") --[[@as string]], "rocks")
      
          -- Set up configuration options related to rocks.nvim (recommended to leave as default)
          local rocks_config = {
              rocks_path = vim.fs.normalize(install_location),
          }
      
          vim.g.rocks_nvim = rocks_config
      
          -- Configure the package path (so that plugin code can be found)
          local luarocks_path = {
              vim.fs.joinpath(rocks_config.rocks_path, "share", "lua", "5.1", "?.lua"),
              vim.fs.joinpath(rocks_config.rocks_path, "share", "lua", "5.1", "?", "init.lua"),
          }
          package.path = package.path .. ";" .. table.concat(luarocks_path, ";")
      
          -- Configure the C path (so that e.g. tree-sitter parsers can be found)
          local luarocks_cpath = {
              vim.fs.joinpath(rocks_config.rocks_path, "lib", "lua", "5.1", "?.so"),
              vim.fs.joinpath(rocks_config.rocks_path, "lib64", "lua", "5.1", "?.so"),
          }
          package.cpath = package.cpath .. ";" .. table.concat(luarocks_cpath, ";")
      
          -- Add rocks.nvim to the runtimepath
          vim.opt.runtimepath:append(vim.fs.joinpath(rocks_config.rocks_path, "lib", "luarocks", "rocks-5.1", "rocks.nvim", "*"))
      end
      
      -- If rocks.nvim is not installed then install it!
      if not pcall(require, "rocks") then
          local rocks_location = vim.fs.joinpath(vim.fn.stdpath("cache") --[[@as string]], "rocks.nvim")
      
          if not vim.uv.fs_stat(rocks_location) then
              -- Pull down rocks.nvim
              local url = "https://github.com/lumen-oss/rocks.nvim"
              vim.fn.system({ "git", "clone", "--filter=blob:none", url, rocks_location })
              -- Make sure the clone was successfull
              assert(vim.v.shell_error == 0, "rocks.nvim installation failed. Try exiting and re-entering Neovim!")
          end
      
          -- If the clone was successful then source the bootstrapping script
          vim.cmd.source(vim.fs.joinpath(rocks_location, "bootstrap.lua"))
      
          vim.fn.delete(rocks_location, "rf")
      end
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-deps.md",
  },
  {
    "wsdjeg/nvim-plug",
    config = function()
      
      local dir = vim.fn.stdpath('data') .. '/repos/'
      
      local function bootstrap(repo)
        if vim.fn.isdirectory(dir .. repo) == 0 then
          vim.fn.system({
            'git',
            'clone',
            '--depth',
            '1',
            'https://github.com/' .. repo .. '.git',
            dir .. repo,
          })
        end
        vim.opt.runtimepath:append(dir .. repo)
      end
      
      bootstrap('wsdjeg/job.nvim')
      bootstrap('wsdjeg/logger.nvim')
      bootstrap('wsdjeg/nvim-plug')
      
      
      require('plug').setup({
        -- set the bundle dir
        bundle_dir = vim.fn.stdpath('data') .. '/repos',
        -- set the path where raw plugin is download to
        raw_plugin_dir = vim.fn.stdpath('data') .. '/repos/raw_plugin',
        -- max number of processes used for nvim-plug job
        max_processes = 5,
        base_url = 'https://github.com',
        -- default ui is `default`,
        -- to use `notify` for floating window notify
        -- you need to install wsdjeg/notify.nvim
        ui = 'default',
        -- default is nil
        http_proxy = 'http://127.0.0.1:7890',
        -- default is nil
        https_proxy = 'http://127.0.0.1:7890',
        -- default history depth for `git clone`
        clone_depth = 1,
        -- plugin priority, readme [plugin priority] for more info
        enable_priority = false,
      })
      
      
      require('plug').add({
        {
          'wsdjeg/scrollbar.vim',
          events = { 'VimEnter' },
        },
        {
          'wsdjeg/vim-chat',
          enabled = function()
            return vim.fn.has('nvim-0.10.0') == 1
          end,
        },
        {
          'wsdjeg/flygrep.nvim',
          cmds = { 'FlyGrep' },
          config = function()
            require('flygrep').setup()
          end,
        },
        {
          type = 'raw',
          url = 'https://gist.githubusercontent.com/wsdjeg/4ac99019c5ca156d35704550648ba321/raw/4e8c202c74e98b5d56616c784bfbf9b873dc8868/markdown.vim',
          script_type = 'after/syntax'
        },
        {
          'D:/wsdjeg/winbar.nvim',
          events = { 'VimEnter' },
        },
        {
          'wsdjeg/vim-mail',
          on_func = 'mail#',
        },
      })
      
      
      if vim.fn.isdirectory('D:/bundle_dir/wsdjeg/nvim-plug') == 0 then
        vim.fn.system({
          'git',
          'clone',
          '--depth',
          '1',
          'https://github.com/wsdjeg/nvim-plug.git',
          'D:/bundle_dir/wsdjeg/nvim-plug',
        })
      end
      vim.opt.runtimepath:append('D:/bundle_dir/wsdjeg/nvim-plug')
      require('plug').setup({
        -- set the bundle dir
        bundle_dir = 'D:/bundle_dir',
      })
      require('plug').add({
        {
          'wsdjeg/nvim-plug',
          fetch = true,
        },
      })
      
      
      vim.cmd('hi def link PlugTitle TODO')
      vim.cmd('hi def link PlugProcess Repeat')
      vim.cmd('hi def link PlugDone Type')
      vim.cmd('hi def link PlugFailed WarningMsg')
      vim.cmd('hi def link PlugDoing Number')
      
      
      if vim.fn.isdirectory('D:/bundle_dir/wsdjeg/nvim-plug') == 0 then
        vim.fn.system({
          'git',
          'clone',
          '--depth',
          '1',
          'https://github.com/wsdjeg/nvim-plug.git',
          'D:/bundle_dir/wsdjeg/nvim-plug',
        })
      end
      vim.opt.runtimepath:append('D:/bundle_dir/wsdjeg/nvim-plug')
      if vim.fn.isdirectory('D:/bundle_dir/wsdjeg/notify.nvim') == 0 then
        vim.fn.system({
          'git',
          'clone',
          '--depth',
          '1',
          'https://github.com/wsdjeg/notify.nvim.git',
          'D:/bundle_dir/wsdjeg/notify.nvim',
        })
      end
      vim.opt.runtimepath:append('D:/bundle_dir/wsdjeg/notify.nvim')
      
      require('plug').setup({
      
        bundle_dir = 'D:/bundle_dir',
        raw_plugin_dir = 'D:/bundle_dir/raw_plugin',
        ui = 'notify',
        http_proxy = 'http://127.0.0.1:7890',
        https_proxy = 'http://127.0.0.1:7890',
        enable_priority = true,
        max_processes = 16,
      })
      
      require('plug').add({
        {
          'wsdjeg/logger.nvim',
          config = function()
            require('logger').setup({ level = 0 })
            vim.keymap.set(
              'n',
              '<leader>hL',
              '<cmd>lua require("logger").viewRuntimeLog()<cr>',
              { silent = true }
            )
          end,
        },
        {
          'wsdjeg/notify.nvim',
          fetch = true,
        },
        {
          'wsdjeg/nvim-plug',
          fetch = true,
        },
      })
      
      
      --- your custom UI
      
      local function on_ui_update(name, data)
        -- logic
      end
      
      
      require('plug').setup({
        bundle_dir = 'D:/bundle_dir',
        max_processes = 5, -- max number of processes used for nvim-plug job
        base_url = 'https://github.com',
        ui = on_ui_update, -- default ui is notify, use `default` for split window UI
      })
      
      
      require('plug').setup({
        max_processes = 5,
        enable_priority = true,
      })
      require('plug').add({
        {
          'wsdjeg/scrollbar.vim',
          events = { 'VimEnter' },
        },
        {
          'wsdjeg/vim-chat',
          enabled = function()
            return vim.fn.has('nvim-0.10.0') == 1
          end,
        },
        {
          'wsdjeg/flygrep.nvim',
          cmds = { 'FlyGrep' },
          config = function()
            require('flygrep').setup()
          end,
        },
        {
          'rakr/vim-one',
          config = function()
            vim.cmd('colorscheme one')
          end,
          priority = 100,
        },
      })
      require('plug').load()
      
    end,
  },
  {
    "romus204/referencer.nvim",
    config = function()
      
      {
          "romus204/referencer.nvim",
          config = function()
              require("referencer").setup()
          end
      }
      
      
      use {
          "romus204/referencer.nvim",
          config = function()
              require("referencer").setup()
          end
      }
      
      
      require("referencer").setup({
          enable = false,                      -- enable after LSP attach
          format = "  %d reference(s)",       -- format string for reference count
          show_no_reference = true,            -- show if refs count = 0
          kinds = { 5, 6, 8, 12, 13, 14, 23, } -- LSP SymbolKinds to show references for
          hl_group = "Comment",                -- default highlight group
          color = nil,                         -- optional custom color (overrides hl_group)
          virt_text_pos = "eol",               -- virtual text position (eol | overlay | right_align)
          pattern = nil,                       -- pattern for LspAttach autocmd to auto-enable
          lsp_servers = {}                     -- list of servers for which this plugin will be active. nil or {} is ALL LSP clients
      
      })
      
      
      require("referencer").setup({
          enable = true,
          format = "  %d ref",
          show_no_reference = true,
          kinds = { 12, 6, 5, 23, 8 },
          hl_group = "Comment",
          color = "#FFA500",
          virt_text_pos = "eol",
          pattern = {"*.go", "*.py"},
          lsp_servers = {'gopls', 'pyright'}
      
      })
      
    end,
  },
  {
    "Dan7h3x/signup.nvim",
    config = function()
      
      require("lazy").setup({
        {
          "Dan7h3x/signup.nvim",
          branch = "main",
          opts = {
                -- Your configuration options here
          },
          config = function(_,opts)
            require("signup").setup(opts)
          end
        }
      })
      
      
      lua << EOF
      require('signup').setup({
        -- Your configuration options here
      })
      EOF
      
      
      {
          silent = true,
          icons = {
            parameter = "",
            method = "󰡱",
            documentation = "󱪙",
            type = "󰌗",
            default = "󰁔",
          },
          colors = {
            parameter = "#86e1fc",
            method = "#c099ff",
            documentation = "#4fd6be",
            default_value = "#a80888",
            type = "#f6c177",
          },
          active_parameter = true,   -- enable/disable active_parameter highlighting
          active_parameter_colors = {
            bg = "#86e1fc",
            fg = "#1a1a1a",
          },
          border = "rounded",
          dock_border = "rounded",
          winblend = 10,
          auto_close = true,
          trigger_chars = { "(", ",", ")" },
          max_height = 10,
          max_width = 40,
          floating_window_above_cur_line = true,
          debounce_time = 50,
          dock_toggle_key = "<Leader>sd",
          dock_mode = {
            enabled = false,
            position = "bottom",   -- "bottom", "top", or "middle"
            height = 4,            -- If > 1: fixed height in lines, if <= 1: percentage of window height (e.g., 0.3 = 30%)
            padding = 1,           -- Padding from window edges
            side = "right",        -- "right", "left", or "center"
            width_percentage = 40, -- Percentage of editor width (10-90%)
          },
        }
      
    end,
  },
  {
    "neovim/nvim-lspconfig",
    config = function()
      
        vim.pack.add{
          { src = 'https://github.com/neovim/nvim-lspconfig' },
        }
        
      
         vim.lsp.enable('pyright')
         
      
      vim.lsp.config('jdtls', {
        cmd = { '/path/to/jdtls' },
      })
      
      
      vim.lsp.config('rust_analyzer', {
        -- Server-specific settings. See `:help lsp-quickstart`
        settings = {
          ['rust-analyzer'] = {},
        },
      })
      
      
         vim.lsp.config('<client name>', {
           root_dir = vim.fn.fnamemodify(debug.getinfo(1, 'S').source:sub(2), ':p:h'),
         })
         
      
      vim.lsp.set_log_level("debug")
      
    end,
  },
  {
    "nvim-lua/lsp-status.nvim",
    config = function()
      
      update_current_function() -- Set/reset the b:lsp_current_function variable
      -- Shows the current function, method, class, struct, interface, enum, module, or namespace
      diagnostics() -- Return a table with all diagnostic counts for the current buffer
      messages() -- Return a table listing progress and other status messages for display
      register_progress() -- Register the provided handler for progress messages
      register_client() -- Register a client for messages
      -- Integrate misc. LS protocol extensions into the messages framework
      -- Each extension table contains a set of handlers and a setup() function 
      -- returning said handlers
      extensions = { clangd, pyls_ms }
      -- Set up a client for use with lsp-status. Calls register_client() and sets up 
      -- buffer autocommands
      on_attach(client) 
      config(config_vals) -- Configure lsp-status
      -- Table of client capabilities extended to signal support for progress messages
      capabilities 
      status() -- One example out-of-the-box statusline component (as shown in the images above)
      
      
      lsp_status.config {
        select_symbol = function(cursor_pos, symbol)
          if symbol.valueRange then
            local value_range = {
              ["start"] = {
                character = 0,
                line = vim.fn.byte2line(symbol.valueRange[1])
              },
              ["end"] = {
                character = 0,
                line = vim.fn.byte2line(symbol.valueRange[2])
              }
            }
      
            return require("lsp-status.util").in_range(cursor_pos, value_range)
          end
        end
      }
      
      
      local lsp_status = require('lsp-status')
      -- completion_customize_lsp_label as used in completion-nvim
      -- Optional: customize the kind labels used in identifying the current function.
      -- g:completion_customize_lsp_label is a dict mapping from LSP symbol kind 
      -- to the string you want to display as a label
      -- lsp_status.config { kind_labels = vim.g.completion_customize_lsp_label }
      
      -- Register the progress handler
      lsp_status.register_progress()
      
      
      -- Set default client capabilities plus window/workDoneProgress
      config.capabilities = vim.tbl_extend('keep', config.capabilities or {}, lsp_status.capabilities)
      
      
      -- Register client for messages and set up buffer autocommands to update 
      -- the statusline and the current function.
      -- NOTE: on_attach is called with the client object, which is the "client" parameter below
      lsp_status.on_attach(client)
      
      
      clangd = {
        handlers = lsp_status.extensions.clangd.setup()
      },
      pyls_ms = {
        handlers = lsp_status.extensions.pyls_ms.setup()
      },
      
    end,
  },
  {
    "RishabhRD/nvim-lsputils",
    config = function()
      
      code_action_handler(_, _, actions, _, _, _, customSelectionHandler)
      
      
      local function customSelectionHandler(selectedAction)
        print("Action selected: ", selectedAction)
      end
      
      
      local jdtls_ui = require'jdtls.ui'
      function jdtls_ui.pick_one_async(items, _, _, cb)
        require'lsputil.codeAction'.code_action_handler(nil, nil, items, nil, nil, nil, cb)
      end
      
    end,
  },
  {
    "nvimdev/lspsaga.nvim",
  },
  {
    "kosayoda/nvim-lightbulb",
    config = function()
      
      { 'kosayoda/nvim-lightbulb' }
      
      
      use { 'kosayoda/nvim-lightbulb' }
      
      
      require("nvim-lightbulb").setup({
        autocmd = { enabled = true }
      })
      
      
      local default_config = {
          -- Priority of the lightbulb for all handlers except float.
          priority = 10,
      
          -- Whether or not to hide the lightbulb when the buffer is not focused.
          -- Only works if configured during NvimLightbulb.setup
          hide_in_unfocused_buffer = true,
      
          -- Whether or not to link the highlight groups automatically.
          -- Default highlight group links:
          --   LightBulbSign -> DiagnosticSignInfo
          --   LightBulbFloatWin -> DiagnosticFloatingInfo
          --   LightBulbVirtualText -> DiagnosticVirtualTextInfo
          --   LightBulbNumber -> DiagnosticSignInfo
          --   LightBulbLine -> CursorLine
          -- Only works if configured during NvimLightbulb.setup
          link_highlights = true,
      
          -- Perform full validation of configuration.
          -- Available options: "auto", "always", "never"
          --   "auto" only performs full validation in NvimLightbulb.setup.
          --   "always" performs full validation in NvimLightbulb.update_lightbulb as well.
          --   "never" disables config validation.
          validate_config = "auto",
      
          -- Code action kinds to observe.
          -- To match all code actions, set to `nil`.
          -- Otherwise, set to a table of kinds.
          -- Example: { "quickfix", "refactor.rewrite" }
          -- See: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#codeActionKind
          action_kinds = nil,
      
          -- Enable code lens support.
          -- If the current position has executable code lenses, the icon is changed from `text` to `lens_text`
          -- for sign, virtual_text, float and status_text.
          -- The code lens icon is configurable per handler.
          code_lenses = false,
      
          -- Configuration for various handlers:
          -- 1. Sign column.
          sign = {
              enabled = true,
              -- Text to show in the sign column.
              -- Must be between 1-2 characters.
              text = "💡",
              lens_text = "🔎",
              -- Highlight group to highlight the sign column text.
              hl = "LightBulbSign",
          },
      
          -- 2. Virtual text.
          virtual_text = {
              enabled = false,
              -- Text to show in the virt_text.
              text = "💡",
              lens_text = "🔎",
              -- Position of virtual text given to |nvim_buf_set_extmark|.
              -- Can be a number representing a fixed column (see `virt_text_pos`).
              -- Can be a string representing a position (see `virt_text_win_col`).
              pos = "eol",
              -- Highlight group to highlight the virtual text.
              hl = "LightBulbVirtualText",
              -- How to combine other highlights with text highlight.
              -- See `hl_mode` of |nvim_buf_set_extmark|.
              hl_mode = "combine",
          },
      
          -- 3. Floating window.
          float = {
              enabled = false,
              -- Text to show in the floating window.
              text = "💡",
              lens_text = "🔎",
              -- Highlight group to highlight the floating window.
              hl = "LightBulbFloatWin",
              -- Window options.
              -- See |vim.lsp.util.open_floating_preview| and |nvim_open_win|.
              -- Note that some options may be overridden by |open_floating_preview|.
              win_opts = {
                  focusable = false,
              },
          },
      
          -- 4. Status text.
          -- When enabled, will allow using |NvimLightbulb.get_status_text|
          -- to retrieve the configured text.
          status_text = {
              enabled = false,
              -- Text to set if a lightbulb is available.
              text = "💡",
              lens_text = "🔎",
              -- Text to set if a lightbulb is unavailable.
              text_unavailable = "",
          },
      
          -- 5. Number column.
          number = {
              enabled = false,
              -- Highlight group to highlight the number column if there is a lightbulb.
              hl = "LightBulbNumber",
          },
      
          -- 6. Content line.
          line = {
              enabled = false,
              -- Highlight group to highlight the line if there is a lightbulb.
              hl = "LightBulbLine",
          },
      
          -- Autocmd configuration.
          -- If enabled, automatically defines an autocmd to show the lightbulb.
          -- If disabled, you will have to manually call |NvimLightbulb.update_lightbulb|.
          -- Only works if configured during NvimLightbulb.setup
          autocmd = {
              -- Whether or not to enable autocmd creation.
              enabled = false,
              -- See |updatetime|.
              -- Set to a negative value to avoid setting the updatetime.
              updatetime = 200,
              -- See |nvim_create_autocmd|.
              events = { "CursorHold", "CursorHoldI" },
              -- See |nvim_create_autocmd| and |autocmd-pattern|.
              pattern = { "*" },
          },
      
          -- Scenarios to not show a lightbulb.
          ignore = {
              -- LSP client names to ignore.
              -- Example: {"null-ls", "lua_ls"}
              clients = {},
              -- Filetypes to ignore.
              -- Example: {"neo-tree", "lua"}
              ft = {},
              -- Ignore code actions without a `kind` like refactor.rewrite, quickfix.
              actions_without_kind = false,
          },
      
          --- A general filter function for code actions.
          --- The function is called for code actions *after* any `ignore` or `action_kinds`
          --- options are applied.
          --- The function should return true to keep the code action, false otherwise.
          ---@type (fun(client_name:string, result:lsp.CodeAction|lsp.Command):boolean)|nil
          filter = nil,
      }
      
    end,
  },
  {
    "roobert/action-hints.nvim",
    config = function()
      
      {
        "roobert/action-hints.nvim",
        config = function()
          require("action-hints").setup()
        end,
      },
      
      
      {
        "roobert/action-hints.nvim",
        config = function()
          require("action-hints").setup({
            template = {
              definition = { text = " ⊛", color = "#add8e6" },
              references = { text = " ↱%s", color = "#ff6666" },
            },
            use_virtual_text = true,
          })
        end,
      },
      
      
      require("lualine").setup({
        sections = {
          lualine_x = { require("action-hints").statusline },
        },
      })
      
    end,
  },
  {
    "onsails/lspkind.nvim",
    config = function()
      
      -- setup() is also available as an alias
      require('lspkind').init({
          -- DEPRECATED (use mode instead): enables text annotations
          --
          -- default: true
          -- with_text = true,
      
          -- defines how annotations are shown
          -- default: symbol
          -- options: 'text', 'text_symbol', 'symbol_text', 'symbol'
          mode = 'symbol_text',
      
          -- default symbol map
          -- can be either 'default' (requires nerd-fonts font) or
          -- 'codicons' for codicon preset (requires vscode-codicons font)
          --
          -- default: 'default'
          preset = 'codicons',
      
          -- override preset symbols
          --
          -- default: {}
          symbol_map = {
            Text = "󰉿",
            Method = "󰆧",
            Function = "󰊕",
            Constructor = "",
            Field = "󰜢",
            Variable = "󰀫",
            Class = "󰠱",
            Interface = "",
            Module = "",
            Property = "󰜢",
            Unit = "󰑭",
            Value = "󰎠",
            Enum = "",
            Keyword = "󰌋",
            Snippet = "",
            Color = "󰏘",
            File = "󰈙",
            Reference = "󰈇",
            Folder = "󰉋",
            EnumMember = "",
            Constant = "󰏿",
            Struct = "󰙅",
            Event = "",
            Operator = "󰆕",
            TypeParameter = "",
          },
      })
      
      
      local lspkind = require('lspkind')
      cmp.setup {
        formatting = {
          format = lspkind.cmp_format({
            mode = 'symbol', -- show only symbol annotations
            maxwidth = {
              -- prevent the popup from showing more than provided characters (e.g 50 will not show more than 50 characters)
              -- can also be a function to dynamically calculate max width such as
              -- menu = function() return math.floor(0.45 * vim.o.columns) end,
              menu = 50, -- leading text (labelDetails)
              abbr = 50, -- actual suggestion item
            },
            ellipsis_char = '...', -- when popup menu exceed maxwidth, the truncated part would show ellipsis_char instead (must define maxwidth first)
            show_labelDetails = true, -- show labelDetails in menu. Disabled by default
      
            -- The function below will be called before any actual modifications from lspkind
            -- so that you can provide more controls on popup customization. (See [#30](https://github.com/onsails/lspkind-nvim/pull/30))
            before = function (entry, vim_item)
              -- ...
              return vim_item
            end
          })
        }
      }
      
    end,
  },
  {
    "ojroques/nvim-lspfuzzy",
    config = function()
      
      use {
        'ojroques/nvim-lspfuzzy',
        requires = {
          {'junegunn/fzf'},
          {'junegunn/fzf.vim'},  -- to enable preview (optional)
        },
      }
      
      
      paq {'junegunn/fzf'}
      paq {'junegunn/fzf.vim'}  -- to enable preview (optional)
      paq {'ojroques/nvim-lspfuzzy'}
      
      
      require('lspfuzzy').setup {}
      
      
      vim.api.nvim_create_autocmd('LspAttach', {
         callback = function(args)
           local client = vim.lsp.get_client_by_id(args.data.client_id)
           if not client then
             return
           else
             client.request = require('lspfuzzy').wrap_request(client.request)
           end
         end
       })
      
      
      require('lspfuzzy').setup {
        methods = 'all',         -- either 'all' or a list of LSP methods (see below)
        jump_one = true,         -- jump immediately if there is only one location
        save_last = false,       -- save last location results for the :LspFuzzyLast command
        callback = nil,          -- callback called after jumping to a location
        fzf_preview = {          -- arguments to the FZF '--preview-window' option
          'right:+{2}-/2'          -- preview on the right and centered on entry
        },
        fzf_action = {               -- FZF actions
          ['ctrl-t'] = 'tab split',  -- go to location in a new tab
          ['ctrl-v'] = 'vsplit',     -- go to location in a vertical split
          ['ctrl-x'] = 'split',      -- go to location in a horizontal split
        },
        fzf_modifier = ':~:.',   -- format FZF entries, see |filename-modifiers|
        fzf_trim = true,         -- trim FZF entries
      }
      
      
      vim.g.fzf_preview_window = {'down:+{2}-/2'}
      
    end,
  },
  {
    "gfanto/fzf-lsp.nvim",
    config = function()
      
      require'fzf_lsp'.setup()
      
      
      vim.lsp.handlers["textDocument/codeAction"] = require'fzf_lsp'.code_action_handler
      vim.lsp.handlers["textDocument/definition"] = require'fzf_lsp'.definition_handler
      vim.lsp.handlers["textDocument/declaration"] = require'fzf_lsp'.declaration_handler
      vim.lsp.handlers["textDocument/typeDefinition"] = require'fzf_lsp'.type_definition_handler
      vim.lsp.handlers["textDocument/implementation"] = require'fzf_lsp'.implementation_handler
      vim.lsp.handlers["textDocument/references"] = require'fzf_lsp'.references_handler
      vim.lsp.handlers["textDocument/documentSymbol"] = require'fzf_lsp'.document_symbol_handler
      vim.lsp.handlers["workspace/symbol"] = require'fzf_lsp'.workspace_symbol_handler
      vim.lsp.handlers["callHierarchy/incomingCalls"] = require'fzf_lsp'.incoming_calls_handler
      vim.lsp.handlers["callHierarchy/outgoingCalls"] = require'fzf_lsp'.outgoing_calls_handler
      
    end,
  },
  {
    "ray-x/lsp_signature.nvim",
    config = function()
      
      local cfg = {…}  -- add your config here
      require "lsp_signature".setup(cfg)
      
      
      local golang_setup = {
        on_attach = function(client, bufnr)
          …
          require "lsp_signature".on_attach(signature_setup, bufnr)  -- Note: add in lsp client on-attach
          …
        end,
        …
      }
      
      require'lspconfig'.gopls.setup(golang_setup)
      
      
      {
        "ray-x/lsp_signature.nvim",
        event = "InsertEnter",
        opts = {
          bind = true,
          handler_opts = {
            border = "rounded"
          }
        },
        -- or use config
        -- config = function(_, opts) require'lsp_signature'.setup({you options}) end
      }
      
      
      local example_setup = {
        on_attach = function(client, bufnr)
          …
          require "lsp_signature".on_attach({
            bind = true,
            handler_opts = {
              border = "rounded"
            }
          }, bufnr)
          …
        end,
        …
      }
      
      
      require'lspconfig'.gopls.setup()
      require "lsp_signature".setup({
        bind = true,
        handler_opts = {
          border = "rounded"
        }
      })
      
      
          vim.keymap.set({ 'n' }, '<C-k>', function()       require('lsp_signature').toggle_float_win()
          end, { silent = true, noremap = true, desc = 'toggle signature' })
      
          vim.keymap.set({ 'n' }, '<Leader>k', function()
           vim.lsp.buf.signature_help()
          end, { silent = true, noremap = true, desc = 'toggle signature' })
      
      
       cfg = {
        debug = false, -- set to true to enable debug logging
        log_path = vim.fn.stdpath("cache") .. "/lsp_signature.log", -- log dir when debug is on
        -- default is  ~/.cache/nvim/lsp_signature.log
        verbose = false, -- show debug line number
      
        bind = true, -- This is mandatory, otherwise border config won't get registered.
                     -- If you want to hook lspsaga or other signature handler, pls set to false
        doc_lines = 10, -- will show two lines of comment/doc(if there are more than two lines in doc, will be truncated);
                       -- set to 0 if you DO NOT want any API comments be shown
                       -- This setting only take effect in insert mode, it does not affect signature help in normal
                       -- mode, 10 by default
      
        max_height = 12, -- max height of signature floating_window, include borders
        max_width = function()
          return vim.api.nvim_win_get_width(0) * 0.8
        end, -- max_width of signature floating_window, line will be wrapped if exceed max_width
                        -- the value need >= 40
                        -- if max_width is function, it will be called
        wrap = true, -- allow doc/signature text wrap inside floating_window, useful if your lsp return doc/sig is too long
        floating_window = true, -- show hint in a floating window, set to false for virtual text only mode
      
        floating_window_above_cur_line = true, -- try to place the floating above the current line when possible Note:
        -- will set to true when fully tested, set to false will use whichever side has more space
        -- this setting will be helpful if you do not want the PUM and floating win overlap
      
        floating_window_off_x = 1, -- adjust float windows x position.
                                   -- can be either a number or function
        floating_window_off_y = 0, -- adjust float windows y position. e.g -2 move window up 2 lines; 2 move down 2 lines
                                    -- can be either number or function, see examples
        ignore_error = func(err, ctx, config), -- this scilence errors, check init.lua for more details
      
        close_timeout = 4000, -- close floating window after ms when laster parameter is entered
        fix_pos = false,  -- set to true, the floating window will not auto-close until finish all parameters
        hint_enable = true, -- virtual hint enable
        hint_prefix = "🐼 ",  -- Panda for parameter, NOTE: for the terminal not support emoji, might crash
        -- or, provide a table with 3 icons
        -- hint_prefix = {
        --     above = "↙ ",  -- when the hint is on the line above the current line
        --     current = "← ",  -- when the hint is on the same line
        --     below = "↖ "  -- when the hint is on the line below the current line
        -- }
        hint_scheme = "String",
        hint_inline = function() return false end,  -- should the hint be inline(nvim 0.10 only)?  default false
        -- return true | 'inline' to show hint inline, return 'eol' to show hint at end of line, return false to disable
        -- return 'right_align' to display hint right aligned in the current line
        hi_parameter = "LspSignatureActiveParameter", -- how your parameter will be highlight
        handler_opts = {
          border = "rounded"   -- double, rounded, single, shadow, none, or a table of borders
        },
      
        always_trigger = false, -- sometime show signature on new line or in middle of parameter can be confusing, set it to false for #58
      
        auto_close_after = nil, -- autoclose signature float win after x sec, disabled if nil.
        extra_trigger_chars = {}, -- Array of extra characters that will trigger signature completion, e.g., {"(", ","}
        zindex = 200, -- by default it will be on top of all floating windows, set to <= 50 send it to bottom
      
        padding = '', -- character to pad on left and right of signature can be ' ', or '|'  etc
      
        transparency = nil, -- disabled by default, allow floating win transparent value 1~100
        shadow_blend = 36, -- if you using shadow as border use this set the opacity
        shadow_guibg = 'Black', -- if you using shadow as border use this set the color e.g. 'Green' or '#121315'
        timer_interval = 200, -- default timer check interval set to lower value if you want to reduce latency
        toggle_key = nil, -- toggle signature on and off in insert mode,  e.g. toggle_key = '<M-x>'
        toggle_key_flip_floatwin_setting = false, -- true: toggle floating_windows: true|false setting after toggle key pressed
           -- false: floating_windows setup will not change, toggle_key will pop up signature helper, but signature
           -- may not popup when typing depends on floating_window setting
      
        select_signature_key = nil, -- cycle to next signature, e.g. '<M-n>' function overloading
        move_signature_window_key = nil, -- move the floating window, e.g. {'<M-k>', '<M-j>'} to move up and down, or
          -- table of 4 keymaps, e.g. {'<M-k>', '<M-j>', '<M-h>', '<M-l>'} to move up, down, left, right
        move_cursor_key = nil, -- imap, use nvim_set_current_win to move cursor between current win and floating window
        -- e.g. move_cursor_key = '<M-p>',
        -- once moved to floating window, you can use <M-d>, <M-u> to move cursor up and down
        keymaps = {}  -- relate to move_cursor_key; the keymaps inside floating window with arguments of bufnr
        -- e.g. keymaps = function(bufnr) vim.keymap.set(...) end
        -- it can be function that set keymaps
        -- e.g. keymaps = { { 'j', '<C-o>j' }, } this map j to <C-o>j in floating window
        -- <M-d> and <M-u> are default keymaps to move cursor up and down
      }
      
      -- recommended:
      require'lsp_signature'.setup(cfg) -- no need to specify bufnr if you don't use toggle_key
      
      -- You can also do this inside lsp on_attach
      -- note: on_attach deprecated
      require'lsp_signature'.on_attach(cfg, bufnr) -- no need to specify bufnr if you don't use toggle_key
      
      
      require("lsp_signature").status_line(max_width)
      
      
      {
        label = 'func fun_name(arg1, arg2…)'
        hint = 'arg1',
        range = {start = 13, ['end'] = 17 }
        doc = 'func_name return arg1 + arg2 …'
      }
      
      
      local current_signature = function(width)
        if not pcall(require, 'lsp_signature') then return end
        local sig = require("lsp_signature").status_line(width)
        return sig.label .. "🐼" .. sig.hint
      end
      
      
      -- cfg = {…}  -- add you config here
      local cfg = {
        floating_window_off_x = 5, -- adjust float windows x position.
        floating_window_off_y = function() -- adjust float windows y position. e.g. set to -2 can make floating window move up 2 lines
          local linenr = vim.api.nvim_win_get_cursor(0)[1] -- buf line number
          local pumheight = vim.o.pumheight
          local winline = vim.fn.winline() -- line number in the window
          local winheight = vim.fn.winheight(0)
      
          -- window top
          if winline - 1 < pumheight then
            return pumheight
          end
      
          -- window bottom
          if winheight - winline < pumheight then
            return -pumheight
          end
          return 0
        end,
      }
      require "lsp_signature".setup(cfg)
      
      
      fix_pos = function(signatures, lspclient)
         if signatures[1].activeParameter >= 0 and #signatures[1].parameters == 1 then
           return false
         end
         if lspclient.name == 'sumneko_lua' then
           return true
         end
         return false
      end
      
    end,
  },
  {
    "smjonas/inc-rename.nvim",
    config = function()
      
      {
        "smjonas/inc-rename.nvim",
        opts = {}
      }
      
      
      use {
        "smjonas/inc-rename.nvim",
        config = function()
          require("inc_rename").setup()
        end,
      }
      
      
      require("inc_rename").setup()
      
      
      vim.keymap.set("n", "<leader>rn", ":IncRename ")
      
      
      vim.keymap.set("n", "<leader>rn", function()
        return ":IncRename " .. vim.fn.expand("<cword>")
      end, { expr = true })
      
      
      require("noice").setup {
        presets = { inc_rename = true }
      }
      
      
      require("inc_rename").setup {
        input_buffer_type = "dressing",
      }
      
      
      require("dressing").setup {
        input = {
          override = function(conf)
            conf.col = -1
            conf.row = 0
            return conf
          end,
        },
      }
      
      
      require("inc_rename").setup {
        input_buffer_type = "snacks",
      }
      
      
      require("inc_rename").setup {
       -- the name of the command
        cmd_name = "IncRename",
         -- the highlight group used for highlighting the identifier's new name
        hl_group = "Substitute",
         -- whether an empty new name should be previewed; if false the command preview will be cancelled instead
        preview_empty_name = false,
         -- whether to display a `Renamed m instances in n files` message after a rename operation
        show_message = true,
         -- whether to save the "IncRename" command in the commandline history (set to false to prevent issues with
         -- navigating to older entries that may arise due to the behavior of command preview)
        save_in_cmdline_history = true,
         -- the type of the external input buffer to use (currently supports "dressing" or "snacks")
        input_buffer_type = nil,
         -- callback to run after renaming, receives the result table (from LSP handler) as an argument
        post_hook = nil,
      }
      
    end,
  },
  {
    "rmagatti/goto-preview",
    config = function()
      
      {
        "rmagatti/goto-preview",
        dependencies = { "rmagatti/logger.nvim" },
        event = "BufEnter",
        config = true, -- necessary as per https://github.com/rmagatti/goto-preview/issues/88
      }
      
      
      require('goto-preview').setup {
        width = 120, -- Width of the floating window
        height = 15, -- Height of the floating window
        border = {"↖", "─" ,"┐", "│", "┘", "─", "└", "│"}, -- Border characters of the floating window
        default_mappings = false, -- Bind default mappings
        debug = false, -- Print debug information
        opacity = nil, -- 0-100 opacity level of the floating window where 100 is fully transparent.
        resizing_mappings = false, -- Binds arrow keys to resizing the floating window.
        post_open_hook = nil, -- A function taking two arguments, a buffer and a window to be ran as a hook.
        post_close_hook = nil, -- A function taking two arguments, a buffer and a window to be ran as a hook.
        references = { -- Configure the telescope UI for slowing the references cycling window.
          provider = "telescope", -- telescope|fzf_lua|snacks|mini_pick|default
          telescope = require("telescope.themes").get_dropdown({ hide_preview = false })
        },
        -- These two configs can also be passed down to the goto-preview definition and implementation calls for one off "peak" functionality.
        focus_on_open = true, -- Focus the floating window when opening it.
        dismiss_on_move = false, -- Dismiss the floating window when moving the cursor.
        force_close = true, -- passed into vim.api.nvim_win_close's second argument. See :h nvim_win_close
        bufhidden = "wipe", -- the bufhidden option to set on the floating window. See :h bufhidden
        stack_floating_preview_windows = true, -- Whether to nest floating windows
        same_file_float_preview = true, -- Whether to open a new floating window for a reference within the current file
        preview_window_title = { enable = true, position = "left" }, -- Whether to set the preview window title as the filename
        zindex = 1, -- Starting zindex for the stack of floating windows
        vim_ui_input = true, -- Whether to override vim.ui.input with a goto-preview floating window
       
      }
      
      
      vim.keymap.set("n", "gp", "<cmd>lua require('goto-preview').goto_preview_definition()<CR>", {noremap=true})
      
      
      require("goto-preview").close_all_win { skip_curr_window = true }
      
    end,
  },
  {
    "jubnzv/virtual-types.nvim",
  },
  {
    "marilari88/twoslash-queries.nvim",
    config = function()
      
      use("marilari88/twoslash-queries.nvim")
      
      
      require("lspconfig")["tsserver"].setup({
          on_attach = function(client, bufnr)
             require("twoslash-queries").attach(client, bufnr)
          end,
      })
      
      
      vim.api.nvim_set_keymap('n',"<C-k>","<cmd>TwoslashQueriesInspect<CR>",{})
      
      
      use({
         "marilari88/twoslash-queries.nvim",			
          config = function()
              require("twoslash-queries").setup({
                  multi_line = true, -- to print types in multi line mode
                  is_enabled = false, -- to keep disabled at startup and enable it on request with the TwoslashQueriesEnable 
                  highlight = "Type", -- to set up a highlight group for the virtual text
      	   })
          end,
      })
      
    end,
  },
  {
    "ray-x/navigator.lua",
    config = function()
      
      use({
          'ray-x/navigator.lua',
          requires = {
              { 'ray-x/guihua.lua', run = 'cd lua/fzy && make' },
              { 'neovim/nvim-lspconfig' },
          },
      })
      
      
      lua require'navigator'.setup()
      
      
      require('nvim-autopairs').setup{
      disable_filetype = { "TelescopePrompt" , "guihua", "guihua_rust", "clap_input" },
      
      if vim.o.ft == 'clap_input' and vim.o.ft == 'guihua' and vim.o.ft == 'guihua_rust' then
        require'cmp'.setup.buffer { completion = {enable = false} }
      end
      
      -- or with autocmd
      vim.cmd("autocmd FileType guihua lua require('cmp').setup.buffer { enabled = false }")
      vim.cmd("autocmd FileType guihua_rust lua require('cmp').setup.buffer { enabled = false }")
      
      ...
      }
      
      
      require'navigator'.setup({
        debug = false, -- log output, set to true and log path: ~/.cache/nvim/gh.log
                       -- slowdownd startup and some actions
        width = 0.75, -- max width ratio (number of cols for the floating window) / (window width)
        height = 0.3, -- max list window height, 0.3 by default
        preview_height = 0.35, -- max height of preview windows
        border = {"╭", "─", "╮", "│", "╯", "─", "╰", "│"}, -- border style, can be one of 'none', 'single', 'double',
                                                           -- 'shadow', or a list of chars which defines the border
        on_attach = function(client, bufnr) -- no longer supported for nvim > 0.11 use your own LspAttach autocmd
        end,
      
        ts_fold = {
          enable = false,
          comment_fold = true, -- fold with comment string
          max_lines_scan_comments = 20, -- only fold when the fold level higher than this value
          disable_filetypes = {'help', 'guihua', 'text'}, -- list of filetypes which doesn't fold using treesitter
        },  -- modified version of treesitter folding
        default_mapping = true,  -- set to false if you will remap every key
        keymaps = {{key = "gK", func = vim.lsp.declaration, desc = 'declaration'}}, -- a list of key maps
        -- this kepmap gK will override "gD" mapping function declaration()  in default kepmap
        -- please check mapping.lua for all keymaps
        -- rule of overriding: if func and mode ('n' by default) is same
        -- the key will be overridden
        treesitter_analysis = true, -- treesitter variable context
        treesitter_navigation = true, -- bool|table false: use lsp to navigate between symbol ']r/[r', table: a list of
        --lang using TS navigation
        treesitter_analysis_max_num = 100, -- how many items to run treesitter analysis
        treesitter_analysis_condense = true, -- condense form for treesitter analysis
        -- this value prevent slow in large projects, e.g. found 100000 reference in a project
        transparency = 50, -- 0 ~ 100 blur the main window, 100: fully transparent, 0: opaque,  set to nil or 100 to disable it
      
        lsp_signature_help = true, -- if you would like to hook ray-x/lsp_signature plugin in navigator
        -- setup here. if it is nil, navigator will not init signature help
        signature_help_cfg = nil, -- if you would like to init ray-x/lsp_signature plugin in navigator, and pass in your own config to signature help
        icons = { -- refer to lua/navigator.lua for more icons config
          -- requires nerd fonts or nvim-web-devicons
          icons = true,
          -- Code action
          code_action_icon = "🏏", -- note: need terminal support, for those not support unicode, might crash
          -- Diagnostics
          diagnostic_head = '🐛',
          diagnostic_head_severity_1 = "🈲",
          fold = {
            prefix = '⚡',  -- icon to show before the folding need to be 2 spaces in display width
            separator = '',  -- e.g. shows   3 lines 
          },
        },
        mason = false, -- Deprecated, mason no longer supported as setup lsp changed in nvim 0.11
        lsp = {
          enable = true,  -- skip lsp setup, and only use treesitter in navigator.
                          -- Use this if you are not using LSP servers, and only want to enable treesitter support.
                          -- If you only want to prevent navigator from touching your LSP server configs,
                          -- use `disable_lsp = "all"` instead.
                          -- If disabled, make sure add require('navigator.lspclient.mapping').setup({bufnr=bufnr, client=client}) in your
                          -- own on_attach
          code_action = {enable = true, sign = true, sign_priority = 40, virtual_text = true},
          code_lens_action = {enable = true, sign = true, sign_priority = 40, virtual_text = true},
          document_highlight = true, -- LSP reference highlight,
                                     -- it might already supported by you setup, e.g. LunarVim
          format_on_save = true, -- {true|false} set to false to disasble lsp code format on save (if you are using prettier/efm/formater etc)
                                 -- table: {enable = {'lua', 'go'}, disable = {'javascript', 'typescript'}} to enable/disable specific language
                                    -- enable: a whitelist of language that will be formatted on save
                                    -- disable: a blacklist of language that will not be formatted on save
                                 -- function: function(bufnr) return true end to enable/disable lsp format on save
          format_options = {async=false}, -- async: disable by default, the option used in vim.lsp.buf.format({async={true|false}, name = 'xxx'})
          disable_format_cap = {"sqlls", "lua_ls", "gopls"},  -- a list of lsp disable format capacity (e.g. if you using efm or vim-codeformat etc), empty {} by default
                                                                  -- If you using null-ls and want null-ls format your code
                                                                  -- you should disable all other lsp and allow only null-ls.
          -- disable_lsp = {'pylsd', 'sqlls'},  -- prevents navigator from setting up this list of servers.
                                                -- if you use your own LSP setup, and don't want navigator to setup
                                                -- any LSP server for you, use `disable_lsp = "all"`.
                                                -- you may need to add this to your own on_attach hook:
                                                -- require('navigator.lspclient.mapping').setup({bufnr=bufnr, client=client})
                                                -- for e.g. denols and tsserver you may want to enable one lsp server at a time.
                                                -- default value: {}
          diagnostic = {
            underline = true,
            virtual_text = { spacing = 3, source = true }, -- show virtual for diagnostic message
                                                           -- set to false to prefer virtual lines
            update_in_insert = false, -- update diagnostic message in insert mode
            severity_sort = { reverse = true },
            float = {                 -- setup for floating windows style, set to false to disable floating window
              focusable = false,
              style = 'minimal',
              border = 'rounded',
              source = 'always',
              header = '',
              prefix = '',
            },
            virtual_lines = {
              current_line = false, -- show diagnostic only on current line
            },
            register = 'D',  -- yank the error into register
          },
      
          hover = {
            enable = true,
            -- fallback when hover failed
            -- e.g. if filetype is go, try godoc
            go = function()
              local w = vim.fn.expand('<cWORD>')
              vim.cmd('GoDoc ' .. w)
            end,
            -- if python, do python doc
            python = function()
              -- run pydoc, behaviours defined in lua/navigator.lua
            end,
            default = function()
              -- fallback apply to all file types not been specified above
              -- local w = vim.fn.expand('<cWORD>')
              -- vim.lsp.buf.workspace_symbol(w)
            end,
          },
      
          diagnostic_scrollbar_sign = {'▃', '▆', '█'}, -- experimental:  diagnostic status in scroll bar area; set to false to disable the diagnostic sign,
                                                       --                for other style, set to {'╍', 'ﮆ'} or {'-', '='}
          diagnostic_virtual_text = true,  -- show virtual for diagnostic message
          diagnostic_update_in_insert = false, -- update diagnostic message in insert mode
          display_diagnostic_qf = true, -- always show quickfix if there are diagnostic errors, set to false if you want to ignore it
                                        -- set to 'trouble' to show diagnostcs in Trouble
          ctags ={
            cmd = 'ctags',
            tagfile = 'tags',
            options = '-R --exclude=.git --exclude=node_modules --exclude=test --exclude=vendor --excmd=number',
          },
          -- lsp setup and config no longer supported for nvim 0.11
          -- refer to nvim 0.11 lsp setup doc and lspconfig for more info
          ts_ls = {  -- no longer supported for nvim 0.11
          },
          gopls = {   -- no longer supported for nvim 0.11
          },
          -- the lsp setup can be a function, .e.g
          gopls = function() -- no longer supported for nvim 0.11
          end,
      
          lua_ls = { }, -- no longer supported
      
          servers = {'cmake', 'ltex'}, -- by default empty, and it should load all LSP clients available based on filetype
          -- but if you want navigator load  e.g. `cmake` and `ltex` for you , you
          -- can put them in the `servers` list and navigator will auto load them.
          -- you could still specify the custom config  like this
          -- cmake = {filetypes = {'cmake', 'makefile'}, single_file_support = false},
        }
      })
      
      
      local servers = {
        "angularls", "gopls", "ts_ls", "flow", "bashls", "dockerls", "julials", "pylsp", "pyright",
        "jedi_language_server", "jdtls", "lua_ls", "vimls", "html", "jsonls", "solargraph", "cssls",
        "yamlls", "clangd", "ccls", "sqlls", "denols", "graphql", "dartls", "dotls",
        "kotlin_language_server", "nimls", "intelephense", "vuels", "phpactor", "omnisharp",
        "r_language_server", "rust_analyzer", "terraformls", "svelte", "texlab", "clojure_lsp", "elixirls",
        "sourcekit", "fsautocomplete", "vls", "hls"
      }
      
      
      require'navigator'setup{lsp={servers={'cmake', 'lexls'}}}
      
      
      require'navigator'.setup({
        lsp={
         pylsd={filetype={}}
        }
      })
      
      
      require'navigator'.setup({
        lsp={
          disable_lsp = {'pylsd', 'sqlls'},
        }
      })
      
      
      require("navigator.lspclient.mapping").setup({ client = client, bufnr = bufnr }) -- setup navigator keymaps here,
      require("navigator.dochighlight").documentHighlight(bufnr)
      require("navigator.codeAction").code_action_prompt(client, bufnr)
      
      
      use  {"folke/neodev.nvim",
        ft = 'lua',
        config =  function()
          require'neodev'.setup{}
        end
      }
      
      use {"ray-x/navigator.lua",
        config=function()
          require'navigator'.setup{}
        end
        }
      
      
      require('rust-tools').setup({
        server = {
          on_attach = function(client, bufnr)
            require('navigator.lspclient.mapping').setup({client=client, bufnr=bufnr}) -- setup navigator keymaps here,
      
            require("navigator.dochighlight").documentHighlight(bufnr)
            require('navigator.codeAction').code_action_prompt(client, bufnr)
            -- otherwise, you can define your own commands to call navigator functions
          end,
        }
      })
      
      require("clangd_extensions").setup {
        server = {
          on_attach = function(client, bufnr)
            require('navigator.lspclient.mapping').setup({client=client, bufnr=bufnr}) -- setup navigator keymaps here,
            require("navigator.dochighlight").documentHighlight(bufnr)
            require('navigator.codeAction').code_action_prompt(client, bufnr)
            -- otherwise, you can define your own commands to call navigator functions
          end,
        }
      }
      
      
      -- The attach will be call at end of navigator on_attach()
      require'navigator'.setup({on_attach = function(client, bufnr) require 'illuminate'.on_attach(client)})
      
      
      require'navigator'.setup({
        debug = false, -- log output, set to true and log path: ~/.local/share/nvim/gh.log
        })
      
      
      -- a example of adding logs in the plugin
      
      local log = require"navigator.util".log
      
      local definition_hdlr = util.mk_handler(function(err, locations, ctx, _)
        -- output your log
        log('[definition] log for locations', locations, "and ctx", ctx)
        if err ~= nil then
          return
        end
      end
      
      
      local function treesitter_and_diag_panel()
        local Panel = require('guihua.panel')
      
        local diag = require('navigator.diagnostics')
        local ft = vim.bo.filetype
        local results = diag.diagnostic_list[ft]
        log(diag.diagnostic_list, ft)
      
        local bufnr = api.nvim_get_current_buf()
        local p = Panel:new({
          header = 'treesitter',
          render = function(b)
            log('render for ', bufnr, b)
            return require('navigator.treesitter').all_ts_nodes(b)
          end,
        })
        p:add_section({
          header = 'diagnostic',
          render = function(buf)
            log(buf, diagnostic)
            if diag.diagnostic_list[ft] ~= nil then
              local display_items = {}
              for _, client_items in pairs(results) do
                for _, items in pairs(client_items) do
                  for _, it in pairs(items) do
                    log(it)
                    table.insert(display_items, it)
                  end
                end
              end
              return display_items
            else
              return {}
            end
          end,
        })
        p:open(true)
      end
      
    end,
  },
  {
    "hedyhli/outline.nvim",
    config = function()
      
      {
        "hedyhli/outline.nvim",
        config = function()
          -- Example mapping to toggle outline
          vim.keymap.set("n", "<leader>o", "<cmd>Outline<CR>",
            { desc = "Toggle Outline" })
      
          require("outline").setup {
            -- Your setup opts here (leave empty to use defaults)
          }
        end,
      },
      
      
      {
        "hedyhli/outline.nvim",
        lazy = true,
        cmd = { "Outline", "OutlineOpen" },
        keys = { -- Example mapping to toggle outline
          { "<leader>o", "<cmd>Outline<CR>", desc = "Toggle outline" },
        },
        opts = {
          -- Your setup opts here
        },
      },
      
      
      require("outline").setup({})
      
      
      {
        outline_window = {
          -- Where to open the split window: right/left
          position = 'right',
          -- The default split commands used are 'topleft vs' and 'botright vs'
          -- depending on `position`. You can change this by providing your own
          -- `split_command`.
          -- `position` will not be considered if `split_command` is non-nil.
          -- This should be a valid vim command used for opening the split for the
          -- outline window. Eg, 'rightbelow vsplit'.
          -- Width can be included (with will override the width setting below):
          -- Eg, `topleft 20vsp` to prevent a flash of windows when resizing.
          split_command = nil,
      
          -- Percentage or integer of columns
          width = 25,
          -- Whether width is relative to the total width of nvim
          -- When relative_width = true, this means take 25% of the total
          -- screen width for outline window.
          relative_width = true,
      
          -- Auto close the outline window if goto_location is triggered and not for
          -- peek_location
          auto_close = false,
          -- Automatically scroll to the location in code when navigating outline window.
          auto_jump = false,
          -- boolean or integer for milliseconds duration to apply a temporary highlight
          -- when jumping. false to disable.
          jump_highlight_duration = 300,
          -- Whether to center the cursor line vertically in the screen when
          -- jumping/focusing. Executes zz.
          center_on_jump = true,
      
          -- Vim options for the outline window
          show_numbers = false,
          show_relative_numbers = false,
          wrap = false,
      
          -- true/false/'focus_in_outline'/'focus_in_code'.
          -- The last two means only show cursorline when the focus is in outline/code.
          -- 'focus_in_outline' can be used if the outline_items.auto_set_cursor
          -- operations are too distracting due to visual contrast caused by cursorline.
          show_cursorline = true,
          -- Enable this only if you enabled cursorline so your cursor color can
          -- blend with the cursorline, in effect, as if your cursor is hidden
          -- in the outline window.
          -- This makes your line of cursor have the same color as if the cursor
          -- wasn't focused on the outline window.
          -- This feature is experimental.
          hide_cursor = false,
      
          -- Whether to auto-focus on the outline window when it is opened.
          -- Set to false to *always* retain focus on your previous buffer when opening
          -- outline.
          -- If you enable this you can still use bangs in :Outline! or :OutlineOpen! to
          -- retain focus on your code. If this is false, retaining focus will be
          -- enforced for :Outline/:OutlineOpen and you will not be able to have the
          -- other behaviour.
          focus_on_open = true,
          -- Winhighlight option for outline window.
          -- See :help 'winhl'
          -- To change background color to "CustomHl" for example, use "Normal:CustomHl".
          winhl = '',
          -- Message displayed when there are no providers avialable.
          no_provider_message = 'No supported provider...'
        },
      
        outline_items = {
          -- Show extra details with the symbols (lsp dependent) as virtual next
          show_symbol_details = true,
          -- Show corresponding line numbers of each symbol on the left column as
          -- virtual text, for quick navigation when not focused on outline.
          -- Why? See this comment:
          -- https://github.com/simrat39/symbols-outline.nvim/issues/212#issuecomment-1793503563
          show_symbol_lineno = false,
          -- Whether to highlight the currently hovered symbol and all direct parents
          highlight_hovered_item = true,
          -- Whether to automatically set cursor location in outline to match
          -- location in code when focus is in code. If disabled you can use
          -- `:OutlineFollow[!]` from any window or `<C-g>` from outline window to
          -- trigger this manually.
          auto_set_cursor = true,
          -- Autocmd events to automatically trigger these operations.
          auto_update_events = {
            -- Includes both setting of cursor and highlighting of hovered item.
            -- The above two options are respected.
            -- This can be triggered manually through `follow_cursor` lua API,
            -- :OutlineFollow command, or <C-g>.
            follow = { 'CursorMoved' },
            -- Re-request symbols from the provider.
            -- This can be triggered manually through `refresh_outline` lua API, or
            -- :OutlineRefresh command.
            items = { 'InsertLeave', 'WinEnter', 'BufEnter', 'BufWinEnter', 'TabEnter', 'BufWritePost' },
          },
        },
      
        -- Options for outline guides which help show tree hierarchy of symbols
        guides = {
          enabled = true,
          markers = {
            -- It is recommended for bottom and middle markers to use the same number
            -- of characters to align all child nodes vertically.
            bottom = '└',
            middle = '├',
            vertical = '│',
          },
        },
      
        symbol_folding = {
          -- Depth past which nodes will be folded by default. Set to false to unfold all on open.
          autofold_depth = 1,
          -- When to auto unfold nodes
          auto_unfold = {
            -- Auto unfold currently hovered symbol
            hovered = true,
            -- Auto fold when the root level only has this many nodes.
            -- Set true for 1 node, false for 0.
            only = true,
          },
          markers = { '', '' },
        },
      
        preview_window = {
          -- Automatically open preview of code location when navigating outline window
          auto_preview = false,
          -- Automatically open hover_symbol when opening preview (see keymaps for
          -- hover_symbol).
          -- If you disable this you can still open hover_symbol using your keymap
          -- below.
          open_hover_on_preview = false,
          width = 50,     -- Percentage or integer of columns
          min_width = 50, -- Minimum number of columns
          -- Whether width is relative to the total width of nvim.
          -- When relative_width = true, this means take 50% of the total
          -- screen width for preview window, ensure the result width is at least 50
          -- characters wide.
          relative_width = true,
          height = 50,     -- Percentage or integer of lines
          min_height = 10, -- Minimum number of lines
          -- Similar to relative_width, except the height is relative to the outline
          -- window's height.
          relative_height = true,
          -- Border option for floating preview window.
          -- Options include: single/double/rounded/solid/shadow or an array of border
          -- characters.
          -- See :help nvim_open_win() and search for "border" option.
          border = 'single',
          -- winhl options for the preview window, see ':h winhl'
          winhl = 'NormalFloat:',
          -- Pseudo-transparency of the preview window, see ':h winblend'
          winblend = 0,
          -- Experimental feature that let's you edit the source content live
          -- in the preview window. Like VS Code's "peek editor".
          live = false
        },
      
        -- These keymaps can be a string or a table for multiple keys.
        -- Set to `{}` to disable. (Using 'nil' will fallback to default keys)
        keymaps = {
          show_help = '?',
          close = {'<Esc>', 'q'},
          -- Jump to symbol under cursor.
          -- It can auto close the outline window when triggered, see
          -- 'auto_close' option above.
          goto_location = '<Cr>',
          -- Jump to symbol under cursor but keep focus on outline window.
          peek_location = 'o',
          -- Visit location in code and close outline immediately
          goto_and_close = '<S-Cr>',
          -- Change cursor position of outline window to match current location in code.
          -- 'Opposite' of goto/peek_location.
          restore_location = '<C-g>',
          -- Open LSP/provider-dependent symbol hover information
          hover_symbol = '<C-space>',
          -- Preview location code of the symbol under cursor
          toggle_preview = 'K',
          rename_symbol = 'r',
          code_actions = 'a',
          -- These fold actions are collapsing tree nodes, not code folding
          fold = 'h',
          unfold = 'l',
          fold_toggle = '<Tab>',
          -- Toggle folds for all nodes.
          -- If at least one node is folded, this action will fold all nodes.
          -- If all nodes are folded, this action will unfold all nodes.
          fold_toggle_all = '<S-Tab>',
          fold_all = 'W',
          unfold_all = 'E',
          fold_reset = 'R',
          -- Move down/up by one line and peek_location immediately.
          -- You can also use outline_window.auto_jump=true to do this for any
          -- j/k/<down>/<up>.
          down_and_jump = '<C-j>',
          up_and_jump = '<C-k>',
        },
      
        providers = {
          priority = { 'lsp', 'coc', 'markdown', 'norg', 'man' },
          -- Configuration for each provider (3rd party providers are supported)
          lsp = {
            -- Lsp client names to ignore
            blacklist_clients = {},
          },
          markdown = {
            -- List of supported ft's to use the markdown provider
            filetypes = {'markdown'},
          },
        },
      
        symbols = {
          -- Filter by kinds (string) for symbols in the outline.
          -- Possible kinds are the Keys in the icons table below.
          -- A filter list is a string[] with an optional exclude (boolean) field.
          -- The symbols.filter option takes either a filter list or ft:filterList
          -- key-value pairs.
          -- Put  exclude=true  in the string list to filter by excluding the list of
          -- kinds instead.
          -- Include all except String and Constant:
          --   filter = { 'String', 'Constant', exclude = true }
          -- Only include Package, Module, and Function:
          --   filter = { 'Package', 'Module', 'Function' }
          -- See more examples below.
          filter = nil,
      
          -- You can use a custom function that returns the icon for each symbol kind.
          -- This function takes a kind (string) as parameter and should return an
          -- icon as string.
          ---@param kind string Key of the icons table below
          ---@param bufnr integer Code buffer
          ---@param symbol outline.Symbol The current symbol object
          ---@returns string|boolean The icon string to display, such as "f", or `false`
          ---                        to fallback to `icon_source`.
          icon_fetcher = nil,
          -- 3rd party source for fetching icons. This is used as a fallback if
          -- icon_fetcher returned an empty string.
          -- Currently supported values: 'lspkind'
          icon_source = nil,
          -- The next fallback if both icon_fetcher and icon_source has failed, is
          -- the custom mapping of icons specified below. The icons table is also
          -- needed for specifying hl group.
          icons = {
            File = { icon = '󰈔', hl = 'Identifier' },
            Module = { icon = '󰆧', hl = 'Include' },
            Namespace = { icon = '󰅪', hl = 'Include' },
            Package = { icon = '󰏗', hl = 'Include' },
            Class = { icon = '𝓒', hl = 'Type' },
            Method = { icon = 'ƒ', hl = 'Function' },
            Property = { icon = '', hl = 'Identifier' },
            Field = { icon = '󰆨', hl = 'Identifier' },
            Constructor = { icon = '', hl = 'Special' },
            Enum = { icon = 'ℰ', hl = 'Type' },
            Interface = { icon = '󰜰', hl = 'Type' },
            Function = { icon = '', hl = 'Function' },
            Variable = { icon = '', hl = 'Constant' },
            Constant = { icon = '', hl = 'Constant' },
            String = { icon = '𝓐', hl = 'String' },
            Number = { icon = '#', hl = 'Number' },
            Boolean = { icon = '⊨', hl = 'Boolean' },
            Array = { icon = '󰅪', hl = 'Constant' },
            Object = { icon = '⦿', hl = 'Type' },
            Key = { icon = '🔐', hl = 'Type' },
            Null = { icon = 'NULL', hl = 'Type' },
            EnumMember = { icon = '', hl = 'Identifier' },
            Struct = { icon = '𝓢', hl = 'Structure' },
            Event = { icon = '🗲', hl = 'Type' },
            Operator = { icon = '+', hl = 'Identifier' },
            TypeParameter = { icon = '𝙏', hl = 'Identifier' },
            Component = { icon = '󰅴', hl = 'Function' },
            Fragment = { icon = '󰅴', hl = 'Constant' },
            TypeAlias = { icon = ' ', hl = 'Type' },
            Parameter = { icon = ' ', hl = 'Identifier' },
            StaticMethod = { icon = ' ', hl = 'Function' },
            Macro = { icon = ' ', hl = 'Function' },
          },
        },
      }
      
      
      symbols.filter = { 'String', 'Variable', exclude=true }
      
      
      symbols.filter = { 'Function' }
      
      
      symbols.filter = {
        default = { 'String', exclude=true },
        python = { 'Function', 'Class' },
      }
      
      
      keymaps = {
        up_and_jump = '<C-p>',
        down_and_jump = '<C-n>',
      }
      
      
      keymaps = {
        up_and_jump = '<up>',
        down_and_jump = '<down>',
      }
      
      
      outline_window = {
        winhl = '',
      },
      
      
      preview_window = {
        winhl = 'NormalFloat:',
      },
      
      
      require'outline'
      
      
      symbols = {
        icon_fetcher = function(k)
          if k == 'Package' then
            return ""
          end
          return false
        end,
        icon_source = 'lspkind',
      }
      
      
      symbols = {
        icon_fetcher = function(kind, bufnr, symbol)
          -- Use nvim_buf_get_option(bufnr, 'ft') for nvim 0.7 users
          local ft = vim.api.nvim_get_option_value('ft', { buf = bufnr })
          -- ...
        end,
      }
      
      
      symbols = {
        icon_fetcher = function(kind, bufnr, symbol)
          local access_icons = { public = '○', protected = '◉', private = '●' }
          local icon = require('outline.config').o.symbols.icons[kind].icon
          -- ctags provider might add an `access` key
          if symbol and symbol.access then
            return icon .. ' ' .. access_icons[symbol.access]
          end
          return icon
        end,
      }
      
      
      symbol_folding = {
        autofold_depth = 1,
        auto_unfold = {
          hovered = true,
        },
      },
      
      
      symbol_folding = {
        autofold_depth = false,
      },
      
      
      symbol_folding = {
        auto_unfold = {
          only = 2,
        },
      },
      
      
      preview_window = {
        auto_preview = true,
      },
      
      
      outline_window = {
        auto_jump = true,
      },
      
      
      outline_items = {
        show_symbol_details = false,
      },
      
      
      outline_items = {
        show_symbol_lineno = true,
      },
      
      
      outline_window = {
        show_cursorline = true,
        hide_cursor = true,
      }
      
      
      symbols = {
        icon_fetcher = function(kind, bufnr, symbol) return kind:sub(1,1) end,
      }
      
      
      symbols = {
        icon_fetcher = function(kind, bufnr)
          -- Use nvim_buf_get_option(bufnr, 'ft') for nvim 0.7 users
          local ft = vim.api.nvim_get_option_value('ft', { buf = bufnr })
          -- ...
        end,
      }
      
      
      symbols = {
        icon_fetcher = function() return "" end,
      }
      
      
      symbols = {
        icon_fetcher = function(k, buf)
          if k == 'String' then
            return ""
          end
          return false
        end,
        icon_source = 'lspkind',
      }
      
      
      symbols = {
        icon_fetcher = function(k, buf)
          -- Use nvim_buf_get_option(buf, 'ft') for nvim 0.7 users
          local ft = vim.api.nvim_get_option_value("ft", { buf = buf })
          if ft == 'markdown' then
            return ""
          end
          return false
        end,
        icon_source = "lspkind",
      }
      
      
      preview_window = {
        live = true,
      }
      
    end,
  },
  {
    "stevearc/aerial.nvim",
    config = function()
      
      {
        'stevearc/aerial.nvim',
        opts = {},
        -- Optional dependencies
        dependencies = {
           "nvim-treesitter/nvim-treesitter",
           "nvim-tree/nvim-web-devicons"
        },
      }
      
      
      require("packer").startup(function()
        use({
          "stevearc/aerial.nvim",
          config = function()
            require("aerial").setup()
          end,
        })
      end)
      
      
      require("paq")({
        { "stevearc/aerial.nvim" },
      })
      
      
      require("aerial").setup({
        -- optionally use on_attach to set keymaps when aerial has attached to a buffer
        on_attach = function(bufnr)
          -- Jump forwards/backwards with '{' and '}'
          vim.keymap.set("n", "{", "<cmd>AerialPrev<CR>", { buffer = bufnr })
          vim.keymap.set("n", "}", "<cmd>AerialNext<CR>", { buffer = bufnr })
        end,
      })
      -- You probably also want to set a keymap to toggle aerial
      vim.keymap.set("n", "<leader>a", "<cmd>AerialToggle!<CR>")
      
      
      -- Call the setup function to change the default behavior
      require("aerial").setup({
        -- Priority list of preferred backends for aerial.
        -- This can be a filetype map (see :help aerial-filetype-map)
        backends = { "treesitter", "lsp", "markdown", "asciidoc", "man" },
      
        layout = {
          -- These control the width of the aerial window.
          -- They can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
          -- min_width and max_width can be a list of mixed types.
          -- max_width = {40, 0.2} means "the lesser of 40 columns or 20% of total"
          max_width = { 40, 0.2 },
          width = nil,
          min_width = 10,
      
          -- key-value pairs of window-local options for aerial window (e.g. winhl)
          win_opts = {},
      
          -- Determines the default direction to open the aerial window. The 'prefer'
          -- options will open the window in the other direction *if* there is a
          -- different buffer in the way of the preferred direction
          -- Enum: prefer_right, prefer_left, right, left, float
          default_direction = "prefer_right",
      
          -- Determines where the aerial window will be opened
          --   edge   - open aerial at the far right/left of the editor
          --   window - open aerial to the right/left of the current window
          placement = "window",
      
          -- When the symbols change, resize the aerial window (within min/max constraints) to fit
          resize_to_content = true,
      
          -- Preserve window size equality with (:help CTRL-W_=)
          preserve_equality = false,
        },
      
        -- Determines how the aerial window decides which buffer to display symbols for
        --   window - aerial window will display symbols for the buffer in the window from which it was opened
        --   global - aerial window will display symbols for the current window
        attach_mode = "window",
      
        -- List of enum values that configure when to auto-close the aerial window
        --   unfocus       - close aerial when you leave the original source window
        --   switch_buffer - close aerial when you change buffers in the source window
        --   unsupported   - close aerial when attaching to a buffer that has no symbol source
        close_automatic_events = {},
      
        -- Keymaps in aerial window. Can be any value that `vim.keymap.set` accepts OR a table of keymap
        -- options with a `callback` (e.g. { callback = function() ... end, desc = "", nowait = true })
        -- Additionally, if it is a string that matches "actions.<name>",
        -- it will use the mapping at require("aerial.actions").<name>
        -- Set to `false` to remove a keymap
        keymaps = {
          ["?"] = "actions.show_help",
          ["g?"] = "actions.show_help",
          ["<CR>"] = "actions.jump",
          ["<2-LeftMouse>"] = "actions.jump",
          ["<C-v>"] = "actions.jump_vsplit",
          ["<C-s>"] = "actions.jump_split",
          ["p"] = "actions.scroll",
          ["<C-j>"] = "actions.down_and_scroll",
          ["<C-k>"] = "actions.up_and_scroll",
          ["{"] = "actions.prev",
          ["}"] = "actions.next",
          ["[["] = "actions.prev_up",
          ["]]"] = "actions.next_up",
          ["q"] = "actions.close",
          ["o"] = "actions.tree_toggle",
          ["za"] = "actions.tree_toggle",
          ["O"] = "actions.tree_toggle_recursive",
          ["zA"] = "actions.tree_toggle_recursive",
          ["l"] = "actions.tree_open",
          ["zo"] = "actions.tree_open",
          ["L"] = "actions.tree_open_recursive",
          ["zO"] = "actions.tree_open_recursive",
          ["h"] = "actions.tree_close",
          ["zc"] = "actions.tree_close",
          ["H"] = "actions.tree_close_recursive",
          ["zC"] = "actions.tree_close_recursive",
          ["zr"] = "actions.tree_increase_fold_level",
          ["zR"] = "actions.tree_open_all",
          ["zm"] = "actions.tree_decrease_fold_level",
          ["zM"] = "actions.tree_close_all",
          ["zx"] = "actions.tree_sync_folds",
          ["zX"] = "actions.tree_sync_folds",
        },
      
        -- When true, don't load aerial until a command or function is called
        -- Defaults to true, unless `on_attach` is provided, then it defaults to false
        lazy_load = true,
      
        -- Disable aerial on files with this many lines
        disable_max_lines = 10000,
      
        -- Disable aerial on files this size or larger (in bytes)
        disable_max_size = 2000000, -- Default 2MB
      
        -- A list of all symbols to display. Set to false to display all symbols.
        -- This can be a filetype map (see :help aerial-filetype-map)
        -- To see all available values, see :help SymbolKind
        filter_kind = {
          "Class",
          "Constructor",
          "Enum",
          "Function",
          "Interface",
          "Module",
          "Method",
          "Struct",
        },
      
        -- Determines line highlighting mode when multiple splits are visible.
        -- split_width   Each open window will have its cursor location marked in the
        --               aerial buffer. Each line will only be partially highlighted
        --               to indicate which window is at that location.
        -- full_width    Each open window will have its cursor location marked as a
        --               full-width highlight in the aerial buffer.
        -- last          Only the most-recently focused window will have its location
        --               marked in the aerial buffer.
        -- none          Do not show the cursor locations in the aerial window.
        highlight_mode = "split_width",
      
        -- Highlight the closest symbol if the cursor is not exactly on one.
        highlight_closest = true,
      
        -- Highlight the symbol in the source buffer when cursor is in the aerial win
        highlight_on_hover = false,
      
        -- When jumping to a symbol, highlight the line for this many ms.
        -- Set to false to disable
        highlight_on_jump = 300,
      
        -- Jump to symbol in source window when the cursor moves
        autojump = false,
      
        -- Define symbol icons. You can also specify "<Symbol>Collapsed" to change the
        -- icon when the tree is collapsed at that symbol, or "Collapsed" to specify a
        -- default collapsed icon. The default icon set is determined by the
        -- "nerd_font" option below.
        -- If you have lspkind-nvim installed, it will be the default icon set.
        -- This can be a filetype map (see :help aerial-filetype-map)
        icons = {},
      
        -- Control which windows and buffers aerial should ignore.
        -- Aerial will not open when these are focused, and existing aerial windows will not be updated
        ignore = {
          -- Ignore unlisted buffers. See :help buflisted
          unlisted_buffers = false,
      
          -- Ignore diff windows (setting to false will allow aerial in diff windows)
          diff_windows = true,
      
          -- List of filetypes to ignore.
          filetypes = {},
      
          -- Ignored buftypes.
          -- Can be one of the following:
          -- false or nil - No buftypes are ignored.
          -- "special"    - All buffers other than normal, help and man page buffers are ignored.
          -- table        - A list of buftypes to ignore. See :help buftype for the
          --                possible values.
          -- function     - A function that returns true if the buffer should be
          --                ignored or false if it should not be ignored.
          --                Takes two arguments, `bufnr` and `buftype`.
          buftypes = "special",
      
          -- Ignored wintypes.
          -- Can be one of the following:
          -- false or nil - No wintypes are ignored.
          -- "special"    - All windows other than normal windows are ignored.
          -- table        - A list of wintypes to ignore. See :help win_gettype() for the
          --                possible values.
          -- function     - A function that returns true if the window should be
          --                ignored or false if it should not be ignored.
          --                Takes two arguments, `winid` and `wintype`.
          wintypes = "special",
        },
      
        -- Use symbol tree for folding. Set to true or false to enable/disable
        -- Set to "auto" to manage folds if your previous foldmethod was 'manual'
        -- This can be a filetype map (see :help aerial-filetype-map)
        manage_folds = false,
      
        -- When you fold code with za, zo, or zc, update the aerial tree as well.
        -- Only works when manage_folds = true
        link_folds_to_tree = false,
      
        -- Fold code when you open/collapse symbols in the tree.
        -- Only works when manage_folds = true
        link_tree_to_folds = true,
      
        -- Set default symbol icons to use patched font icons (see https://www.nerdfonts.com/)
        -- "auto" will set it to true if nvim-web-devicons or lspkind-nvim is installed.
        nerd_font = "auto",
      
        -- Call this function when aerial attaches to a buffer.
        on_attach = function(bufnr) end,
      
        -- Call this function when aerial first sets symbols on a buffer.
        on_first_symbols = function(bufnr) end,
      
        -- Automatically open aerial when entering supported buffers.
        -- This can be a function (see :help aerial-open-automatic)
        open_automatic = false,
      
        -- Run this command after jumping to a symbol (false will disable)
        post_jump_cmd = "normal! zz",
      
        -- Invoked after each symbol is parsed, can be used to modify the parsed item,
        -- or to filter it by returning false.
        --
        -- bufnr: a neovim buffer number
        -- item: of type aerial.Symbol
        -- ctx: a record containing the following fields:
        --   * backend_name: treesitter, lsp, man...
        --   * lang: info about the language
        --   * symbols?: specific to the lsp backend
        --   * symbol?: specific to the lsp backend
        --   * syntax_tree?: specific to the treesitter backend
        --   * match?: specific to the treesitter backend, TS query match
        post_parse_symbol = function(bufnr, item, ctx)
          return true
        end,
      
        -- Invoked after all symbols have been parsed and post-processed,
        -- allows to modify the symbol structure before final display
        --
        -- bufnr: a neovim buffer number
        -- items: a collection of aerial.Symbol items, organized in a tree,
        --        with 'parent' and 'children' fields
        -- ctx: a record containing the following fields:
        --   * backend_name: treesitter, lsp, man...
        --   * lang: info about the language
        --   * symbols?: specific to the lsp backend
        --   * syntax_tree?: specific to the treesitter backend
        post_add_all_symbols = function(bufnr, items, ctx)
          return items
        end,
      
        -- When true, aerial will automatically close after jumping to a symbol
        close_on_select = false,
      
        -- The autocmds that trigger symbols update (not used for LSP backend)
        update_events = "TextChanged,InsertLeave",
      
        -- Show box drawing characters for the tree hierarchy
        show_guides = false,
      
        -- Customize the characters used when show_guides = true
        guides = {
          -- When the child item has a sibling below it
          mid_item = "├─",
          -- When the child item is the last in the list
          last_item = "└─",
          -- When there are nested child guides to the right
          nested_top = "│ ",
          -- Raw indentation
          whitespace = "  ",
        },
      
        -- Set this function to override the highlight groups for certain symbols
        get_highlight = function(symbol, is_icon, is_collapsed)
          -- return "MyHighlight" .. symbol.kind
        end,
      
        -- Options for opening aerial in a floating win
        float = {
          -- Controls border appearance. Passed to nvim_open_win
          border = "rounded",
      
          -- Determines location of floating window
          --   cursor - Opens float on top of the cursor
          --   editor - Opens float centered in the editor
          --   win    - Opens float centered in the window
          relative = "cursor",
      
          -- These control the height of the floating window.
          -- They can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
          -- min_height and max_height can be a list of mixed types.
          -- min_height = {8, 0.1} means "the greater of 8 rows or 10% of total"
          max_height = 0.9,
          height = nil,
          min_height = { 8, 0.1 },
      
          override = function(conf, source_winid)
            -- This is the config that will be passed to nvim_open_win.
            -- Change values here to customize the layout
            return conf
          end,
        },
      
        -- Options for the floating nav windows
        nav = {
          border = "rounded",
          max_height = 0.9,
          min_height = { 10, 0.1 },
          max_width = 0.5,
          min_width = { 0.2, 20 },
          win_opts = {
            cursorline = true,
            winblend = 10,
          },
          -- Jump to symbol in source window when the cursor moves
          autojump = false,
          -- Show a preview of the code in the right column, when there are no child symbols
          preview = false,
          -- Keymaps in the nav window
          keymaps = {
            ["<CR>"] = "actions.jump",
            ["<2-LeftMouse>"] = "actions.jump",
            ["<C-v>"] = "actions.jump_vsplit",
            ["<C-s>"] = "actions.jump_split",
            ["h"] = "actions.left",
            ["l"] = "actions.right",
            ["<C-c>"] = "actions.close",
          },
        },
      
        lsp = {
          -- If true, fetch document symbols when LSP diagnostics update.
          diagnostics_trigger_update = false,
      
          -- Set to false to not update the symbols when there are LSP errors
          update_when_errors = true,
      
          -- How long to wait (in ms) after a buffer change before updating
          -- Only used when diagnostics_trigger_update = false
          update_delay = 300,
      
          -- Map of LSP client name to priority. Default value is 10.
          -- Clients with higher (larger) priority will be used before those with lower priority.
          -- Set to -1 to never use the client.
          priority = {
            -- pyright = 10,
          },
        },
      
        treesitter = {
          -- How long to wait (in ms) after a buffer change before updating
          update_delay = 300,
        },
      
        markdown = {
          -- How long to wait (in ms) after a buffer change before updating
          update_delay = 300,
        },
      
        asciidoc = {
          -- How long to wait (in ms) after a buffer change before updating
          update_delay = 300,
        },
      
        man = {
          -- How long to wait (in ms) after a buffer change before updating
          update_delay = 300,
        },
      })
      
      
      require("aerial").snacks_picker()
      
      
      require("aerial").snacks_picker({
        layout = {
          preset = "dropdown",
          preview = false,
        }
      })
      
      
      require("telescope").setup({
        extensions = {
          aerial = {
            -- Set the width of the first two columns (the second
            -- is relevant only when show_columns is set to 'both')
            col1_width = 4,
            col2_width = 30,
            -- How to format the symbols
            format_symbol = function(symbol_path, filetype)
              if filetype == "json" or filetype == "yaml" then
                return table.concat(symbol_path, ".")
              else
                return symbol_path[#symbol_path]
              end
            end,
            -- Available modes: symbols, lines, both
            show_columns = "both",
          },
        },
      })
      
      
      require("telescope").load_extension("aerial")
      
      
      require("aerial").fzf_lua_picker()
      
      
      require("aerial").fzf_lua_picker({
        profile = 'ivy',
      })
      
      
      require("lualine").setup({
        sections = {
          lualine_x = { "aerial" },
      
          -- Or you can customize it
          lualine_y = {
            {
              "aerial",
              -- The separator to be used to separate symbols in status line.
              sep = " ) ",
      
              -- The number of symbols to render top-down. In order to render only 'N' last
              -- symbols, negative numbers may be supplied. For instance, 'depth = -1' can
              -- be used in order to render only current symbol.
              depth = nil,
      
              -- When 'dense' mode is on, icons are not rendered near their symbols. Only
              -- a single icon that represents the kind of current symbol is rendered at
              -- the beginning of status line.
              dense = false,
      
              -- The separator to be used to separate symbols in dense mode.
              dense_sep = ".",
      
              -- Color the symbol icons.
              colored = true,
            },
          },
        },
      })
      
    end,
  },
  {
    "SmiteshP/nvim-navbuddy",
    config = function()
      
      use {
          "SmiteshP/nvim-navbuddy",
          requires = {
              "neovim/nvim-lspconfig",
              "SmiteshP/nvim-navic",
              "MunifTanjim/nui.nvim",
              "numToStr/Comment.nvim",        -- Optional
              "nvim-telescope/telescope.nvim" -- Optional
          }
      }
      
      
      return {
          "neovim/nvim-lspconfig",
          dependencies = {
              {
                  "SmiteshP/nvim-navbuddy",
                  dependencies = {
                      "SmiteshP/nvim-navic",
                      "MunifTanjim/nui.nvim"
                  },
                  opts = { lsp = { auto_attach = true } }
              }
          },
          -- your lsp config or other stuff
      }
      
      
      local navbuddy = require("nvim-navbuddy")
      
      require("lspconfig").clangd.setup {
          on_attach = function(client, bufnr)
              navbuddy.attach(client, bufnr)
          end
      }
      
      
      local navbuddy = require("nvim-navbuddy")
      local actions = require("nvim-navbuddy.actions")
      
      navbuddy.setup {
          window = {
              border = "single",  -- "rounded", "double", "solid", "none"
                                  -- or an array with eight chars building up the border in a clockwise fashion
                                  -- starting with the top-left corner. eg: { "╔", "═" ,"╗", "║", "╝", "═", "╚", "║" }.
              size = "60%",       -- Or table format example: { height = "40%", width = "100%"}
              position = "50%",   -- Or table format example: { row = "100%", col = "0%"}
              scrolloff = nil,    -- scrolloff value within navbuddy window
              sections = {
                  left = {
                      size = "20%",
                      border = nil, -- You can set border style for each section individually as well.
                  },
                  mid = {
                      size = "40%",
                      border = nil,
                  },
                  right = {
                      -- No size option for right most section. It fills to
                      -- remaining area.
                      border = nil,
                      preview = "leaf",  -- Right section can show previews too.
                                         -- Options: "leaf", "always" or "never"
                  }
              },
          },
          node_markers = {
              enabled = true,
              icons = {
                  leaf = "  ",
                  leaf_selected = " → ",
                  branch = " ",
              },
          },
          icons = {
              File          = "󰈙 ",
              Module        = " ",
              Namespace     = "󰌗 ",
              Package       = " ",
              Class         = "󰌗 ",
              Method        = "󰆧 ",
              Property      = " ",
              Field         = " ",
              Constructor   = " ",
              Enum          = "󰕘",
              Interface     = "󰕘",
              Function      = "󰊕 ",
              Variable      = "󰆧 ",
              Constant      = "󰏿 ",
              String        = " ",
              Number        = "󰎠 ",
              Boolean       = "◩ ",
              Array         = "󰅪 ",
              Object        = "󰅩 ",
              Key           = "󰌋 ",
              Null          = "󰟢 ",
              EnumMember    = " ",
              Struct        = "󰌗 ",
              Event         = " ",
              Operator      = "󰆕 ",
              TypeParameter = "󰊄 ",
          },
          use_default_mappings = true,            -- If set to false, only mappings set
                                                  -- by user are set. Else default
                                                  -- mappings are used for keys
                                                  -- that are not set by user
          mappings = {
              ["<esc>"] = actions.close(),        -- Close and cursor to original location
              ["q"] = actions.close(),
      
              ["j"] = actions.next_sibling(),     -- down
              ["k"] = actions.previous_sibling(), -- up
      
              ["h"] = actions.parent(),           -- Move to left panel
              ["l"] = actions.children(),         -- Move to right panel
              ["0"] = actions.root(),             -- Move to first panel
      
              ["v"] = actions.visual_name(),      -- Visual selection of name
              ["V"] = actions.visual_scope(),     -- Visual selection of scope
      
              ["y"] = actions.yank_name(),        -- Yank the name to system clipboard "+
              ["Y"] = actions.yank_scope(),       -- Yank the scope to system clipboard "+
      
              ["i"] = actions.insert_name(),      -- Insert at start of name
              ["I"] = actions.insert_scope(),     -- Insert at start of scope
      
              ["a"] = actions.append_name(),      -- Insert at end of name
              ["A"] = actions.append_scope(),     -- Insert at end of scope
      
              ["r"] = actions.rename(),           -- Rename currently focused symbol
      
              ["d"] = actions.delete(),           -- Delete scope
      
              ["f"] = actions.fold_create(),      -- Create fold of current scope
              ["F"] = actions.fold_delete(),      -- Delete fold of current scope
      
              ["c"] = actions.comment(),          -- Comment out current scope
      
              ["<enter>"] = actions.select(),     -- Goto selected symbol
              ["o"] = actions.select(),
      
              ["J"] = actions.move_down(),        -- Move focused node down
              ["K"] = actions.move_up(),          -- Move focused node up
      
              ["s"] = actions.toggle_preview(),   -- Show preview of current node
      
              ["<C-v>"] = actions.vsplit(),       -- Open selected node in a vertical split
              ["<C-s>"] = actions.hsplit(),       -- Open selected node in a horizontal split
      
              ["t"] = actions.telescope({         -- Fuzzy finder at current level.
                  layout_config = {               -- All options that can be
                      height = 0.60,              -- passed to telescope.nvim's
                      width = 0.60,               -- default can be passed here.
                      prompt_position = "top",
                      preview_width = 0.50
                  },
                  layout_strategy = "horizontal"
              }),
      
              ["g?"] = actions.help(),            -- Open mappings help window
          },
          lsp = {
              auto_attach = false,   -- If set to true, you don't need to manually use attach function
              preference = nil,      -- list of lsp server names in order of preference
          },
          source_buffer = {
              follow_node = true,    -- Keep the current node in focus on the source buffer
              highlight = true,      -- Highlight the currently focused node
              reorient = "smart",    -- "smart", "top", "mid" or "none"
              scrolloff = nil        -- scrolloff value when navbuddy is open
          },
      	custom_hl_group = nil,     -- "Visual" or any other hl group to use instead of inverted colors
      }
      
    end,
  },
  {
    "tamago324/nlsp-settings.nvim",
    config = function()
      
      local mason = require("mason")
      local mason_lspconfig = require("mason-lspconfig")
      local lspconfig = require("lspconfig")
      local nlspsettings = require("nlspsettings")
      
      nlspsettings.setup({
        config_home = vim.fn.stdpath('config') .. '/nlsp-settings',
        local_settings_dir = ".nlsp-settings",
        local_settings_root_markers_fallback = { '.git' },
        append_default_schemas = true,
        loader = 'json'
      })
      
      function on_attach(client, bufnr)
        local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end
        buf_set_option('omnifunc', 'v:lua.vim.lsp.omnifunc')
      end
      
      local global_capabilities = vim.lsp.protocol.make_client_capabilities()
      global_capabilities.textDocument.completion.completionItem.snippetSupport = true
      
      lspconfig.util.default_config = vim.tbl_extend("force", lspconfig.util.default_config, {
        capabilities = global_capabilities,
      })
      
      mason.setup()
      mason_lspconfig.setup()
      mason_lspconfig.setup_handlers({
        function (server_name)
          lspconfig[server_name].setup({
            on_attach = on_attach
          })
        end
      })
      
      
      local mason = require("mason")
      local mason_lspconfig = require("mason-lspconfig")
      local lspconfig = require("lspconfig")
      
      local server_opts = {}
      
      -- lua
      server_opts.sumneko_lua = {
        settings = {
          Lua = {
            workspace = {
              library = {
                [vim.fn.expand("$VIMRUNTIME/lua")] = true,
                [vim.fn.stdpath("config") .. '/lua'] = true,
              }
            }
          }
        }
      }
      
      local common_setup_opts = {
        -- on_attach = on_attach,
        -- capabilities = require('cmp_nvim_lsp').update_capabilities(
        --   vim.lsp.protocol.make_client_capabilities()
        -- )
      }
      
      mason.setup()
      mason_lspconfig.setup()
      mason_lspconfig.setup_handlers({
        function (server_name)
          local opts = vim.deepcopy(common_setup_opts)
          if server_opts[server_name] then
            opts = vim.tbl_deep_extend('force', opts, server_opts[server_name])
          end
          lspconfig[server_name].setup(opts)
        end
      })
      
    end,
  },
  {
    "jakewvincent/texmagic.nvim",
    config = function()
      
      use({'jakewvincent/texmagic.nvim',
           config = function()
              require('texmagic').setup({
                  -- Config goes here; leave blank for defaults
              })
           end
      })
      
      
      require('paq')({
          -- Your other plugins;
          'jakewvincent/texmagic.nvim';
          -- Your other plugins;
      })
      
      -- Include the setup function somewhere else in your init.lua file, or the
      -- plugin won't activate itself:
      require('texmagic').setup({
          -- Config goes here; leave blank for defaults
      })
      
      
      -- Only default build engines made available (pdflatex, xelatex, dvipspdf)
      require('texmagic').setup{}
      
      
      -- Run setup and specify two custom build engines
      require('texmagic').setup{
          engines = {
              pdflatex = {    -- This has the same name as a default engine but would
                              -- be preferred over the same-name default if defined
                  executable = "latexmk",
                  args = {
                      "-pdflatex",
                      "-interaction=nonstopmode",
                      "-synctex=1",
                      "-outdir=.build",
                      "-pv",
                      "%f"
                  },
                  isContinuous = false
              },
              lualatex = {    -- This is *not* one of the defaults, but it can be
                              -- called via magic comment if defined here
                  executable = "latexmk",
                  args = {
                      "-pdflua",
                      "-interaction=nonstopmode",
                      "-synctex=1",
                      "-pv",
                      "%f"
                  },
                  isContinuous = false
              }
          }
      }
      
      
      require('lspconfig').texlab.setup{
          cmd = {"texlab"},
          filetypes = {"tex", "bib"},
          settings = {
              texlab = {
                  rootDirectory = nil,
                  --      ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓
                  build = _G.TeXMagicBuildConfig,
                  --      ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑
                  forwardSearch = {
                      executable = "evince",
                      args = {"%p"}
                  }
              }
          }
      }
      
    end,
  },
  {
    "aznhe21/actions-preview.nvim",
    config = function()
      
      use {
        "aznhe21/actions-preview.nvim",
        config = function()
          vim.keymap.set({ "v", "n" }, "gf", require("actions-preview").code_actions)
        end,
      }
      
      
      require("actions-preview").setup {
        -- options for vim.diff(): https://neovim.io/doc/user/lua.html#vim.diff()
        diff = {
          ctxlen = 3,
        },
      
        -- priority list of external command to highlight diff
        -- disabled by defalt, must be set by yourself
        highlight_command = {
          -- require("actions-preview.highlight").delta(),
          -- require("actions-preview.highlight").diff_so_fancy(),
          -- require("actions-preview.highlight").diff_highlight(),
        },
      
        -- priority list of preferred backend
        backend = { "telescope", "minipick", "snacks", "nui" },
      
        -- options related to telescope.nvim
        telescope = vim.tbl_extend(
          "force",
          -- telescope theme: https://github.com/nvim-telescope/telescope.nvim#themes
          require("telescope.themes").get_dropdown(),
          -- a table for customizing content
          {
            -- a function to make a table containing the values to be displayed.
            -- fun(action: Action): { title: string, client_name: string|nil }
            make_value = nil,
      
            -- a function to make a function to be used in `display` of a entry.
            -- see also `:h telescope.make_entry` and `:h telescope.pickers.entry_display`.
            -- fun(values: { index: integer, action: Action, title: string, client_name: string }[]): function
            make_make_display = nil,
          }
        ),
      
        -- options for nui.nvim components
        nui = {
          -- component direction. "col" or "row"
          dir = "col",
          -- keymap for selection component: https://github.com/MunifTanjim/nui.nvim/tree/main/lua/nui/menu#keymap
          keymap = nil,
          -- options for nui Layout component: https://github.com/MunifTanjim/nui.nvim/tree/main/lua/nui/layout
          layout = {
            position = "50%",
            size = {
              width = "60%",
              height = "90%",
            },
            min_width = 40,
            min_height = 10,
            relative = "editor",
          },
          -- options for preview area: https://github.com/MunifTanjim/nui.nvim/tree/main/lua/nui/popup
          preview = {
            size = "60%",
            border = {
              style = "rounded",
              padding = { 0, 1 },
            },
          },
          -- options for selection area: https://github.com/MunifTanjim/nui.nvim/tree/main/lua/nui/menu
          select = {
            size = "40%",
            border = {
              style = "rounded",
              padding = { 0, 1 },
            },
          },
        },
      
        --- options for snacks picker
        ---@type snacks.picker.Config
        snacks = {
          layout = { preset = "default" },
        },
      }
      
      
      require("actions-preview").setup {
        diff = {
          algorithm = "patience",
          ignore_whitespace = true,
        },
        telescope = require("telescope.themes").get_dropdown { winblend = 10 },
      }
      
      
      local hl = require("actions-preview.highlight")
      require("actions-preview").setup {
        highlight_command = {
          -- Highlight diff using delta: https://github.com/dandavison/delta
          -- The argument is optional, in which case "delta" is assumed to be
          -- specified.
          hl.delta("path/to/delta --option1 --option2"),
          -- You may need to specify "--no-gitconfig" since it is dependent on
          -- the gitconfig of the project by default.
          -- hl.delta("delta --no-gitconfig --side-by-side"),
      
          -- Highlight diff using diff-so-fancy: https://github.com/so-fancy/diff-so-fancy
          -- The arguments are optional, in which case ("diff-so-fancy", "less -R")
          -- is assumed to be specified. The existence of less is optional.
          hl.diff_so_fancy("path/to/diff-so-fancy --option1 --option2"),
      
          -- Highlight diff using diff-highlight included in git-contrib.
          -- The arguments are optional; the first argument is assumed to be
          -- "diff-highlight" and the second argument is assumed to be 
          -- `{ colordiff = "colordiff", pager = "less -R" }`. The existence of
          -- colordiff and less is optional.
          hl.diff_highlight(
            "path/to/diff-highlight",
            { colordiff = "path/to/colordiff" }
          ),
      
          -- And, you can use any command to highlight diff.
          -- Define the pipeline by `hl.commands`.
          hl.commands({
            { cmd = "command-to-diff-highlight" },
            -- `optional` can be used to define that the command is optional.
            { cmd = "less -R", optional = true },
          }),
          -- If you use optional `less -R` (or similar command), you can also use `hl.with_pager`.
          hl.with_pager("command-to-diff-highlight"),
          -- hl.with_pager("command-to-diff-highlight", "custom-pager"),
      
          -- Functions can also be specified for items. Functions are executed during setup.
          -- This is useful for `require(...)` at definition time, such as in lazy.nvim.
          function()
              return require("actions-preview.highlight").delta()
          end,
        },
      }
      
      
      require("actions-preview").setup {
        telescope = {
          sorting_strategy = "ascending",
          layout_strategy = "vertical",
          layout_config = {
            width = 0.8,
            height = 0.9,
            prompt_position = "top",
            preview_cutoff = 20,
            preview_height = function(_, _, max_lines)
              return max_lines - 15
            end,
          },
        },
      }
      
    end,
  },
  {
    "mfussenegger/nvim-lint",
    config = function()
      
      require('lint').linters_by_ft = {
        markdown = {'vale'},
      }
      
      
      vim.api.nvim_create_autocmd({ "BufWritePost" }, {
        callback = function()
      
          -- try_lint without arguments runs the linters defined in `linters_by_ft`
          -- for the current filetype
          require("lint").try_lint()
      
          -- You can call `try_lint` with a linter name or a list of names to always
          -- run specific linters, independent of the `linters_by_ft` configuration
          require("lint").try_lint("cspell")
        end,
      })
      
      
      require('lint').linters.your_linter_name = {
        cmd = 'linter_cmd',
        stdin = true, -- or false if it doesn't support content input via stdin. In that case the filename is automatically added to the arguments.
        append_fname = true, -- Automatically append the file name to `args` if `stdin = false` (default: true)
        args = {}, -- list of arguments. Can contain functions with zero arguments that will be evaluated once the linter is used.
        stream = nil, -- ('stdout' | 'stderr' | 'both') configure the stream to which the linter outputs the linting result.
        ignore_exitcode = false, -- set this to true if the linter exits with a code != 0 and that's considered normal.
        env = nil, -- custom environment table to use with the external process. Note that this replaces the *entire* environment, it is not additive.
        parser = your_parse_function
      }
      
      
      env = { ["FOO"] = "bar" }
      
      
      parser = require("lint.parser").for_sarif()
      
      
      parser = require('lint.parser').from_errorformat(errorformat)
      
      
      parser = require('lint.parser').from_pattern(pattern, groups, severity_map, defaults, opts)
      
      
      local pattern = '[^:]+:(%d+):(%d+):(%w+):(.+)'
      local groups = { 'lnum', 'col', 'code', 'message' }
      
      
      defaults = {["source"] = "mylint-name"}
      
      
      local phpcs = require('lint').linters.phpcs
      phpcs.args = {
        '-q',
        -- <- Add a new parameter here
        '--report=json',
        '-'
      }
      
      
      local original = require("lint").linters.terraform_validate
      require("lint").linters.terraform_validate = function()
        local linter = original()
        linter.cmd = "my_custom"
        return linter
      end
      
      
      local lint = require("lint")
      lint.linters.cspell = require("lint.util").wrap(lint.linters.cspell, function(diagnostic)
        diagnostic.severity = vim.diagnostic.severity.HINT
        return diagnostic
      end)
      
      
      local ns = require("lint").get_namespace("my_linter_name")
      vim.diagnostic.config({ virtual_text = true }, ns)
      
      
      local lint_progress = function()
        local linters = require("lint").get_running()
        if #linters == 0 then
            return "󰦕"
        end
        return "󱉶 " .. table.concat(linters, ", ")
      end
      
    end,
  },
  {
    "b0o/SchemaStore.nvim",
    config = function()
      
        "b0o/schemastore.nvim",
      
      
      use "b0o/schemastore.nvim"
      
      
      require('lspconfig').jsonls.setup {
        settings = {
          json = {
            schemas = require('schemastore').json.schemas(),
            validate = { enable = true },
          },
        },
      }
      
      
      require('lspconfig').yamlls.setup {
        settings = {
          yaml = {
            schemaStore = {
              -- You must disable built-in schemaStore support if you want to use
              -- this plugin and its advanced options like `ignore`.
              enable = false,
              -- Avoid TypeError: Cannot read properties of undefined (reading 'length')
              url = "",
            },
            schemas = require('schemastore').yaml.schemas(),
          },
        },
      }
      
      
      require('lspconfig').jsonls.setup {
        settings = {
          json = {
            schemas = require('schemastore').json.schemas {
              select = {
                '.eslintrc',
                'package.json',
              },
            },
            validate = { enable = true },
          },
        },
      }
      
      
      require('lspconfig').jsonls.setup {
        settings = {
          json = {
            schemas = require('schemastore').json.schemas {
              ignore = {
                '.eslintrc',
                'package.json',
              },
            },
            validate = { enable = true },
          },
        },
      }
      
      
      require('lspconfig').jsonls.setup {
        settings = {
          json = {
            schemas = require('schemastore').json.schemas {
              replace = {
                ['package.json'] = {
                  description = 'package.json overridden',
                  fileMatch = { 'package.json' },
                  name = 'package.json',
                  url = 'https://example.com/package.json',
                },
              },
            },
            validate = { enable = true },
          },
        },
      }
      
      
      require('lspconfig').jsonls.setup {
        settings = {
          json = {
            schemas = require('schemastore').json.schemas {
              extra = {
                {
                  description = 'My custom JSON schema',
                  fileMatch = 'foo.json',
                  name = 'foo.json',
                  url = 'https://example.com/schema/foo.json',
                },
                {
                  description = 'My other custom JSON schema',
                  fileMatch = { 'bar.json', '.baar.json' },
                  name = 'bar.json',
                  url = 'https://example.com/schema/bar.json',
                },
              },
            },
            validate = { enable = true },
          },
        },
      }
      
      
      require("schemastore").json.schemas({
        extra = {
          {
            description = "Local JSON schema",
            fileMatch = "local.json",
            name = "local.json",
            url = "file:///path/to/your/schema.json", -- or '/path/to/your/schema.json'
          },
        },
      })
      
    end,
  },
  {
    "ldelossa/litee.nvim",
  },
  {
    "j-hui/fidget.nvim",
    config = function()
      
      local fidget = require("fidget")
      
      vim.keymap.set("n", "A", function()
        fidget.notify("This is from fidget.notify().")
      end)
      
      vim.keymap.set("n", "B", function()
        fidget.notify("This is also from fidget.notify().", vim.log.levels.WARN)
      end)
      
      vim.keymap.set("n", "C", function()
        fidget.notify("fidget.notify() supports annotations...", nil, { annote = "MY NOTE", key = "foobar" })
      end)
      
      vim.keymap.set("n", "D", function()
        fidget.notify(nil, vim.log.levels.ERROR, { annote = "bottom text", key = "foobar" })
        fidget.notify("... and overwriting notifications.", vim.log.levels.WARN, { annote = "YOUR AD HERE" })
      end)
      
      
      {
        "j-hui/fidget.nvim",
        opts = {
          -- options
        },
      }
      
      
      {
        "j-hui/fidget.nvim",
        tag = "*", -- alternatively, pin this to a specific version, e.g., "v1.6.1"
        opts = {
          -- options
        },
      }
      
      
      {
        -- Options related to LSP progress subsystem
        progress = {
          poll_rate = 0,                -- How and when to poll for progress messages
          suppress_on_insert = false,   -- Suppress new messages while in insert mode
          ignore_done_already = false,  -- Ignore new tasks that are already complete
          ignore_empty_message = false, -- Ignore new tasks that don't contain a message
          clear_on_detach =             -- Clear notification group when LSP server detaches
            function(client_id)
              local client = vim.lsp.get_client_by_id(client_id)
              return client and client.name or nil
            end,
          notification_group =          -- How to get a progress message's notification group key
            function(msg) return msg.lsp_client.name end,
          ignore = {},                  -- List of LSP servers to ignore
      
          -- Options related to how LSP progress messages are displayed as notifications
          display = {
            render_limit = 16,          -- How many LSP messages to show at once
            done_ttl = 3,               -- How long a message should persist after completion
            done_icon = "✔",            -- Icon shown when all LSP progress tasks are complete
            done_style = "Constant",    -- Highlight group for completed LSP tasks
            progress_ttl = math.huge,   -- How long a message should persist when in progress
            progress_icon =             -- Icon shown when LSP progress tasks are in progress
              { "dots" },
            progress_style =            -- Highlight group for in-progress LSP tasks
              "WarningMsg",
            group_style = "Title",      -- Highlight group for group name (LSP server name)
            icon_style = "Question",    -- Highlight group for group icons
            priority = 30,              -- Ordering priority for LSP notification group
            skip_history = true,        -- Whether progress notifications should be omitted from history
            format_message =            -- How to format a progress message
              require("fidget.progress.display").default_format_message,
            format_annote =             -- How to format a progress annotation
              function(msg) return msg.title end,
            format_group_name =         -- How to format a progress notification group's name
              function(group) return tostring(group) end,
            overrides = {               -- Override options from the default notification config
              rust_analyzer = { name = "rust-analyzer" },
            },
          },
      
          -- Options related to Neovim's built-in LSP client
          lsp = {
            progress_ringbuf_size = 0,  -- Configure the nvim's LSP progress ring buffer size
            log_handler = false,        -- Log `$/progress` handler invocations (for debugging)
          },
        },
      
        -- Options related to notification subsystem
        notification = {
          poll_rate = 10,               -- How frequently to update and render notifications
          filter = vim.log.levels.INFO, -- Minimum notifications level
          history_size = 128,           -- Number of removed messages to retain in history
          override_vim_notify = false,  -- Automatically override vim.notify() with Fidget
          configs =                     -- How to configure notification groups when instantiated
            { default = require("fidget.notification").default_config },
          redirect =                    -- Conditionally redirect notifications to another backend
            function(msg, level, opts)
              if opts and opts.on_open then
                return require("fidget.integration.nvim-notify").delegate(msg, level, opts)
              end
            end,
      
          -- Options related to how notifications are rendered as text
          view = {
            stack_upwards = true,       -- Display notification items from bottom to top
            align = "message",          -- Indent messages longer than a single line
            reflow = false,             -- Reflow (wrap) messages wider than notification window
            icon_separator = " ",       -- Separator between group name and icon
            group_separator = "---",    -- Separator between notification groups
            group_separator_hl =        -- Highlight group used for group separator
              "Comment",
            line_margin = 1,            -- Spaces to pad both sides of each non-empty line
            render_message =            -- How to render notification messages
              function(msg, cnt)
                return cnt == 1 and msg or string.format("(%dx) %s", cnt, msg)
              end,
          },
      
          -- Options related to the notification window and buffer
          window = {
            normal_hl = "Comment",      -- Base highlight group in the notification window
            winblend = 100,             -- Background color opacity in the notification window
            border = "none",            -- Border around the notification window
            zindex = 45,                -- Stacking priority of the notification window
            max_width = 0,              -- Maximum width of the notification window
            max_height = 0,             -- Maximum height of the notification window
            x_padding = 1,              -- Padding from right edge of window boundary
            y_padding = 0,              -- Padding from bottom edge of window boundary
            align = "bottom",           -- How to align the notification window
            relative = "editor",        -- What the notification window position is relative to
            tabstop = 8,                -- Width of each tab character in the notification window
            avoid = {}                  -- Filetypes the notification window should avoid
                                        -- e.g., { "aerial", "NvimTree", "neotest-summary" }
          },
        },
      
        -- Options related to integrating with other plugins
        integration = {
          ["nvim-tree"] = {
            enable = true,              -- Integrate with nvim-tree/nvim-tree.lua (if installed)
                                        -- DEPRECATED; use notification.window.avoid = { "NvimTree" }
          },
          ["xcodebuild-nvim"] = {
            enable = true,              -- Integrate with wojciech-kulik/xcodebuild.nvim (if installed)
                                        -- DEPRECATED; use notification.window.avoid = { "TestExplorer" }
          },
        },
      
        -- Options related to logging
        logger = {
          level = vim.log.levels.WARN,  -- Minimum logging level
          max_size = 10000,             -- Maximum log file size, in KB
          float_precision = 0.01,       -- Limit the number of decimals displayed for floats
          path =                        -- Where Fidget writes its logs to
            string.format("%s/fidget.nvim.log", vim.fn.stdpath("cache")),
        },
      }
      
      
      require("telescope").load_extension("fidget")
      
      
      require("telescope").extensions.fidget.fidget()
      
    end,
  },
  {
    "scalameta/nvim-metals",
    config = function()
      
      {
        "scalameta/nvim-metals",
        ft = { "scala", "sbt", "java" },
        opts = function()
          local metals_config = require("metals").bare_config()
          metals_config.on_attach = function(client, bufnr)
            -- your on_attach function
          end
      
          return metals_config
        end,
        config = function(self, metals_config)
          local nvim_metals_group = vim.api.nvim_create_augroup("nvim-metals", { clear = true })
          vim.api.nvim_create_autocmd("FileType", {
            pattern = self.ft,
            callback = function()
              require("metals").initialize_or_attach(metals_config)
            end,
            group = nvim_metals_group,
          })
        end
      }
      
    end,
  },
  {
    "junnplus/lsp-setup.nvim",
    config = function()
      
      require('lsp-setup').setup({
        servers = {
          pylsp = {},
          clangd = {}
        }
      })
      
      
      require('lsp-setup').setup({
        servers = {
          ['rust_analyzer@nightly'] = {}
        }
      })
      
      
      require('lsp-setup').setup({
        inlay_hints = {
          enabled = true,
        }
      })
      
      
      require('lsp-setup').setup({
        servers = {
          tsserver = {
            settings = {
              typescript = {
                inlayHints = {
                  includeInlayParameterNameHints = 'all',
                  includeInlayParameterNameHintsWhenArgumentMatchesName = false,
                  includeInlayFunctionParameterTypeHints = true,
                  includeInlayVariableTypeHints = true,
                  includeInlayVariableTypeHintsWhenTypeMatchesName = false,
                  includeInlayPropertyDeclarationTypeHints = true,
                  includeInlayFunctionLikeReturnTypeHints = true,
                  includeInlayEnumMemberValueHints = true,
                }
              }
            }
          }
        }
      })
      
      
      require('lsp-setup').setup({
        servers = {
          volar = {
            settings = {
              typescript = {
                inlayHints = {
                  enumMemberValues = {
                    enabled = true,
                  },
                  functionLikeReturnTypes = {
                    enabled = true,
                  },
                  propertyDeclarationTypes = {
                    enabled = true,
                  },
                  parameterTypes = {
                    enabled = true,
                    suppressWhenArgumentMatchesName = true,
                  },
                  variableTypes = {
                    enabled = true,
                  }
                }
              }
            }
          }
        }
      })
      
      
      require('lsp-setup').setup({
        servers = {
          gopls = {
            settings = {
              gopls = {
                hints = {
                  rangeVariableTypes = true,
                  parameterNames = true,
                  constantValues = true,
                  assignVariableTypes = true,
                  compositeLiteralFields = true,
                  compositeLiteralTypes = true,
                  functionTypeParameters = true,
                }
              }
            }
          }
        }
      })
      
      
      require('lsp-setup').setup({
        servers = {
          rust_analyzer = {
            settings = {
              ['rust-analyzer'] = {
                inlayHints = {
                  bindingModeHints = {
                    enable = false,
                  },
                  chainingHints = {
                    enable = true,
                  },
                  closingBraceHints = {
                    enable = true,
                    minLines = 25,
                  },
                  closureReturnTypeHints = {
                    enable = 'never',
                  },
                  lifetimeElisionHints = {
                    enable = 'never',
                    useParameterNames = false,
                  },
                  maxLength = 25,
                  parameterHints = {
                    enable = true,
                  },
                  reborrowHints = {
                    enable = 'never',
                  },
                  renderColons = true,
                  typeHints = {
                    enable = true,
                    hideClosureInitialization = false,
                    hideNamedConstructor = false,
                  }
                }
              }
            }
          }
        }
      })
      
      
      require('lsp-setup').setup({
        servers = {
          lua_ls = {
            settings = {
              Lua = {
                hint = {
                  enable = false,
                  arrayIndex = "Auto",
                  await = true,
                  paramName = "All",
                  paramType = true,
                  semicolon = "SameLine",
                  setType = false,
                },
              },
            },
          },
        }
      })
      
      
      require('lsp-setup').setup({
        servers = {
          zls = {
            settings = {
              zls = {
                enable_inlay_hints = true,
                inlay_hints_show_builtin = true,
                inlay_hints_exclude_single_argument = true,
                inlay_hints_hide_redundant_param_names = false,
                inlay_hints_hide_redundant_param_names_last_token = false,
              }
            }
          },
        }
      })
      
      
      require('lsp-setup').setup({
        -- Default mappings
        -- gD = { cmd = vim.lsp.buf.declaration, opts = { desc = 'Go To Declaration' } },
        -- gd = { cmd = vim.lsp.buf.definition, opts = { desc = 'Go To Definition' } },
        -- gi = { cmd = vim.lsp.buf.implementation, opts = { desc = 'Go To Implementation' } },
        -- gr = { cmd = vim.lsp.buf.references, opts = { desc = 'Go To References' } },
        -- K = { cmd = vim.lsp.buf.hover, opts = { desc = 'Hover' } },
        -- ['<C-k>'] = { cmd = vim.lsp.buf.signature_help, opts = { desc = 'Show Signature Help' } },
        -- ['<space>rn'] = { cmd = vim.lsp.buf.rename, opts = { desc = 'Rename' } },
        -- ['<space>ca'] = { cmd = vim.lsp.buf.code_action, opts = { desc = 'Code Action' } },
        -- ['<space>f'] = { cmd = vim.lsp.buf.formatting, opts = { desc = 'Format' } },
        -- ['<space>e'] = { cmd = vim.diagnostic.open_float, opts = { desc = 'Show Diagnostics' } },
        -- ['[d'] = { cmd = function() vim.diagnostic.jump({ count = -1, float = true }) end, opts = { desc = 'Prev Diagnostic' } },
        -- [']d'] = { cmd = function() vim.diagnostic.jump({ count = 1, float = true }) end, opts = { desc = 'Next Diagnostic' } },
        default_mappings = true,
        -- Custom mappings, will overwrite the default mappings for the same key
        -- Example mappings for telescope pickers:
        -- gd = 'lua require"telescope.builtin".lsp_definitions()',
        -- gi = 'lua require"telescope.builtin".lsp_implementations()',
        -- gr = 'lua require"telescope.builtin".lsp_references()',
        mappings = {},
        -- Global on_attach
        on_attach = function(client, bufnr)
          -- Support custom the on_attach function for global
          -- Formatting on save as default
          require('lsp-setup.utils').format_on_save(client)
        end,
        -- Global capabilities
        capabilities = vim.lsp.protocol.make_client_capabilities(),
        -- Configuration of LSP servers 
        servers = {
          -- Install LSP servers automatically (requires mason and mason-lspconfig)
          -- LSP server configuration please see: https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md
          -- pylsp = {},
          -- rust_analyzer = {
          --   settings = {
          --     ['rust-analyzer'] = {
          --       cargo = {
          --         loadOutDirsFromCheck = true,
          --       },
          --       procMacro = {
          --         enable = true,
          --       },
          --     },
          --   },
          -- },
        },
        -- Configuration of LSP inlay hints
        inlay_hints = {
          enabled = false,
          highlight = 'Comment',
        }
      })
      
      
      -- Setup lua_ls with lazydev
      require('lazydev').setup()
      require('lsp-setup').setup({
        servers = {
          lua_ls = {}
        }
      })
      
      
      require('lsp-setup').setup({
        servers = {
          rust_analyzer = function()
            require('rust-tools').setup({
              server = {
                settings = {
                  ['rust-analyzer'] = {
                    cargo = {
                      loadOutDirsFromCheck = true,
                    },
                    procMacro = {
                      enable = true,
                    },
                  },
                },
              },
            })
            -- no need to return anything
          end,
        }
      })
      
    end,
  },
  {
    "amrbashir/nvim-docs-view",
    config = function()
      
      use {
        "amrbashir/nvim-docs-view",
        opt = true,
        cmd = { "DocsViewToggle" },
        config = function()
          require("docs-view").setup {
            position = "right",
            width = 60,
          }
        end
      }
      
      
      {
        "amrbashir/nvim-docs-view",
        lazy = true,
        cmd = "DocsViewToggle",
        opts = {
          position = "right",
          width = 60
        }
      }
      
    end,
  },
  {
    "roobert/hoversplit.nvim",
      
      {
        "roobert/hoversplit.nvim",
        config = function()
          require("hoversplit").setup()
        end
      },
      
      
      {
        "roobert/hoversplit.nvim",
        config = function()
          require("hoversplit").setup({
            key_bindings = {
              split_remain_focused = "<leader>hs",
              vsplit_remain_focused = "<leader>hv",
              split = "<leader>hS",
              vsplit = "<leader>hV",
            },
          })
        end,
      }
      
  },
  {
    "mfussenegger/nvim-jdtls",
    config = function()
      
      vim.lsp.enable("jdtls")
      
      
      vim.lsp.config("jdtls", {
        settings = {
          java = {
              -- Custom eclipse.jdt.ls options go here
          },
        },
      })
      vim.lsp.enable("jdtls")
      
      
      -- See `:help vim.lsp.start` for an overview of the supported `config` options.
      local config = {
        name = "jdtls",
      
      
        -- `cmd` defines the executable to launch eclipse.jdt.ls.
        -- `jdtls` must be available in $PATH and you must have Python3.9 for this to work.
        --
        -- As alternative you could also avoid the `jdtls` wrapper and launch
        -- eclipse.jdt.ls via the `java` executable
        -- See: https://github.com/eclipse/eclipse.jdt.ls#running-from-the-command-line
        cmd = {"jdtls"},
      
      
        -- `root_dir` must point to the root of your project.
        -- See `:help vim.fs.root`
        root_dir = vim.fs.root(0, {'gradlew', '.git', 'mvnw'}),
      
      
        -- Here you can configure eclipse.jdt.ls specific settings
        -- See https://github.com/eclipse/eclipse.jdt.ls/wiki/Running-the-JAVA-LS-server-from-the-command-line#initialize-request
        -- for a list of options
        settings = {
          java = {
          }
        },
      
      
        -- This sets the `initializationOptions` sent to the language server
        -- If you plan on using additional eclipse.jdt.ls plugins like java-debug
        -- you'll need to set the `bundles`
        --
        -- See https://codeberg.org/mfussenegger/nvim-jdtls#java-debug-installation
        --
        -- If you don't plan on any eclipse.jdt.ls plugins you can remove this
        init_options = {
          bundles = {}
        },
      }
      require('jdtls').start_or_attach(config)
      
      
      -- If you started neovim within `~/dev/xy/project-1` this would resolve to `project-1`
      local project_name = vim.fn.fnamemodify(vim.fn.getcwd(), ':p:h:t')
      
      local workspace_dir = '/path/to/workspace-root/' .. project_name
      --                                               ^^
      --                                               string concattenation in Lua
      
      local config = {
        cmd = {
          '-data', workspace_dir
        }
      }
      
      
      require'jdtls'.test_class()
      require'jdtls'.test_nearest_method()
      
      
      local bundles = {
        vim.fn.glob("path/to/com.microsoft.java.debug.plugin-*.jar", 1)
      }
      config['init_options'] = {
        bundles = bundles
      }
      
      
      
      -- This bundles definition is the same as in the previous section (java-debug installation)
      local bundles = {
        vim.fn.glob("path/to/com.microsoft.java.debug.plugin-*.jar", 1)
      }
      
      
      -- This is the new part
      local java_test_bundles = vim.split(vim.fn.glob("/path/to/vscode-java-test/server/*.jar", 1), "\n")
      local excluded = {
        "com.microsoft.java.test.runner-jar-with-dependencies.jar",
        "jacocoagent.jar",
      }
      for _, java_test_jar in ipairs(java_test_bundles) do
        local fname = vim.fn.fnamemodify(java_test_jar, ":t")
        if not vim.tbl_contains(excluded, fname) then
          table.insert(bundles, java_test_jar)
        end
      end
      -- End of the new part
      
      
      config['init_options'] = {
        bundles = bundles;
      }
      
      
      local config = {
        ..., -- not valid Lua, this is a placeholder for your other properties.
        settings = {
          java = {
            configuration = {
              -- See https://github.com/eclipse/eclipse.jdt.ls/wiki/Running-the-JAVA-LS-server-from-the-command-line#initialize-request
              -- And search for `interface RuntimeOption`
              -- The `name` is NOT arbitrary, but must match one of the elements from `enum ExecutionEnvironment` in the link above
              runtimes = {
                {
                  name = "JavaSE-11",
                  path = "/usr/lib/jvm/java-11-openjdk/",
                },
                {
                  name = "JavaSE-17",
                  path = "/usr/lib/jvm/java-17-openjdk/",
                },
              }
            }
          }
        }
      }
      
      
      config.settings = {
          java = {
            project = {
              referencedLibraries = {
                '/path/to/dependencyA.jar',
                '/path/to/dependencyB.jar',
              },
            }
          }
        }
      
    end,
  },
  {
    "Kasama/nvim-custom-diagnostic-highlight",
    config = function()
      
      -- Packer
      use {
        'Kasama/nvim-custom-diagnostic-highlight',
        config = function()
          require('nvim-custom-diagnostic-highlight').setup {}
        end
      }
      
      -- Plug
      Plug 'Kasama/nvim-custom-diagnostic-highlight'
      require('nvim-custom-diagnostic-highlight').setup {}
      
      -- ...etc
      
      
      local final_opts = {
        register_handler = true,                                    -- Wether to register the handler automatically
        handler_name = 'kasama/nvim-custom-diagnostic-highlight',   -- The name of the handler to be registered (has no effect if register_handler = false)
        highlight_group = 'Conceal',                                -- The Highlight group to set at the diagnostic
        patterns_override = {                                       -- Lua patterns to be tested against the diagnostic message. Overrides default behavior
          '%sunused', '^unused', 'not used', 'never used',
          'not read', 'never read', 'empty block', 'not accessed'
        },
        extra_patterns = {},                                        -- Extra lua patterns to add. Does NOT override and will be added to the above
        diagnostic_handler_namespace = 'unused_hl_ns',              -- Name of the handler namespace that will contain the highlight (needs to be unique)
        defer_until_n_lines_away = false,                           -- If set to a number, then highlighting is deferred until the cursor is N lines away from
                                                                    -- diagnostics. Useful to avoid unwanted highlights in the currently edited position.
        defer_highlight_update_events = {'CursorHold', 'CursorHoldI'}, -- Events on which deferred highlights will be updated (passed to nvim_create_autocmd)
      }
      
      
      local unused_handler = require('nvim-custom-diagnostic-highlight').setup {
        register_handler = false,
        diagnostic_handler_namespace = 'unused_handler'
      }
      local import_handler = require('nvim-custom-diagnostic-highlight').setup {
        register_handler = false,
        highlight_group = 'MyCustomHighlightGroup',
        patterns_override = { 'import' },
        diagnostic_handler_namespace = 'import_handler'
      }
      
      vim.cmd [[highlight MyCustomHighlightGroup ctermfg=168 ctermbg=16 guifg=#e06c75 guibg=#282c34]]
      
      vim.diagnostic.handlers['my/unused'] = unused_handler
      vim.diagnostic.handlers['my/import'] = import_handler
      
    end,
  },
  {
    "mrcjkb/haskell-tools.nvim",
    config = function()
      
      {
        'mrcjkb/haskell-tools.nvim',
        version = '^6', -- Recommended
        lazy = false, -- This plugin is already lazy
      }
      
      
      -- ~/.config/nvim/after/ftplugin/haskell.lua
      local ht = require('haskell-tools')
      local bufnr = vim.api.nvim_get_current_buf()
      local opts = { noremap = true, silent = true, buffer = bufnr, }
      -- haskell-language-server relies heavily on codeLenses,
      -- so auto-refresh (see advanced configuration) is enabled by default
      vim.keymap.set('n', '<space>cl', vim.lsp.codelens.run, opts)
      -- Hoogle search for the type signature of the definition under the cursor
      vim.keymap.set('n', '<space>hs', ht.hoogle.hoogle_signature, opts)
      -- Evaluate all code snippets
      vim.keymap.set('n', '<space>ea', ht.lsp.buf_eval_all, opts)
      -- Toggle a GHCi repl for the current package
      vim.keymap.set('n', '<leader>rr', ht.repl.toggle, opts)
      -- Toggle a GHCi repl for the current buffer
      vim.keymap.set('n', '<leader>rf', function()
        ht.repl.toggle(vim.api.nvim_buf_get_name(0))
      end, opts)
      vim.keymap.set('n', '<leader>rq', ht.repl.quit, opts)
      
      
      require('haskell-tools').hoogle.hoogle_signature()
      
      
      vim.keymap.set('n', '<space>a', '<Plug>HaskellHoverAction')
      
      
      vim.g.haskell_tools = {
        ---@type haskell-tools.tools.Opts
        tools = {
          -- ...
        },
        ---@type haskell-tools.lsp.ClientOpts
        ---You can also configure these via `:h vim.lsp.config`,
        --- with the "haskell-tools" key.
        hls = {
          ---@param client number The LSP client ID.
          ---@param bufnr number The buffer number
          ---@param ht HaskellTools = require('haskell-tools')
          on_attach = function(client, bufnr, ht)
            -- Set keybindings, etc. here.
          end,
          -- ...
        },
        ---@type haskell-tools.dap.Opts
        dap = {
          -- ...
        },
      }
      
      
      vim.g.haskell_tools = {
        -- ...
        hls = {
          ---@param project_root string Path to the project root
          settings = function(project_root)
            local ht = require('haskell-tools')
            return ht.lsp.load_hls_settings(project_root, {
              settings_file_pattern = 'hls.json'
            })
          end,
        },
      }
      
      
      hls = {
        settings = {
          haskell = {
            plugin = {
              class = { -- missing class methods
                codeLensOn = false,
              },
              importLens = { -- make import lists fully explicit
                codeLensOn = false,
              },
              refineImports = { -- refine imports
                codeLensOn = false,
              },
              tactics = { -- wingman
                codeLensOn = false,
              },
              moduleName = { -- fix module names
                globalOn = false,
              },
              eval = { -- evaluate code snippets
                globalOn = false,
              },
              ['ghcide-type-lenses'] = { -- show/add missing type signatures
                globalOn = false,
              },
            },
          },
        },
      },
      
      
      local iron = require("iron.core")
      iron.setup {
        config = {
          repl_definition = {
            haskell = {
              command = function(meta)
                local file = vim.api.nvim_buf_get_name(meta.current_bufnr)
                -- call `require` in case iron is set up before haskell-tools
                return require('haskell-tools').repl.mk_repl_cmd(file)
              end,
            },
          },
        },
      }
      
      
      local ht = require('haskell-tools')
      --- Start or attach the LSP client.
      ht.lsp.start()
      
      --- Stop the LSP client.
      ht.lsp.stop()
      
      --- Restart the LSP client.
      ht.lsp.restart()
      
      --- Callback for dynamically loading haskell-language-server settings
      --- Falls back to the `hls.default_settings` if no file is found
      --- or one is found, but it cannot be read or decoded.
      --- @param project_root string? The project root
      ht.lsp.load_hls_settings(project_root)
      
      --- Evaluate all code snippets in comments
      ht.lsp.buf_eval_all()
      
      
      local ht = require('haskell-tools')
      --- Run a hoogle signature search for the value under the cursor
      ht.hoogle.hoogle_signature()
      
      
      local ht = require('haskell-tools')
      --- Toggle a GHCi repl for the current project
      ht.repl.toggle()
      
      --- Toggle a GHCi repl for `file`
      --- @param file string Path to a Haskell file
      ht.repl.toggle(file)
      
      --- Quit the repl
      ht.repl.quit()
      
      --- Paste a command to the repl from register `reg`.
      --- @param reg string? Register to paste from (:h registers), defaults to '"'.
      ht.repl.paste(reg)
      
      --- Query the repl for the type of register `reg`, and paste it to the repl.
      --- @param reg string? Register to paste from (:h registers), defaults to '"'.
      ht.repl.paste_type(reg)
      
      --- Query the repl for the type of word under the cursor
      ht.repl.cword_type()
      
      --- Query the repl for info on register `reg`.
      --- @param reg string? Register to paste from (:h registers), defaults to '"'.
      ht.repl.paste_info(reg)
      
      --- Query the repl for info on the word under the cursor
      ht.repl.cword_info()
      
      --- Load a file into the repl
      --- @param file string The absolute file path
      ht.repl.load_file(file)
      
      --- Reload the repl
      ht.repl.reload()
      
      
      local ht = require('haskell-tools')
      --- Open the project file for the current buffer (cabal.project or stack.yaml)
      ht.project.open_project_file()
      
      --- Open the package.yaml file for the current buffer
      ht.project.open_package_yaml()
      
      --- Open the *.cabal file for the current buffer
      ht.project.open_package_cabal()
      
      --- Search for files within the current (sub)package
      --- @param opts table Optional telescope.nvim `find_files` options
      ht.project.telescope_package_files(opts)
      --- Live grep within the current (sub)package
      --- @param opts table Optional telescope.nvim `live_grep` options
      ht.project.telescope_package_grep(opts)
      
      
      local ht = require('haskell-tools')
      
      -- Generate tags for the whole project
      ---@param path string? An optional file path, defaults to the current buffer
      ---@param opts table Optional options:
      ---       opts.refresh boolean
      ---       - Whether to refresh tags if they have already been generated for a project
      ht.tags.generate_project_tags(path, opts)
      
      -- Generate tags for the whole project
      ---@param path string? An optional file path, defaults to the current buffer
      ht.tags.generate_package_tags(path)
      
      
      local ht = require('haskell-tools')
      
      ---@param bufnr integer The buffer number
      ---@param opts table? Optional
      ---@param opts.autodetect: (boolean)
      --- Whether to auto-detect launch configurations
      ---@param opts.settings_file_pattern: (string)
      --- File name or pattern to search for. Defaults to 'launch.json'
      ht.dap.discover_configurations(bufnr, opts)
      
      
      require('telescope').load_extension('ht')
      
      
      vim.g.haskell_tools = {
        tools = { -- haskell-tools options
          log = {
            level = vim.log.levels.DEBUG,
          },
        },
      }
      
      
      :lua require('haskell-tools').log.set_level(vim.log.levels.DEBUG)
      
      
      -- haskell-tools.nvim log
      :lua =require('haskell-tools').log.get_logfile()
      -- haskell-language-server logs
      :lua =require('haskell-tools').log.get_hls_logfile()
      
      
      :lua require('haskell-tools').log.nvim_open_logfile() -- or :Haskell log openLog
      :lua require('haskell-tools').log.nvim_open_hls_logfile() -- or :Haskell log openHlsLog
      
    end,
  },
  {
    "p00f/clangd_extensions.nvim",
    config = function()
      
      require("clangd_extensions").setup({
          ast = {
              -- These are unicode, should be available in any font
              role_icons = {
                  type = "🄣",
                  declaration = "🄓",
                  expression = "🄔",
                  statement = ";",
                  specifier = "🄢",
                  ["template argument"] = "🆃",
              },
              kind_icons = {
                  Compound = "🄲",
                  Recovery = "🅁",
                  TranslationUnit = "🅄",
                  PackExpansion = "🄿",
                  TemplateTypeParm = "🅃",
                  TemplateTemplateParm = "🅃",
                  TemplateParamObject = "🅃",
              },
              --[[ These require codicons (https://github.com/microsoft/vscode-codicons)
                  role_icons = {
                      type = "",
                      declaration = "",
                      expression = "",
                      specifier = "",
                      statement = "",
                      ["template argument"] = "",
                  },
      
                  kind_icons = {
                      Compound = "",
                      Recovery = "",
                      TranslationUnit = "",
                      PackExpansion = "",
                      TemplateTypeParm = "",
                      TemplateTemplateParm = "",
                      TemplateParamObject = "",
                  }, ]]
      
              highlights = {
                  detail = "Comment",
              },
          },
          memory_usage = {
              border = "none",
          },
          symbol_info = {
              border = "none",
          },
      })
      
      
      local cmp = require "cmp"
      cmp.setup {
          -- ... rest of your cmp setup ...
      
          sorting = {
              comparators = {
                  cmp.config.compare.offset,
                  cmp.config.compare.exact,
                  cmp.config.compare.recently_used,
                  require("clangd_extensions.cmp_scores"),
                  cmp.config.compare.kind,
                  cmp.config.compare.sort_text,
                  cmp.config.compare.length,
                  cmp.config.compare.order,
              },
          },
      }
      
    end,
  },
  {
    "ranjithshegde/ccls.nvim",
    config = function()
      
      defaults = {
          win_config = {
              -- Sidebar configuration
              sidebar = {
                  size = 50,
                  position = "topleft",
                  split = "vnew",
                  width = 50,
                  height = 20,
              },
              -- floating window configuration. check :help nvim_open_win for options
              float = {
                  style = "minimal",
                  relative = "cursor",
                  width = 50,
                  height = 20,
                  row = 0,
                  col = 0,
                  border = "rounded",
              },
          },
          filetypes = {"c", "cpp", "objc", "objcpp"},
      
          -- Lsp is not setup by default to avoid overriding user's personal configurations.
          -- Look ahead for instructions on using this plugin for ccls setup
          lsp = {
              codelens = {
                  enabled = false,
                  events = {"BufEnter", "BufWritePost"}
              }
          }
      }
      
      
      require("ccls").setup({filetypes = {"c", "cpp", "opencl"}})
      
      
          local util = require "lspconfig.util"
          local server_config = {
              filetypes = { "c", "cpp", "objc", "objcpp", "opencl" },
              root_dir = function(fname)
                  return util.root_pattern("compile_commands.json", "compile_flags.txt", ".git")(fname)
                      or util.find_git_ancestor(fname)
              end,
              init_options = { cache = {
                  directory = vim.env.XDG_CACHE_HOME .. "/ccls/",
                  -- or vim.fs.normalize "~/.cache/ccls" -- if on nvim 0.8 or higher
              } },
              --on_attach = require("my.attach").func,
              --capabilities = my_caps_table_or_func
          }
          require("ccls").setup { lsp = { lspconfig = server_config } }
      
      
      require("ccls").setup({lsp = {use_defaults = true}})
      
      
      require("ccls").setup {
          lsp = {
              -- check :help vim.lsp.start for config options
              server = {
                  name = "ccls", --String name
                  cmd = {"/usr/bin/ccls"}, -- point to your binary, has to be a table
                  args = {--[[Any args table]] },
                  offset_encoding = "utf-32", -- default value set by plugin
                  root_dir = vim.fs.dirname(vim.fs.find({ "compile_commands.json", ".git" }, { upward = true })[1]), -- or some other function that returns a string
                  --on_attach = your_func,
                  --capabilites = your_table/func
              },
          },
      }
      
      
      require('ccls').setup({
          lsp = {
              codelens = {
                  enable = true,
                  events = {"BufWritePost", "InsertLeave"}
              }
          }
      })
      
      
      require("ccls").setup {
          lsp = {
              disable_capabilities = {
                  completionProvider = true,
                  documentFormattingProvider = true,
                  documentRangeFormattingProvider = true,
                  documentHighlightProvider = true,
                  documentSymbolProvider = true,
                  workspaceSymbolProvider = true,
                  renameProvider = true,
                  hoverProvider = true,
                  codeActionProvider = true,
              },
              disable_diagnostics = true,
              disable_signature = true,
          },
      }
      
      
          local filetypes = { "c", "cpp", "objc", "objcpp", "opencl" }
          local server_config = {
              filetypes = filetypes,
              init_options = { cache = {
                  directory = vim.fs.normalize "~/.cache/ccls/",
              } },
              name = "ccls",
              cmd = { "ccls" },
              offset_encoding = "utf-32",
              root_dir = vim.fs.dirname(
                  vim.fs.find({ "compile_commands.json", "compile_flags.txt", ".git" }, { upward = true })[1]
              ),
          }
          require("ccls").setup {
              filetypes = filetypes,
              lsp = {
                  server = server_config,
                  disable_capabilities = {
                      completionProvider = true,
                      documentFormattingProvider = true,
                      documentRangeFormattingProvider = true,
                      documentHighlightProvider = true,
                      documentSymbolProvider = true,
                      workspaceSymbolProvider = true,
                      renameProvider = true,
                      hoverProvider = true,
                      codeActionProvider = true,
                  },
                  disable_diagnostics = true,
                  disable_signature = true,
                  codelens = { enable = true }
              },
          }
      
    end,
  },
  {
    "idanarye/nvim-buffls",
    config = function()
      
      require'null-ls'.setup {
          sources = {
              require'buffls',
          };
      }
      
    end,
  },
  {
    "DNLHC/glance.nvim",
    config = function()
      
      {
          'dnlhc/glance.nvim',
          cmd = 'Glance'
      }
      
      
      MiniDeps.add({
        source = 'dnlhc/glance.nvim',
      })
      
      
      use({
        'dnlhc/glance.nvim',
        cmd = 'Glance'
      })
      
      
      vim.keymap.set('n', 'gD', '<CMD>Glance definitions<CR>')
      vim.keymap.set('n', 'gR', '<CMD>Glance references<CR>')
      vim.keymap.set('n', 'gY', '<CMD>Glance type_definitions<CR>')
      vim.keymap.set('n', 'gM', '<CMD>Glance implementations<CR>')
      
      
      -- Lua configuration
      local glance = require('glance')
      local actions = glance.actions
      
      glance.setup({
        height = 18, -- Height of the window
        zindex = 45,
      
        -- When enabled, adds virtual lines behind the preview window to maintain context in the parent window
        -- Requires Neovim >= 0.10.0
        preserve_win_context = true,
      
        -- Controls whether the preview window is "embedded" within your parent window or floating
        -- above all windows.
        detached = function(winid)
          -- Automatically detach when parent window width < 100 columns
          return vim.api.nvim_win_get_width(winid) < 100
        end,
        -- Or use a fixed setting: detached = true,
      
        preview_win_opts = { -- Configure preview window options
          cursorline = true,
          number = true,
          wrap = true,
        },
      
        border = {
          enable = false, -- Show window borders. Only horizontal borders allowed
          top_char = '―',
          bottom_char = '―',
        },
      
        list = {
          position = 'right', -- Position of the list window 'left'|'right'
          width = 0.33, -- Width as percentage (0.1 to 0.5)
        },
      
        theme = {
          enable = true, -- Generate colors based on current colorscheme
          mode = 'auto', -- 'brighten'|'darken'|'auto', 'auto' will set mode based on the brightness of your colorscheme
        },
      
        mappings = {
          list = {
            ['j'] = actions.next, -- Next item
            ['k'] = actions.previous, -- Previous item
            ['<Down>'] = actions.next,
            ['<Up>'] = actions.previous,
            ['<Tab>'] = actions.next_location, -- Next location (skips groups, cycles)
            ['<S-Tab>'] = actions.previous_location, -- Previous location (skips groups, cycles)
            ['<C-u>'] = actions.preview_scroll_win(5), -- Scroll up the preview window
            ['<C-d>'] = actions.preview_scroll_win(-5), -- Scroll down the preview window
            ['v'] = actions.jump_vsplit, -- Open location in vertical split
            ['s'] = actions.jump_split, -- Open location in horizontal split
            ['t'] = actions.jump_tab, -- Open in new tab
            ['<CR>'] = actions.jump, -- Jump to location
            ['o'] = actions.jump,
            ['l'] = actions.open_fold,
            ['h'] = actions.close_fold,
            ['<leader>l'] = actions.enter_win('preview'), -- Focus preview window
            ['q'] = actions.close, -- Closes Glance window
            ['Q'] = actions.close,
            ['<Esc>'] = actions.close,
            ['<C-q>'] = actions.quickfix, -- Send all locations to quickfix list
            -- ['<Esc>'] = false -- Disable a mapping
          },
      
          preview = {
            ['Q'] = actions.close,
            ['<Tab>'] = actions.next_location, -- Next location (skips groups, cycles)
            ['<S-Tab>'] = actions.previous_location, -- Previous location (skips groups, cycles)
            ['<leader>l'] = actions.enter_win('list'), -- Focus list window
          },
        },
      
        hooks = {}, -- Described in Hooks section
      
        folds = {
          fold_closed = '',
          fold_open = '',
          folded = true, -- Automatically fold list on startup
        },
      
        indent_lines = {
          enable = true, -- Show indent guidelines
          icon = '│',
        },
      
        winbar = {
          enable = true, -- Enable winbar for the preview (requires neovim-0.8+)
        },
      
        use_trouble_qf = false -- Quickfix action will open trouble.nvim instead of built-in quickfix list
      })
      
      
      local actions = require('glance').actions
      
      
      ---Opens Glance with specified method, can recieve optional table with hooks
      ---@param method GlanceMethod
      ---@param opts? { hooks: GlanceHooks }
      actions.open(method, opts)
      
      ---Closes the Glance window
      actions.close
      
      ---Resumes last Glance session
      actions.resume
      
      ---Enters specified window
      ---@param win "preview"|"list"
      ---@return fun() function callback to focus specified window
      actions.enter_win(win)
      
      
      ---Moves cursor to the next item in the list
      actions.next
      
      ---Moves cursor to the previous item in the list
      actions.previous
      
      ---Moves to next location (skips groups, cycles)
      actions.next_location
      
      ---Moves to previous location (skips groups, cycles)
      actions.previous_location
      
      
       -- Jump to the selected location
       -- Example using a Vim command
       actions.jump({ cmd = 'vsplit' })
      
       -- Example using a callback function
       actions.jump({
         cmd = function(selected_item)
           vim.cmd('topleft split')
           -- Perform custom actions with the selected item
         end
       })
      
      ---Jumps to location in vertical split
      actions.jump_vsplit
      
      ---Jumps to location in horizontal split
      actions.jump_split
      
      ---Jumps to location in new tab
      actions.jump_tab
      
      
      ---Toggles fold state
      actions.toggle_fold
      
      ---Opens fold
      actions.open_fold
      
      ---Closes fold
      actions.close_fold
      
      
      ---Scrolls preview window
      ---@param distance integer Number of lines to scroll (negative scrolls up, positive scrolls down)
      ---@return fun() function callback to scroll the preview window
      actions.preview_scroll_win(distance)
      
      ---Sends locations to quickfix list
      actions.quickfix
      
      -- Check if Glance is currently open
      require('glance').is_open()
      
      
      require('glance').register_method({
        method = 'volar/client/findFileReference', -- The LSP method name to be called
        name = 'vue_references',                   -- The command name (used as :Glance vue_references)
        label = 'References',                      -- Display name shown in the Glance UI
      })
      
      
      require('glance').setup({
          hooks = {
              -- your hooks here
          }
      })
      
      
      hooks = {
        before_open = function(results, open, jump, method)
          open(results)
        end,
      }
      
      
      hooks = {
          before_open = function(results, open, jump, method)
              if #results == 1 then
                  jump(results[1])
              else
                  open(results)
              end
          end,
      }
      
      
      hooks = {
          before_open = function(results, open, jump, method)
              if #results == 1 then
                  local uri = vim.uri_from_bufnr(0)
                  local target_uri = results[1].uri or results[1].targetUri
      
                  if target_uri == uri then
                      jump(results[1])
                  else
                      open(results)
                  end
              else
                  open(results)
              end
          end,
      }
      
    end,
  },
  {
    "deathbeam/lspecho.nvim",
    config = function()
      
      require("lspecho").setup {
          echo = true, -- Echo progress messages, if set to false you can use .message() to get the current message
          decay = 3000, -- Message decay time in milliseconds
          interval = 100, -- Minimum time between echo updates in milliseconds
          attach_log = false, -- Attach to logMessage and showMessage
      }
      
      
    end,
  },
  {
    "linrongbin16/lsp-progress.nvim",
    config = function()
      
      require("lsp-progress").setup()
      
      
      require("lsp-progress").setup({
        client_format = function(client_name, spinner, series_messages)
          if #series_messages == 0 then
            return nil
          end
          return {
            name = client_name,
            body = spinner .. " " .. table.concat(series_messages, ", "),
          }
        end,
        format = function(client_messages)
          --- @param name string
          --- @param msg string?
          --- @return string
          local function stringify(name, msg)
            return msg and string.format("%s %s", name, msg) or name
          end
      
          local sign = "" -- nf-fa-gear \uf013
          local lsp_clients = vim.lsp.get_active_clients()
          local messages_map = {}
          for _, climsg in ipairs(client_messages) do
            messages_map[climsg.name] = climsg.body
          end
      
          if #lsp_clients > 0 then
            table.sort(lsp_clients, function(a, b)
              return a.name < b.name
            end)
            local builder = {}
            for _, cli in ipairs(lsp_clients) do
              if
                type(cli) == "table"
                and type(cli.name) == "string"
                and string.len(cli.name) > 0
              then
                if messages_map[cli.name] then
                  table.insert(builder, stringify(cli.name, messages_map[cli.name]))
                else
                  table.insert(builder, stringify(cli.name))
                end
              end
            end
            if #builder > 0 then
              return sign .. " " .. table.concat(builder, ", ")
            end
          end
          return ""
        end,
      })
      
      
      require("lsp-progress").setup({
        decay = 1200,
        series_format = function(title, message, percentage, done)
          local builder = {}
          local has_title = false
          local has_message = false
          if type(title) == "string" and string.len(title) > 0 then
            table.insert(builder, title)
            has_title = true
          end
          if type(message) == "string" and string.len(message) > 0 then
            table.insert(builder, message)
            has_message = true
          end
          if percentage and (has_title or has_message) then
            table.insert(builder, string.format("(%.0f%%)", percentage))
          end
          return { msg = table.concat(builder, " "), done = done }
        end,
        client_format = function(client_name, spinner, series_messages)
          if #series_messages == 0 then
            return nil
          end
          local builder = {}
          local done = true
          for _, series in ipairs(series_messages) do
            if not series.done then
              done = false
            end
            table.insert(builder, series.msg)
          end
          if done then
            spinner = "✓" -- replace your check mark
          end
          return "["
            .. client_name
            .. "] "
            .. spinner
            .. " "
            .. table.concat(builder, ", ")
        end,
      })
      
      
      -- lua
      return require('packer').startup(function(use)
        use {
          'linrongbin16/lsp-progress.nvim',
          config = function()
            require('lsp-progress').setup()
          end
        }
      end)
      
      
      -- lua
      require("lazy").setup({
        {
          'linrongbin16/lsp-progress.nvim',
          config = function()
            require('lsp-progress').setup()
          end
        }
      })
      
      
        require('lsp-progress').progress({
          format = ...,
          max_size = ...,
        })
        
      
      require("lualine").setup({
        sections = {
          -- Other Status Line components
          lualine_a = { ... },
          lualine_b = { ... },
      
          lualine_c = {
            function()
              -- invoke `progress` here.
              return require('lsp-progress').progress()
            end,
          },
          ...
        }
      })
      
      -- listen lsp-progress event and refresh lualine
      vim.api.nvim_create_augroup("lualine_augroup", { clear = true })
      vim.api.nvim_create_autocmd("User", {
        group = "lualine_augroup",
        pattern = "LspProgressStatusUpdated",
        callback = require("lualine").refresh,
      })
      
      
      local LspProgress = {
        provider = function()
          return require('lsp-progress').progress()
        end,
        update = {
          'User',
          pattern = 'LspProgressStatusUpdated',
          callback = vim.schedule_wrap(function()
            vim.cmd('redrawstatus')
          end),
        }
      }
      
      local StatusLine = {
        -- Other StatusLine components
        { ... },
      
        -- Lsp progress status component here
        LspProgress,
      }
      
      require('heirline').setup({
        statusline = StatusLine
      })
      
      
      require('lsp-progress').setup(opts)
      
    end,
  },
  {
    "jinzhongjia/LspUI.nvim",
    config = function()
      
      {
        "jinzhongjia/LspUI.nvim",
        branch = "main",
        config = function()
          require("LspUI").setup({
      	  -- config options go here
      	  })
        end
      }
      
      
      use {
        "jinzhongjia/LspUI.nvim",
      	branch = 'main',
      	config = function()
          require("LspUI").setup({
      	  -- config options go here
      	  })
        end
      }
      
      
      local LspUI = require("LspUI")
      LspUI.setup()
      
      
      require("LspUI").setup({
        -- General settings
        prompt = {
          border = true,
          borderchars = { "─", "│", "─", "│", "╭", "╮", "╯", "╰" },
        },
        
        -- Code Action configuration
        code_action = {
          enable = true,
          command_enable = true,
          gitsigns = false,
          extend_gitsigns = false,
          ui = {
            title = "Code Action",
            border = "rounded",
            winblend = 0,
          },
          keys = {
            quit = "q",
            exec = "<CR>",
          },
        },
        
        -- Hover configuration  
        hover = {
          enable = true,
          command_enable = true,
          ui = {
            title = "Hover",
            border = "rounded",
            winblend = 0,
          },
          keys = {
            quit = "q",
          },
        },
        
        -- Rename configuration
        rename = {
          enable = true,
          command_enable = true,
          auto_save = false,
          ui = {
            title = "Rename",
            border = "rounded",
            winblend = 0,
          },
          keys = {
            quit = "<C-c>",
            exec = "<CR>",
          },
        },
        
        -- Diagnostic configuration
        diagnostic = {
          enable = true,
          command_enable = true,
          ui = {
            title = "Diagnostic",
            border = "rounded",
            winblend = 0,
          },
          keys = {
            quit = "q",
            exec = "<CR>",
          },
        },
        
        -- Definition configuration
        definition = {
          enable = true,
          command_enable = true,
          ui = {
            title = "Definition",
            border = "rounded",
            winblend = 0,
          },
          keys = {
            quit = "q",
            exec = "<CR>",
            vsplit = "v",
            split = "s",
            tabe = "t",
          },
        },
        
        -- Reference configuration
        reference = {
          enable = true,
          command_enable = true,
          ui = {
            title = "Reference",
            border = "rounded",
            winblend = 0,
          },
          keys = {
            quit = "q",
            exec = "<CR>",
            vsplit = "v",
            split = "s",
            tabe = "t",
          },
        },
        
        -- Implementation configuration
        implementation = {
          enable = true,
          command_enable = true,
          ui = {
            title = "Implementation",
            border = "rounded",
            winblend = 0,
          },
          keys = {
            quit = "q",
            exec = "<CR>",
            vsplit = "v",
            split = "s",
            tabe = "t",
          },
        },
        
        -- Type Definition configuration
        type_definition = {
          enable = true,
          command_enable = true,
          ui = {
            title = "Type Definition",
            border = "rounded",
            winblend = 0,
          },
          keys = {
            quit = "q",
            exec = "<CR>",
            vsplit = "v",
            split = "s",
            tabe = "t",
          },
        },
        
        -- Declaration configuration
        declaration = {
          enable = true,
          command_enable = true,
          ui = {
            title = "Declaration",
            border = "rounded",
            winblend = 0,
          },
          keys = {
            quit = "q",
            exec = "<CR>",
            vsplit = "v",
            split = "s",
            tabe = "t",
          },
        },
        
        -- Call Hierarchy configuration
        call_hierarchy = {
          enable = true,
          command_enable = true,
          ui = {
            title = "Call Hierarchy",
            border = "rounded",
            winblend = 0,
          },
          keys = {
            quit = "q",
            exec = "<CR>",
            expand = "o",
            jump = "e",
            vsplit = "v",
            split = "s",
            tabe = "t",
          },
        },
        
        -- Lightbulb configuration
        lightbulb = {
          enable = true,
          command_enable = true,
          icon = "💡",
          action_kind = {
            QuickFix = "🔧",
            Refactor = "♻️",
            RefactorExtract = "📤",
            RefactorInline = "📥",
            RefactorRewrite = "✏️",
            Source = "📄",
            SourceOrganizeImports = "📦",
          },
        },
        
        -- Inlay Hint configuration
        inlay_hint = {
          enable = true,
          command_enable = true,
        },
        
        -- Signature Help configuration
        signature = {
          enable = true,
          command_enable = true,
          ui = {
            title = "Signature Help",
            border = "rounded",
            winblend = 0,
          },
          keys = {
            quit = "q",
          },
        },
      })
      
      
      -- Basic keybinding setup
      vim.keymap.set("n", "K", "<cmd>LspUI hover<CR>")
      vim.keymap.set("n", "gr", "<cmd>LspUI reference<CR>")  
      vim.keymap.set("n", "gd", "<cmd>LspUI definition<CR>")
      vim.keymap.set("n", "gt", "<cmd>LspUI type_definition<CR>")
      vim.keymap.set("n", "gi", "<cmd>LspUI implementation<CR>")
      vim.keymap.set("n", "<leader>rn", "<cmd>LspUI rename<CR>")
      vim.keymap.set("n", "<leader>ca", "<cmd>LspUI code_action<CR>")
      vim.keymap.set("n", "<leader>ci", "<cmd>LspUI call_hierarchy incoming_calls<CR>")
      vim.keymap.set("n", "<leader>co", "<cmd>LspUI call_hierarchy outgoing_calls<CR>")
      
    end,
  },
  {
    "VidocqH/lsp-lens.nvim",
    config = function()
      
      require("lazy").setup({
        'VidocqH/lsp-lens.nvim'
      })
      
      
      require'lsp-lens'.setup({})
      
      
      local SymbolKind = vim.lsp.protocol.SymbolKind
      
      require'lsp-lens'.setup({
        enable = true,
        include_declaration = false,      -- Reference include declaration
        sections = {                      -- Enable / Disable specific request, formatter example looks 'Format Requests'
          definition = false,
          references = true,
          implements = true,
          git_authors = true,
        },
        ignore_filetype = {
          "prisma",
        },
        -- Target Symbol Kinds to show lens information
        target_symbol_kinds = { SymbolKind.Function, SymbolKind.Method, SymbolKind.Interface },
        -- Symbol Kinds that may have target symbol kinds as children
        wrapper_symbol_kinds = { SymbolKind.Class, SymbolKind.Struct },
      })
      
      
      require'lsp-lens'.setup({
        sections = {
          definition = function(count)
              return "Definitions: " .. count
          end,
          references = function(count)
              return "References: " .. count
          end,
          implements = function(count)
              return "Implements: " .. count
          end,
          git_authors = function(latest_author, count)
              return " " .. latest_author .. (count - 1 == 0 and "" or (" + " .. count - 1))
          end,
        }
      })
      
      
      
      {
        LspLens = { link = "Comment" },
      }
      
    end,
  },
  {
    "chrisgrieser/nvim-dr-lsp",
    config = function()
      
      -- lazy.nvim
      { 
      	"chrisgrieser/nvim-dr-lsp",
      	event = "LspAttach",
      	opts = {},
      },
      
      -- packer
      use { 
      	"chrisgrieser/nvim-dr-lsp",
      	config = function() require("dr-lsp").setup({}) end,
      }
      
      
      -- default config
      require("dr-lsp").setup {
      	highlightCursorWordReferences = {
      		enable = true,
      	},
      }
      
      
      -- adding the component to lualine.nvim
      {
      	sections = {
      		lualine_c = {
      			{ require("dr-lsp").lspCount },
      		},
      	}
      }
      
      
      lualine_c = {
      	{ 
      		require("dr-lsp").lspCount, 
      		-- remove the letters from the component
      		fmt = function(str) return str:gsub("[RD]", "") end,
      	},
      },
      
      
      {
      	file = {
      		definitions = 1,
      		references = 4,
      	},
      	workspace = {
      		definitions = 2,
      		references = 10,
      	},
      }
      
    end,
  },
  {
    "Wansmer/symbol-usage.nvim",
    config = function()
      
      {
        'Wansmer/symbol-usage.nvim',
        event = 'BufReadPre', -- need run before LspAttach if you use nvim 0.9. On 0.10 use 'LspAttach'
        config = function()
          require('symbol-usage').setup()
        end
      }
      
      
      local SymbolKind = vim.lsp.protocol.SymbolKind
      
      ---@type UserOpts
      require('symbol-usage').setup({
        ---@type table<string, any> `nvim_set_hl`-like options for highlight virtual text
        hl = { link = 'Comment' },
        ---@type lsp.SymbolKind[] Symbol kinds what need to be count (see `lsp.SymbolKind`)
        kinds = { SymbolKind.Function, SymbolKind.Method },
        ---Additional filter for kinds. Recommended use in the filetypes override table.
        ---fiterKind: function(data: { symbol:table, parent:table, bufnr:integer }): boolean
        ---`symbol` and `parent` is an item from `textDocument/documentSymbol` request
        ---See: #filter-kinds
        ---@type table<lsp.SymbolKind, filterKind[]>
        kinds_filter = {},
        ---@type 'above'|'end_of_line'|'textwidth'|'signcolumn' `above` by default
        vt_position = 'above',
        vt_priority = nil, ---@type integer Virtual text priority (see `nvim_buf_set_extmark`)
        ---Text to display when request is pending. If `false`, extmark will not be
        ---created until the request is finished. Recommended to use with `above`
        ---vt_position to avoid "jumping lines".
        ---@type string|table|false
        request_pending_text = 'loading...',
        ---The function can return a string to which the highlighting group from `opts.hl` is applied.
        ---Alternatively, it can return a table of tuples of the form `{ { text, hl_group }, ... }`` - in this case the specified groups will be applied.
        ---If `vt_position` is 'signcolumn', then only a 1-2 length string or a `{{ icon, hl_group }}` table is expected.
        ---See `#format-text-examples`
        ---@type function(symbol: Symbol): string|table Symbol{ definition = integer|nil, implementation = integer|nil, references = integer|nil, stacked_count = integer, stacked_symbols = table<SymbolId, Symbol> }
        -- text_format = function(symbol) end,
        references = { enabled = true, include_declaration = false },
        definition = { enabled = false },
        implementation = { enabled = false },
        ---@type { lsp?: string[], filetypes?: string[], cond?: function[] } Disables `symbol-usage.nvim' for specific LSPs, filetypes, or on custom conditions.
        ---The function in the `cond` list takes an argument `bufnr` and returns a boolean. If it returns true, `symbol-usage` will not run in that buffer.
        disable = { lsp = {}, filetypes = {}, cond = {} },
        ---@type UserOpts[] See default overridings in `lua/symbol-usage/langs.lua`
        -- filetypes = {},
        ---@type 'start'|'end' At which position of `symbol.selectionRange` the request to the lsp server should start. Default is `end` (try changing it to `start` if the symbol counting is not correct).
        symbol_request_pos = 'end', -- Recommended redefine only in `filetypes` override table
        ---@type (fun(ctx: lsp.HandlerContext):fun(symbol: lsp.Location): boolean)?
        -- This is a function factory that takes the LSP context as a parameter and
        -- produce a filter function for vim.tbl_filter. This can be used to exclude
        -- certain references/definition/implementation from being included in the
        -- count. See [Filtering Symbols] for details.
        symbol_filter = nil,
        ---@type LoggerConfig
        log = { enabled = false },
      })
      
      
      SymbolKind = {
        File = 1,
        Module = 2,
        Namespace = 3,
        Package = 4,
        Class = 5,
        Method = 6,
        Property = 7,
        Field = 8,
        Constructor = 9,
        Enum = 10,
        Interface = 11,
        Function = 12,
        Variable = 13,
        Constant = 14,
        String = 15,
        Number = 16,
        Boolean = 17,
        Array = 18,
        Object = 19,
        Key = 20,
        Null = 21,
        EnumMember = 22,
        Struct = 23,
        Event = 24,
        Operator = 25,
        TypeParameter = 26,
      }
      
      
      local function text_format(symbol)
        local fragments = {}
      
        -- Indicator that shows if there are any other symbols in the same line
        local stacked_functions = symbol.stacked_count > 0
            and (' | +%s'):format(symbol.stacked_count)
            or ''
      
        if symbol.references then
          local usage = symbol.references <= 1 and 'usage' or 'usages'
          local num = symbol.references == 0 and 'no' or symbol.references
          table.insert(fragments, ('%s %s'):format(num, usage))
        end
      
        if symbol.definition then
          table.insert(fragments, symbol.definition .. ' defs')
        end
      
        if symbol.implementation then
          table.insert(fragments, symbol.implementation .. ' impls')
        end
      
        return table.concat(fragments, ', ') .. stacked_functions
      end
      
      require('symbol-usage').setup({
        text_format = text_format,
      })
      
      
      local function h(name) return vim.api.nvim_get_hl(0, { name = name }) end
      
      -- hl-groups can have any name
      vim.api.nvim_set_hl(0, 'SymbolUsageRounding', { fg = h('CursorLine').bg, italic = true })
      vim.api.nvim_set_hl(0, 'SymbolUsageContent', { bg = h('CursorLine').bg, fg = h('Comment').fg, italic = true })
      vim.api.nvim_set_hl(0, 'SymbolUsageRef', { fg = h('Function').fg, bg = h('CursorLine').bg, italic = true })
      vim.api.nvim_set_hl(0, 'SymbolUsageDef', { fg = h('Type').fg, bg = h('CursorLine').bg, italic = true })
      vim.api.nvim_set_hl(0, 'SymbolUsageImpl', { fg = h('@keyword').fg, bg = h('CursorLine').bg, italic = true })
      
      local function text_format(symbol)
        local res = {}
      
        local round_start = { '', 'SymbolUsageRounding' }
        local round_end = { '', 'SymbolUsageRounding' }
      
        -- Indicator that shows if there are any other symbols in the same line
        local stacked_functions_content = symbol.stacked_count > 0
            and ("+%s"):format(symbol.stacked_count)
            or ''
      
        if symbol.references then
          local usage = symbol.references <= 1 and 'usage' or 'usages'
          local num = symbol.references == 0 and 'no' or symbol.references
          table.insert(res, round_start)
          table.insert(res, { '󰌹 ', 'SymbolUsageRef' })
          table.insert(res, { ('%s %s'):format(num, usage), 'SymbolUsageContent' })
          table.insert(res, round_end)
        end
      
        if symbol.definition then
          if #res > 0 then
            table.insert(res, { ' ', 'NonText' })
          end
          table.insert(res, round_start)
          table.insert(res, { '󰳽 ', 'SymbolUsageDef' })
          table.insert(res, { symbol.definition .. ' defs', 'SymbolUsageContent' })
          table.insert(res, round_end)
        end
      
        if symbol.implementation then
          if #res > 0 then
            table.insert(res, { ' ', 'NonText' })
          end
          table.insert(res, round_start)
          table.insert(res, { '󰡱 ', 'SymbolUsageImpl' })
          table.insert(res, { symbol.implementation .. ' impls', 'SymbolUsageContent' })
          table.insert(res, round_end)
        end
      
        if stacked_functions_content ~= '' then
          if #res > 0 then
            table.insert(res, { ' ', 'NonText' })
          end
          table.insert(res, round_start)
          table.insert(res, { ' ', 'SymbolUsageImpl' })
          table.insert(res, { stacked_functions_content, 'SymbolUsageContent' })
          table.insert(res, round_end)
        end
      
        return res
      end
      
      require('symbol-usage').setup({
        text_format = text_format,
      })
      
      
      local function h(name) return vim.api.nvim_get_hl(0, { name = name }) end
      
      vim.api.nvim_set_hl(0, 'SymbolUsageRef', { bg = h('Type').fg, fg = h('Normal').bg, bold = true })
      vim.api.nvim_set_hl(0, 'SymbolUsageRefRound', { fg = h('Type').fg })
      
      vim.api.nvim_set_hl(0, 'SymbolUsageDef', { bg = h('Function').fg, fg = h('Normal').bg, bold = true })
      vim.api.nvim_set_hl(0, 'SymbolUsageDefRound', { fg = h('Function').fg })
      
      vim.api.nvim_set_hl(0, 'SymbolUsageImpl', { bg = h('@parameter').fg, fg = h('Normal').bg, bold = true })
      vim.api.nvim_set_hl(0, 'SymbolUsageImplRound', { fg = h('@parameter').fg })
      
      local function text_format(symbol)
        local res = {}
      
        -- Indicator that shows if there are any other symbols in the same line
        local stacked_functions_content = symbol.stacked_count > 0
            and ("+%s"):format(symbol.stacked_count)
            or ''
      
        if symbol.references then
          table.insert(res, { '󰍞', 'SymbolUsageRefRound' })
          table.insert(res, { '󰌹 ' .. tostring(symbol.references), 'SymbolUsageRef' })
          table.insert(res, { '󰍟', 'SymbolUsageRefRound' })
        end
      
        if symbol.definition then
          if #res > 0 then
            table.insert(res, { ' ', 'NonText' })
          end
          table.insert(res, { '󰍞', 'SymbolUsageDefRound' })
          table.insert(res, { '󰳽 ' .. tostring(symbol.definition), 'SymbolUsageDef' })
          table.insert(res, { '󰍟', 'SymbolUsageDefRound' })
        end
      
        if symbol.implementation then
          if #res > 0 then
            table.insert(res, { ' ', 'NonText' })
          end
          table.insert(res, { '󰍞', 'SymbolUsageImplRound' })
          table.insert(res, { '󰡱 ' .. tostring(symbol.implementation), 'SymbolUsageImpl' })
          table.insert(res, { '󰍟', 'SymbolUsageImplRound' })
        end
      
        if stacked_functions_content ~= '' then
          if #res > 0 then
            table.insert(res, { ' ', 'NonText' })
          end
          table.insert(res, { '󰍞', 'SymbolUsageImplRound' })
          table.insert(res, { ' ' .. tostring(stacked_functions_content), 'SymbolUsageImpl' })
          table.insert(res, { '󰍟', 'SymbolUsageImplRound' })
        end
      
        return res
      end
      
      require('symbol-usage').setup({
        text_format = text_format,
      })
      
      
      symbol_filter = function(ctx)
        return function(symbol)
          if ctx.method == vim.lsp.protocol.Methods.textDocument_references then
            -- if the LSP request is 'textDocument/references', do not count it if the URI contains `tests/`
            return string.find(symbol.uri, "tests") == nil
          else
            -- for other types of LSP requests, do not apply a filter and always count
            -- the occurrence.
            return true
          end
        end
      end
      
      
      ---Setup `symbol-usage`
      ---@param opts UserOpts
      require('symbol-usage').setup(opts)
      
      
      require('symbol-usage').toggle()
      
      
      ---@return boolean True if active, false otherwise
      require('symbol-usage').toggle_globally()
      
      
      require('symbol-usage').refresh()
      
    end,
  },
  {
    "creativenull/efmls-configs-nvim",
    config = function()
      
      {
        'creativenull/efmls-configs-nvim',
        version = 'v1.x.x', -- version is optional, but recommended
        dependencies = { 'neovim/nvim-lspconfig' },
      }
      
      
      use {
        'creativenull/efmls-configs-nvim',
        tag = 'v1.*', -- tag is optional, but recommended
        requires = { 'neovim/nvim-lspconfig' },
      }
      
      
      -- Register linters and formatters per language
      local eslint = require('efmls-configs.linters.eslint')
      local prettier = require('efmls-configs.formatters.prettier')
      local stylua = require('efmls-configs.formatters.stylua')
      local languages = {
        typescript = { eslint, prettier },
        lua = { stylua },
      }
      
      -- Or use the defaults provided by this plugin
      -- check doc/SUPPORTED_LIST.md for the supported languages
      --
      -- local languages = require('efmls-configs.defaults').languages()
      
      local efmls_config = {
        filetypes = vim.tbl_keys(languages),
        settings = {
          rootMarkers = { '.git/' },
          languages = languages,
        },
        init_options = {
          documentFormatting = true,
          documentRangeFormatting = true,
        },
      }
      
      require('lspconfig').efm.setup(vim.tbl_extend('force', efmls_config, {
        -- Pass your custom lsp config below like on_attach and capabilities
        --
        -- on_attach = on_attach,
        -- capabilities = capabilities,
      }))
      
      
      local languages = require('efmls-configs.defaults').languages()
      
      
      local languages = require('efmls-configs.defaults').languages()
      languages = vim.tbl_extend('force', languages, {
        -- Custom languages, or override existing ones
        html = {
          require('efmls-configs.formatters.prettier'),
        },
      })
      
      
      local lsp_fmt_group = vim.api.nvim_create_augroup('LspFormattingGroup', {})
      vim.api.nvim_create_autocmd('BufWritePost', {
        group = lsp_fmt_group,
        callback = function(ev)
          local efm = vim.lsp.get_active_clients({ name = 'efm', bufnr = ev.buf })
      
          if vim.tbl_isempty(efm) then
            return
          end
      
          vim.lsp.buf.format({ name = 'efm' })
        end,
      })
      
    end,
  },
  {
    "creativenull/diagnosticls-configs-nvim",
    config = function()
      
      use {
          'creativenull/diagnosticls-configs-nvim',
          tag = 'v0.1.8', -- `tag` is optional
          requires = 'neovim/nvim-lspconfig',
      }
      
      
      -- Lua file
      local function on_attach(client)
        print('Attached to ' .. client.name)
      end
      
      local dlsconfig = require 'diagnosticls-configs'
      
      dlsconfig.init {
        -- Your custom attach function
        on_attach = on_attach,
      }
      
      
      -- Lua file
      local eslint = require 'diagnosticls-configs.linters.eslint'
      local standard = require 'diagnosticls-configs.linters.standard'
      local prettier = require 'diagnosticls-configs.formatters.prettier'
      local prettier_standard = require 'diagnosticls-configs.formatters.prettier_standard'
      dlsconfig.setup {
        ['javascript'] = {
          linter = eslint,
          formatter = prettier
        },
        ['javascriptreact'] = {
          -- Add multiple linters
          linter = { eslint, standard },
          -- Add multiple formatters
          formatter = { prettier, prettier_standard }
        }
      }
      
      
      -- Lua file
      dlsconfig.init {
        -- Use a list of default configurations
        -- set by this plugin
        -- (Default: false)
        default_config = false,
      
        -- Set to false if formatting is not needed at all,
        -- any formatter provided will be ignored
        -- (Default: true)
        format = true,
      }
      
      dlsconfig.setup()
      
      
      -- Lua file
      local eslint = require 'diagnosticls-configs.linter.eslint'
      
      -- ESLint Extented Config
      eslint = vim.tbl_extend('force', eslint, {
      
        -- REQUIRED: if `default_config` is enabled, separate name from original sourceName
        sourceName = 'eslint_extended',
      
        args = { 'extra', 'args' },
        rootPatterns = { '.git' }
      })
      
      dlsconfig.setup {
        javascript = {
          linter = eslint
        }
      }
      
    end,
  },
  {
    "hinell/lsp-timeout.nvim",
    config = function()
      
      require("lazy").setup(
          {
      	"hinell/lsp-timeout.nvim",
      	dependencies={ "neovim/nvim-lspconfig" }
          }
      )
      
      
      -- $HOME/.config/nvim/lua/user/init.lua
      packer.setup(function(use)
          use({
              "hinell/lsp-timeout.nvim",
              requires={ "neovim/nvim-lspconfig" }
          })
      end)
      
    end,
  },
  {
    "nvimtools/none-ls.nvim",
    config = function()
      
      local null_ls = require("null-ls")
      
      null_ls.setup({
          sources = {
              null_ls.builtins.formatting.stylua,
              null_ls.builtins.completion.spell,
              require("none-ls.diagnostics.eslint"), -- requires none-ls-extras.nvim
          },
      })
      
      
      local null_ls = require("null-ls")
      
      local no_really = {
          method = null_ls.methods.DIAGNOSTICS,
          filetypes = { "markdown", "text" },
          generator = {
              fn = function(params)
                  local diagnostics = {}
                  -- sources have access to a params object
                  -- containing info about the current file and editor state
                  for i, line in ipairs(params.content) do
                      local col, end_col = line:find("really")
                      if col and end_col then
                          -- null-ls fills in undefined positions
                          -- and converts source diagnostics into the required format
                          table.insert(diagnostics, {
                              row = i,
                              col = col,
                              end_col = end_col + 1,
                              source = "no-really",
                              message = "Don't use 'really!'",
                              severity = vim.diagnostic.severity.WARN,
                          })
                      end
                  end
                  return diagnostics
              end,
          },
      }
      
      null_ls.register(no_really)
      
      
      local null_ls = require("null-ls")
      local helpers = require("null-ls.helpers")
      
      local markdownlint = {
          method = null_ls.methods.DIAGNOSTICS,
          filetypes = { "markdown" },
          -- null_ls.generator creates an async source
          -- that spawns the command with the given arguments and options
          generator = null_ls.generator({
              command = "markdownlint",
              args = { "--stdin" },
              to_stdin = true,
              from_stderr = true,
              -- choose an output format (raw, json, or line)
              format = "line",
              check_exit_code = function(code, stderr)
                  local success = code <= 1
      
                  if not success then
                      -- can be noisy for things that run often (e.g. diagnostics), but can
                      -- be useful for things that run on demand (e.g. formatting)
                      print(stderr)
                  end
      
                  return success
              end,
              -- use helpers to parse the output from string matchers,
              -- or parse it manually with a function
              on_output = helpers.diagnostics.from_patterns({
                  {
                      pattern = [[:(%d+):(%d+) [%w-/]+ (.*)]],
                      groups = { "row", "col", "message" },
                  },
                  {
                      pattern = [[:(%d+) [%w-/]+ (.*)]],
                      groups = { "row", "message" },
                  },
              }),
          }),
      }
      
      null_ls.register(markdownlint)
      
      
         require("null-ls").setup({
             debug = true,
         })
         
      
      vim.lsp.buf.format({ timeout_ms = 2000 })
      
    end,
  },
  {
    "zeioth/none-ls-autoload.nvim",
    config = function()
      
      {
        "zeioth/none-ls-autoload.nvim",
        event = "BufEnter",
        dependencies = { "williamboman/mason.nvim", "nvimtools/none-ls.nvim" },
        opts = {},
      },
      
      
      {
        "zeioth/none-ls-autoload.nvim",
        event = "BufEnter",
        dependencies = {
          "williamboman/mason.nvim",
          "zeioth/none-ls-external-sources.nvim" -- To install a external sources library.
        },
        opts = {
          external_sources = {
            -- To specify where to find a external source.
            'none-ls-external-sources.formatting.reformat_gherkin'
          },
        },
      },
      
    end,
  },
  {
    "vxpm/ferris.nvim",
    config = function()
      
      {
          'vxpm/ferris.nvim',
          opts = {
              -- your options here
          }
      }
      
      
      {
          -- If true, will automatically create commands for each LSP method
          create_commands = true, -- bool
          -- Handler for URL's (used for opening documentation)
          url_handler = "xdg-open", -- string | function(string)
      }
      
      
      local view_mem_layout = require("ferris.methods.view_memory_layout")
      
      -- call the returned function to execute the request
      view_mem_layout()
      
    end,
  },
  {
    "mrcjkb/rustaceanvim",
    config = function()
      
      {
        'mrcjkb/rustaceanvim',
        version = '^6', -- Recommended
        lazy = false, -- This plugin is already lazy
      }
      
      
      local bufnr = vim.api.nvim_get_current_buf()
      vim.keymap.set(
        "n", 
        "<leader>a", 
        function()
          vim.cmd.RustLsp('codeAction') -- supports rust-analyzer's grouping
          -- or vim.lsp.buf.codeAction() if you don't want grouping.
        end,
        { silent = true, buffer = bufnr }
      )
      vim.keymap.set(
        "n", 
        "K",  -- Override Neovim's built-in hover keymap with rustaceanvim's hover actions
        function()
          vim.cmd.RustLsp({'hover', 'actions'})
        end,
        { silent = true, buffer = bufnr }
      )
      
      
        vim.cmd.RustLsp('debug')
        vim.cmd.RustLsp('debuggables')
        -- or, to run the previous debuggable:
        vim.cmd.RustLsp { 'debuggables', bang = true }
        -- or, to override the executable's args:
        vim.cmd.RustLsp {'debuggables', 'arg1', 'arg2' }
        
      
        vim.cmd.RustLsp('run') 
        vim.cmd.RustLsp('runnables')
        -- or, to run the previous runnable:
        vim.cmd.RustLsp { 'runnables', bang = true }
        -- or, to override the executable's args:
        vim.cmd.RustLsp {'runnables', 'arg1', 'arg2' }
        
      
        vim.cmd.RustLsp('testables')
        -- or, to run the previous testables:
        vim.cmd.RustLsp { 'testables', bang = true }
        -- or, to override the executable's args:
        vim.cmd.RustLsp {'testables', 'arg1', 'arg2' }
        
      
        require('neotest').setup {
            -- ...,
            adapters = {
              -- ...,
              require('rustaceanvim.neotest')
            },
        }
        
      
        vim.cmd.RustLsp('expandMacro')
        
      
        vim.cmd.RustLsp('rebuildProcMacros')
        
      
        vim.cmd.RustLsp { 'moveItem',  'up' }
        vim.cmd.RustLsp { 'moveItem',  'down' }
        
      
       vim.cmd.RustLsp('codeAction')
       
      
       vim.cmd.RustLsp { 'hover', 'actions' }
       
      
       vim.keymap.set('n', '<space>a', '<Plug>RustHoverAction')
       
      
        vim.cmd.RustLsp { 'hover', 'range' }
        
      
        vim.cmd.RustLsp('explainError') -- default to 'cycle'
        vim.cmd.RustLsp({ 'explainError', 'cycle' })
        vim.cmd.RustLsp({ 'explainError', 'cycle_prev' })
        vim.cmd.RustLsp({ 'explainError', 'current' })
        
      
        vim.cmd.RustLsp('renderDiagnostic') -- defaults to 'cycle'
        vim.cmd.RustLsp({ 'renderDiagnostic', 'cycle' })
        vim.cmd.RustLsp({ 'renderDiagnostic', 'cycle_prev' })
        vim.cmd.RustLsp({ 'renderDiagnostic', 'current' })
        
      
        vim.cmd.RustLsp('relatedDiagnostics')
        
      
        vim.cmd.RustLsp('openCargo')
        
      
        vim.cmd.RustLsp('openDocs')
        
      
        vim.cmd.RustLsp('parentModule')
        
      
        vim.cmd.RustLsp('workspaceSymbol')
        -- or
        vim.cmd.RustLsp { 
          'workspaceSymbol', 
          '<onlyTypes|allSymbols>' --[[ optional ]], 
          '<query>' --[[ optional ]], 
          bang = true --[[ optional ]]
        }
        
      
        vim.cmd.RustLsp('joinLines')
        
      
        vim.cmd.RustLsp { 'ssr', '<query>' --[[ optional ]] }
        
      
        vim.cmd.RustLsp { 'crateGraph', '[backend]', '[output]' }
        
      
        vim.cmd.RustLsp('syntaxTree')
        
      
        vim.cmd.RustLsp('flyCheck') -- defaults to 'run'
        vim.cmd.RustLsp { 'flyCheck', 'run' }
        vim.cmd.RustLsp { 'flyCheck', 'clear' }
        vim.cmd.RustLsp { 'flyCheck', 'cancel' }
        
      
        vim.cmd.RustLsp { 'view', 'hir' }
        vim.cmd.RustLsp { 'view', 'mir' }
        
      
        vim.cmd.Rustc { 'unpretty', 'hir' }
        vim.cmd.Rustc { 'unpretty', 'mir' }
        -- ...
        
      
        vim.cmd.RustAnalyzer { 'config', '{ checkOnSave = false }' }
        
      
      vim.g.rustaceanvim = {
        -- Plugin configuration
        tools = {
        },
        -- LSP configuration
        server = {
          on_attach = function(client, bufnr)
            -- you can also put keymaps in here
          end,
          default_settings = {
            -- rust-analyzer language server configuration
            ['rust-analyzer'] = {
            },
          },
        },
        -- DAP configuration
        dap = {
        },
      }
      
      
      vim.g.rustaceanvim = function()
        -- Update this path
        local extension_path = vim.env.HOME .. '/.vscode/extensions/vadimcn.vscode-lldb-1.10.0/'
        local codelldb_path = extension_path .. 'adapter/codelldb'
        local liblldb_path = extension_path .. 'lldb/lib/liblldb'
        local this_os = vim.uv.os_uname().sysname;
      
        -- The path is different on Windows
        if this_os:find "Windows" then
          codelldb_path = extension_path .. "adapter\\codelldb.exe"
          liblldb_path = extension_path .. "lldb\\bin\\liblldb.dll"
        else
          -- The liblldb extension is .so for Linux and .dylib for MacOS
          liblldb_path = liblldb_path .. (this_os == "Linux" and ".so" or ".dylib")
        end
      
        local cfg = require('rustaceanvim.config')
        return {
          dap = {
            adapter = cfg.get_codelldb_adapter(codelldb_path, liblldb_path),
          },
        }
      end
      
    end,
  },
  {
    "soulis-1256/eagle.nvim",
    config = function()
      
      {
          "soulis-1256/eagle.nvim",
          opts = {
            --override the default values found in config.lua
          }
      },
      
      
      { "soulis-1256/eagle.nvim" },
      
      
      require("eagle").setup({
      --override the default values found in config.lua
      })
      
      
        show_headers = true,
        order = 1,
        improved_markdown = true,
        mouse_mode = true,
        keyboard_mode = false,
        logging = false,
        close_on_cmd = true,
        show_lsp_info = true,
        scrollbar_offset = 0,
        max_width_factor = 2,
        max_height_factor = 2.5,
        render_delay = 500,
        detect_idle_timer = 50,
        window_row = 1,
        window_col = 5,
        border = "single",
        title = "",
        title_pos = "center",
        title_color = "#8AAAE5",
        border_color = "#8AAAE5",
      
      
      vim.o.mousemoveevent = true
      
      
      vim.keymap.set('n', '<Tab>', ':EagleWin<CR>', { noremap = true, silent = true })
      
    end,
  },
  {
    "stevanmilic/nvim-lspimport",
    config = function()
      
      { "stevanmilic/nvim-lspimport" }
      
      
      vim.keymap.set("n", "<leader>a", require("lspimport").import, { noremap = true })
      
    end,
  },
  {
    "jmbuhr/otter.nvim",
    config = function()
      
      {
        'nvim-treesitter/nvim-treesitter'
      }
      
      
      {
          'jmbuhr/otter.nvim',
          dependencies = {
            'nvim-treesitter/nvim-treesitter',
          },
          opts = {},
      }
      
      
      local otter = require'otter'
      otter.setup{
        lsp = {
          -- `:h events` that cause the diagnostics to update. Set to:
          -- { "BufWritePost", "InsertLeave", "TextChanged" } for less performant
          -- but more instant diagnostic updates
          diagnostic_update_events = { "BufWritePost" },
          -- function to find the root dir where the otter-ls is started
          root_dir = function(_, bufnr)
            return vim.fs.root(bufnr or 0, {
              ".git",
              "_quarto.yml",
              "package.json",
            }) or vim.fn.getcwd(0)
          end,
        },
        -- options related to the otter buffers
        buffers = {
          -- if set to true, the filetype of the otterbuffers will be set.
          -- otherwise only the autocommand of lspconfig that attaches
          -- the language server will be executed without setting the filetype
          --- this setting is deprecated and will default to true in the future
          set_filetype = true,
          -- write <path>.otter.<embedded language extension> files
          -- to disk on save of main buffer.
          -- usefule for some linters that require actual files.
          -- otter files are deleted on quit or main buffer close
          write_to_disk = false,
          -- a table of preambles for each language. The key is the language and the value is a table of strings that will be written to the otter buffer starting on the first line.
          preambles = {},
          -- a table of postambles for each language. The key is the language and the value is a table of strings that will be written to the end of the otter buffer.
          postambles = {},
          -- A table of patterns to ignore for each language. The key is the language and the value is a lua match pattern to ignore.
          -- lua patterns: https://www.lua.org/pil/20.2.html
          ignore_pattern = {
            -- ipython cell magic (lines starting with %) and shell commands (lines starting with !)
            python = "^(%s*[%%!].*)",
          },
        },
        -- list of characters that should be stripped from the beginning and end of the code chunks
        strip_wrapping_quote_characters = { "'", '"', "`" },
        -- remove whitespace from the beginning of the code chunks when writing to the otter buffers
        -- and calculate it back in when handling lsp requests
        handle_leading_whitespace = true,
        -- mapping of filetypes to extensions for those not already included in otter.tools.extensions
        -- e.g. ["bash"] = "sh"
        extensions = {
        },
        -- add event listeners for LSP events for debugging
        debug = false,
        verbose = { -- set to false to disable all verbose messages
          no_code_found = false -- warn if otter.activate is called, but no injected code was found
        },
      }
      
      
      --- Activate the current buffer by adding and synchronizing
      ---@param languages table|nil List of languages to activate. If nil, all available languages will be activated.
      ---@param completion boolean|nil Enable completion for otter buffers. Default: true
      ---@param diagnostics boolean|nil Enable diagnostics for otter buffers. Default: true
      ---@param tsquery string|nil Explicitly provide a treesitter query. If nil, the injections query for the current filetyepe will be used. See :h treesitter-language-injections.
      otter.activate(languages, completion, diagnostics, tsquery)
      
      
      -- Export the raft of otters as files.
      -- Asks for filename for each language.
      otter.export()
      otter.export_otter_as()
      
      
      local ms = vim.lsp.protocol.Methods
      local function get_otter_symbols_lang()
        local otterkeeper = require'otter.keeper'
        local main_nr = vim.api.nvim_get_current_buf()
        local langs = {}
        for i,l in ipairs(otterkeeper.rafts[main_nr].languages) do
          langs[i] = i .. ': ' .. l
        end
        -- promt to choose one of langs
        local i = vim.fn.inputlist(langs)
        local lang = otterkeeper.rafts[main_nr].languages[i]
        local params = {
          textDocument = vim.lsp.util.make_text_document_params(),
          otter = {
            lang = lang
          }
        }
        -- don't pass a handler, as we want otter to use its own handlers
        vim.lsp.buf_request(main_nr, ms.textDocument_documentSymbol, params, nil)
      end
      
      vim.keymap.set("n", "<leader>os", get_otter_symbols_lang, {desc = "otter [s]ymbols"})
      
      
        local clients = vim.lsp.get_clients({
            -- the client is always named otter-ls[<buffnr>]
            name = 'otter-ls'.. '[' .. main_nr .. ']'
        })
        if #clients == 1 then
          local otter_client = clients[1]
          otter_client.request(ms.textDocument_documentSymbol, params, nil)
        end
      
    end,
  },
  {
    "lopi-py/luau-lsp.nvim",
    config = function()
      
      {
        "lopi-py/luau-lsp.nvim",
        opts = {
          ...
        },
        dependencies = {
          "nvim-lua/plenary.nvim",
        },
      }
      
      
      use {
        "lopi-py/luau-lsp.nvim",
        config = function()
          require("luau-lsp").setup {
            ...
          }
        end,
        requires = {
          "nvim-lua/plenary.nvim",
        },
      }
      
      
      require("luau-lsp").setup {
        ...
      }
      
      
      require("mason-lspconfig").setup {
        automatic_enable = {
          exclude = { "luau_lsp" },
        },
      }
      
      
      require("luau-lsp").setup {
        platform = {
          type = "roblox",
        },
        types = {
          roblox_security_level = "PluginSecurity",
        },
      }
      
      
      require("luau-lsp").setup {
        sourcemap = {
          enabled = true,
          autogenerate = true, -- automatic generation when the server is initialized
          rojo_project_file = "default.project.json",
          sourcemap_file = "sourcemap.json",
        },
      }
      
      
      require("luau-lsp").setup {
        sourcemap = {
          -- based on https://argon.wiki/docs/commands/cli#sourcemap
          generator_cmd = { "argon", "sourcemap", "--watch", "--non-scripts" },
        },
      }
      
      
      require("luau-lsp").setup {
        plugin = {
          enabled = true,
          port = 3667,
        },
      }
      
      
      require("luau-lsp").setup {
        types = {
          definition_files = { "path/to/definitions/file" },
          documentation_files = { "path/to/documentation/file" },
        },
      }
      
      
      require("luau-lsp").setup {
        fflags = {
          enable_new_solver = true, -- enables the fflags required for luau's new type solver
          sync = true, -- sync currently enabled fflags with roblox's published fflags
          override = { -- override fflags passed to luau 
            LuauTableTypeMaximumStringifierLength = "100",
          },
        },
      }
      
      
      vim.lsp.config("luau-lsp", {
        settings = {
          ["luau-lsp"] = {
            completion = {
              imports = {
                enabled = true, -- enable auto imports
              },
            },
          },
        },
      })
      
      
      require("luau-lsp").config {
        ...
      }
      
      
      ---@alias luau-lsp.PlatformType "standard" | "roblox"
      ---@alias luau-lsp.RobloxSecurityLevel "None" | "LocalUserSecurity" | "PluginSecurity" | "RobloxScriptSecurity"
      
      ---@class luau-lsp.Config : {}
      local defaults = {
        platform = {
          ---@type luau-lsp.PlatformType
          type = "roblox",
        },
        sourcemap = {
          enabled = true,
          autogenerate = true,
          rojo_path = "rojo",
          rojo_project_file = "default.project.json",
          include_non_scripts = true,
          sourcemap_file = "sourcemap.json",
          ---@type string[]?
          generator_cmd = nil,
        },
        types = {
          ---@type string[]
          definition_files = {},
          ---@type string[]
          documentation_files = {},
          ---@type luau-lsp.RobloxSecurityLevel
          roblox_security_level = "PluginSecurity",
        },
        fflags = {
          enable_by_default = false,
          enable_new_solver = false,
          sync = true,
          ---@type table<string, string>
          override = {},
        },
        plugin = {
          enabled = false,
          port = 3667,
        },
        server = {
          path = "luau-lsp",
        },
      }
      
      
      vim.lsp.config("*", {
        capabilities = {
          workspace = {
            didChangeWatchedFiles = {
              dynamicRegistration = true,
            },
          },
        },
      })
      
      
      local function rojo_project()
        return vim.fs.root(0, function(name)
          return name:match ".+%.project%.json$"
        end)
      end
      
      require("luau-lsp").setup {
        platform = {
          type = rojo_project() and "roblox" or "standard",
        },
      }
      
      
      local function rojo_project()
        return vim.fs.root(0, function(name)
          return name:match ".+%.project%.json$"
        end)
      end
      
      if rojo_project() then
        vim.filetype.add {
          extension = {
            lua = function(path)
              return path:match "%.nvim%.lua$" and "lua" or "luau"
            end,
          },
        }
      end
      
      
      local schemas = {
        {
          name = "default.project.json",
          description = "JSON schema for Rojo project files",
          fileMatch = { "*.project.json" },
          url = "https://raw.githubusercontent.com/rojo-rbx/vscode-rojo/master/schemas/project.template.schema.json",
        },
      }
      
      vim.lsp.config("jsonls", {
        settings = {
          json = {
            -- without SchemaStore.nvim
            schemas = schemas,
      
            -- or if using SchemaStore.nvim
            -- schemas = require("schemastore").json.schemas { extra = schemas },
      
            validate = {
              enabled = true
            },
          },
        },
      })
      
    end,
  },
  {
    "LukasPietzschmann/boo.nvim",
    config = function()
      
      {
      	'LukasPietzschmann/boo.nvim',
      	opts = {
      		-- here goes your config :)
      	},
      }
      
      
      require('boo').setup({
      	-- here goes your config :)
      })
      
      
      local boo = require('boo')
      
      
      boo.boo()
      
      
      boo.close()
      
      
      {
      	-- win_opts will be used when creating the window. You can put everything here,
      	-- that vim.api.nvim_open_win (https://neovim.io/doc/user/api.html#nvim_open_win())
      	-- can handle.
      	win_opts = {
      		title = 'LSP Info',
      		title_pos = 'center',
      		relative = 'cursor',
      		row = 1,
      		col = 0,
      		style = 'minimal',
      		border = 'rounded',
      		focusable = true,
      	},
      	-- The window will not be wider than max_width (in character cells)
      	max_width = 80,
      	-- The window will not be taller than max_height (in character cells)
      	max_height = 20,
      	-- When the boo window is focused, pressing one of these will close it.
      	-- They will only be mapped in normalmode
      	escape_mappings = { 'q', '<esc>' },
      	-- Focus boo's window automatically after it's created
      	focus_on_open = true,
      	-- When the boo window is focused, and you'll focus another buffer,
      	-- the window will be closed when this is set to true
      	close_on_leave = true,
      	-- When moving the cursor in the buffer that boo was opened from, boo
      	-- will be closed. This makes most sense when paired with
      	-- `focus_on_open = false`
      	close_on_mouse_move = true,
      }
      
    end,
  },
  {
    "Zeioth/garbage-day.nvim",
    config = function()
      
      {
        "zeioth/garbage-day.nvim",
        dependencies = "neovim/nvim-lspconfig",
        event = "VeryLazy",
        opts = {
          -- your options here
        }
      },
      
      
      require("garbage-day.utils").stop_lsp()  -- stop all lsp clients.
      require("garbage-day.utils").start_lsp() -- start lsp clients for the current buffer.
      
    end,
  },
  {
    "rachartier/tiny-inline-diagnostic.nvim",
    config = function()
      
      {
          "rachartier/tiny-inline-diagnostic.nvim",
          event = "VeryLazy",
          priority = 1000,
          config = function()
              require('tiny-inline-diagnostic').setup()
              vim.diagnostic.config({ virtual_text = false }) -- Disable default virtual text
          end
      }
      
      
      require("tiny-inline-diagnostic").setup({
          -- Style preset for diagnostic messages
          -- Available options: "modern", "classic", "minimal", "powerline", "ghost", "simple", "nonerdfont", "amongus"
          preset = "modern",
      
          -- Set the background of the diagnostic to transparent
          transparent_bg = false,
      
          -- Set the background of the cursorline to transparent (only for the first diagnostic)
          -- Default is true in the source code, not false as in the old README
          transparent_cursorline = true,
      
          hi = {
              -- Highlight group for error messages
              error = "DiagnosticError",
      
              -- Highlight group for warning messages
              warn = "DiagnosticWarn",
      
              -- Highlight group for informational messages
              info = "DiagnosticInfo",
      
              -- Highlight group for hint or suggestion messages
              hint = "DiagnosticHint",
      
              -- Highlight group for diagnostic arrows
              arrow = "NonText",
      
              -- Background color for diagnostics
              -- Can be a highlight group or a hexadecimal color (#RRGGBB)
              background = "CursorLine",
      
              -- Color blending option for the diagnostic background
              -- Use "None" or a hexadecimal color (#RRGGBB) to blend with another color
              -- Default is "Normal" in the source code
              mixing_color = "Normal",
          },
      
          options = {
              -- Display the source of the diagnostic (e.g., basedpyright, vsserver, lua_ls etc.)
              show_source = {
                  enabled = false,
                  -- Show source only when multiple sources exist for the same diagnostic
                  if_many = false,
              },
      
              -- Use icons defined in the diagnostic configuration instead of preset icons
              use_icons_from_diagnostic = false,
      
              -- Set the arrow icon to the same color as the first diagnostic severity
              set_arrow_to_diag_color = false,
      
              -- Add messages to diagnostics when multiline diagnostics are enabled
              -- If set to false, only signs will be displayed
              add_messages = true,
      
              -- Time (in milliseconds) to throttle updates while moving the cursor
              -- Increase this value for better performance on slow computers
              -- Set to 0 for immediate updates and better visual feedback
              throttle = 20,
      
              -- Minimum message length before wrapping to a new line
              softwrap = 30,
      
              -- Configuration for multiline diagnostics
              -- Can be a boolean or a table with detailed options
              multilines = {
                  -- Enable multiline diagnostic messages
                  enabled = false,
      
                  -- Always show messages on all lines for multiline diagnostics
                  always_show = false,
      
                  -- Trim whitespaces from the start/end of each line
                  trim_whitespaces = false,
      
                  -- Replace tabs with this many spaces in multiline diagnostics
                  tabstop = 4,
              },
      
              -- Display all diagnostic messages on the cursor line, not just those under cursor
              show_all_diags_on_cursorline = false,
      
              -- Enable diagnostics in Insert mode
              -- If enabled, consider setting throttle to 0 to avoid visual artifacts
              enable_on_insert = false,
      
              -- Enable diagnostics in Select mode (e.g., when auto-completing with Blink)
              enable_on_select = false,
      
              -- Manage how diagnostic messages handle overflow
              overflow = {
                  -- Overflow handling mode:
                  -- "wrap" - Split long messages into multiple lines
                  -- "none" - Do not truncate messages
                  -- "oneline" - Keep the message on a single line, even if it's long
                  mode = "wrap",
      
                  -- Trigger wrapping this many characters earlier when mode == "wrap"
                  -- Increase if the last few characters of wrapped diagnostics are obscured
                  padding = 0,
              },
      
              -- Configuration for breaking long messages into separate lines
              break_line = {
                  -- Enable breaking messages after a specific length
                  enabled = false,
      
                  -- Number of characters after which to break the line
                  after = 30,
              },
      
              -- Custom format function for diagnostic messages
              -- Function receives a diagnostic object and should return a string
              -- Example: function(diagnostic) return diagnostic.message .. " [" .. diagnostic.source .. "]" end
              format = nil,
      
              -- Virtual text display configuration
              virt_texts = {
                  -- Priority for virtual text display (higher values appear on top)
                  -- Increase if other plugins (like GitBlame) override diagnostics
                  priority = 2048,
              },
      
              -- Filter diagnostics by severity levels
              -- Available severities: vim.diagnostic.severity.ERROR, WARN, INFO, HINT
              severity = {
                  vim.diagnostic.severity.ERROR,
                  vim.diagnostic.severity.WARN,
                  vim.diagnostic.severity.INFO,
                  vim.diagnostic.severity.HINT,
              },
      
              -- Events to attach diagnostics to buffers
              -- Default: { "LspAttach" }
              -- Only change if the plugin doesn't work with your configuration
              overwrite_events = nil,
          },
      
          -- List of filetypes to disable the plugin for
          disabled_ft = {}
      })
      
      
      require("tiny-inline-diagnostic").setup({
          signs = {
              left = "",       -- Left border character
              right = "",      -- Right border character
              diag = "●",       -- Diagnostic indicator character
              arrow = "    ",   -- Arrow pointing to diagnostic
              up_arrow = "    ", -- Upward arrow for multiline
              vertical = " │",   -- Vertical line for multiline
              vertical_end = " └", -- End of vertical line for multiline
          },
          blend = {
              factor = 0.22,    -- Transparency factor (0.0 = transparent, 1.0 = opaque)
          },
      })
      
      
      local diag = require("tiny-inline-diagnostic")
      
      -- Change colors dynamically
      diag.change(blend_config, highlight_config)
      
      -- Get diagnostic under cursor (useful for statusline)
      local diagnostic = diag.get_diagnostic_under_cursor()
      
      -- Control plugin state
      diag.enable()
      diag.disable()
      diag.toggle()
      
      -- Filter by severity
      diag.change_severities({
          vim.diagnostic.severity.ERROR,
          vim.diagnostic.severity.WARN
      })
      
    end,
  },
  {
    "chrisgrieser/nvim-lsp-endhints",
    config = function()
      
      -- lazy.nvim
      {
      	"chrisgrieser/nvim-lsp-endhints",
      	event = "LspAttach",
      	opts = {}, -- required, even if empty
      },
      
      -- packer
      use {
      	"chrisgrieser/nvim-lsp-endhints",
      	config = function()
      		require("lsp-endhints").setup() -- required, even if empty
      	end,
      }
      
      
      -- default settings
      require("lsp-endhints").setup {
      	icons = {
      		type = "󰜁 ",
      		parameter = "󰏪 ",
      		offspec = " ", -- hint kind not defined in official LSP spec
      		unknown = " ", -- hint kind is nil
      	},
      	label = {
      		truncateAtChars = 20,
      		padding = 1,
      		marginLeft = 0,
      		sameKindSeparator = ", ",
      	},
      	extmark = {
      		priority = 50,
      	},
      	autoEnableHints = true,
      }
      
      
      -- inlay hints will show at the end of the line (default)
      require("lsp-endhints").enable()
      
      -- inlay hints will show as if the plugin was not installed
      require("lsp-endhints").disable()
      
      -- toggle between the two
      require("lsp-endhints").toggle()
      
      
      -- lua-ls
      require("lspconfig").lua_ls.setup {
      	settings = {
      		Lua = {
      			hint = { enable = true },
      		},
      	},
      }
      
      -- tsserver
      local inlayHints = {
      	includeInlayParameterNameHints = "all",
      	includeInlayParameterNameHintsWhenArgumentMatchesName = false,
      	includeInlayFunctionParameterTypeHints = true,
      	includeInlayVariableTypeHints = true,
      	includeInlayVariableTypeHintsWhenTypeMatchesName = false,
      	includeInlayPropertyDeclarationTypeHints = true,
      	includeInlayFunctionLikeReturnTypeHints = true,
      	includeInlayEnumMemberValueHints = true,
      }
      require("lspconfig").tsserver.setup {
      	settings = {
      		typescript = {
      			inlayHints = inlayHints,
      		},
      		javascript = {
      			inlayHints = inlayHints,
      		},
      	},
      }
      
      -- gopls
      require("lspconfig").gopls.setup {
      	settings = {
      		hints = {
      			rangeVariableTypes = true,
      			parameterNames = true,
      			constantValues = true,
      			assignVariableTypes = true,
      			compositeLiteralFields = true,
      			compositeLiteralTypes = true,
      			functionTypeParameters = true,
      		},
      	},
      }
      
      -- clangd
      require("lspconfig").clangd.setup {
      	settings = {
      		clangd = {
      			InlayHints = {
      				Designators = true,
      				Enabled = true,
      				ParameterNames = true,
      				DeducedTypes = true,
      			},
      			fallbackFlags = { "-std=c++20" },
      		},
      	},
      }
      
    end,
  },
  {
    "rachartier/tiny-code-action.nvim",
    config = function()
      
      {
          "rachartier/tiny-code-action.nvim",
          dependencies = {
              {"nvim-lua/plenary.nvim"},
      
              -- optional picker via telescope
              {"nvim-telescope/telescope.nvim"},
              -- optional picker via fzf-lua
              {"ibhagwan/fzf-lua"},
              -- .. or via snacks
              {
                "folke/snacks.nvim",
                opts = {
                  terminal = {},
                }
              }
          },
          event = "LspAttach",
          opts = {},
      }
      
      
      vim.keymap.set({ "n", "x" }, "<leader>ca", function()
      	require("tiny-code-action").code_action()
      end, { noremap = true, silent = true })
      
      
      {
          "rachartier/tiny-code-action.nvim",
          dependencies = {
              {"nvim-lua/plenary.nvim"},
          },
          event = "LspAttach",
          opts = {
            --- The backend to use, currently only "vim", "delta", "difftastic", "diffsofancy" are supported
            backend = "vim",
      
            -- The picker to use, "telescope", "snacks", "select", "buffer", "fzf-lua" are supported
            -- And it's opts that will be passed at the picker's creation, optional
            --
            -- You can also set `picker = "<picker>"` without any opts.
            picker = "telescope",
            backend_opts = {
              delta = {
                -- Header from delta can be quite large.
                -- You can remove them by setting this to the number of lines to remove
                header_lines_to_remove = 4,
      
                -- The arguments to pass to delta
                -- If you have a custom configuration file, you can set the path to it like so:
                -- args = {
                --     "--config" .. os.getenv("HOME") .. "/.config/delta/config.yml",
                -- }
                args = {
                  "--line-numbers",
                },
              },
              difftastic = {
                header_lines_to_remove = 1,
      
                -- The arguments to pass to difftastic
                args = {
                  "--color=always",
                  "--display=inline",
                  "--syntax-highlight=on",
                },
              },
              diffsofancy = {
                header_lines_to_remove = 4,
              }
            },
      
            resolve_timeout = 100, -- Timeout in milliseconds to resolve code actions
      
            -- The icons to use for the code actions
            -- You can add your own icons, you just need to set the exact action's kind of the code action
            -- You can set the highlight like so: { link = "DiagnosticError" } or  like nvim_set_hl ({ fg ..., bg..., bold..., ...})
            signs = {
              quickfix = { "", { link = "DiagnosticWarning" } },
              others = { "", { link = "DiagnosticWarning" } },
              refactor = { "", { link = "DiagnosticInfo" } },
              ["refactor.move"] = { "󰪹", { link = "DiagnosticInfo" } },
              ["refactor.extract"] = { "", { link = "DiagnosticError" } },
              ["source.organizeImports"] = { "", { link = "DiagnosticWarning" } },
              ["source.fixAll"] = { "󰃢", { link = "DiagnosticError" } },
              ["source"] = { "", { link = "DiagnosticError" } },
              ["rename"] = { "󰑕", { link = "DiagnosticWarning" } },
              ["codeAction"] = { "", { link = "DiagnosticWarning" } },
            },
         }
      }
      
      
      require("tiny-code-action").setup({
        picker = {
          "buffer",
          opts = {
            hotkeys = true, -- Enable hotkeys for quick selection of actions
            hotkeys_mode = "text_diff_based", -- Modes for generating hotkeys
            auto_preview = false, -- Enable or disable automatic preview
            auto_accept = false, -- Automatically accept the selected action
            position = "cursor", -- Position of the picker window
            winborder = "single", -- Border style for picker and preview windows
            custom_keys = {
              { key = 'm', pattern = 'Fill match arms' },
              { key = 'r', pattern = 'Rename.*' }, -- Lua pattern matching
            },
          },
        },
      })
      
      
      hotkeys_mode = function(titles, used_hotkeys)
        local t = {}
        for i = 1, #titles do t[i] = tostring(i) end
        return t
      end
      
      
      custom_keys = {
        { key = 'm', pattern = 'Fill match arms' },
        { key = 'm', pattern = 'Consider making this binding mutable: mut' },
        { key = 'r', pattern = 'Rename.*' }, -- Lua pattern matching
        { key = 'e', pattern = 'Extract Method' },
      }
      
      
      custom_keys = {
        ['e'] = "Extract Method", -- Assigning 'e' for the 'Extract Method' action
        ['r'] = "Rename", -- Assigning 'r' for the 'Rename' action
      }
      
      
      -- Listen for main window opening
      vim.api.nvim_create_autocmd("User", {
        pattern = "TinyCodeActionWindowEnterMain",
        callback = function(event)
          local buf = event.data.buf
          local win = event.data.win
          vim.notify("Code action main window opened: buf=" .. buf .. ", win=" .. win)
        end,
      })
      
      -- Listen for preview window opening
      vim.api.nvim_create_autocmd("User", {
        pattern = "TinyCodeActionWindowEnterPreview",
        callback = function(event)
          local buf = event.data.buf
          local win = event.data.win
          -- Custom logic for preview window
        end,
      })
      
      
      require("tiny-code-action").code_action({
          context = { only = "refactor" },
      })
      
      
      require("tiny-code-action").code_action({
          filters = {
              kind = "refactor",
              str = "Wrap",
              client = "omnisharp",
              line = 10,
          }
      })
      
      
      require("tiny-code-action").code_action({
          filter = function(action)
              -- Only show actions that have "Rename" in the title and are preferred
              return action.title:find("Rename") and action.isPreferred
          end,
      })
      
    end,
  },
  {
    "mawkler/refjump.nvim",
    config = function()
      
      {
        'mawkler/refjump.nvim',
        event = 'LspAttach', -- Uncomment to lazy load
        opts = {}
      }
      
      
      opts = {
        keymaps = {
          enable = true,
          next = ']r', -- Keymap to jump to next LSP reference
          prev = '[r', -- Keymap to jump to previous LSP reference
        },
        highlights = {
          enable = true, -- Highlight the LSP references on jump
          auto_clear = true, -- Automatically clear highlights when cursor moves
        },
        integrations = {
          demicolon = {
            enable = true, -- Make `]r`/`[r` repeatable with `;`/`,` using demicolon.nvim
          },
        },
        verbose = true, -- Print message if no reference is found
      }
      
    end,
  },
  {
    "alexpasmantier/pymple.nvim",
    config = function()
      
      return {
        {
          "alexpasmantier/pymple.nvim",
          dependencies = {
            "nvim-lua/plenary.nvim",
            "MunifTanjim/nui.nvim",
            -- optional (nicer ui)
            "stevearc/dressing.nvim",
            "nvim-tree/nvim-web-devicons",
          },
          build = ":PympleBuild",
          config = function()
            require("pymple").setup()
          end,
        },
      }
      
      
      use {
        "alexpasmantier/pymple.nvim",
        requires = {
          "nvim-lua/plenary.nvim",
          "MunifTanjim/nui.nvim",
          -- optional (nicer ui)
          "stevearc/dressing.nvim",
          "nvim-tree/nvim-web-devicons",
        },
        run = ":PympleBuild",
        config = function()
          require("pymple").setup()
        end,
      }
      
      
      {
        "nvim-neo-tree/neo-tree.nvim",
        opts = function(_, opts)
          local api    = require("pymple.api")
          local config = require("pymple.config")
      
          local function on_move(args)
            api.update_imports(
              args.source,
              args.destination,
              config.user_config.update_imports
            )
          end
      
          local events = require("neo-tree.events")
          opts.event_handlers = opts.event_handlers or {}
          vim.list_extend(opts.event_handlers, {
            { event = events.FILE_MOVED,   handler = on_move },
            { event = events.FILE_RENAMED, handler = on_move },
          })
        end,
      },
      
      
        -- automatically register the following keymaps on plugin setup
        keymaps = {
          -- Resolves import for symbol under cursor.
          -- This will automatically find and add the corresponding import to
          -- the top of the file (below any existing doctsring)
          resolve_import_under_cursor = {
            desc = "Resolve import under cursor",
            keys = "<leader>li"  -- feel free to change this to whatever you like
          }
        },
      
      
      default_config = {
      {
        -- options for the update imports feature
        update_imports = {
          -- the filetypes on which to run the update imports command
          -- NOTE: this should at least include "python" for the plugin to
          -- actually do anything useful
          filetypes = { "python", "markdown" }
        },
        -- options for the add import for symbol under cursor feature
        add_import_to_buf = {
          -- whether to autosave the buffer after adding the import (which will
          -- automatically format/sort the imports if you have on-save autocommands)
          autosave = true
        },
        -- automatically register the following keymaps on plugin setup
        keymaps = {
          -- Resolves import for symbol under cursor.
          -- This will automatically find and add the corresponding import to
          -- the top of the file (below any existing doctsring)
          resolve_import_under_cursor = {
            desc = "Resolve import under cursor",
            keys = "<leader>li"  -- feel free to change this to whatever you like
          }
        },
        -- logging options
        logging = {
          -- whether to log to the neovim console (only use this for debugging
          -- as it might quickly ruin your neovim experience)
          console = {
            enabled = false
          },
          -- whether or not to log to a file (default location is nvim's
          -- stdpath("data")/pymple.vlog which will typically be at
          -- `~/.local/share/nvim/pymple.vlog` on unix systems)
          file = {
            enabled = true,
            -- the maximum number of lines to keep in the log file (pymple will
            -- automatically manage this for you so you don't have to worry about
            -- the log file getting too big)
            max_lines = 1000,
            path = "/Users/alex/.local/share/nvim/pymple.vlog"
          },
          -- the log level to use
          -- (one of "trace", "debug", "info", "warn", "error", "fatal")
          level = "info"
        },
        -- python options
        python = {
          -- the names of root markers to look out for when discovering a project
          root_markers = { "pyproject.toml", "setup.py", ".git", "manage.py" },
          -- the names of virtual environment folders to look out for when
          -- discovering a project
          virtual_env_names = { ".venv" }
        }
      }
      
      
      :help pymple.txt
      
      
      require("pymple").setup({
        logging = {
          file = {
            enabled = true,
            path = vim.fn.stdpath("data") .. "/pymple.vlog",
            max_lines = 1000, -- feel free to increase this number
          },
          -- this might help in some scenarios
          console = {
            enabled = false,
          },
          level = "debug",
        },
      })
      
    end,
  },
  {
    "esmuellert/nvim-eslint",
    config = function()
      
      require('nvim-eslint').setup({})
      
      
      {
          -- Toggle debug mode for ESLint language server, see debugging part
          debug = false,
      
          -- Command to launch language server. You might hardly want to change this setting
          cmd = M.create_cmd(),
      
          -- root_dir is used by Neovim LSP client API to determine if to attach or launch new LSP
          -- The default configuration uses the git root folder as the root_dir
          -- For monorepo it can have many projects, so launching too many LSP for one workspace is not efficient
          -- You can override it with passing function(bufnr)
          -- It should receive active buffer number and return root_dir
          root_dir = M.resolve_git_dir(args.buf),
      
          -- A table used to determine what filetypes trigger the start of LSP
          filetypes = { 'javascript', 'javascriptreact', 'javascript.jsx', 'typescript', 'typescriptreact',
          'typescript.tsx', 'vue', 'svelte', 'astro'},
      
          -- The client capabilities for LSP Protocol. See Nvim LSP docs for details
          -- It uses the default Nvim LSP client capabilities. Adding the capability to dynamically change configs
          capabilities = M.make_client_capabilities(),
      
          handlers = {
              -- The handlers handles language server responses. See Nvim LSP docs for details
              -- The default handlers only has a rewrite of default "workspace/configuration" handler of Nvim LSP
              -- Basically, when you load a new buffer, ESLint LSP requests the settings with this request
              -- To make it work with monorepo, the workingDirectory setting needs to be calculated at runtime
              -- This is the main reaason for rewriting, and it also works if you have a simple structure repo
              -- You might add more custom handler with reference to LSP protocol spec and vscode-eslint code
          },
      
          -- The settings send to ESLint LSP. See below part for details.
          settings = {
              validate = 'on',
              -- packageManager = 'pnpm',
              useESLintClass = true,
              useFlatConfig = function(bufnr)
                  return M.use_flat_config(bufnr)
              end,
              experimental = { useFlatConfig = false },
              codeAction = {
                  disableRuleComment = {
                      enable = true,
                      location = 'separateLine',
                  },
                  showDocumentation = {
                      enable = true,
                  },
              },
              codeActionOnSave = { mode = 'all' },
              format = false,
              quiet = false,
              onIgnoredFiles = 'off',
              options = {},
              rulesCustomizations = {},
              run = 'onType',
              problems = { shortenToSingleLine = false },
              nodePath = function(bufnr)
                  return M.resolve_node_path()
              end,
              workingDirectory = { mode = 'location' },
              workspaceFolder = function(bufnr)
                  local git_dir = M.resolve_git_dir(bufnr)
                  return {
                      uri = vim.uri_from_fname(git_dir),
                      name = vim.fn.fnamemodify(git_dir, ':t'),
                  }
              end,
          }
      }
      
      
              function(bufnr)
                  return { directory = vim.fs.root(bufnr, {'package.json'}) }
              end
              
    end,
  },
  {
    "Fildo7525/pretty_hover",
    config = function()
      
      {
      	"Fildo7525/pretty_hover",
      	event = "LspAttach",
      	opts = {}
      },
      
      
      use {
      	"Fildo7525/pretty_hover",
      	config = function()
      		require("pretty_hover").setup({})
      	end
      }
      
      
      require("pretty_hover").hover()
      
      
      require("pretty_hover").close()
      
      
      {
      	-- Tables grouping the detected strings and using the markdown highlighters.
      	header = {
      		detect = { "[\\@]class" },
      		styler = '###',
      	},
      	line = {
      		detect = { "[\\@]brief" },
      		styler = '**',
      	},
      	listing = {
      		detect = { "[\\@]li" },
      		styler = " - ",
      	},
      	references = {
      		detect = { "[\\@]ref", "[\\@]c", "[\\@]name" },
      		styler = { "**", "`" },
      	},
      	group = {
      		detect = {
      			-- ["Group name"] = {"detectors"}
      			["Parameters"] = { "[\\@]param", "[\\@]*param*" },
      			["Types"] = { "[\\@]tparam" },
      			["See"] = { "[\\@]see" },
      			["Return Value"] = { "[\\@]retval" },
      		},
      		styler = "`",
      	},
      
      	-- Tables used for cleaner identification of hover segments.
      	code = {
      		start = { "[\\@]code" },
      		ending = { "[\\@]endcode" },
      	},
      	return_statement = {
      		"[\\@]return",
      		"[\\@]*return*",
      	},
      
      	-- Highlight groups used in the hover method. Feel free to define your own highlight group.
      	hl = {
      		error = {
      			color = "#DC2626",
      			detect = { "[\\@]error", "[\\@]bug" },
      			line = false, -- Flag detecting if the whole line should be highlighted
      		},
      		warning = {
      			color = "#FBBF24",
      			detect = { "[\\@]warning", "[\\@]thread_safety", "[\\@]throw" },
      			line = false,
      		},
      		info = {
      			color = "#2563EB",
      			detect = { "[\\@]remark", "[\\@]note", "[\\@]notes" },
      		},
      		-- Here you can set up your highlight groups.
      	},
      
      	-- If you use nvim 0.11.0 or higher you can choose, whether you want to use the new
      	-- multi lsp support or not. Otherwise this option is ignored.
      	multi_server = true,
      	border = "rounded",
      	wrap = true,
      	max_width = nil,
      	max_height = nil,
      	toggle = false,
      }
      
      
      local parsed = require("pretty_hover.parser").parse(text)
      
      
      vim.lsp.util.open_floating_preview(parsed.text, "markdown", {
      	focus = true,
      	focusable = true,
      	wrap = true,
      	wrap_at = 100,
      	max_width = 100,
      	border = "rounded",
      	focus_id = "pretty-hover-example",
      })
      
      
      {
      	completion = {
      		documentation = {
      			draw = function(opts)
      				if opts.item and opts.item.documentation and opts.item.documentation.value then
      					local out = require("pretty_hover.parser").parse(opts.item.documentation.value)
      					opts.item.documentation.value = out:string()
      				end
      
      				opts.default_implementation(opts)
      			end,
      		}
      	},
      }
      
    end,
  },
  {
    "yarospace/dev-tools.nvim",
    config = function()
      
      {
        'yarospace/dev-tools.nvim',
        dependencies = {
          "nvim-treesitter/nvim-treesitter", -- code manipulation in buffer, required
          {
            "folke/snacks.nvim", -- optional
            opts = {
              picker = { enabled = true }, -- actions picker
              terminal = { enabled = true }, -- terminal for running spec actions
            },
          },
          {
            "ThePrimeagen/refactoring.nvim", -- refactoring library, optional
            dependencies = { "nvim-lua/plenary.nvim" },
          },
        },
      
        opts = {
          ---@type Action[]|fun():Action[]
          actions = {},
      
          filetypes = { -- filetypes for which to attach the LSP
            include = {}, -- {} to include all, except for special buftypes, e.g. nofile|help|terminal|prompt
            exclude = {},
          },
        }
      }
      
      
      {
        'yarospace/dev-tools.nvim',
        dependencies = { 
          "nvim-treesitter/nvim-treesitter", -- code manipulation in buffer, required
          {
            "folke/snacks.nvim", -- optional
            opts = {
              picker = { enabled = true }, -- actions picker
              terminal = { enabled = true }, -- terminal for running spec actions
            },
          },
          {
            "ThePrimeagen/refactoring.nvim", -- refactoring library, optional
            dependencies = { "nvim-lua/plenary.nvim" },
          },
        },
      
        opts = {
          ---@type Action[]|fun():Action[]
          actions = {},
      
          filetypes = { -- filetypes for which to attach the LSP
            include = {}, -- {} to include all, except for special buftypes, e.g. nofile|help|terminal|prompt
            exclude = {},
          },
      
          builtin_actions = {
            include = {}, -- filetype/group/name of actions to include or {} to include all
            exclude = {}, -- filetype/group/name of actions to exclude or "true" to exclude all
          },
      
          action_opts = { -- override options for actions
            {
              group = "Debugging",
              name = "Log vars under cursor",
              opts = {
                keymap = nil, ---@type Keymap action keymap spec, e.g. 
                    -- { 
                    --   global = "<leader>dl" | { "<leader>dl", mode = { "n", "x" } }, 
                    --   picker = "<M-l>",
                    --   hide = true,  -- hide the action from the picker
                    -- }
              },
            },
          },
      
          ui = {
            override = true, -- override vim.ui.select, requires `snacks.nvim` to be included in dependencies or installed separately
            group_actions = true, -- group actions by group
          },
        }
      }
      
      
      local M = {
        ---@type Action[]|fun():Action[]
        actions = {},
      
        filetypes = { -- filetypes for which to attach the LSP
          include = {}, -- {} to include all, except for special buftypes, e.g. nofile|help|terminal|prompt
          exclude = {},
        },
      
        builtin_actions = {
          include = {}, -- filetype/group/name of actions to include or {} to include all
          exclude = {}, -- filetype/group/name of actions to exclude or "true" to exclude all
        },
      
        action_opts = { -- override default options for actions
          {
            group = "Debugging",
            name = "Log vars under cursor",
            opts = {
              logger = nil, ---@type function to log debug info, default dev-tools.log
              keymap = nil, ---@type Keymap action keymap spec, e.g.
              -- {
              --   global = "<leader>dl"|{ "<leader>dl", mode = { "n", "x" } },
              --   picker = "<M-l>",
              --   hide = true,  -- hide the action from the picker
              -- }
            },
          },
          {
            group = "Specs",
            name = "Watch specs",
            opts = {
              tree_cmd = nil, ---@type string command to run the file tree, default "git ls-files -cdmo --exclude-standard"
              test_cmd = nil, ---@type string command to run tests, default "nvim -l tests/minit.lua tests --shuffle-tests -v"
              test_tag = nil, ---@type string test tag, default "wip"
              terminal_cmd = nil, ---@type function to run the terminal, default is Snacks.terminal
            },
          },
          {
            group = "Todo",
            name = "Open Todo",
            opts = {
              filename = nil, ---@type string name of the todo file, default ".todo.md"
              template = nil, ---@type string[] -- template for the todo file
            },
          },
        },
      
        ui = {
          override = true, -- override vim.ui.select, requires `snacks.nvim` to be included in dependencies or installed separately
          group_actions = true, -- group actions by group
          keymaps = { filter = "<C-b>", open_group = "<C-l>", close_group = "<C-h>" },
        },
      
        debug = false, -- extra debug info
        cache = true, -- cache the actions on start
      }
      
      
      require('lspsaga').setup({
        lightbulb = { ignore = { clients = { 'dev-tools' } } }
      })
      
      require("nvim-lightbulb").setup({
       ignore = { clients = { "dev-tools" } }
      })
      
      
      ---@class ActionOpts: vim.lsp.buf.code_action.Opts
      ---@field group? string - only show actions matching this group
      ---@field name? string - only show actions matching this name
      ---@field kind? string - only show actions matching this kind
      ---@field filter? fun(x: lsp.CodeAction|lsp.Command):boolean - only show actions for which the function returns true
      ---@field apply? boolean - apply the action without opening the picker if there is only one action available
      
      
      ---@class Action
      ---@field name string - name of the action
      ---@field group string|nil - group of the action
      ---@field condition string|nil|fun(action: ActionCtx): boolean - function or pattern to match against buffer name
      ---@field filetype string[]|nil - filetype to limit the action to
      ---@field fn fun(action: ActionCtx) - function to execute the action
      
      ---@class ActionCtx: Action
      ---@field ctx Ctx - context of the action
      
      ---@class Ctx
      ---@field buf number - buffer number
      ---@field win number - window number
      ---@field row number - current line number
      ---@field col number - current column number
      ---@field line string - current line
      ---@field word string - word under cursor
      ---@field ts_node TSNode|nil - current TS node
      ---@field ts_type string|nil - type of the current TS node
      ---@field ts_range table<number, number, number, number>|nil - range of the current TS node
      ---@field bufname string - full path to file in buffer
      ---@field root string - root directory of the file
      ---@field filetype string - filetype
      ---@field range Range|nil - range of the current selection
      ---@field edit Edit - edititng functions
      
      ---@class Range
      ---@field start {line: number, character: number} - start position of the range
      ---@field end {line: number, character: number} - end position of the range
      ---@field rc table<number, number, number, number> - row/col format
      
      opts = {
        ---@type Action[]|fun():Action[]
        actions = {
          {
            name = "Extract variable",
            filetype = { "lua" },
            fn = function(action)
              local ctx = action.ctx
      
              vim.ui.input({ prompt = "Variable name:", default = "" }, function(var_name)
                if not var_name then return end
      
                local var_body = ("local %s = %s"):format(var_name, ctx.edit:get_range()[1])
      
                ctx.edit:set_range { var_name }
                ctx.edit:set_lines({ var_body }, ctx.range.rc[1], ctx.range.rc[1])
      
                ctx.edit:indent(ctx.range.rc[1] - 1, ctx.range.rc[3] + 1)
                ctx.edit:set_cursor(ctx.range.rc[1] + 2, ctx.range.rc[2] + 1)
              end)
            end,
          },
        }
      }
      
      
      ---@class Edit: Ctx
      ---@field get_lines fun(self: Edit, l_start?: number, l_end?: number): string[] - get lines in the buffer
      ---@field set_lines fun(self: Edit, lines: string[], l_start?: number, l_end?: number) - set lines in the buffer
      ---@field get_range fun(self: Edit, ls?: number, cs?: number, le?: number, ce?: number): string[] - get lines in the range of the buffer
      ---@field set_range fun(self: Edit, lines: string[], ls?: number, cs?: number, le?: number, ce?: number) - set lines in range of the buffer
      ---@field get_node fun(self: Edit, types: string|string[], node?: TSNode|nil, predicate?: fun(node: TSNode): boolean| nil): TSNode|nil, table <number, number, number, number>|nil - traverses up the tree to find the first TS node matching specified type/s
      ---@field get_previous_node fun(self: Edit, node: TSNode, allow_switch_parents?: boolean, allow_previous_parent?: boolean): TSNode|nil - get previous node with same parent
      ---@field get_node_text fun(self: Edit, node?: TSNode): string|nil - get the text of the node
      ---@field indent fun(self: Edit, l_start?: number, l_end?: number) - indent range in the buffer
      ---@field set_cursor fun(self: Edit, row?: number, col?: number) - set the cursor in the buffer
      ---@field write fun() - write the buffer
      
      
      ---@class Actions
      ---@field group string - group of actions
      ---@field filetype string[]|nil - filetype to limit the actions group to
      ---@field actions Action[]|fun(): Action[] - list oe actions
      
      ---@class Action
      ---@field name string - name of the action
      ---@field group string|nil - group of the action
      ---@field condition string|nil|fun(action: ActionCtx): boolean - function or pattern to match against buffer name
      ---@field filetype string[]|nil - filetype to limit the action to
      ---@field fn fun(action: ActionCtx) - function to execute the action
      
      ---@type Actions
      return {
        group = "Refactoring",
        filetype = { "lua" },
        actions = {
          {
            name = "Extract variable",
            condition = "_spec",
            fn = function(action)
              ---
            end,
          },
          {
            name = "Extract function",
            condition = function(action) return action.ctx.root:match("project") end,
            fn = function(action)
              --
            end,
          },
        },
      }
      
    end,
  },
  {
    "SunnyTamang/neodoc.nvim",
    config = function()
      
      use {
          'sunnytamang/neodoc.nvim',
          config = function()
              require('neodoc').setup({
                  -- your configuration here
              })
          end
      }
      
      
      {
          'sunnytamang/neodoc.nvim',
          config = function()
              require('neodoc').setup({
                  -- your configuration here
              })
          end
      }
      
      
      require('neodoc').setup({
          -- Python interpreter path (default: 'python3')
          python_interpreter = 'python3',
          
          -- Default docstring style (default: 'google')
          docstring_style = 'google',
          
          -- Enable keymaps (default: true)
          enable_keymaps = true,
          
          -- Keymap prefix (default: '<leader>d')
          keymap = '<leader>d',
          
          -- Use custom template (default: false)
          use_custom_template = false
      })
      
      
         require('neodoc').setup({
             enable_keymaps = false  -- Disable all keymaps
         })
         
      
         require('neodoc').setup({
             keymap = '<leader>g'  -- Change prefix to <leader>g
         })
         
    end,
  },
  {
    "anott03/nvim-lspinstall",
  },
  {
    "alexaandru/nvim-lspupdate",
  },
  {
    "williamboman/mason.nvim",
    config = function()
      
      require("mason").setup()
      
      
      {
          "mason-org/mason.nvim",
          opts = {}
      }
      
      
      require("mason").setup({
          ui = {
              icons = {
                  package_installed = "✓",
                  package_pending = "➜",
                  package_uninstalled = "✗"
              }
          }
      })
      
      
      {
          "mason-org/mason.nvim",
          opts = {
              ui = {
                  icons = {
                      package_installed = "✓",
                      package_pending = "➜",
                      package_uninstalled = "✗"
                  }
              }
          }
      }
      
      
      ---@class MasonSettings
      local DEFAULT_SETTINGS = {
          ---@since 1.0.0
          -- The directory in which to install packages.
          install_root_dir = path.concat { vim.fn.stdpath "data", "mason" },
      
          ---@since 1.0.0
          -- Where Mason should put its bin location in your PATH. Can be one of:
          -- - "prepend" (default, Mason's bin location is put first in PATH)
          -- - "append" (Mason's bin location is put at the end of PATH)
          -- - "skip" (doesn't modify PATH)
          ---@type '"prepend"' | '"append"' | '"skip"'
          PATH = "prepend",
      
          ---@since 1.0.0
          -- Controls to which degree logs are written to the log file. It's useful to set this to vim.log.levels.DEBUG when
          -- debugging issues with package installations.
          log_level = vim.log.levels.INFO,
      
          ---@since 1.0.0
          -- Limit for the maximum amount of packages to be installed at the same time. Once this limit is reached, any further
          -- packages that are requested to be installed will be put in a queue.
          max_concurrent_installers = 4,
      
          ---@since 1.0.0
          -- [Advanced setting]
          -- The registries to source packages from. Accepts multiple entries. Should a package with the same name exist in
          -- multiple registries, the registry listed first will be used.
          registries = {
              "github:mason-org/mason-registry",
          },
      
          ---@since 1.0.0
          -- The provider implementations to use for resolving supplementary package metadata (e.g., all available versions).
          -- Accepts multiple entries, where later entries will be used as fallback should prior providers fail.
          -- Builtin providers are:
          --   - mason.providers.registry-api  - uses the https://api.mason-registry.dev API
          --   - mason.providers.client        - uses only client-side tooling to resolve metadata
          providers = {
              "mason.providers.registry-api",
              "mason.providers.client",
          },
      
          github = {
              ---@since 1.0.0
              -- The template URL to use when downloading assets from GitHub.
              -- The placeholders are the following (in order):
              -- 1. The repository (e.g. "rust-lang/rust-analyzer")
              -- 2. The release version (e.g. "v0.3.0")
              -- 3. The asset name (e.g. "rust-analyzer-v0.3.0-x86_64-unknown-linux-gnu.tar.gz")
              download_url_template = "https://github.com/%s/releases/download/%s/%s",
          },
      
          pip = {
              ---@since 1.0.0
              -- Whether to upgrade pip to the latest version in the virtual environment before installing packages.
              upgrade_pip = false,
      
              ---@since 1.0.0
              -- These args will be added to `pip install` calls. Note that setting extra args might impact intended behavior
              -- and is not recommended.
              --
              -- Example: { "--proxy", "https://proxyserver" }
              install_args = {},
          },
      
          ui = {
              ---@since 1.0.0
              -- Whether to automatically check for new versions when opening the :Mason window.
              check_outdated_packages_on_open = true,
      
              ---@since 1.0.0
              -- The border to use for the UI window. Accepts same border values as |nvim_open_win()|.
              -- Defaults to `:h 'winborder'` if nil.
              border = nil,
      
              ---@since 1.11.0
              -- The backdrop opacity. 0 is fully opaque, 100 is fully transparent.
              backdrop = 60,
      
              ---@since 1.0.0
              -- Width of the window. Accepts:
              -- - Integer greater than 1 for fixed width.
              -- - Float in the range of 0-1 for a percentage of screen width.
              width = 0.8,
      
              ---@since 1.0.0
              -- Height of the window. Accepts:
              -- - Integer greater than 1 for fixed height.
              -- - Float in the range of 0-1 for a percentage of screen height.
              height = 0.9,
      
              icons = {
                  ---@since 1.0.0
                  -- The list icon to use for installed packages.
                  package_installed = "◍",
                  ---@since 1.0.0
                  -- The list icon to use for packages that are installing, or queued for installation.
                  package_pending = "◍",
                  ---@since 1.0.0
                  -- The list icon to use for packages that are not installed.
                  package_uninstalled = "◍",
              },
      
              keymaps = {
                  ---@since 1.0.0
                  -- Keymap to expand a package
                  toggle_package_expand = "<CR>",
                  ---@since 1.0.0
                  -- Keymap to install the package under the current cursor position
                  install_package = "i",
                  ---@since 1.0.0
                  -- Keymap to reinstall/update the package under the current cursor position
                  update_package = "u",
                  ---@since 1.0.0
                  -- Keymap to check for new version for the package under the current cursor position
                  check_package_version = "c",
                  ---@since 1.0.0
                  -- Keymap to update all installed packages
                  update_all_packages = "U",
                  ---@since 1.0.0
                  -- Keymap to check which installed packages are outdated
                  check_outdated_packages = "C",
                  ---@since 1.0.0
                  -- Keymap to uninstall a package
                  uninstall_package = "X",
                  ---@since 1.0.0
                  -- Keymap to cancel a package installation
                  cancel_installation = "<C-c>",
                  ---@since 1.0.0
                  -- Keymap to apply language filter
                  apply_language_filter = "<C-f>",
                  ---@since 1.1.0
                  -- Keymap to toggle viewing package installation log
                  toggle_package_install_log = "<CR>",
                  ---@since 1.8.0
                  -- Keymap to toggle the help view
                  toggle_help = "g?",
              },
          },
      }
      
    end,
  },
  {
    "sontungexpt/better-diagnostic-virtual-text",
    config = function()
      
      -- lazy.nvim
      {
          'sontungexpt/better-diagnostic-virtual-text',
          "LspAttach"
          config = function(_)
              require('better-diagnostic-virtual-text').setup(opts)
          end
      }
      
      -- or better ways configure in on_attach of lsp client
      -- if use this way don't need to call setup function
      {
          'sontungexpt/better-diagnostic-virtual-text',
          lazy = true,
      }
      M.on_attach = function(client, bufnr)
          -- nil can replace with the options of each buffer
      	require("better-diagnostic-virtual-text.api").setup_buf(bufnr, {})
      
          --- ... other config for lsp client
      end
      
      
      -- Can be applied to each buffer separately
      
      local default_options = {
          ui = {
              wrap_line_after = false, -- wrap the line after this length to avoid the virtual text is too long
              left_kept_space = 3, --- the number of spaces kept on the left side of the virtual text, make sure it enough to custom for each line
              right_kept_space = 3, --- the number of spaces kept on the right side of the virtual text, make sure it enough to custom for each line
              arrow = "  ",
              up_arrow = "  ",
              down_arrow = "  ",
              above = false, -- the virtual text will be displayed above the line
          },
          priority = 2003, -- the priority of virtual text
          inline = true,
      }
      
      
      --- Format line chunks for virtual text display.
      ---
      --- This function formats the line chunks for virtual text display, considering various options such as severity,
      --- underline symbol, text offsets, and parts to be removed.
      ---
      --- @param ui_opts table - The table of UI options. Should contain:
      ---     - arrow: The symbol used as the left arrow.
      ---     - up_arrow: The symbol used as the up arrow.
      ---     - down_arrow: The symbol used as the down arrow.
      ---     - left_kept_space: The space to keep on the left side.
      ---     - right_kept_space: The space to keep on the right side.
      ---     - wrap_line_after: The maximum line length to wrap after.
      --- @param line_idx number - The index of the current line (1-based). It start from the cursor line to above or below depend on the above option.
      --- @param line_msg string - The message to display on the line.
      --- @param severity number - The severity level of the diagnostic (1 = Error, 2 = Warn, 3 = Info, 4 = Hint).
      --- @param max_line_length number - The maximum length of the line.
      --- @param lasted_line boolean - Whether this is the last line of the diagnostic message. Please check line_idx == 1 to know the first line before checking lasted_line because the first line can be the lasted line if the message has only one line.
      --- @param virt_text_offset number - The offset for virtual text positioning.
      --- @param should_display_below boolean - Whether to display the virtual text below the line. If above is true, this option will be whether the virtual text should be above
      --- @param above_instead boolean - Display above or below
      --- @param removed_parts table - A table indicating which parts should be deleted and make room for message (e.g., arrow, left_kept_space, right_kept_space).
      --- @param diagnostic table - The diagnostic to display. see `:help vim.Diagnostic.` for more information.
      --- @return table - A list of formatted chunks for virtual text display.
      --- @see vim.api.nvim_buf_set_extmark
      function M.format_line_chunks(
      	ui_opts,
      	line_idx,
      	line_msg,
      	severity,
      	max_line_length,
      	lasted_line,
      	virt_text_offset,
      	should_display_below,
      	above_instead,
      	removed_parts,
      	diagnostic
      )
      	local chunks = {}
      	local first_line = line_idx == 1
      	local severity_suffix = SEVERITY_SUFFIXS[severity]
      
      	local function hls(extend_hl_groups)
      		local default_groups = {
      			"DiagnosticVirtualText" .. severity_suffix,
      			"BetterDiagnosticVirtualText" .. severity_suffix,
      		}
      		if extend_hl_groups then
      			for i, hl in ipairs(extend_hl_groups) do
      				default_groups[2 + i] = hl
      			end
      		end
      		return default_groups
      	end
      
      	local message_highlight = hls()
      
      	if should_display_below then
      		local arrow_symbol = (above_instead and ui_opts.down_arrow or ui_opts.up_arrow):match("^%s*(.*)")
      		local space_offset = space(virt_text_offset)
      		if first_line then
      			if not removed_parts.arrow then
      				tbl_insert(chunks, {
      					space_offset .. arrow_symbol,
      					hls({ "BetterDiagnosticVirtualTextArrow", "BetterDiagnosticVirtualTextArrow" .. severity_suffix }),
      				})
      			end
      		else
      			tbl_insert(chunks, {
      				space_offset .. space(strdisplaywidth(arrow_symbol)),
      				message_highlight,
      			})
      		end
      	else
      		local arrow_symbol = ui_opts.arrow
      		if first_line then
      			if not removed_parts.arrow then
      				tbl_insert(chunks, {
      					arrow_symbol,
      					hls({ "BetterDiagnosticVirtualTextArrow", "BetterDiagnosticVirtualTextArrow" .. severity_suffix }),
      				})
      			end
      		else
      			tbl_insert(chunks, {
      				space(virt_text_offset + strdisplaywidth(arrow_symbol)),
      				message_highlight,
      			})
      		end
      	end
      
      	if not removed_parts.left_kept_space then
      		local tree_symbol = "   "
      		if first_line then
      			if not lasted_line then
      				tree_symbol = above_instead and " └ " or " ┌ "
      			end
      		elseif lasted_line then
      			tree_symbol = above_instead and " ┌ " or " └ "
      		else
      			tree_symbol = " │ "
      		end
      		tbl_insert(chunks, {
      			tree_symbol,
      			hls({ "BetterDiagnosticVirtualTextTree", "BetterDiagnosticVirtualTextTree" .. severity_suffix }),
      		})
      	end
      
      	tbl_insert(chunks, {
      		line_msg,
      		message_highlight,
      	})
      
      	if not removed_parts.right_kept_space then
      		local last_space = space(max_line_length - strdisplaywidth(line_msg) + ui_opts.right_kept_space)
      		tbl_insert(chunks, { last_space, message_highlight })
      	end
      
      	return chunks
      end
      
      
      
          vim.diagnostic.enable(true, { bufnr = vim.api.nvim_get_current_buf() }) -- Enable the plugin for the current buffer.
          vim.diagnostic.enable(false, { bufnr = vim.api.nvim_get_current_buf() }) -- Disable the plugin for the current buffer.
      
      
      local meta_pairs = function(t)
        local metatable = getmetatable(t)
        if metatable and metatable.__pairs then
            return metatable.__pairs(t)
        end
        return pairs(t)
      end
      
      
      require("better-diagnostic-virtual-text.api").foreach_line(bufnr, function(line, diagnostics)
        for _, diagnostic in meta_pairs(diagnostics) do
          print(diagnostic.message)
        end
      end)
      
    end,
  },
  {
    "onsails/diaglist.nvim",
    config = function()
      
      lua require("diaglist").init({
          -- optional settings
          -- below are defaults
          debug = false, 
      
          -- increase for noisy servers
          debounce_ms = 150,
      })
      
    end,
  },
  {
    "folke/trouble.nvim",
    config = function()
      
      {
        "folke/trouble.nvim",
        opts = {}, -- for default options, refer to the configuration section for custom setup.
        cmd = "Trouble",
        keys = {
          {
            "<leader>xx",
            "<cmd>Trouble diagnostics toggle<cr>",
            desc = "Diagnostics (Trouble)",
          },
          {
            "<leader>xX",
            "<cmd>Trouble diagnostics toggle filter.buf=0<cr>",
            desc = "Buffer Diagnostics (Trouble)",
          },
          {
            "<leader>cs",
            "<cmd>Trouble symbols toggle focus=false<cr>",
            desc = "Symbols (Trouble)",
          },
          {
            "<leader>cl",
            "<cmd>Trouble lsp toggle focus=false win.position=right<cr>",
            desc = "LSP Definitions / references / ... (Trouble)",
          },
          {
            "<leader>xL",
            "<cmd>Trouble loclist toggle<cr>",
            desc = "Location List (Trouble)",
          },
          {
            "<leader>xQ",
            "<cmd>Trouble qflist toggle<cr>",
            desc = "Quickfix List (Trouble)",
          },
        },
      }
      
      
      ---@class trouble.Mode: trouble.Config,trouble.Section.spec
      ---@field desc? string
      ---@field sections? string[]
      
      ---@class trouble.Config
      ---@field mode? string
      ---@field config? fun(opts:trouble.Config)
      ---@field formatters? table<string,trouble.Formatter> custom formatters
      ---@field filters? table<string, trouble.FilterFn> custom filters
      ---@field sorters? table<string, trouble.SorterFn> custom sorters
      local defaults = {
        auto_close = false, -- auto close when there are no items
        auto_open = false, -- auto open when there are items
        auto_preview = true, -- automatically open preview when on an item
        auto_refresh = true, -- auto refresh when open
        auto_jump = false, -- auto jump to the item when there's only one
        focus = false, -- Focus the window when opened
        restore = true, -- restores the last location in the list when opening
        follow = true, -- Follow the current item
        indent_guides = true, -- show indent guides
        max_items = 200, -- limit number of items that can be displayed per section
        multiline = true, -- render multi-line messages
        pinned = false, -- When pinned, the opened trouble window will be bound to the current buffer
        warn_no_results = true, -- show a warning when there are no results
        open_no_results = false, -- open the trouble window when there are no results
        ---@type trouble.Window.opts
        win = {}, -- window options for the results window. Can be a split or a floating window.
        -- Window options for the preview window. Can be a split, floating window,
        -- or `main` to show the preview in the main editor window.
        ---@type trouble.Window.opts
        preview = {
          type = "main",
          -- when a buffer is not yet loaded, the preview window will be created
          -- in a scratch buffer with only syntax highlighting enabled.
          -- Set to false, if you want the preview to always be a real loaded buffer.
          scratch = true,
        },
        -- Throttle/Debounce settings. Should usually not be changed.
        ---@type table<string, number|{ms:number, debounce?:boolean}>
        throttle = {
          refresh = 20, -- fetches new data when needed
          update = 10, -- updates the window
          render = 10, -- renders the window
          follow = 100, -- follows the current item
          preview = { ms = 100, debounce = true }, -- shows the preview for the current item
        },
        -- Key mappings can be set to the name of a builtin action,
        -- or you can define your own custom action.
        ---@type table<string, trouble.Action.spec|false>
        keys = {
          ["?"] = "help",
          r = "refresh",
          R = "toggle_refresh",
          q = "close",
          o = "jump_close",
          ["<esc>"] = "cancel",
          ["<cr>"] = "jump",
          ["<2-leftmouse>"] = "jump",
          ["<c-s>"] = "jump_split",
          ["<c-v>"] = "jump_vsplit",
          -- go down to next item (accepts count)
          -- j = "next",
          ["}"] = "next",
          ["]]"] = "next",
          -- go up to prev item (accepts count)
          -- k = "prev",
          ["{"] = "prev",
          ["[["] = "prev",
          dd = "delete",
          d = { action = "delete", mode = "v" },
          i = "inspect",
          p = "preview",
          P = "toggle_preview",
          zo = "fold_open",
          zO = "fold_open_recursive",
          zc = "fold_close",
          zC = "fold_close_recursive",
          za = "fold_toggle",
          zA = "fold_toggle_recursive",
          zm = "fold_more",
          zM = "fold_close_all",
          zr = "fold_reduce",
          zR = "fold_open_all",
          zx = "fold_update",
          zX = "fold_update_all",
          zn = "fold_disable",
          zN = "fold_enable",
          zi = "fold_toggle_enable",
          gb = { -- example of a custom action that toggles the active view filter
            action = function(view)
              view:filter({ buf = 0 }, { toggle = true })
            end,
            desc = "Toggle Current Buffer Filter",
          },
          s = { -- example of a custom action that toggles the severity
            action = function(view)
              local f = view:get_filter("severity")
              local severity = ((f and f.filter.severity or 0) + 1) % 5
              view:filter({ severity = severity }, {
                id = "severity",
                template = "{hl:Title}Filter:{hl} {severity}",
                del = severity == 0,
              })
            end,
            desc = "Toggle Severity Filter",
          },
        },
        ---@type table<string, trouble.Mode>
        modes = {
          -- sources define their own modes, which you can use directly,
          -- or override like in the example below
          lsp_references = {
            -- some modes are configurable, see the source code for more details
            params = {
              include_declaration = true,
            },
          },
          -- The LSP base mode for:
          -- * lsp_definitions, lsp_references, lsp_implementations
          -- * lsp_type_definitions, lsp_declarations, lsp_command
          lsp_base = {
            params = {
              -- don't include the current location in the results
              include_current = false,
            },
          },
          -- more advanced example that extends the lsp_document_symbols
          symbols = {
            desc = "document symbols",
            mode = "lsp_document_symbols",
            focus = false,
            win = { position = "right" },
            filter = {
              -- remove Package since luals uses it for control flow structures
              ["not"] = { ft = "lua", kind = "Package" },
              any = {
                -- all symbol kinds for help / markdown files
                ft = { "help", "markdown" },
                -- default set of symbol kinds
                kind = {
                  "Class",
                  "Constructor",
                  "Enum",
                  "Field",
                  "Function",
                  "Interface",
                  "Method",
                  "Module",
                  "Namespace",
                  "Package",
                  "Property",
                  "Struct",
                  "Trait",
                },
              },
            },
          },
        },
        -- stylua: ignore
        icons = {
          ---@type trouble.Indent.symbols
          indent = {
            top           = "│ ",
            middle        = "├╴",
            last          = "└╴",
            -- last          = "-╴",
            -- last       = "╰╴", -- rounded
            fold_open     = " ",
            fold_closed   = " ",
            ws            = "  ",
          },
          folder_closed   = " ",
          folder_open     = " ",
          kinds = {
            Array         = " ",
            Boolean       = "󰨙 ",
            Class         = " ",
            Constant      = "󰏿 ",
            Constructor   = " ",
            Enum          = " ",
            EnumMember    = " ",
            Event         = " ",
            Field         = " ",
            File          = " ",
            Function      = "󰊕 ",
            Interface     = " ",
            Key           = " ",
            Method        = "󰊕 ",
            Module        = " ",
            Namespace     = "󰦮 ",
            Null          = " ",
            Number        = "󰎠 ",
            Object        = " ",
            Operator      = " ",
            Package       = " ",
            Property      = " ",
            String        = " ",
            Struct        = "󰆼 ",
            TypeParameter = " ",
            Variable      = "󰀫 ",
          },
        },
      }
      
      
      -- Opens trouble with the given mode.
      -- If a view is already open with the same mode,
      -- it will be focused unless `opts.focus = false`.
      -- When a view is already open and `opts.new = true`,
      -- a new view will be created.
      ---@param opts? trouble.Mode | { new?: boolean, refresh?: boolean } | string
      ---@return trouble.View?
      require("trouble").open(opts)
      
      -- Closes the last open view matching the filter.
      ---@param opts? trouble.Mode|string
      ---@return trouble.View?
      require("trouble").close(opts)
      
      -- Toggle the view with the given mode.
      ---@param opts? trouble.Mode|string
      ---@return trouble.View?
      require("trouble").toggle(opts)
      
      -- Returns true if there is an open view matching the mode.
      ---@param opts? trouble.Mode|string
      require("trouble").is_open(opts)
      
      -- Refresh all open views. Normally this is done automatically,
      -- unless you disabled auto refresh.
      ---@param opts? trouble.Mode|string
      require("trouble").refresh(opts)
      
      -- Get all items from the active view for a given mode.
      ---@param opts? trouble.Mode|string
      require("trouble").get_items(opts)
      
      -- Renders a trouble list as a statusline component.
      -- Check the docs for examples.
      ---@param opts? trouble.Mode|string|{hl_group?:string}
      ---@return {get: (fun():string), has: (fun():boolean)}
      require("trouble").statusline(opts)
      
      -- Closes the preview and goes to the main window.
      -- The Trouble window is not closed.
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").cancel(opts)
      
      -- Open the preview
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").delete(opts)
      
      -- filter
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").filter(opts)
      
      -- Go to the first item
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").first(opts)
      
      -- Focus the trouble window
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").focus(opts)
      
      -- Fold close 
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").fold_close(opts)
      
      -- fold close all
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").fold_close_all(opts)
      
      -- Fold close recursive
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").fold_close_recursive(opts)
      
      -- fold disable
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").fold_disable(opts)
      
      -- fold enable
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").fold_enable(opts)
      
      -- fold more
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").fold_more(opts)
      
      -- Fold open 
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").fold_open(opts)
      
      -- fold open all
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").fold_open_all(opts)
      
      -- Fold open recursive
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").fold_open_recursive(opts)
      
      -- fold reduce
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").fold_reduce(opts)
      
      -- Fold toggle 
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").fold_toggle(opts)
      
      -- fold toggle enable
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").fold_toggle_enable(opts)
      
      -- Fold toggle recursive
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").fold_toggle_recursive(opts)
      
      -- fold update
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").fold_update(opts)
      
      -- fold update all
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").fold_update_all(opts)
      
      -- Show the help
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").help(opts)
      
      -- Dump the item to the console
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").inspect(opts)
      
      -- Jump to the item if on an item, otherwise fold the node
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").jump(opts)
      
      -- Jump to the item and close the trouble window
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").jump_close(opts)
      
      -- Jump to the item if on an item, otherwise do nothing
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").jump_only(opts)
      
      -- Open the item in a split
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").jump_split(opts)
      
      -- Open the item in a split and close the trouble window
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").jump_split_close(opts)
      
      -- Open the item in a vsplit
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").jump_vsplit(opts)
      
      -- Open the item in a vsplit and close the trouble window
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").jump_vsplit_close(opts)
      
      -- Go to the last item
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").last(opts)
      
      -- Go to the next item
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").next(opts)
      
      -- Go to the previous item
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").prev(opts)
      
      -- Open the preview
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").preview(opts)
      
      -- Refresh the trouble source
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").refresh(opts)
      
      -- Toggle the preview
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").toggle_preview(opts)
      
      -- Toggle the auto refresh
      ---@param opts? trouble.Mode | { new? : boolean } | string
      ---@return trouble.View
      require("trouble").toggle_refresh(opts)
      
      
      local actions = require("telescope.actions")
      local open_with_trouble = require("trouble.sources.telescope").open
      
      -- Use this to add more results without clearing the trouble list
      local add_to_trouble = require("trouble.sources.telescope").add
      
      local telescope = require("telescope")
      
      telescope.setup({
        defaults = {
          mappings = {
            i = { ["<c-t>"] = open_with_trouble },
            n = { ["<c-t>"] = open_with_trouble },
          },
        },
      })
      
      
      local config = require("fzf-lua.config")
      local actions = require("trouble.sources.fzf").actions
      config.defaults.actions.files["ctrl-t"] = actions.open
      
      
      {
        "nvim-lualine/lualine.nvim",
        opts = function(_, opts)
          local trouble = require("trouble")
          local symbols = trouble.statusline({
            mode = "lsp_document_symbols",
            groups = {},
            title = false,
            filter = { range = true },
            format = "{kind_icon}{symbol.name:Normal}",
            -- The following line is needed to fix the background color
            -- Set it to the lualine section you want to use
            hl_group = "lualine_c_normal",
          })
          table.insert(opts.sections.lualine_c, {
            symbols.get,
            cond = symbols.has,
          })
        end,
      }
      
    end,
  },
  {
    "piersolenski/wtf.nvim",
    config = function()
      
      {
        "piersolenski/wtf.nvim",
        dependencies = {
          "nvim-lua/plenary.nvim",
          "MunifTanjim/nui.nvim",
          -- Optional: For WtfGrepHistory (pick one)
          "nvim-telescope/telescope.nvim",
          -- "folke/snacks.nvim",
          -- "ibhagwan/fzf-lua",
        },
        opts = {},
        keys = {
          {
            "<leader>wd",
            mode = { "n", "x" },
            function()
              require("wtf").diagnose()
            end,
            desc = "Debug diagnostic with AI",
          },
          {
            "<leader>wf",
            mode = { "n", "x" },
            function()
              require("wtf").fix()
            end,
            desc = "Fix diagnostic with AI",
          },
          {
            mode = { "n" },
            "<leader>ws",
            function()
              require("wtf").search()
            end,
            desc = "Search diagnostic with Google",
          },
          {
            mode = { "n" },
            "<leader>wp",
            function()
              require("wtf").pick_provider()
            end,
            desc = "Pick provider",
          },
          {
            mode = { "n" },
            "<leader>wh",
            function()
              require("wtf").history()
            end,
            desc = "Populate the quickfix list with previous chat history",
          },
          {
            mode = { "n" },
            "<leader>wg",
            function()
              require("wtf").grep_history()
            end,
            desc = "Grep previous chat history with Telescope",
          },
        },
      }
      
      
      use({
        "piersolenski/wtf.nvim",
        config = function()
          require("wtf").setup()
        end,
        requires = {
          "nvim-lua/plenary.nvim",
          "MunifTanjim/nui.nvim",
          -- Optional: For WtfGrepHistory (pick one)
          "nvim-telescope/telescope.nvim",
          -- "folke/snacks.nvim",
          -- "ibhagwan/fzf-lua",
        },
      })
      
      
      {
        -- Directory for storing chat files
        chat_dir = vim.fn.stdpath("data"):gsub("/$", "") .. "/wtf/chats",
        -- Default AI popup type
        popup_type = "popup" | "horizontal" | "vertical",
        -- The default provider
        provider = "anthropic" | "copilot" | "deepseek" | "gemini" | "grok" | "ollama" | "openai",
        -- Configure providers
        providers = {
          anthropic = {
            -- An alternative way to set your API key
            api_key = "32lkj23sdjke223ksdlfk" | function() os.getenv("API_KEY") end,
            -- Your preferred model
            model_id = "claude-3-5-sonnet-20241022",
          },
        },
        -- Set your preferred language for the response
        language = "english",
        -- Any additional instructions
        additional_instructions = "Start the reply with 'OH HAI THERE'",
        -- Default search engine, can be overridden by passing an option to WtfSeatch
        search_engine = "google" | "duck_duck_go" | "stack_overflow" | "github" | "phind" | "perplexity",
        -- Picker for history search (telescope, snacks, or fzf-lua)
        picker = "telescope" | "snacks" | "fzf-lua",
        -- Callbacks
        hooks = {
          request_started = nil,
          request_finished = nil,
        },
        -- Add custom colours
        winhighlight = "Normal:Normal,FloatBorder:FloatBorder",
      }
      
      
      hooks = {
          request_started = function()
              vim.cmd("hi StatusLine ctermbg=NONE ctermfg=yellow")
          end,
          request_finished = function()
              vim.cmd("hi StatusLine ctermbg=NONE ctermfg=NONE")
          end,
      },
      
      
      local wtf = require("wtf")
      
      require("lualine").setup({
        sections = {
          lualine_x = { wtf.get_status },
        },
      })
      
    end,
  },
  {
    "chrisgrieser/nvim-rulebook",
    config = function()
      
      -- lazy.nvim
      { "chrisgrieser/nvim-rulebook" },
      
      -- packer
      use { "chrisgrieser/nvim-rulebook" }
      
      
      require("rulebook").ignoreRule()
      require("rulebook").prettifyError()
      require("rulebook").yankDiagnosticCode()
      require("rulebook").suppressFormatter()
      require("rulebook").prettifyError()
      
      
      -- snippets to create keymaps, for your convenience
      vim.keymap.set("n", "<leader>ri", function() require("rulebook").ignoreRule() end)
      vim.keymap.set("n", "<leader>rl", function() require("rulebook").lookupRule() end)
      vim.keymap.set("n", "<leader>ry", function() require("rulebook").yankDiagnosticCode() end)
      vim.keymap.set({ "n", "x" }, "<leader>rf", function() require("rulebook").suppressFormatter() end)
      
      vim.api.nvim_create_autocmd("Filetype", {
      	pattern = { "typescript", "javascript" },
      	group = vim.api.nvim_create_augroup("rulebook.prettify-ts-error", { clear = true }),
      	callback = function(ctx)
      		vim.keymap.set(
      			"n",
      			"<leader>rp",
      			function() require("rulebook").prettifyError() end,
      			{ buffer = ctx.buf }
      		)
      	end,
      })
      
      
      require("rulebook").setup = ({
      	-- if no diagnostic is found in the current line, search this many lines forward
      	forwSearchLines = 10,
      
      	ignoreComments = {
      		shellcheck = {
      			comment = "# shellcheck disable=%s",
      			location = "prevLine",
      			multiRuleIgnore = true,
      			multiRuleSeparator = ",",
      		},
      		-- ... (a full list of sources with builtin support can be found in the README)
      
      		yourCustomSource = { -- exact, case-sensitive source-name
      			---@type string|fun(vim.Diagnostic): string if string, "%s" will be replaced with the rule id
      			comment = "// disabling-comment %s",
      
      			---@type "prevLine"|"sameLine"|"encloseLine"|"inlineBeforeDiagnostic"|fun(vim.Diagnostic): string
      			location = "sameLine",
      
      			-- whether multiple rules can be ignored with one comment, defaults to `false`
      			multiRuleIgnore = true,
      
      			-- separator for multiple rule-ids, defaults to ", " (with space)
      			multiRuleSeparator = ",",
      		}
      
      		-- if location is `encloseLine`, the comment needs to be a list of two strings
      		anotherCustomSource = {
      			location = "encloseLine",
      			comment = { 
      				"// disable-rule %s", 
      				"// enable-rule %s",
      			},
      		}
      	},
      
      	ruleDocs = {
      		selene = "https://kampfkarren.github.io/selene/lints/%s.html"
      		-- ... (a full list of sources with builtin support can be found in the README)
      
      		-- Search URL when no documentation definition is available for a
      		-- diagnostic source. `%s` will be replaced with the diagnostic source and 
      		-- the code/message.
      		fallback = "https://www.google.com/search?q=%s",
      
      		-- the key must be named exactly like `diagnostic.source` (case-sensitive!)
      		-- * string: `%s` will be replaced with the rule id
      		-- * function: will be called with the diagnostic object
      		-- * `false`: disable rule docs, will use the fallback
      		---@type string|false|fun(diag: vim.Diagnostic): string?
      		yourCustomSource = "https://my-docs/%s.hthml",
      		anotherCustomSource = function(diag)
      			-- ...
      			return url
      		end,
      	}
      
      	suppressFormatter = {
      		lua = {
      			-- used for normal mode
      			ignoreBlock = "-- stylua: ignore",
      
      			---@type "prevLine"|"sameLine"|"encloseLine"|fun(): string
      			location = "prevLine",
      
      			-- used for visual mode
      			ignoreRange = { "-- stylua: ignore start", "-- stylua: ignore end" },
      		},
      	}
      
      	prettifyError = {
      		---@type fun(vim.Diagnostic): string[]
      		typescript = function(diag)
            -- ...
      		end,
      	}
      })
      
      
      -- example: use `disable-line` instead of the default `disable-next-line` for eslint
      require("rulebook").setup = {
      	ignoreComments = {
      		eslint = {
      			comment = "// eslint-disable-line %s",
      			location = "sameLine",
      		},
      	},
      }
      
      
      -- example: configuring efm langserver for `markdownlint` in `/lsp/efm.lua`
      return {
      	filetypes = { "markdown" },
      	settings = {
      		languages = {
      			markdown = {
      				{
      					lintSource = "markdownlint",
      					lintCommand = "markdownlint $'{INPUT}'",
      					lintStdin = false,
      					lintIgnoreExitCode = true,
      					lintFormats = {
      						"%f:%l:%c MD%n/%m",
      						"%f:%l MD%n/%m",
      					},
      				},
      			},
      		},
      	},
      }
      
      
      -- example to use ChatGPT for rule lookup
      require("rulebook").setup = ({
      	ruleDocs = {
      		fallback = "https://chatgpt.com/?q=Explain%20the%20following%20diagnostic%20error%3A%20%s"
      
      		-- To use `fallback` instead of the builtin rule docs, overwrite the
      		-- builtin one with `false`.
      		typescript = false,
      	}
      })
      
      
      vim.diagnostic.config {
      	virtual_text = {
      		suffix = function(diag) return require("rulebook").hasDocs(diag) and "  " or "" end,
      	},
      }
      
    end,
  },
  {
    "artemave/workspace-diagnostics.nvim",
    config = function()
      
      use {"artemave/workspace-diagnostics.nvim"}
      
      
      Plug "artemave/workspace-diagnostics.nvim"
      
      
      require("lazy").setup({"artemave/workspace-diagnostics.nvim"})
      
      
      require('lspconfig').tsserver.setup({
        on_attach = function(client, bufnr)
                      ...
                      require("workspace-diagnostics").populate_workspace_diagnostics(client, bufnr)
                      ...
                    end
      })
      
      
      vim.api.nvim_set_keymap('n', '<space>x', '', {
        noremap = true,
        callback = function()
          for _, client in ipairs(vim.lsp.buf_get_clients()) do
            require("workspace-diagnostics").populate_workspace_diagnostics(client, 0)
          end
        end
      })
      
      
      require("workspace-diagnostics").setup({
        workspace_files = function()
          return { 'index.js', 'lib/banana.js' }
        end
      })
      
      
      require("roslyn").setup({
        config = {
          filetypes = { 'cs' },
        },
      })
      
    end,
  },
  {
    "ms-jpq/coq_nvim",
    config = function()
      
      local coq = require "coq" -- add this
      
      -- legacy style
      local lsp = require "lspconfig"
      lsp.<server>.setup(<stuff...>)                              -- before
      lsp.<server>.setup(coq.lsp_ensure_capabilities(<stuff...>)) -- after
      
      -- new style
      vim.lsp.config(<server>, <stuff...>)                              -- before
      vim.lsp.config(<server>, coq.lsp_ensure_capabilities(<stuff...>)) -- after
      vim.lsp.enable(<server>)
      
      
        {
          "neovim/nvim-lspconfig", -- REQUIRED: for native Neovim LSP integration
          lazy = false, -- REQUIRED: tell lazy.nvim to start this plugin at startup
          dependencies = {
            -- main one
            { "ms-jpq/coq_nvim", branch = "coq" },
        
            -- 9000+ Snippets
            { "ms-jpq/coq.artifacts", branch = "artifacts" },
        
            -- lua & third party sources -- See https://github.com/ms-jpq/coq.thirdparty
            -- Need to **configure separately**
            { 'ms-jpq/coq.thirdparty', branch = "3p" }
            -- - shell repl
            -- - nvim lua api
            -- - scientific calculator
            -- - comment banner
            -- - etc
          },
          init = function()
            vim.g.coq_settings = {
                auto_start = true, -- if you want to start COQ at startup
                -- Your COQ settings here
            }
          end,
          config = function()
            -- Your LSP settings here
          end,
        }
        
    end,
  },
  {
    "hrsh7th/nvim-cmp",
  },
  {
    "lukas-reineke/cmp-under-comparator",
    config = function()
      
      -- init.lua
      require("packer").startup(
          function()
              use "lukas-reineke/cmp-under-comparator"
          end
      )
      
      
      local cmp = require "cmp"
      cmp.setup {
          -- ... rest of your setup ...
      
          sorting = {
              comparators = {
                  cmp.config.compare.offset,
                  cmp.config.compare.exact,
                  cmp.config.compare.score,
                  require "cmp-under-comparator".under,
                  cmp.config.compare.kind,
                  cmp.config.compare.sort_text,
                  cmp.config.compare.length,
                  cmp.config.compare.order,
              },
          },
      }
      
    end,
  },
  {
    "SergioRibera/cmp-dotenv",
    config = function()
      
      require("cmp").setup {
          sources = {
              { name = "dotenv" }
          }
      }
      
      
      local cmp = require("cmp")
      
      cmp.setup {
          sources = {
              {
                name = "dotenv",
                -- Defaults
                option = {
                  path = '.',
                  load_shell = true,
                  item_kind = cmp.lsp.CompletionItemKind.Variable,
                  eval_on_confirm = false,
                  show_documentation = true,
                  show_content_on_docs = true,
                  documentation_kind = 'markdown',
                  dotenv_environment = '.*',
                  file_priority = function(a, b)
                    -- Prioritizing local files
                    return a:upper() < b:upper()
                  end,
                }
              }
          }
      }
      
      
      local dotenv = require('cmp-dotenv.dotenv')
      
      -- Get the variable you want by name or
      -- get the default value in case it does not exist.
      dotenv.get_env_variable(name, default)
      
      -- Get all variables that have been loaded
      dotenv.get_all_env()
      
      -- You can set a variable to the auto-completion system and
      -- find it available throughout the Neovim environment.
      -- You can pass it a documentation in the format
      -- you have configured or not pass it at all.
      dotenv.set_env_variable(name, value, docs or nil)
      
      -- This loads all the environment variables according to the
      -- configuration you have from the files or the shell,
      -- I do not recommend calling this function as it is
      -- usually called by default by cmp.
      dotenv.load(force, options)
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-completion.md",
  },
  {
    "deathbeam/autocomplete.nvim",
    config = function()
      
      -- LSP signature help
      require("autocomplete.signature").setup {
          border = nil, -- Signature help border style
          width = 80, -- Max width of signature window
          height = 25, -- Max height of signature window
          debounce_delay = 100
      }
      
      -- buffer autocompletion with LSP and Tree-sitter
      require("autocomplete.buffer").setup {
          border = nil, -- Documentation border style
          entry_mapper = nil, -- Custom completion entry mapper
          debounce_delay = 100,
      }
      
      -- cmdline autocompletion
      require("autocomplete.cmd").setup()
      
      
      vim.o.completeopt = 'menuone,noselect,noinsert,popup'
      
      
      -- Here we grab default Neovim capabilities and extend them with ones we want on top
      local capabilities = vim.tbl_deep_extend('force', 
          vim.lsp.protocol.make_client_capabilities(), 
          require('autocomplete.capabilities')
      )
      
      -- Now set capabilities on your LSP servers
      require('lspconfig')['<YOUR_LSP_SERVER>'].setup {
          capabilities = capabilities
      }
      
    end,
  },
  {
    "Saghen/blink.cmp",
  },
  {
    "zbirenbaum/copilot.lua",
    config = function()
      
      use { "zbirenbaum/copilot.lua" 
        requires = {
          "copilotlsp-nvim/copilot-lsp", -- (optional) for NES functionality
        },
      }
      
      
      use {
        "zbirenbaum/copilot.lua",
        requires = {
          "copilotlsp-nvim/copilot-lsp", -- (optional) for NES functionality
        },
        cmd = "Copilot",
        event = "InsertEnter",
        config = function()
          require("copilot").setup({})
        end,
      }
      
      
      require('copilot').setup({
        panel = {
          enabled = true,
          auto_refresh = false,
          keymap = {
            jump_prev = "[[",
            jump_next = "]]",
            accept = "<CR>",
            refresh = "gr",
            open = "<M-CR>"
          },
          layout = {
            position = "bottom", -- | top | left | right | bottom |
            ratio = 0.4
          },
        },
        suggestion = {
          enabled = true,
          auto_trigger = false,
          hide_during_completion = true,
          debounce = 75,
          trigger_on_accept = true,
          keymap = {
            accept = "<M-l>",
            accept_word = false,
            accept_line = false,
            next = "<M-]>",
            prev = "<M-[>",
            dismiss = "<C-]>",
          },
        },
        nes = {
          enabled = false, -- requires copilot-lsp as a dependency
          auto_trigger = false,
          keymap = {
            accept_and_goto = false,
            accept = false,
            dismiss = false,
          },
        },
        auth_provider_url = nil, -- URL to authentication provider, if not "https://github.com/"
        logger = {
          file = vim.fn.stdpath("log") .. "/copilot-lua.log",
          file_log_level = vim.log.levels.OFF,
          print_log_level = vim.log.levels.WARN,
          trace_lsp = "off", -- "off" | "messages" | "verbose"
          trace_lsp_progress = false,
          log_lsp_messages = false,
        },
        copilot_node_command = 'node', -- Node.js version must be > 20
        workspace_folders = {},
        copilot_model = "",
        disable_limit_reached_message = false,  -- Set to `true` to suppress completion limit reached popup
        root_dir = function()
          return vim.fs.dirname(vim.fs.find(".git", { upward = true })[1])
        end,
        should_attach = function(_, _)
          if not vim.bo.buflisted then
            logger.debug("not attaching, buffer is not 'buflisted'")
            return false
          end
      
          if vim.bo.buftype ~= "" then
            logger.debug("not attaching, buffer 'buftype' is " .. vim.bo.buftype)
            return false
          end
      
          return true
        end,
        server = {
          type = "nodejs", -- "nodejs" | "binary"
          custom_server_filepath = nil,
        },
        server_opts_overrides = {},
      })
      
      
      require("copilot.panel").accept()
      require("copilot.panel").jump_next()
      require("copilot.panel").jump_prev()
      require("copilot.panel").open({position, ratio})
      require("copilot.panel").close()
      require("copilot.panel").toggle()
      require("copilot.panel").refresh()
      require("copilot.panel").is_open()
      
      
      cmp.event:on("menu_opened", function()
        vim.b.copilot_suggestion_hidden = true
      end)
      
      cmp.event:on("menu_closed", function()
        vim.b.copilot_suggestion_hidden = false
      end)
      
      
      vim.api.nvim_create_autocmd("User", {
        pattern = "BlinkCmpMenuOpen",
        callback = function()
          vim.b.copilot_suggestion_hidden = true
        end,
      })
      
      vim.api.nvim_create_autocmd("User", {
        pattern = "BlinkCmpMenuClose",
        callback = function()
          vim.b.copilot_suggestion_hidden = false
        end,
      })
      
      
      
      require("copilot.suggestion").is_visible()
      require("copilot.suggestion").accept(modifier)
      require("copilot.suggestion").accept_word()
      require("copilot.suggestion").accept_line()
      require("copilot.suggestion").next()
      require("copilot.suggestion").prev()
      require("copilot.suggestion").clear_preview()
      require("copilot.suggestion").update_preview()
      require("copilot.suggestion").dismiss()
      require("copilot.suggestion").toggle_auto_trigger()
      
      
      use {
        "zbirenbaum/copilot.lua",
        requires = {
          "copilotlsp-nvim/copilot-lsp",
          init = function()
            vim.g.copilot_nes_debounce = 500
          end,
        },
        cmd = "Copilot",
        event = "InsertEnter",
        config = function()
          require("copilot").setup({
            nes = {
              enabled = true,
              keymap = {
                accept_and_goto = "<leader>p",
                accept = false,
                dismiss = "<Esc>",
              },
            },
          })
        end,
      }
      
      
      require("copilot").setup {
        filetypes = {
          markdown = true, -- overrides default
          terraform = false, -- disallow specific filetype
          sh = function ()
            if string.match(vim.fs.basename(vim.api.nvim_buf_get_name(0)), '^%.env.*') then
              -- disable for .env files
              return false
            end
            return true
          end,
        },
      }
      
      
      require("copilot").setup {
        filetypes = {
          javascript = true, -- allow specific filetype
          typescript = true, -- allow specific filetype
          ["*"] = false, -- disable for all other filetypes and ignore default `filetypes`
        },
      }
      
      
      vim.log = {
        levels = {
          TRACE = 0,
          DEBUG = 1,
          INFO = 2,
          WARN = 3,
          ERROR = 4,
          OFF = 5,
        },
      }
      
      
      copilot_node_command = vim.fn.expand("$HOME") .. "/.config/nvm/versions/node/v20.0.1/bin/node", -- Node.js version must be > 20
      
      
      require("copilot").setup {
        server_opts_overrides = {
          trace = "verbose",
          settings = {
            advanced = {
              listCount = 10, -- #completions for panel
              inlineSuggestCount = 3, -- #completions for getCompletions
            }
          },
        }
      }
      
      
      workspace_folders = {
        "/home/user/gits",
        "/home/user/projects",
      }
      
      
      require("copilot").setup {
        should_attach = function(_, bufname)
          if string.match(bufname, "env") then
            return false
          end
      
          return true
        end
      }
      
      
      require("copilot").setup {
        server = {
          type = "nodejs",
          custom_server_filepath = "/home/user/copilot-lsp/language-server.js",
        },
      }
      
      
      local capabilities = vim.lsp.protocol.make_client_capabilities() -- Get The capabilities
      capabilities.general.positionEncodings = { "utf-16" } -- Set the offset encoding, see `:h vim.lsp.start` for more info
      require("lspconfig")[server].setup({ capabilities = capabilities }) -- Setup the server
      
      
      server_opts_overrides = {
        offset_encoding = "utf-16" -- Set the offset encoding same as above, see `:h vim.lsp.start` for more info
      }
      
    end,
  },
  {
    "brianaung/compl.nvim",
    config = function()
      
      {
        "brianaung/compl.nvim",
        opts = {
          -- Default options (no need to set them again)
          completion = {
            fuzzy = false,
            timeout = 100,
          },
          info = {
            enable = true,
            timeout = 100,
          },
          snippet = {
            enable = false,
            paths = {},
          }
        },
      }
      
      
      -- A set of options for better completion experience. See `:h completeopt`
      vim.opt.completeopt = { "menuone", "noselect", "noinsert" }
      
      -- Hides the ins-completion-menu messages. See `:h shm-c`
      vim.opt.shortmess:append "c"
      
      
      vim.keymap.set("i", "<CR>", function()
        if vim.fn.complete_info()["selected"] ~= -1 then return "<C-y>" end
        if vim.fn.pumvisible() ~= 0 then return "<C-e><CR>" end
        return "<CR>"
      end, { expr = true })
      
      
      vim.keymap.set("i", "<Tab>", function()
        if vim.fn.pumvisible() ~= 0 then return "<C-n>" end
        return "<Tab>"
      end, { expr = true })
      
      vim.keymap.set("i", "<S-Tab>", function()
        if vim.fn.pumvisible() ~= 0 then return "<C-p>" end
        return "<S-Tab>"
      end, { expr = true })
      
      
      vim.keymap.set({ "i", "s" }, "<C-k>", function()
        if vim.snippet.active { direction = 1 } then
          return "<cmd>lua vim.snippet.jump(1)<cr>"
        end
      end, { expr = true })
      
      vim.keymap.set({ "i", "s" }, "<C-j>", function()
        if vim.snippet.active { direction = -1 } then
          return "<cmd>lua vim.snippet.jump(-1)<cr>"
        end
      end, { expr = true })
      
      
      {
        "brianaung/compl.nvim",
        dependencies = {
          "rafamadriz/friendly-snippets"
        },
        opts = {
          -- ...
          snippet = {
            enable = true,
            paths = {
      	vim.fn.stdpath "data" .. "/lazy/friendly-snippets",
      	-- You can include more paths that contains the package.json manifest for your custom snippets. See below for defining your own snippets.
            },
          },
          -- ...
        },
      }
      
    end,
  },
  {
    "blob42/codegpt-ng.nvim",
    config = function()
      
      {
        "blob42/codegpt-ng.nvim",
        dependencies = {
          'nvim-lua/plenary.nvim',
          'MunifTanjim/nui.nvim',
        },
        opts = {
          -- configuration here
        }
      }
      
      
      use({
         "blob42/codegpt-ng.nvim",
         requires = {
            "MunifTanjim/nui.nvim",
            "nvim-lua/plenary.nvim",
         },
         config = function()
            require("codegpt").setup({
              -- Configuration here
            })
         end
      })
      
      
      require("codegpt").setup({
        api = {
          provider = "openai",  -- or "Ollama", "Azure", etc.
          openai_api_key = vim.fn.getenv("OPENAI_API_KEY"),
          chat_completions_url = "https://api.openai.com/v1/chat/completions",
        },
        models { 
          -- model definitions
        },
        commands = {
          -- Command defaults
        },
        ui = {
          -- UI configuration
        },
        hooks = {
          -- Status hooks
        },
        clear_visual_selection = true,
      })
      
      
      commands = {
        completion = {
          model = "gpt-3.5-turbo",
          user_message_template = "This is a template...",
          callback_type = "replace_lines",
        },
        tests = {
          language_instructions = { java = "Use TestNG framework" },
        }
      }
      
      
      commands = {
        modernize = {
          user_message_template = "Modernize the code...",
          language_instructions = { cpp = "..." }
        }
      }
      
      
        models = {
          default = "gpt-3.5-turbo",              -- Global default model
          ollama = {
            default = "gemma3:1b",                -- Ollama default model
            ['qwen3:4b'] = {
              alias = "qwen3",                    -- Alias to call this model
              max_tokens = 8192,
              temperature = 0.8,
              append_string = '/no_thinking', -- Custom string to append to the prompt
            },
          },
          openai = {
            ["gpt-3.5-turbo"] = {
              alias = "gpt35",
              max_tokens = 4096,
              temperature = 0.8,
            },
          },
        }
      
      
          ["gpt-foo"] = {
            from = "gpt-3.5-turbo",  -- Inherit from openai's default
            temperature = 0.7,       -- Override temperature
          }
      
      
      ui = {
        popup_type = "popup",  -- or "horizontal", "vertical"
        text_popup_filetype = "markdown",
        mappings = {
          quit = "q",
          use_as_output = "<c-o>",
        },
        popup_options = {
          relative = "editor",
          position = "50%",
          size = { width = "80%", height = "80%" },
        },
        popup_border = { style = "rounded" },
        popup_window_options = { wrap = true, number = true },
      }
      
      
      hooks = {
        request_started = function() vim.cmd("hi StatusLine ctermfg=yellow") end,
        request_finished = function() vim.cmd("hi StatusLine ctermfg=NONE") end,
      }
      
      
        commands = {
        --- other commands
          cli_helpgen = {
            system_message_template = 'You are a documentation assistant to a software developer. Generate documentation for a CLI app using the --help flag style, including usage and options. Only output the help text and nothing else.',
            user_message_template = 'App name and usage:\n\n
      \nlocal = search_common_pattern = {}
      
      require("codegpt").setup({
        -- Connection settings for API providers
        connection = {
          api_provider = "openai",                -- Default API provider
          openai_api_key = vim.fn.getenv("OPENAI_API_KEY"),
          chat_completions_url = "https://api.openai.com/v1/chat/completions", -- Default OpenAI endpoint
          ollama_base_url = "http://localhost:11434",  -- Ollama base URL
          proxy = nil,                            -- Can also be set with $http_proxy environment variable
          allow_insecure = false,                 -- Disable insecure connections by default
        },
      
        -- UI configuration for popups
        ui = {
          stream_output = false,                  -- Disable streaming by default
          popup_border = { style = "rounded", padding = { 0, 1 } },  -- Default border style
          popup_options = nil,                    -- No additional popup options
          text_popup_filetype = "markdown",       -- Default filetype for text
      popups
          popup_type = "popup",                   -- Default popup type
          horizontal_popup_size = "20%",          -- Default horizontal size
          vertical_popup_size = "20%",            -- Default vertical size
          spinners = { "", "", "", "", "", "" },  -- Default spinner icons
          spinner_speed = 80,                     -- Default spinner speed
          actions = {
            quit = "q",                           -- Quit key
            use_as_output = "<c-o>",              -- Use as output key
            use_as_input = "<c-i>",               -- Use as input key
            cancel = "<c-c>", 		    -- cancel current request
            custom = nil,                         -- table. with custom actions
          },
        },
      
        -- Model configurations grouped by provider
        models = {
          default = "gpt-3.5-turbo",              -- Global default model
          ollama = {
            default = "gemma3:1b",                -- Ollama default model
            ['qwen3:4b'] = {
              alias = "qwen3",                    -- Alias to call this model
              max_tokens = 8192,
              temperature = 0.8,
              append_string = '/no_think',		-- Custom string to append to the prompt
            },
          },
          openai = {
            ["gpt-3.5-turbo"] = {
              alias = "gpt35",
              max_tokens = 4096,
              temperature = 0.8,
            },
          },
        },
      
        -- General options
        clear_visual_selection = true,            -- Clear visual selection when the command starts
      
        -- Custom hooks
        hooks = {
          request_started = nil,                  --  
          request_finished = nil,                 -- 
        },
      
        commands = {
          -- Add you custom commands here. Example:
          doc = {
            language_instructions = { python = "Use Google style docstrings" },
            max_tokens = 1024,
          },
          modernize = {
            user_message_template = "I have the following {{language}} code: 
    end,
  },
  {
    "Aaronik/GPTModels.nvim",
    config = function()
      
      {
        "Aaronik/GPTModels.nvim",
        dependencies = {
          "MunifTanjim/nui.nvim",
          "nvim-telescope/telescope.nvim"
        }
      }
      
      
      -- Both visual and normal mode for each, so you can open with a visual selection or without.
      vim.api.nvim_set_keymap('v', '<leader>a', ':GPTModelsCode<CR>', { noremap = true })
      vim.api.nvim_set_keymap('n', '<leader>a', ':GPTModelsCode<CR>', { noremap = true })
      
      vim.api.nvim_set_keymap('v', '<leader>c', ':GPTModelsChat<CR>', { noremap = true })
      vim.api.nvim_set_keymap('n', '<leader>c', ':GPTModelsChat<CR>', { noremap = true })
      
    end,
  },
  {
    "Robitx/gp.nvim",
    config = function()
      
      -- lazy.nvim
      {
          "robitx/gp.nvim",
          config = function()
              local conf = {
                  -- For customization, refer to Install > Configuration in the Documentation/Readme
              }
              require("gp").setup(conf)
      
              -- Setup shortcuts here (see Usage > Shortcuts in the Documentation/Readme)
          end,
      }
      
      
      -- packer.nvim
      use({
          "robitx/gp.nvim",
          config = function()
              local conf = {
                  -- For customization, refer to Install > Configuration in the Documentation/Readme
              }
              require("gp").setup(conf)
      
              -- Setup shortcuts here (see Usage > Shortcuts in the Documentation/Readme)
          end,
      })
      
      
      -- vim-plug
      Plug 'robitx/gp.nvim'
      
      local conf = {
          -- For customization, refer to Install > Configuration in the Documentation/Readme
      }
      require("gp").setup(conf)
      
      -- Setup shortcuts here (see Usage > Shortcuts in the Documentation/Readme)
      
      
      	providers = {
      		openai = {
      			endpoint = "https://api.openai.com/v1/chat/completions",
      			secret = os.getenv("OPENAI_API_KEY"),
      		},
      
      		-- azure = {...},
      
      		copilot = {
      			endpoint = "https://api.githubcopilot.com/chat/completions",
      			secret = {
      				"bash",
      				"-c",
      				"cat ~/.config/github-copilot/apps.json | sed -e 's/.*oauth_token...//;s/\".*//'",
      			},
      		},
      
      		pplx = {
      			endpoint = "https://api.perplexity.ai/chat/completions",
      			secret = os.getenv("PPLX_API_KEY"),
      		},
      
      		ollama = {
      			endpoint = "http://localhost:11434/v1/chat/completions",
      		},
      
      		googleai = {
      			endpoint = "https://generativelanguage.googleapis.com/v1beta/models/{{model}}:streamGenerateContent?key={{secret}}",
      			secret = os.getenv("GOOGLEAI_API_KEY"),
      		},
      
      		anthropic = {
      			endpoint = "https://api.anthropic.com/v1/messages",
      			secret = os.getenv("ANTHROPIC_API_KEY"),
      		},
      	},
      
      
      	agents = {
      		{
      			name = "ChatGPT3-5",
      			disable = true,
      		},
      		{
      			name = "MyCustomAgent",
      			provider = "copilot",
      			chat = true,
      			command = true,
      			model = { model = "gpt-4-turbo" },
      			system_prompt = "Answer any query with just: Sure thing..",
      		},
      	},
      
      
      
          vim.api.nvim_create_autocmd({ "User" }, {
              pattern = {"GpDone"},
              callback = function(event)
                  print("event fired:\n", vim.inspect(event))
                  -- local b = event.buf
                  -- DO something
              end,
          })
      
      
      local function keymapOptions(desc)
          return {
              noremap = true,
              silent = true,
              nowait = true,
              desc = "GPT prompt " .. desc,
          }
      end
      
      -- Chat commands
      vim.keymap.set({"n", "i"}, "<C-g>c", "<cmd>GpChatNew<cr>", keymapOptions("New Chat"))
      vim.keymap.set({"n", "i"}, "<C-g>t", "<cmd>GpChatToggle<cr>", keymapOptions("Toggle Chat"))
      vim.keymap.set({"n", "i"}, "<C-g>f", "<cmd>GpChatFinder<cr>", keymapOptions("Chat Finder"))
      
      vim.keymap.set("v", "<C-g>c", ":<C-u>'<,'>GpChatNew<cr>", keymapOptions("Visual Chat New"))
      vim.keymap.set("v", "<C-g>p", ":<C-u>'<,'>GpChatPaste<cr>", keymapOptions("Visual Chat Paste"))
      vim.keymap.set("v", "<C-g>t", ":<C-u>'<,'>GpChatToggle<cr>", keymapOptions("Visual Toggle Chat"))
      
      vim.keymap.set({ "n", "i" }, "<C-g><C-x>", "<cmd>GpChatNew split<cr>", keymapOptions("New Chat split"))
      vim.keymap.set({ "n", "i" }, "<C-g><C-v>", "<cmd>GpChatNew vsplit<cr>", keymapOptions("New Chat vsplit"))
      vim.keymap.set({ "n", "i" }, "<C-g><C-t>", "<cmd>GpChatNew tabnew<cr>", keymapOptions("New Chat tabnew"))
      
      vim.keymap.set("v", "<C-g><C-x>", ":<C-u>'<,'>GpChatNew split<cr>", keymapOptions("Visual Chat New split"))
      vim.keymap.set("v", "<C-g><C-v>", ":<C-u>'<,'>GpChatNew vsplit<cr>", keymapOptions("Visual Chat New vsplit"))
      vim.keymap.set("v", "<C-g><C-t>", ":<C-u>'<,'>GpChatNew tabnew<cr>", keymapOptions("Visual Chat New tabnew"))
      
      -- Prompt commands
      vim.keymap.set({"n", "i"}, "<C-g>r", "<cmd>GpRewrite<cr>", keymapOptions("Inline Rewrite"))
      vim.keymap.set({"n", "i"}, "<C-g>a", "<cmd>GpAppend<cr>", keymapOptions("Append (after)"))
      vim.keymap.set({"n", "i"}, "<C-g>b", "<cmd>GpPrepend<cr>", keymapOptions("Prepend (before)"))
      
      vim.keymap.set("v", "<C-g>r", ":<C-u>'<,'>GpRewrite<cr>", keymapOptions("Visual Rewrite"))
      vim.keymap.set("v", "<C-g>a", ":<C-u>'<,'>GpAppend<cr>", keymapOptions("Visual Append (after)"))
      vim.keymap.set("v", "<C-g>b", ":<C-u>'<,'>GpPrepend<cr>", keymapOptions("Visual Prepend (before)"))
      vim.keymap.set("v", "<C-g>i", ":<C-u>'<,'>GpImplement<cr>", keymapOptions("Implement selection"))
      
      vim.keymap.set({"n", "i"}, "<C-g>gp", "<cmd>GpPopup<cr>", keymapOptions("Popup"))
      vim.keymap.set({"n", "i"}, "<C-g>ge", "<cmd>GpEnew<cr>", keymapOptions("GpEnew"))
      vim.keymap.set({"n", "i"}, "<C-g>gn", "<cmd>GpNew<cr>", keymapOptions("GpNew"))
      vim.keymap.set({"n", "i"}, "<C-g>gv", "<cmd>GpVnew<cr>", keymapOptions("GpVnew"))
      vim.keymap.set({"n", "i"}, "<C-g>gt", "<cmd>GpTabnew<cr>", keymapOptions("GpTabnew"))
      
      vim.keymap.set("v", "<C-g>gp", ":<C-u>'<,'>GpPopup<cr>", keymapOptions("Visual Popup"))
      vim.keymap.set("v", "<C-g>ge", ":<C-u>'<,'>GpEnew<cr>", keymapOptions("Visual GpEnew"))
      vim.keymap.set("v", "<C-g>gn", ":<C-u>'<,'>GpNew<cr>", keymapOptions("Visual GpNew"))
      vim.keymap.set("v", "<C-g>gv", ":<C-u>'<,'>GpVnew<cr>", keymapOptions("Visual GpVnew"))
      vim.keymap.set("v", "<C-g>gt", ":<C-u>'<,'>GpTabnew<cr>", keymapOptions("Visual GpTabnew"))
      
      vim.keymap.set({"n", "i"}, "<C-g>x", "<cmd>GpContext<cr>", keymapOptions("Toggle Context"))
      vim.keymap.set("v", "<C-g>x", ":<C-u>'<,'>GpContext<cr>", keymapOptions("Visual Toggle Context"))
      
      vim.keymap.set({"n", "i", "v", "x"}, "<C-g>s", "<cmd>GpStop<cr>", keymapOptions("Stop"))
      vim.keymap.set({"n", "i", "v", "x"}, "<C-g>n", "<cmd>GpNextAgent<cr>", keymapOptions("Next Agent"))
      vim.keymap.set({"n", "i", "v", "x"}, "<C-g>l", "<cmd>GpSelectAgent<cr>", keymapOptions("Select Agent"))
      
      -- optional Whisper commands with prefix <C-g>w
      vim.keymap.set({"n", "i"}, "<C-g>ww", "<cmd>GpWhisper<cr>", keymapOptions("Whisper"))
      vim.keymap.set("v", "<C-g>ww", ":<C-u>'<,'>GpWhisper<cr>", keymapOptions("Visual Whisper"))
      
      vim.keymap.set({"n", "i"}, "<C-g>wr", "<cmd>GpWhisperRewrite<cr>", keymapOptions("Whisper Inline Rewrite"))
      vim.keymap.set({"n", "i"}, "<C-g>wa", "<cmd>GpWhisperAppend<cr>", keymapOptions("Whisper Append (after)"))
      vim.keymap.set({"n", "i"}, "<C-g>wb", "<cmd>GpWhisperPrepend<cr>", keymapOptions("Whisper Prepend (before) "))
      
      vim.keymap.set("v", "<C-g>wr", ":<C-u>'<,'>GpWhisperRewrite<cr>", keymapOptions("Visual Whisper Rewrite"))
      vim.keymap.set("v", "<C-g>wa", ":<C-u>'<,'>GpWhisperAppend<cr>", keymapOptions("Visual Whisper Append (after)"))
      vim.keymap.set("v", "<C-g>wb", ":<C-u>'<,'>GpWhisperPrepend<cr>", keymapOptions("Visual Whisper Prepend (before)"))
      
      vim.keymap.set({"n", "i"}, "<C-g>wp", "<cmd>GpWhisperPopup<cr>", keymapOptions("Whisper Popup"))
      vim.keymap.set({"n", "i"}, "<C-g>we", "<cmd>GpWhisperEnew<cr>", keymapOptions("Whisper Enew"))
      vim.keymap.set({"n", "i"}, "<C-g>wn", "<cmd>GpWhisperNew<cr>", keymapOptions("Whisper New"))
      vim.keymap.set({"n", "i"}, "<C-g>wv", "<cmd>GpWhisperVnew<cr>", keymapOptions("Whisper Vnew"))
      vim.keymap.set({"n", "i"}, "<C-g>wt", "<cmd>GpWhisperTabnew<cr>", keymapOptions("Whisper Tabnew"))
      
      vim.keymap.set("v", "<C-g>wp", ":<C-u>'<,'>GpWhisperPopup<cr>", keymapOptions("Visual Whisper Popup"))
      vim.keymap.set("v", "<C-g>we", ":<C-u>'<,'>GpWhisperEnew<cr>", keymapOptions("Visual Whisper Enew"))
      vim.keymap.set("v", "<C-g>wn", ":<C-u>'<,'>GpWhisperNew<cr>", keymapOptions("Visual Whisper New"))
      vim.keymap.set("v", "<C-g>wv", ":<C-u>'<,'>GpWhisperVnew<cr>", keymapOptions("Visual Whisper Vnew"))
      vim.keymap.set("v", "<C-g>wt", ":<C-u>'<,'>GpWhisperTabnew<cr>", keymapOptions("Visual Whisper Tabnew"))
      
      
      require("which-key").add({
          -- VISUAL mode mappings
          -- s, x, v modes are handled the same way by which_key
          {
              mode = { "v" },
              nowait = true,
              remap = false,
              { "<C-g><C-t>", ":<C-u>'<,'>GpChatNew tabnew<cr>", desc = "ChatNew tabnew" },
              { "<C-g><C-v>", ":<C-u>'<,'>GpChatNew vsplit<cr>", desc = "ChatNew vsplit" },
              { "<C-g><C-x>", ":<C-u>'<,'>GpChatNew split<cr>", desc = "ChatNew split" },
              { "<C-g>a", ":<C-u>'<,'>GpAppend<cr>", desc = "Visual Append (after)" },
              { "<C-g>b", ":<C-u>'<,'>GpPrepend<cr>", desc = "Visual Prepend (before)" },
              { "<C-g>c", ":<C-u>'<,'>GpChatNew<cr>", desc = "Visual Chat New" },
              { "<C-g>g", group = "generate into new .." },
              { "<C-g>ge", ":<C-u>'<,'>GpEnew<cr>", desc = "Visual GpEnew" },
              { "<C-g>gn", ":<C-u>'<,'>GpNew<cr>", desc = "Visual GpNew" },
              { "<C-g>gp", ":<C-u>'<,'>GpPopup<cr>", desc = "Visual Popup" },
              { "<C-g>gt", ":<C-u>'<,'>GpTabnew<cr>", desc = "Visual GpTabnew" },
              { "<C-g>gv", ":<C-u>'<,'>GpVnew<cr>", desc = "Visual GpVnew" },
              { "<C-g>i", ":<C-u>'<,'>GpImplement<cr>", desc = "Implement selection" },
              { "<C-g>n", "<cmd>GpNextAgent<cr>", desc = "Next Agent" },
              { "<C-g>l", "<cmd>GpSelectAgent<cr>", desc = "Select Agent" },
              { "<C-g>p", ":<C-u>'<,'>GpChatPaste<cr>", desc = "Visual Chat Paste" },
              { "<C-g>r", ":<C-u>'<,'>GpRewrite<cr>", desc = "Visual Rewrite" },
              { "<C-g>s", "<cmd>GpStop<cr>", desc = "GpStop" },
              { "<C-g>t", ":<C-u>'<,'>GpChatToggle<cr>", desc = "Visual Toggle Chat" },
              { "<C-g>w", group = "Whisper" },
              { "<C-g>wa", ":<C-u>'<,'>GpWhisperAppend<cr>", desc = "Whisper Append" },
              { "<C-g>wb", ":<C-u>'<,'>GpWhisperPrepend<cr>", desc = "Whisper Prepend" },
              { "<C-g>we", ":<C-u>'<,'>GpWhisperEnew<cr>", desc = "Whisper Enew" },
              { "<C-g>wn", ":<C-u>'<,'>GpWhisperNew<cr>", desc = "Whisper New" },
              { "<C-g>wp", ":<C-u>'<,'>GpWhisperPopup<cr>", desc = "Whisper Popup" },
              { "<C-g>wr", ":<C-u>'<,'>GpWhisperRewrite<cr>", desc = "Whisper Rewrite" },
              { "<C-g>wt", ":<C-u>'<,'>GpWhisperTabnew<cr>", desc = "Whisper Tabnew" },
              { "<C-g>wv", ":<C-u>'<,'>GpWhisperVnew<cr>", desc = "Whisper Vnew" },
              { "<C-g>ww", ":<C-u>'<,'>GpWhisper<cr>", desc = "Whisper" },
              { "<C-g>x", ":<C-u>'<,'>GpContext<cr>", desc = "Visual GpContext" },
          },
      
          -- NORMAL mode mappings
          {
              mode = { "n" },
              nowait = true,
              remap = false,
              { "<C-g><C-t>", "<cmd>GpChatNew tabnew<cr>", desc = "New Chat tabnew" },
              { "<C-g><C-v>", "<cmd>GpChatNew vsplit<cr>", desc = "New Chat vsplit" },
              { "<C-g><C-x>", "<cmd>GpChatNew split<cr>", desc = "New Chat split" },
              { "<C-g>a", "<cmd>GpAppend<cr>", desc = "Append (after)" },
              { "<C-g>b", "<cmd>GpPrepend<cr>", desc = "Prepend (before)" },
              { "<C-g>c", "<cmd>GpChatNew<cr>", desc = "New Chat" },
              { "<C-g>f", "<cmd>GpChatFinder<cr>", desc = "Chat Finder" },
              { "<C-g>g", group = "generate into new .." },
              { "<C-g>ge", "<cmd>GpEnew<cr>", desc = "GpEnew" },
              { "<C-g>gn", "<cmd>GpNew<cr>", desc = "GpNew" },
              { "<C-g>gp", "<cmd>GpPopup<cr>", desc = "Popup" },
              { "<C-g>gt", "<cmd>GpTabnew<cr>", desc = "GpTabnew" },
              { "<C-g>gv", "<cmd>GpVnew<cr>", desc = "GpVnew" },
              { "<C-g>n", "<cmd>GpNextAgent<cr>", desc = "Next Agent" },
              { "<C-g>l", "<cmd>GpSelectAgent<cr>", desc = "Select Agent" },
              { "<C-g>r", "<cmd>GpRewrite<cr>", desc = "Inline Rewrite" },
              { "<C-g>s", "<cmd>GpStop<cr>", desc = "GpStop" },
              { "<C-g>t", "<cmd>GpChatToggle<cr>", desc = "Toggle Chat" },
              { "<C-g>w", group = "Whisper" },
              { "<C-g>wa", "<cmd>GpWhisperAppend<cr>", desc = "Whisper Append (after)" },
              { "<C-g>wb", "<cmd>GpWhisperPrepend<cr>", desc = "Whisper Prepend (before)" },
              { "<C-g>we", "<cmd>GpWhisperEnew<cr>", desc = "Whisper Enew" },
              { "<C-g>wn", "<cmd>GpWhisperNew<cr>", desc = "Whisper New" },
              { "<C-g>wp", "<cmd>GpWhisperPopup<cr>", desc = "Whisper Popup" },
              { "<C-g>wr", "<cmd>GpWhisperRewrite<cr>", desc = "Whisper Inline Rewrite" },
              { "<C-g>wt", "<cmd>GpWhisperTabnew<cr>", desc = "Whisper Tabnew" },
              { "<C-g>wv", "<cmd>GpWhisperVnew<cr>", desc = "Whisper Vnew" },
              { "<C-g>ww", "<cmd>GpWhisper<cr>", desc = "Whisper" },
              { "<C-g>x", "<cmd>GpContext<cr>", desc = "Toggle GpContext" },
          },
      
          -- INSERT mode mappings
          {
              mode = { "i" },
              nowait = true,
              remap = false,
              { "<C-g><C-t>", "<cmd>GpChatNew tabnew<cr>", desc = "New Chat tabnew" },
              { "<C-g><C-v>", "<cmd>GpChatNew vsplit<cr>", desc = "New Chat vsplit" },
              { "<C-g><C-x>", "<cmd>GpChatNew split<cr>", desc = "New Chat split" },
              { "<C-g>a", "<cmd>GpAppend<cr>", desc = "Append (after)" },
              { "<C-g>b", "<cmd>GpPrepend<cr>", desc = "Prepend (before)" },
              { "<C-g>c", "<cmd>GpChatNew<cr>", desc = "New Chat" },
              { "<C-g>f", "<cmd>GpChatFinder<cr>", desc = "Chat Finder" },
              { "<C-g>g", group = "generate into new .." },
              { "<C-g>ge", "<cmd>GpEnew<cr>", desc = "GpEnew" },
              { "<C-g>gn", "<cmd>GpNew<cr>", desc = "GpNew" },
              { "<C-g>gp", "<cmd>GpPopup<cr>", desc = "Popup" },
              { "<C-g>gt", "<cmd>GpTabnew<cr>", desc = "GpTabnew" },
              { "<C-g>gv", "<cmd>GpVnew<cr>", desc = "GpVnew" },
              { "<C-g>n", "<cmd>GpNextAgent<cr>", desc = "Next Agent" },
              { "<C-g>l", "<cmd>GpSelectAgent<cr>", desc = "Select Agent" },
              { "<C-g>r", "<cmd>GpRewrite<cr>", desc = "Inline Rewrite" },
              { "<C-g>s", "<cmd>GpStop<cr>", desc = "GpStop" },
              { "<C-g>t", "<cmd>GpChatToggle<cr>", desc = "Toggle Chat" },
              { "<C-g>w", group = "Whisper" },
              { "<C-g>wa", "<cmd>GpWhisperAppend<cr>", desc = "Whisper Append (after)" },
              { "<C-g>wb", "<cmd>GpWhisperPrepend<cr>", desc = "Whisper Prepend (before)" },
              { "<C-g>we", "<cmd>GpWhisperEnew<cr>", desc = "Whisper Enew" },
              { "<C-g>wn", "<cmd>GpWhisperNew<cr>", desc = "Whisper New" },
              { "<C-g>wp", "<cmd>GpWhisperPopup<cr>", desc = "Whisper Popup" },
              { "<C-g>wr", "<cmd>GpWhisperRewrite<cr>", desc = "Whisper Inline Rewrite" },
              { "<C-g>wt", "<cmd>GpWhisperTabnew<cr>", desc = "Whisper Tabnew" },
              { "<C-g>wv", "<cmd>GpWhisperVnew<cr>", desc = "Whisper Vnew" },
              { "<C-g>ww", "<cmd>GpWhisper<cr>", desc = "Whisper" },
              { "<C-g>x", "<cmd>GpContext<cr>", desc = "Toggle GpContext" },
          },
      })
      
      
        -- example of adding command which writes unit tests for the selected code
        UnitTests = function(gp, params)
            local template = "I have the following code from {{filename}}:\n\n"
                .. "
      
        -- example of adding command which explains the selected code
        Explain = function(gp, params)
            local template = "I have the following code from {{filename}}:\n\n"
                .. "
      
        -- example of usig enew as a function specifying type for the new buffer
        CodeReview = function(gp, params)
            local template = "I have the following code from {{filename}}:\n\n"
                .. "
      
        -- example of adding command which opens new chat dedicated for translation
        Translator = function(gp, params)
            local chat_system_prompt = "You are a Translator, please translate between English and Chinese."
            gp.cmd.ChatNew(params, chat_system_prompt)
      
            -- -- you can also create a chat with a specific fixed agent like this:
            -- local agent = gp.get_chat_agent("ChatGPT4o")
            -- gp.cmd.ChatNew(params, chat_system_prompt, agent)
        end,
        
      
        -- example of making :%GpChatNew a dedicated command which
        -- opens new chat with the entire current buffer as a context
        BufferChatNew = function(gp, _)
            -- call GpChatNew command in range mode on whole buffer
            vim.api.nvim_command("%" .. gp.config.cmd_prefix .. "ChatNew")
        end,
        
      
      ---@param params table  # vim command parameters such as range, args, etc.
      ---@param target integer | function | table  # where to put the response
      ---@param agent table  # obtained from get_command_agent or get_chat_agent
      ---@param template string  # template with model instructions
      ---@param prompt string | nil  # nil for non interactive commads
      ---@param whisper string | nil  # predefined input (e.g. obtained from Whisper)
      ---@param callback function | nil  # callback(response) after completing the prompt
      Prompt(params, target, agent, template, prompt, whisper, callback)
      
      
        params = {
              args = "",
              bang = false,
              count = -1,
              fargs = {},
              line1 = 1352,
              line2 = 1352,
              mods = "",
              name = "GpChatNew",
              range = 0,
              reg = "",
              smods = {
                    browse = false,
                    confirm = false,
                    emsg_silent = false,
                    hide = false,
                    horizontal = false,
                    keepalt = false,
                    keepjumps = false,
                    keepmarks = false,
                    keeppatterns = false,
                    lockmarks = false,
                    noautocmd = false,
                    noswapfile = false,
                    sandbox = false,
                    silent = false,
                    split = "",
                    tab = -1,
                    unsilent = false,
                    verbose = -1,
                    vertical = false
              }
        }
        
      
        M.Target = {
            rewrite = 0, -- for replacing the selection, range or the current line
            append = 1, -- for appending after the selection, range or the current line
            prepend = 2, -- for prepending before the selection, range or the current line
            popup = 3, -- for writing into the popup window
      
            -- for writing into a new buffer
            ---@param filetype nil | string # nil = same as the original buffer
            ---@return table # a table with type=4 and filetype=filetype
            enew = function(filetype)
                return { type = 4, filetype = filetype }
            end,
      
            --- for creating a new horizontal split
            ---@param filetype nil | string # nil = same as the original buffer
            ---@return table # a table with type=5 and filetype=filetype
            new = function(filetype)
                return { type = 5, filetype = filetype }
            end,
      
            --- for creating a new vertical split
            ---@param filetype nil | string # nil = same as the original buffer
            ---@return table # a table with type=6 and filetype=filetype
            vnew = function(filetype)
                return { type = 6, filetype = filetype }
            end,
      
            --- for creating a new tab
            ---@param filetype nil | string # nil = same as the original buffer
            ---@return table # a table with type=7 and filetype=filetype
            tabnew = function(filetype)
                return { type = 7, filetype = filetype }
            end,
        }
        
      
        ---@param name string | nil
        ---@return table # { cmd_prefix, name, model, system_prompt, provider }
        get_command_agent(name)
        
    end,
  },
  {
    "jackMort/ChatGPT.nvim",
    config = function()
      
      {
        ...,
        extra_curl_params = {
          "-H",
          "Origin: https://example.com"
        }
      }
      
      
        local config = {
          api_host_cmd = 'echo -n ""',
          api_key_cmd = 'pass azure-openai-key',
          api_type_cmd = 'echo azure',
          azure_api_base_cmd = 'echo https://{your-resource-name}.openai.azure.com',
          azure_api_engine_cmd = 'echo chat',
          azure_api_version_cmd = 'echo 2023-05-15'
        }
      
        require("chatgpt").setup(config)
      
      
      -- Packer
      use({
        "jackMort/ChatGPT.nvim",
          config = function()
            require("chatgpt").setup()
          end,
          requires = {
            "MunifTanjim/nui.nvim",
            "nvim-lua/plenary.nvim",
            "folke/trouble.nvim",
            "nvim-telescope/telescope.nvim"
          }
      })
      
      
      -- Lazy
      {
        "jackMort/ChatGPT.nvim",
          event = "VeryLazy",
          config = function()
            require("chatgpt").setup()
          end,
          dependencies = {
            "MunifTanjim/nui.nvim",
            "nvim-lua/plenary.nvim",
            "folke/trouble.nvim", -- optional
            "nvim-telescope/telescope.nvim"
          }
      }
      
      
      {
        "jackMort/ChatGPT.nvim",
        event = "VeryLazy",
        config = function()
          require("chatgpt").setup({
            -- this config assumes you have OPENAI_API_KEY environment variable set
            openai_params = {
              -- NOTE: model can be a function returning the model name
              -- this is useful if you want to change the model on the fly
              -- using commands
              -- Example:
              -- model = function()
              --     if some_condition() then
              --         return "gpt-4-1106-preview"
              --     else
              --         return "gpt-3.5-turbo"
              --     end
              -- end,
              model = "gpt-4-1106-preview",
              frequency_penalty = 0,
              presence_penalty = 0,
              max_tokens = 4095,
              temperature = 0.2,
              top_p = 0.1,
              n = 1,
            }
          })
        end,
        dependencies = {
          "MunifTanjim/nui.nvim",
          "nvim-lua/plenary.nvim",
            "folke/trouble.nvim", -- optional
          "nvim-telescope/telescope.nvim"
        }
      }
      
      
      require("chatgpt").setup({
          api_key_cmd = "op read op://private/OpenAI/credential --no-newline"
      })
      
      
      local home = vim.fn.expand("$HOME")
      require("chatgpt").setup({
          api_key_cmd = "gpg --decrypt " .. home .. "/secret.txt.gpg"
      })
      
      
      local chatgpt = require("chatgpt")
      wk.register({
          p = {
              name = "ChatGPT",
              e = {
                  function()
                      chatgpt.edit_with_instructions()
                  end,
                  "Edit with instructions",
              },
          },
      }, {
          prefix = "<leader>",
          mode = "v",
      })
      
      
      c = {
        name = "ChatGPT",
          c = { "<cmd>ChatGPT<CR>", "ChatGPT" },
          e = { "<cmd>ChatGPTEditWithInstruction<CR>", "Edit with instruction", mode = { "n", "v" } },
          g = { "<cmd>ChatGPTRun grammar_correction<CR>", "Grammar Correction", mode = { "n", "v" } },
          t = { "<cmd>ChatGPTRun translate<CR>", "Translate", mode = { "n", "v" } },
          k = { "<cmd>ChatGPTRun keywords<CR>", "Keywords", mode = { "n", "v" } },
          d = { "<cmd>ChatGPTRun docstring<CR>", "Docstring", mode = { "n", "v" } },
          a = { "<cmd>ChatGPTRun add_tests<CR>", "Add Tests", mode = { "n", "v" } },
          o = { "<cmd>ChatGPTRun optimize_code<CR>", "Optimize Code", mode = { "n", "v" } },
          s = { "<cmd>ChatGPTRun summarize<CR>", "Summarize", mode = { "n", "v" } },
          f = { "<cmd>ChatGPTRun fix_bugs<CR>", "Fix Bugs", mode = { "n", "v" } },
          x = { "<cmd>ChatGPTRun explain_code<CR>", "Explain Code", mode = { "n", "v" } },
          r = { "<cmd>ChatGPTRun roxygen_edit<CR>", "Roxygen Edit", mode = { "n", "v" } },
          l = { "<cmd>ChatGPTRun code_readability_analysis<CR>", "Code Readability Analysis", mode = { "n", "v" } },
        },
      
    end,
  },
  {
    "CamdenClark/flyboy",
    config = function()
      
      require('flyboy.config').setup({
        sources = {
          my_source = function () return "world" end
        },
        templates = {
          my_template = {
            template_fn = function(sources) return "# User\nHello, " .. sources.my_source() end
            -- :FlyboyOpen my_template
            -- Output:
            -- # User
            -- Hello, world
          }
        }
      })
      
      
      require('flyboy.config').setup({
        templates = {
          unit_test = {
            template_fn = function(sources)
                return "# User\n"
                  .. "Write a unit test for the following code:\n"
                  .. sources.visual()
            end
            -- :FlyboyStart unit_test
            -- Output:
            -- # User
            -- Write a unit test for the following
            -- <Your visual selection>
          }
        }
      })
      
      
      require('flyboy.config').setup({
        templates = {
          unit_test_buffer = {
            template_fn = function(sources)
                return "# User\n"
                  .. "Write unit tests for the code in the following file:\n"
                  .. sources.buffer()
            end
            -- :FlyboyStart unit_test_buffer
            -- Output:
            -- # User
            -- Write a unit test for the following
            -- <Your previous buffer's contents>
          }
        }
      })
      
      
      require('flyboy.config').setup({
        -- ...
        model = "gpt-4"
      })
      
      
      require('flyboy.config').setup({
        -- should be like "$AZURE_OPENAI_ENDPOINT/openai/deployments/gpt-35-turbo/chat/completions?api-version=2023-07-01-preview"
        url = vim.env.AZURE_OPENAI_GPT4_URL,
        headers = { 
          Api_Key = vim.env.AZURE_OPENAI_GPT4_KEY,
          Content_Type = "application/json"
        }
      })
      
      
      require('flyboy.config').setup({
        on_complete = function() print("foo") end
      })
      
    end,
  },
  {
    "gsuuon/model.nvim",
    config = function()
      
      require('lazy').setup({
        {
          'gsuuon/model.nvim',
      
          -- Don't need these if lazy = false
          cmd = { 'M', 'Model', 'Mchat' },
          init = function()
            vim.filetype.add({
              extension = {
                mchat = 'mchat',
              }
            })
          end,
          ft = 'mchat',
      
          keys = {
            {'<C-m>d', ':Mdelete<cr>', mode = 'n'},
            {'<C-m>s', ':Mselect<cr>', mode = 'n'},
            {'<C-m><space>', ':Mchat<cr>', mode = 'n' }
          },
      
          -- To override defaults add a config field and call setup()
      
          -- config = function()
          --   require('model').setup({
          --     prompts = {..},
          --     chats = {..},
          --     ..
          --   })
          --
          --   require('model.providers.llamacpp').setup({
          --     binary = '~/path/to/server/binary',
          --     models = '~/path/to/models/directory'
          --   })
          --end
        }
      })
      
      
      require('model').setup({
        secrets = {
          PROVIDER_API_KEY = function()
            return 'some key'
          end
        }
      })
      
      
      local qflist = require('model.util.qflist')
      local starters = require('model.prompts.chats')
      
      config.chats = {
        ['codellama:qfix'] = vim.tbl_deep_extend('force', starters['together:codellama'], {
          system = 'You are an intelligent programming assistant',
          create = function()
            return qflist.get_text()
          end
        }),
      }
      
      
      builder = function(input, context)
        ---@type {id: string, content: string}[]
        local store_results = require('model.store').prompt.query_store(input, 2, 0.75)
      
        -- add store_results to your messages
      end
      
      
      require('model').setup({
        default_prompt = {},
        prompts = {...},
        chats = {...},
        hl_group = 'Comment',
        join_undo = true,
      })
      
      
      {
        'gsuuon/model.nvim',
        config = function()
          require('model').setup({
            prompts = {
              instruct = { ... },
              code = { ... },
              ask = { ... }
            }
          })
        end
      }
      
      
      {
        'gsuuon/model.nvim',
        config = function()
          require('model').setup({
            prompts = { ... },
            chats = {
              gpt4 = { ... },
              mixtral = { ... }
              starling = { ... }
            }
          })
        end
      }
      
      
          config = function()
            require('model.providers.openai').initialize({
              model = 'gpt-4-1106-preview'
            })
          end
      
      
        compat = vim.tbl_extend('force', openai.default_prompt, {
          options = {
            url = 'http://127.0.0.1:8000/v1/'
          }
        })
      
      
        {
            "gsuuon/model.nvim",
            cmd = { "Model", "Mchat" },
            init = function()
                vim.filetype.add({ extension = { mchat = "mchat" } })
            end,
            ft = "mchat",
            keys = { { "<leader>h", ":Model<cr>", mode = "v" } },
            config = function()
                local mistral = require("model.providers.openai")
                local util = require("model.util")
                require("model").setup({
                    hl_group = "Substitute",
                    prompts = util.module.autoload("prompt_library"),
                    default_prompt = {
                        provider = mistral,
                        options = {
                            url = "https://api.mistral.ai/v1/",
                            authorization = "Bearer YOUR_MISTRAL_API_KEY",
                        },
                        builder = function(input)
                            return {
                                model = "mistral-medium",
                                temperature = 0.3,
                                max_tokens = 400,
                                messages = {
                                    {
                                        role = "system",
                                        content = "You are helpful assistant.",
                                    },
                                    { role = "user", content = input },
                                },
                            }
                        end,
                    },
                })
            end,
        },
      
      
          config = function()
            require('model').setup({ .. })
      
            require('model.providers.llamacpp').setup({
              binary = '~/path/to/server/binary',
              models = '~/path/to/models/directory'
            })
          end
          
      
          local llamacpp = require('model.providers.llamacpp')
      
          require('model').setup({
            prompts = {
              zephyr = {
                provider = llamacpp,
                options = {
                  model = 'zephyr-7b-beta.Q5_K_M.gguf',
                  args = {
                    '-c', 8192,
                    '-ngl', 35
                  }
                },
                builder = function(input, context)
                  return {
                    prompt =
                      '<|system|>'
                      .. (context.args or 'You are a helpful assistant')
                      .. '\n</s>\n<|user|>\n'
                      .. input
                      .. '</s>\n<|assistant|>',
                    stops = { '</s>' }
                  }
                end
              }
            }
          })
          
      
        ['ollama:starling'] = {
          provider = ollama,
          params = {
            model = 'starling-lm'
          },
          builder = function(input)
            return {
              prompt = 'GPT4 Correct User: ' .. input .. '<|end_of_turn|>GPT4 Correct Assistant: '
            }
          end
        },
      
      
      palm = {
        provider = palm,
        builder = function(input, context)
          return {
            model = 'text-bison-001',
            prompt = {
              text = input
            },
            temperature = 0.2
          }
        end
      }
      
      
        ['together:phind/codellama34b_v2'] = {
          provider = together,
          params = {
            model = 'Phind/Phind-CodeLlama-34B-v2',
            max_tokens = 1024
          },
          builder = function(input)
            return {
              prompt = '### System Prompt\nYou are an intelligent programming assistant\n\n### User Message\n' .. input  ..'\n\n### Assistant\n'
            }
          end
        },
      
      
        ['hf:starcoder'] = {
          provider = huggingface,
          options = {
            model = 'bigcode/starcoder'
          },
          builder = function(input)
            return { inputs = input }
          end
        },
      
      
        ['langserve:make-a-joke'] = {
          provider = langserve,
          options = {
            base_url = 'https://langserve-launch-example-vz4y4ooboq-uc.a.run.app/',
            output_parser = langserve.generation_chunk_parser,
          },
          builder = function(input, context)
            return {
              topic = input,
            }
          end
        },
      
      
      local test_provider = {
        request_completion = function(handlers, params, options)
          vim.notify(vim.inspect({params=params, options=options}))
          handlers.on_partial('a response')
          handlers.on_finish()
        end
      }
      
      require('model').setup({
        prompts = {
          test_prompt = {
            provider = test_provider,
            builder = function(input, context)
              return {
                input = input,
                context = context
              }
            end
          }
        }
      })
      
      
      require('model').setup({
        prompts = {
          ['prompt name'] = ...
        }
      })
      
      
        ask = {
          provider = openai,
          params = {
            temperature = 0.3,
            max_tokens = 1500
          },
          builder = function(input)
            local messages = {
              {
                role = 'user',
                content = input
              }
            }
      
            return util.builder.user_prompt(function(user_input)
              if #user_input > 0 then
                table.insert(messages, {
                  role = 'user',
                  content = user_input
                })
              end
      
              return {
                messages = messages
              }
            end, input)
          end,
        }
      
      
        ['commit message'] = {
          provider = openai,
          mode = mode.INSERT,
          builder = function()
            local git_diff = vim.fn.system {'git', 'diff', '--staged'}
            return {
              messages = {
                {
                  role = 'system',
                  content = 'Write a short commit message according to the Conventional Commits specification for the following git diff: 
      
      --- Looks for `<llm:` at the end and splits into before and after
      --- returns all text if no directive
      local function match_llm_directive(text)
        local before, _, after = text:match("(.-)(<llm:)%s?(.*)$")
        if not before and not after then
          before, after = text, ""
        elseif not before then
          before = ""
        elseif not after then
          after = ""
        end
        return before, after
      end
      
      local instruct_code = 'You are a highly competent programmer. Include only valid code in your response.'
      
      return {
        ['to code'] = {
          provider = openai,
          builder = function(input)
            local text, directive = match_llm_directive(input)
      
            local msgs ={
              {
                role = 'system',
                content = instruct_code,
              },
              {
                role = 'user',
                content = text,
              }
            }
      
            if directive then
              table.insert(msgs, { role = 'user', content = directive })
            end
      
            return {
              messages = msgs
            }
          end,
          mode = segment.mode.REPLACE
        },
        code = {
          provider = openai,
          builder = function(input)
            return {
              messages = {
                {
                  role = 'system',
                  content = instruct_code,
                },
                {
                  role = 'user',
                  content = input,
                }
              }
            }
          end,
        },
      }
      
      
      local openai = require('model.providers.openai')
      local segment = require('model.util.segment')
      
      require('model').setup({
        prompts = {
          ['to spanish'] =
            {
              provider = openai,
              hl_group = 'SpecialComment',
              builder = function(input)
                return {
                  messages = {
                    {
                      role = 'system',
                      content = 'Translate to Spanish',
                    },
                    {
                      role = 'user',
                      content = input,
                    }
                  }
                }
              end,
              mode = segment.mode.REPLACE
            }
        }
      })
      
      
      local openai = require('model.providers.openai')
      
      require('model').setup({
        prompts = {
          ['show parts'] = {
            provider = openai,
            builder = openai.default_builder,
            mode = {
              on_finish = function (final)
                vim.notify('final: ' .. final)
              end,
              on_partial = function (partial)
                vim.notify(partial)
              end,
              on_error = function (msg)
                vim.notify('error: ' .. msg)
              end
            }
          },
        }
      })
      
      
      local openai = require('model.providers.openai')
      
      -- configure default model params here for the provider
      openai.initialize({
        model = 'gpt-3.5-turbo-0301',
        max_tokens = 400,
        temperature = 0.2,
      })
      
      local util = require('model.util')
      
      require('model').setup({
        hl_group = 'Substitute',
        prompts = util.module.autoload('prompt_library'),
        default_prompt = {
          provider = openai,
          builder = function(input)
            return {
              temperature = 0.3,
              max_tokens = 120,
              messages = {
                {
                  role = 'system',
                  content = 'You are helpful assistant.',
                },
                {
                  role = 'user',
                  content = input,
                }
              }
            }
          end
        }
      })
      
      
      local openai = require('model.providers.openai')
      local segment = require('model.util.segment')
      
      return {
        code = {
          provider = openai,
          builder = function(input)
            return {
              messages = {
                {
                  role = 'system',
                  content = 'You are a 10x super elite programmer. Continue only with code. Do not write tests, examples, or output of code unless explicitly asked for.',
                },
                {
                  role = 'user',
                  content = input,
                }
              }
            }
          end,
        },
        ['to spanish'] = {
          provider = openai,
          hl_group = 'SpecialComment',
          builder = function(input)
            return {
              messages = {
                {
                  role = 'system',
                  content = 'Translate to Spanish',
                },
                {
                  role = 'user',
                  content = input,
                }
              }
            }
          end,
          mode = segment.mode.REPLACE
        },
        ['to javascript'] = {
          provider = openai,
          builder = function(input, ctx)
            return {
              messages = {
                {
                  role = 'system',
                  content = 'Convert the code to javascript'
                },
                {
                  role = 'user',
                  content = input
                }
              }
            }
          end,
        },
        ['to rap'] = {
          provider = openai,
          hl_group = 'Title',
          builder = function(input)
            return {
              messages = {
                {
                  role = 'system',
                  content = "Explain the code in 90's era rap lyrics"
                },
                {
                  role = 'user',
                  content = input
                }
              }
            }
          end,
        }
      }
      
    end,
  },
  {
    "dense-analysis/neural",
    config = function()
      
      -- Configure Neural like so in Lua
      require('neural').setup({
          providers = {
              {
                  openai = {
                      api_key = vim.env.OPENAI_API_KEY,
                  },
              },
          },
      })
      
      
      -- Configure Neural like so in Lua
      require('neural').setup({
          providers = {
              {
                  openai = {
                      url = 'http://localhost:7860',
                  },
              },
          },
      })
      
    end,
  },
  {
    "jpmcb/nvim-llama",
    config = function()
      
      use 'jpmcb/nvim-llama'
      
      
      {
          'jpmcb/nvim-llama'
      }
      
      
      Plug 'jpmcb/nvim-llama'
      
      
      require('nvim-llama').setup {}
      
      
      local defaults = {
          -- See plugin debugging logs
          debug = false,
      
          -- The model for ollama to use. This model will be automatically downloaded.
          model = llama2,
      }
      
    end,
  },
  {
    "David-Kunz/gen.nvim",
    config = function()
      
      -- Minimal configuration
      { "David-Kunz/gen.nvim" },
      
      
      
      
      -- Custom Parameters (with defaults)
      {
          "David-Kunz/gen.nvim",
          opts = {
              model = "mistral", -- The default model to use.
              quit_map = "q", -- set keymap to close the response window
              retry_map = "<c-r>", -- set keymap to re-send the current prompt
              accept_map = "<c-cr>", -- set keymap to replace the previous selection with the last result
              host = "localhost", -- The host running the Ollama service.
              port = "11434", -- The port on which the Ollama service is listening.
              display_mode = "float", -- The display mode. Can be "float" or "split" or "horizontal-split" or "vertical-split".
              show_prompt = false, -- Shows the prompt submitted to Ollama. Can be true (3 lines) or "full".
              show_model = false, -- Displays which model you are using at the beginning of your chat session.
              no_auto_close = false, -- Never closes the window automatically.
              file = false, -- Write the payload to a temporary file to keep the command short.
              hidden = false, -- Hide the generation window (if true, will implicitly set `prompt.replace = true`), requires Neovim >= 0.10
              init = function(options) pcall(io.popen, "ollama serve > /dev/null 2>&1 &") end,
              -- Function to initialize Ollama
              command = function(options)
                  local body = {model = options.model, stream = true}
                  return "curl --silent --no-buffer -X POST http://" .. options.host .. ":" .. options.port .. "/api/chat -d $body"
              end,
              -- The command for the Ollama service. You can use placeholders $prompt, $model and $body (shellescaped).
              -- This can also be a command string.
              -- The executed command must return a JSON object with { response, context }
              -- (context property is optional).
              -- list_models = '<omitted lua function>', -- Retrieves a list of model names
              result_filetype = "markdown", -- Configure filetype of the result buffer
              debug = false -- Prints errors and the command which is run.
          }
      },
      
      
      require('gen').setup({
        -- same as above
      })
      
      
      vim.keymap.set({ 'n', 'v' }, '<leader>]', ':Gen<CR>')
      
      
      vim.keymap.set('v', '<leader>]', ':Gen Enhance_Grammar_Spelling<CR>')
      
      
      :Gen Chat
      
      
      require('gen').select_model()
      
      
      require('gen').prompts['Elaborate_Text'] = {
        prompt = "Elaborate the following text:\n$text",
        replace = true
      }
      require('gen').prompts['Fix_Code'] = {
        prompt = "Fix the following code. Only output the result in format 
    end,
  },
  {
    "kiddos/gemini.nvim",
    config = function()
      
      {
        'kiddos/gemini.nvim',
        opts = {}
      }
      
      
      use { 'kiddos/gemini.nvim', opts = {} }
      
      
      {
        model_config = {
          model_id = 'gemini-2.5-flash',
          temperature = 0.10,
          top_k = 128,
          response_mime_type = 'text/plain',
        },
        chat_config = {
          enabled = true,
        },
        hints = {
          enabled = true,
          hints_delay = 2000,
          insert_result_key = '<S-Tab>',
          get_prompt = function(node, bufnr)
            local code_block = vim.treesitter.get_node_text(node, bufnr)
            local filetype = vim.api.nvim_get_option_value('filetype', { buf = bufnr })
            local prompt = [[
        In struction: Use 1 or 2 sentences to describe what the following {filetype} function does:
      
        
    end,
  },
  {
    "olimorris/codecompanion.nvim",
    config = function()
      
      -- lazy.nvim
      {
        "olimorris/codecompanion.nvim",
        dependencies = {
          "nvim-lua/plenary.nvim",
          "nvim-treesitter/nvim-treesitter",
        },
        opts = {
          -- NOTE: The log_level is in `opts.opts`
          opts = {
            log_level = "DEBUG", -- or "TRACE"
          },
        },
      },
      
      -- Other package managers
      require("codecompanion").setup({
        opts = {
          log_level = "DEBUG", -- or "TRACE"
        }
      })
      
    end,
  },
  {
    "you-n-g/simplegpt.nvim",
    config = function()
      
      -- Lazy.nvim
      {
        "you-n-g/simplegpt.nvim",
        dependencies = {
          {
            "yetone/avante.nvim", -- You should configure your avante.nvim make sure it works.
            event = "VeryLazy",
            opts = {<your config>},
            dependencies = {
              "MunifTanjim/nui.nvim",
              "nvim-lua/plenary.nvim",
            },
          },
          "you-n-g/jinja-engine.nvim",
          "ibhagwan/fzf-lua",
        },
        config = true,
      },
      
      -- or packer.nvim
      use({
        "you-n-g/simplegpt.nvim",
        config = function()
          require("simplegpt").setup()
        end,
        requires = {
          {
            "yetone/avante.nvim", -- You should configure your avante.nvim make sure it works.
            event = "VimEnter",
            config = function()
              require("avante").setup({<your config>})
            end,
            requires = {
              "MunifTanjim/nui.nvim",
              "nvim-lua/plenary.nvim",
            },
          },
          "you-n-g/jinja-engine.nvim",
          "ibhagwan/fzf-lua",
        },
      })
      
      
      vim.g.maplocalleader = "\\"  -- change the localleader key to \
      
      
      require("simplegpt").setup({
        custom_template_path = "~/my_custom_templates/"
      })
      
      
      require("simplegpt").setup({
        custom_template_path = "~/my_custom_templates/",
        keymaps = {
          custom_shortcuts = {
            ["<LocalLeader>sQ"] = {
              mode = { "n", "v" },
              tpl = "my_custom_template.json",
              target = "popup",
              opts = { noremap = true, silent = true, desc = "Use custom template" },
            },
          },
        },
      })
      
      
      {
        "you-n-g/simplegpt.nvim",
        --- ... other configurations
        opts = {
          keymaps = {
            shortcuts = {
              prefix = "<m-g>",
            },
            prefix = "<m-g><m-g>",
          },
        },
        --- ... other configurations
      }
      
    end,
  },
  {
    "Exafunction/codeium.nvim",
    config = function()
      
      use {
          "Exafunction/windsurf.nvim",
          requires = {
              "nvim-lua/plenary.nvim",
              "hrsh7th/nvim-cmp",
          },
          config = function()
              require("codeium").setup({
              })
          end
      }
      
      
      {
          "Exafunction/windsurf.nvim",
          dependencies = {
              "nvim-lua/plenary.nvim",
              "hrsh7th/nvim-cmp",
          },
          config = function()
              require("codeium").setup({
              })
          end
      },
      
      
      cmp.setup({
          -- ...
          sources = {
              -- ...
              { name = "codeium" }
          }
      })
      
      
      cmp.setup({
          -- ...
          formatting = {
              format = require('lspkind').cmp_format({
                  mode = "symbol",
                  maxwidth = 50,
                  ellipsis_char = '...',
                  symbol_map = { Codeium = "", }
              })
          }
      })
      
      
      {
        'saghen/blink.cmp',
        dependencies = {
          {
            'Exafunction/codeium.nvim',
          },
        },
        opts = {
          sources = {
            default = { 'lsp', 'path', 'snippets', 'buffer', 'codeium' },
            providers = {
              codeium = { name = 'Codeium', module = 'codeium.blink', async = true },
            },
          },
        },
      }
      
      
      require("codeium").setup({
          -- Optionally disable cmp source if using virtual text only
          enable_cmp_source = false,
          virtual_text = {
              enabled = true,
      
              -- These are the defaults
      
              -- Set to true if you never want completions to be shown automatically.
              manual = false,
              -- A mapping of filetype to true or false, to enable virtual text.
              filetypes = {},
              -- Whether to enable virtual text of not for filetypes not specifically listed above.
              default_filetype_enabled = true,
              -- How long to wait (in ms) before requesting completions after typing stops.
              idle_delay = 75,
              -- Priority of the virtual text. This usually ensures that the completions appear on top of
              -- other plugins that also add virtual text, such as LSP inlay hints, but can be modified if
              -- desired.
              virtual_text_priority = 65535,
              -- Set to false to disable all key bindings for managing completions.
              map_keys = true,
              -- The key to press when hitting the accept keybinding but no completion is showing.
              -- Defaults to \t normally or <c-n> when a popup is showing. 
              accept_fallback = nil,
              -- Key bindings for managing completions in virtual text mode.
              key_bindings = {
                  -- Accept the current completion.
                  accept = "<Tab>",
                  -- Accept the next word.
                  accept_word = false,
                  -- Accept the next line.
                  accept_line = false,
                  -- Clear the virtual text.
                  clear = false,
                  -- Cycle to the next completion.
                  next = "<M-]>",
                  -- Cycle to the previous completion.
                  prev = "<M-[>",
              }
          }
      })
      
      
      -- Request completions immediately.
      require('codeium.virtual_text').complete()
      
      -- Request a completion, or cycle to the next if we already have some
      require('codeium.virtual_text').cycle_or_complete()
      
      -- Complete only after idle_delay has passed with no other calls to debounced_complete().
      require('codeium.virtual_text').debounced_complete()
      
      
      require('codeium.virtual_text').setup({
          virtual_text = {
              filetypes = { 
                  python = true,
                  markdown = false
              },
              default_filetype_enabled = true
          }
      })
      
      
      require('codeium.virtual_text').set_statusbar_refresh(function()
      	require('lualine').refresh()
      end)
      
      
      function custom_status()
      	local status = require('codeium.virtual_text').status()
      
      	if status.state == 'idle' then
      		-- Output was cleared, for example when leaving insert mode
              return ' '
          end
      
      	if status.state == 'waiting' then
      		-- Waiting for response
      		return "Waiting..."
          end
      
      	if status.state == 'completions' and status.total > 0 then
              return string.format('%d/%d', status.current, status.total)
          end
      
      	return ' 0 '
      end
      
      
      require('codeium').setup({
      	workspace_root = {
      		use_lsp = true,
      		find_root = nil,
      		paths = {
      			".bzr",
      			".git",
      			".hg",
      			".svn",
      			"_FOSSIL_",
      			"package.json",
      		}
      	}
      })
      
      
      require('codeium').setup({
      	workspace_root = {
      		find_root = function()
      			return vim.fn.CocAction("currentWorkspacePath")
      		end
      	}
      })
      
    end,
  },
  {
    "GeorgesAlkhouri/nvim-aider",
    config = function()
      
      {
          "GeorgesAlkhouri/nvim-aider",
          cmd = "Aider",
          -- Example key mappings for common actions:
          keys = {
            { "<leader>a/", "<cmd>Aider toggle<cr>", desc = "Toggle Aider" },
            { "<leader>as", "<cmd>Aider send<cr>", desc = "Send to Aider", mode = { "n", "v" } },
            { "<leader>ac", "<cmd>Aider command<cr>", desc = "Aider Commands" },
            { "<leader>ab", "<cmd>Aider buffer<cr>", desc = "Send Buffer" },
            { "<leader>a+", "<cmd>Aider add<cr>", desc = "Add File" },
            { "<leader>a-", "<cmd>Aider drop<cr>", desc = "Drop File" },
            { "<leader>ar", "<cmd>Aider add readonly<cr>", desc = "Add Read-Only" },
            { "<leader>aR", "<cmd>Aider reset<cr>", desc = "Reset Session" },
            -- Example nvim-tree.lua integration if needed
            { "<leader>a+", "<cmd>AiderTreeAddFile<cr>", desc = "Add File from Tree to Aider", ft = "NvimTree" },
            { "<leader>a-", "<cmd>AiderTreeDropFile<cr>", desc = "Drop File from Tree from Aider", ft = "NvimTree" },
          },
          dependencies = {
            "folke/snacks.nvim",
            --- The below dependencies are optional
            "catppuccin/nvim",
            "nvim-tree/nvim-tree.lua",
            --- Neo-tree integration
            {
              "nvim-neo-tree/neo-tree.nvim",
              opts = function(_, opts)
                -- Example mapping configuration (already set by default)
                -- opts.window = {
                --   mappings = {
                --     ["+"] = { "nvim_aider_add", desc = "add to aider" },
                --     ["-"] = { "nvim_aider_drop", desc = "drop from aider" }
                --     ["="] = { "nvim_aider_add_read_only", desc = "add read-only to aider" }
                --   }
                -- }
                require("nvim_aider.neo_tree").setup(opts)
              end,
            },
          },
          config = true,
        }
      
      
      require("nvim_aider").setup({
        -- Command that executes Aider
        aider_cmd = "aider",
        -- Command line arguments passed to aider
        args = {
          "--no-auto-commits",
          "--pretty",
          "--stream",
        },
        -- Automatically reload buffers changed by Aider (requires vim.o.autoread = true)
        auto_reload = false,
        -- Idle timeout in ms for Aider's output.
        idle_timeout = 5000,
        -- Response timeout in ms for Aider's first output chunk.
        response_timeout = 30000,
        -- Timeout in ms for quick commands.
        quick_idle_timeout = 500,
        -- A list of slash-commands that should have a shorter idle timeout.
        quick_commands = {
          "/add",
          "/drop",
          "/read-only",
          "/ls",
          "/clear",
          "/reset",
          "/undo",
        },
        -- Show 'Processing...' and 'Done' notifications.
        notifications = true,
        -- Theme colors (automatically uses Catppuccin flavor if available)
        theme = {
          user_input_color = "#a6da95",
          tool_output_color = "#8aadf4",
          tool_error_color = "#ed8796",
          tool_warning_color = "#eed49f",
          assistant_output_color = "#c6a0f6",
          completion_menu_color = "#cad3f5",
          completion_menu_bg_color = "#24273a",
          completion_menu_current_color = "#181926",
          completion_menu_current_bg_color = "#f4dbd6",
        },
        -- snacks.picker.layout.Config configuration
        picker_cfg = {
          preset = "vscode",
        },
        -- Other snacks.terminal.Opts options
        config = {
          os = { editPreset = "nvim-remote" },
          gui = { nerdFontsVersion = "3" },
        },
        win = {
          wo = { winbar = "Aider" },
          style = "nvim_aider",
          position = "right",
        },
      })
      
      
      local api = require("nvim_aider").api
      
      
      api.health_check()
      
      
      api.toggle_terminal()
      
      
      api.send_to_terminal("Fix the login validation")
      
      
      api.send_command("/commit", "Add error handling")
      
      
      api.reset_session()
      
      
      api.add_file("/src/utils.lua")
      
      
      api.drop_file("/outdated/legacy.py")
      
      
      vim.api.nvim_create_autocmd("BufWritePost", {
        callback = function()
          api.add_current_file()
        end
      })
      
      
      api.drop_current_file()
      
      
      api.add_read_only_file()
      
      
      api.send_buffer_with_prompt()
      
      
      api.send_diagnostics_with_prompt()
      
      
      api.open_command_picker(nil, function(picker, item)
        if item.text == "/custom" then
          -- Implement custom command handling
        else
          -- Default behavior
          picker:close()
          api.send_command(item.text)
        end
      end)
      
    end,
  },
  {
    "CopilotC-Nvim/CopilotChat.nvim",
    config = function()
      
      return {
        {
          "CopilotC-Nvim/CopilotChat.nvim",
          dependencies = {
            { "nvim-lua/plenary.nvim", branch = "master" },
          },
          build = "make tiktoken",
          opts = {
            -- See Configuration section for options
          },
        },
      }
      
      
      > vim.g.copilot_no_tab_map = true
      > vim.keymap.set('i', '<S-Tab>', 'copilot#Accept("\\<S-Tab>")', { expr = true, replace_keycodes = false })
      > 
      
      {
        model = 'gpt-4.1',           -- AI model to use
        temperature = 0.1,           -- Lower = focused, higher = creative
        window = {
          layout = 'vertical',       -- 'vertical', 'horizontal', 'float'
          width = 0.5,              -- 50% of screen width
        },
        auto_insert_mode = true,     -- Enter insert mode when opening
      }
      
      
      {
        window = {
          layout = 'float',
          width = 80, -- Fixed width in columns
          height = 20, -- Fixed height in rows
          border = 'rounded', -- 'single', 'double', 'rounded', 'solid'
          title = '🤖 AI Assistant',
          zindex = 100, -- Ensure window stays on top
        },
      
        headers = {
          user = '👤 You',
          assistant = '🤖 Copilot',
          tool = '🔧 Tool',
        },
      
        separator = '━━',
        auto_fold = true, -- Automatically folds non-assistant messages
      }
      
      
      -- Auto-command to customize chat buffer behavior
      vim.api.nvim_create_autocmd('BufEnter', {
        pattern = 'copilot-*',
        callback = function()
          vim.opt_local.relativenumber = false
          vim.opt_local.number = false
          vim.opt_local.conceallevel = 0
        end,
      })
      
      
      -- In your colorscheme or init.lua
      vim.api.nvim_set_hl(0, 'CopilotChatHeader', { fg = '#7C3AED', bold = true })
      vim.api.nvim_set_hl(0, 'CopilotChatSeparator', { fg = '#374151' })
      
      
      {
        prompts = {
          MyCustomPrompt = {
            prompt = 'Explain how it works.',
            system_prompt = 'You are very good at explaining stuff',
            mapping = '<leader>ccmc',
            description = 'My custom prompt description',
          },
          Yarrr = {
            system_prompt = 'You are fascinated by pirates, so please respond in pirate speak.',
          },
          NiceInstructions = {
            system_prompt = 'You are a nice coding tutor, so please respond in a friendly and helpful manner.',
          }
        }
      }
      
      
      {
        functions = {
          birthday = {
            description = "Retrieves birthday information for a person",
            uri = "birthday://{name}",
            schema = {
              type = 'object',
              required = { 'name' },
              properties = {
                name = {
                  type = 'string',
                  enum = { 'Alice', 'Bob', 'Charlie' },
                  description = "Person's name",
                },
              },
            },
            resolve = function(input)
              return {
                {
                  uri = 'birthday://' .. input.name,
                  mimetype = 'text/plain',
                  data = input.name .. ' birthday info',
                }
              }
            end
          }
        }
      }
      
      
      {
        providers = {
          my_provider = {
            get_url = function(opts) return "https://api.example.com/chat" end,
            get_headers = function() return { ["Authorization"] = "Bearer " .. api_key } end,
            get_models = function() return { { id = "gpt-4.1", name = "GPT-4.1 model" } } end,
            prepare_input = require('CopilotChat.config.providers').copilot.prepare_input,
            prepare_output = require('CopilotChat.config.providers').copilot.prepare_output,
          }
        }
      }
      
      
      {
        -- Optional: Disable provider
        disabled?: boolean,
      
        -- Optional: Extra info about the provider displayed in info panel
        get_info?(): string[]
      
        -- Optional: Get extra request headers with optional expiration time
        get_headers?(): table<string,string>, number?,
      
        -- Optional: Get API endpoint URL
        get_url?(opts: CopilotChat.Provider.options): string,
      
        -- Optional: Prepare request input
        prepare_input?(inputs: table<CopilotChat.Provider.input>, opts: CopilotChat.Provider.options): table,
      
        -- Optional: Prepare response output
        prepare_output?(output: table, opts: CopilotChat.Provider.options): CopilotChat.Provider.output,
      
        -- Optional: Get available models
        get_models?(headers: table): table<CopilotChat.Provider.model>,
      }
      
      
      local chat = require("CopilotChat")
      
      -- Basic Chat Functions
      chat.ask(prompt, config)      -- Ask a question with optional config
      chat.response()               -- Get the last response text
      chat.resolve_prompt()         -- Resolve prompt references
      chat.resolve_tools()          -- Resolve tools that are available for automatic use by LLM
      chat.resolve_model()          -- Resolve model from prompt (WARN: async, requires plenary.async.run)
      
      -- Window Management
      chat.open(config)             -- Open chat window with optional config
      chat.close()                  -- Close chat window
      chat.toggle(config)           -- Toggle chat window visibility with optional config
      chat.reset()                  -- Reset the chat
      chat.stop()                   -- Stop current output
      
      -- Source Management
      chat.get_source()             -- Get the current source buffer and window
      chat.set_source(winnr)        -- Set the source window
      
      -- Prompt & Model Management
      chat.select_prompt(config)    -- Open prompt selector with optional config
      chat.select_model()           -- Open model selector
      
      -- History Management
      chat.load(name, history_path) -- Load chat history
      chat.save(name, history_path) -- Save chat history
      
      -- Configuration
      chat.setup(config)            -- Update configuration
      chat.log_level(level)         -- Set log level (debug, info, etc.)
      
      
      local window = require("CopilotChat").chat
      
      -- Chat UI State
      window:visible()             -- Check if chat window is visible
      window:focused()             -- Check if chat window is focused
      
      -- Message Management
      window:get_message(role, cursor)               -- Get chat message by role, either last or closest to cursor
      window:add_message({ role, content }, replace) -- Add or replace a message in chat
      window:remove_message(role, cursor)            -- Remove chat message by role, either last or closest to cursor
      window:get_block(role, cursor)                 -- Get code block by role, either last or closest to cursor
      window:add_sticky(sticky)                      -- Add sticky prompt to chat message
      
      -- Content Management
      window:append(text)          -- Append text to chat window
      window:clear()               -- Clear chat window content
      window:start()               -- Start writing to chat window
      window:finish()              -- Finish writing to chat window
      
      -- Navigation
      window:follow()              -- Move cursor to end of chat content
      window:focus()               -- Focus the chat window
      
      -- Advanced Features
      window:overlay(opts)         -- Show overlay with specified options
      
      
      -- Open chat, ask a question and handle response
      require("CopilotChat").open()
      require("CopilotChat").ask("#buffer Explain this code", {
        callback = function(response)
          vim.notify("Got response: " .. response:sub(1, 50) .. "...")
          return response
        end,
      })
      
      -- Save and load chat history
      require("CopilotChat").save("my_debugging_session")
      require("CopilotChat").load("my_debugging_session")
      
      -- Use custom sticky and model
      require("CopilotChat").ask("How can I optimize this?", {
        model = "gpt-4.1",
        sticky = {"#buffer", "#gitdiff:staged"}
      })
      
    end,
  },
  {
    "tzachar/cmp-ai",
    config = function()
      
      return require("lazy").setup({
          {'tzachar/cmp-ai', dependencies = 'nvim-lua/plenary.nvim'},
          {'hrsh7th/nvim-cmp', dependencies = {'tzachar/cmp-ai'}},
      })
      
      
      require'cmp'.setup {
          sources = {
              { name = 'cmp_ai' },
          },
      }
      
      
      local cmp_ai = require('cmp_ai.config')
      
      cmp_ai:setup({
        max_lines = 1000,
        provider = 'HF',
        notify = true,
        notify_callback = function(msg)
          vim.notify(msg)
        end,
        run_on_every_keystroke = true,
        ignored_file_types = {
          -- default is not to ignore
          -- uncomment to ignore in lua:
          -- lua = true
        },
      })
      
      
      local cmp_ai = require('cmp_ai.config')
      
      cmp_ai:setup({
        max_lines = 1000,
        provider = 'OpenAI',
        provider_options = {
          model = 'gpt-4',
        },
        notify = true,
        notify_callback = function(msg)
          vim.notify(msg)
        end,
        run_on_every_keystroke = true,
        ignored_file_types = {
          -- default is not to ignore
          -- uncomment to ignore in lua:
          -- lua = true
        },
      })
      
      
      local cmp_ai = require('cmp_ai.config')
      
      cmp_ai:setup({
        max_lines = 1000,
        provider = 'Codestral',
        provider_options = {
          model = 'codestral-latest',
        },
        notify = true,
        notify_callback = function(msg)
          vim.notify(msg)
        end,
        run_on_every_keystroke = true,
        ignored_file_types = {
          -- default is not to ignore
          -- uncomment to ignore in lua:
          -- lua = true
        },
      })
      
      
      local cmp_ai = require('cmp_ai.config')
      
      cmp_ai:setup({
        max_lines = 1000,
        provider = 'Codestral',
        provider_options = {
          model = 'codestral-latest',
          prompt = function(lines_before, lines_after)
            return lines_before
          end,
          suffix = function(lines_after)
            return lines_after
          end
        },
        notify = true,
        notify_callback = function(msg)
          vim.notify(msg)
        end,
        run_on_every_keystroke = true,
      })
      
      
      local cmp_ai = require('cmp_ai.config')
      
      cmp_ai:setup({
        max_lines = 1000,
        provider = 'Bard',
        notify = true,
        notify_callback = function(msg)
          vim.notify(msg)
        end,
        run_on_every_keystroke = true,
        ignored_file_types = {
          -- default is not to ignore
          -- uncomment to ignore in lua:
          -- lua = true
        },
      })
      
      
      local cmp_ai = require('cmp_ai.config')
      
      cmp_ai:setup({
        max_lines = 100,
        provider = 'Ollama',
        provider_options = {
          model = 'codellama:7b-code',
          auto_unload = false, -- Set to true to automatically unload the model when
                              -- exiting nvim.
        },
        notify = true,
        notify_callback = function(msg)
          vim.notify(msg)
        end,
        run_on_every_keystroke = true,
        ignored_file_types = {
          -- default is not to ignore
          -- uncomment to ignore in lua:
          -- lua = true
        },
      })
      
      
      local cmp_ai = require('cmp_ai.config')
      
      cmp_ai:setup({
        max_lines = 100,
        provider = 'Ollama',
        provider_options = {
          model = 'codegemma:2b-code',
          prompt = function(lines_before, lines_after)
            return lines_before
          end,
          suffix = function(lines_after)
            return lines_after
          end,
        },
        notify = true,
        notify_callback = function(msg)
          vim.notify(msg)
        end,
        run_on_every_keystroke = true,
      })
      
      
      local cmp_ai = require('cmp_ai.config')
      
      cmp_ai:setup({
        max_lines = 100,
        provider = 'Ollama',
        provider_options = {
          model = 'qwen2.5-coder:7b-base-q6_K',
          prompt = function(lines_before, lines_after)
          -- You may include filetype and/or other project-wise context in this string as well.
          -- Consult model documentation in case there are special tokens for this.
            return "<|fim_prefix|>" .. lines_before .. "<|fim_suffix|>" .. lines_after .. "<|fim_middle|>"
          end,
        },
        notify = true,
        notify_callback = function(msg)
          vim.notify(msg)
        end,
        run_on_every_keystroke = false,
      })
      
      
      local cmp_ai = require('cmp_ai.config')
      
      cmp_ai:setup({
        max_lines = 1000,
        provider = 'Tabby',
        notify = true,
        provider_options = {
          -- These are optional
          -- user = 'yourusername',
          -- temperature = 0.2,
          -- seed = 'randomstring',
        },
        notify_callback = function(msg)
          vim.notify(msg)
        end,
        run_on_every_keystroke = true,
        ignored_file_types = {
          -- default is not to ignore
          -- uncomment to ignore in lua:
          -- lua = true
        },
      })
      
      
      notify_callback = function(msg)
        require('notify').notify(msg, vim.log.levels.INFO, {
          title = 'OpenAI',
          render = 'compact',
        })
      end
      
      
      notify_callback = {
          on_start = function(msg)
              require('notify').notify(
                  msg .. "completion started",
                  vim.log.levels.INFO,
                  {
                      title = 'OpenAI',
                      render = 'compact',
                  }
              )
      
              -- do pretty animations or something here
          end,
      
          on_end = function(msg)
              require('notify').notify(
                  msg .. "completion ended",
                  vim.log.levels.INFO,
                  {
                      title = 'OpenAI',
                      render = 'compact',
                  }
              )
      
              -- finish pretty animations started above
          end,
      }
      
      
      cmp_ai:setup({
          log_errors = true,
      })
      
      
      cmp_ai:setup({
        max_timeout_seconds = 8,
      })
      
      
      local ignored_file_types = {
        html = true,
      }
      
      
      cmp.setup({
        ...
        mapping = {
          ...
          ['<C-x>'] = cmp.mapping(
            cmp.mapping.complete({
              config = {
                sources = cmp.config.sources({
                  { name = 'cmp_ai' },
                }),
              },
            }),
            { 'i' }
          ),
        },
      })
      
      
      require('cmp').setup({
        sources = {
          { name = 'cmp_ai' },
        },
        formatting = {
          format = require('lspkind').cmp_format({
            mode = "symbol_text",
            maxwidth = 50,
            ellipsis_char = '...',
            show_labelDetails = true,
            symbol_map = {
              HF = "",
              OpenAI = "",
              Codestral = "",
              Bard = "",
            }
          });
        },
      })
      
      
      local compare = require('cmp.config.compare')
      cmp.setup({
        sorting = {
          priority_weight = 2,
          comparators = {
            require('cmp_ai.compare'),
            compare.offset,
            compare.exact,
            compare.score,
            compare.recently_used,
            compare.kind,
            compare.sort_text,
            compare.length,
            compare.order,
          },
        },
      })
      
      
      provider_options = {
        raw_response_cb = function(response)
          -- the `response` parameter contains the raw response (JSON-like) object.
      
          vim.notify(vim.inspect(response)) -- show the response as a lua table
      
          vim.g.ai_raw_response = response -- store the raw response in a global
                                           -- variable so that you can use it
                                           -- somewhere else (like statusline).
        end,
      }
      
    end,
  },
  {
    "milanglacier/minuet-ai.nvim",
    config = function()
      
      specs = {
          {
              'milanglacier/minuet-ai.nvim',
              config = function()
                  require('minuet').setup {
                      -- Your configuration options here
                  }
              end,
          },
          { 'nvim-lua/plenary.nvim' },
          -- optional, if you are using virtual-text frontend, nvim-cmp is not
          -- required.
          { 'hrsh7th/nvim-cmp' },
          -- optional, if you are using virtual-text frontend, blink is not required.
          { 'Saghen/blink.cmp' },
      }
      
      
      require('minuet').setup {
          virtualtext = {
              auto_trigger_ft = {},
              keymap = {
                  -- accept whole completion
                  accept = '<A-A>',
                  -- accept one line
                  accept_line = '<A-a>',
                  -- accept n lines (prompts for number)
                  -- e.g. "A-z 2 CR" will accept 2 lines
                  accept_n_lines = '<A-z>',
                  -- Cycle to prev completion item, or manually invoke completion
                  prev = '<A-[>',
                  -- Cycle to next completion item, or manually invoke completion
                  next = '<A-]>',
                  dismiss = '<A-e>',
              },
          },
      }
      
      
      require('cmp').setup {
          sources = {
              {
                   -- Include minuet as a source to enable autocompletion
                  { name = 'minuet' },
                  -- and your other sources
              }
          },
          performance = {
              -- It is recommended to increase the timeout duration due to
              -- the typically slower response speed of LLMs compared to
              -- other completion sources. This is not needed when you only
              -- need manual completion.
              fetching_timeout = 2000,
          },
      }
      
      
      -- If you wish to invoke completion manually,
      -- The following configuration binds `A-y` key
      -- to invoke the configuration manually.
      require('cmp').setup {
          mapping = {
              ["<A-y>"] = require('minuet').make_cmp_map()
              -- and your other keymappings
          },
      }
      
      
      require('blink-cmp').setup {
          keymap = {
              -- Manually invoke minuet completion.
              ['<A-y>'] = require('minuet').make_blink_map(),
          },
          sources = {
               -- Enable minuet for autocomplete
              default = { 'lsp', 'path', 'buffer', 'snippets', 'minuet' },
              -- For manual completion only, remove 'minuet' from default
              providers = {
                  minuet = {
                      name = 'minuet',
                      module = 'minuet.blink',
                      async = true,
                      -- Should match minuet.config.request_timeout * 1000,
                      -- since minuet.config.request_timeout is in seconds
                      timeout_ms = 3000,
                      score_offset = 50, -- Gives minuet higher priority among suggestions
                  },
              },
          },
          -- Recommended to avoid unnecessary request
          completion = { trigger = { prefetch_on_insert = false } },
      }
      
      
      require('minuet').setup {
          lsp = {
              enabled_ft = { 'toml', 'lua', 'cpp' },
              -- Enables automatic completion triggering using `vim.lsp.completion.enable`
              enabled_auto_trigger_ft = { 'cpp', 'lua' },
          }
      }
      
      
      vim.api.nvim_create_autocmd('LspAttach', {
          callback = function(args)
              local client_id = args.data.client_id
              local bufnr = args.buf
              local client = vim.lsp.get_client_by_id(client_id)
              if not client then
                  return
              end
      
              if client.server_capabilities.completionProvider and client.name ~= 'minuet' then
                  vim.lsp.completion.enable(true, client_id, bufnr, { autotrigger = true })
              end
          end,
          desc = 'Enable built-in auto completion',
      })
      
      
      require('minuet').setup {
          provider = 'openai_compatible',
          request_timeout = 2.5,
          throttle = 1500, -- Increase to reduce costs and avoid rate limits
          debounce = 600, -- Increase to reduce costs and avoid rate limits
          provider_options = {
              openai_compatible = {
                  api_key = 'OPENROUTER_API_KEY',
                  end_point = 'https://openrouter.ai/api/v1/chat/completions',
                  model = 'moonshotai/kimi-k2',
                  name = 'Openrouter',
                  optional = {
                      max_tokens = 56,
                      top_p = 0.9,
                      provider = {
                           -- Prioritize throughput for faster completion
                          sort = 'throughput',
                      },
                  },
              },
          },
      }
      
      
      -- you can use deepseek with both openai_fim_compatible or openai_compatible provider
      require('minuet').setup {
          provider = 'openai_fim_compatible',
          provider_options = {
              openai_fim_compatible = {
                  api_key = 'DEEPSEEK_API_KEY',
                  name = 'deepseek',
                  optional = {
                      max_tokens = 256,
                      top_p = 0.9,
                  },
              },
          },
      }
      
      
      -- or
      require('minuet').setup {
          provider = 'openai_compatible',
          provider_options = {
              openai_compatible = {
                  end_point = 'https://api.deepseek.com/chat/completions',
                  api_key = 'DEEPSEEK_API_KEY',
                  name = 'deepseek',
                  optional = {
                      max_tokens = 256,
                      top_p = 0.9,
                  },
              },
          },
      }
      
      
      require('minuet').setup {
          provider = 'openai_fim_compatible',
          n_completions = 1, -- recommend for local model for resource saving
          -- I recommend beginning with a small context window size and incrementally
          -- expanding it, depending on your local computing power. A context window
          -- of 512, serves as an good starting point to estimate your computing
          -- power. Once you have a reliable estimate of your local computing power,
          -- you should adjust the context window to a larger value.
          context_window = 512,
          provider_options = {
              openai_fim_compatible = {
                  -- For Windows users, TERM may not be present in environment variables.
                  -- Consider using APPDATA instead.
                  api_key = 'TERM',
                  name = 'Ollama',
                  end_point = 'http://localhost:11434/v1/completions',
                  model = 'qwen2.5-coder:7b',
                  optional = {
                      max_tokens = 56,
                      top_p = 0.9,
                  },
              },
          },
      }
      
      
      require('minuet').setup {
          provider = 'openai_fim_compatible',
          n_completions = 1, -- recommend for local model for resource saving
          -- I recommend beginning with a small context window size and incrementally
          -- expanding it, depending on your local computing power. A context window
          -- of 512, serves as an good starting point to estimate your computing
          -- power. Once you have a reliable estimate of your local computing power,
          -- you should adjust the context window to a larger value.
          context_window = 512,
          provider_options = {
              openai_fim_compatible = {
                  -- For Windows users, TERM may not be present in environment variables.
                  -- Consider using APPDATA instead.
                  api_key = 'TERM',
                  name = 'Llama.cpp',
                  end_point = 'http://localhost:8012/v1/completions',
                  -- The model is set by the llama-cpp server and cannot be altered
                  -- post-launch.
                  model = 'PLACEHOLDER',
                  optional = {
                      max_tokens = 56,
                      top_p = 0.9,
                  },
                  -- Llama.cpp does not support the `suffix` option in FIM completion.
                  -- Therefore, we must disable it and manually populate the special
                  -- tokens required for FIM completion.
                  template = {
                      prompt = function(context_before_cursor, context_after_cursor, _)
                          return '<|fim_prefix|>'
                              .. context_before_cursor
                              .. '<|fim_suffix|>'
                              .. context_after_cursor
                              .. '<|fim_middle|>'
                      end,
                      suffix = false,
                  },
              },
          },
      }
      
      
      default_config = {
          -- Enable or disable auto-completion. Note that you still need to add
          -- Minuet to your cmp/blink sources. This option controls whether cmp/blink
          -- will attempt to invoke minuet when minuet is included in cmp/blink
          -- sources. This setting has no effect on manual completion; Minuet will
          -- always be enabled when invoked manually. You can use the command
          -- `Minuet cmp/blink toggle` to toggle this option.
          cmp = {
              enable_auto_complete = true,
          },
          blink = {
              enable_auto_complete = true,
          },
          -- LSP is recommended only for built-in completion. If you are using
          -- `cmp` or `blink`, utilizing LSP for code completion from Minuet is *not*
          -- recommended.
          lsp = {
              enabled_ft = {},
              -- Filetypes excluded from LSP activation. Useful when `enabled_ft` = { '*' }
              disabled_ft = {},
              -- Enables automatic completion triggering using `vim.lsp.completion.enable`
              enabled_auto_trigger_ft = {},
              -- Filetypes excluded from autotriggering. Useful when `enabled_auto_trigger_ft` = { '*' }
              disabled_auto_trigger_ft = {},
              -- if true, when the user is using blink or nvim-cmp or built-in pum
              -- menu, warn the user that they should use the native source instead.
              warn_on_blink_or_cmp = true,
              -- See README section [Built-in Completion, Mini.Completion, and LSP
              -- Setup] for more details on this option.
              adjust_indentation = true,
          },
          virtualtext = {
              -- Specify the filetypes to enable automatic virtual text completion,
              -- e.g., { 'python', 'lua' }. Note that you can still invoke manual
              -- completion even if the filetype is not on your auto_trigger_ft list.
              auto_trigger_ft = {},
              -- specify file types where automatic virtual text completion should be
              -- disabled. This option is useful when auto-completion is enabled for
              -- all file types i.e., when auto_trigger_ft = { '*' }
              auto_trigger_ignore_ft = {},
              keymap = {
                  accept = nil,
                  accept_line = nil,
                  accept_n_lines = nil,
                  -- Cycle to next completion item, or manually invoke completion
                  next = nil,
                  -- Cycle to prev completion item, or manually invoke completion
                  prev = nil,
                  dismiss = nil,
              },
              -- Whether show virtual text suggestion when the completion menu
              -- (nvim-cmp or blink-cmp) is visible.
              show_on_completion_menu = false,
          },
          provider = 'codestral',
          -- the maximum total characters of the context before and after the cursor
          -- 16000 characters typically equate to approximately 4,000 tokens for
          -- LLMs.
          context_window = 16000,
          -- when the total characters exceed the context window, the ratio of
          -- context before cursor and after cursor, the larger the ratio the more
          -- context before cursor will be used. This option should be between 0 and
          -- 1, context_ratio = 0.75 means the ratio will be 3:1.
          context_ratio = 0.75,
          throttle = 1000, -- only send the request every x milliseconds, use 0 to disable throttle.
          -- debounce the request in x milliseconds, set to 0 to disable debounce
          debounce = 400,
          -- Control notification display for request status
          -- Notification options:
          -- false: Disable all notifications (use boolean false, not string "false")
          -- "debug": Display all notifications (comprehensive debugging)
          -- "verbose": Display most notifications
          -- "warn": Display warnings and errors only
          -- "error": Display errors only
          notify = 'warn',
          -- The request timeout, measured in seconds. When streaming is enabled
          -- (stream = true), setting a shorter request_timeout allows for faster
          -- retrieval of completion items, albeit potentially incomplete.
          -- Conversely, with streaming disabled (stream = false), a timeout
          -- occurring before the LLM returns results will yield no completion items.
          request_timeout = 3,
          -- If completion item has multiple lines, create another completion item
          -- only containing its first line. This option only has impact for cmp and
          -- blink. For virtualtext, no single line entry will be added.
          add_single_line_entry = true,
          -- The number of completion items encoded as part of the prompt for the
          -- chat LLM. For FIM model, this is the number of requests to send. It's
          -- important to note that when 'add_single_line_entry' is set to true, the
          -- actual number of returned items may exceed this value. Additionally, the
          -- LLM cannot guarantee the exact number of completion items specified, as
          -- this parameter serves only as a prompt guideline.
          n_completions = 3,
          --  Length of context after cursor used to filter completion text.
          --
          -- This setting helps prevent the language model from generating redundant
          -- text.  When filtering completions, the system compares the suffix of a
          -- completion candidate with the text immediately following the cursor.
          --
          -- If the length of the longest common substring between the end of the
          -- candidate and the beginning of the post-cursor context exceeds this
          -- value, that common portion is trimmed from the candidate.
          --
          -- For example, if the value is 15, and a completion candidate ends with a
          -- 20-character string that exactly matches the 20 characters following the
          -- cursor, the candidate will be truncated by those 20 characters before
          -- being delivered.
          after_cursor_filter_length = 15,
          -- Similar to after_cursor_filter_length but trim the completion item from
          -- prefix instead of suffix.
          before_cursor_filter_length = 2,
          -- proxy port to use
          proxy = nil,
          provider_options = {
              -- see the documentation in each provider in the following part.
          },
          -- see the documentation in the `Prompt` section
          default_system = {
              template = '...',
              prompt = '...',
              guidelines = '...',
              n_completion_template = '...',
          },
          default_system_prefix_first = {
              template = '...',
              prompt = '...',
              guidelines = '...',
              n_completion_template = '...',
          },
          default_fim_template = {
              prompt = '...',
              suffix = '...',
          },
          default_few_shots = { '...' },
          default_chat_input = { '...' },
          default_few_shots_prefix_first = { '...' },
          default_chat_input_prefix_first = { '...' },
          -- Config options for `Minuet change_preset` command
          presets = {}
      }
      
      
      require('minuet').setup {
          provider_options = {
              openai_compatible = {
                  -- good
                  api_key = 'FIREWORKS_API_KEY', -- will read the environment variable FIREWORKS_API_KEY
                  -- good
                  api_key = function() return 'sk-xxxx' end,
                  -- bad
                  api_key = 'sk-xxxx',
              }
          }
      }
      
      
      require('minuet').setup {
          provider = 'gemini'
      }
      
      
      provider_options = {
          openai = {
              model = 'gpt-4.1-mini',
              system = "see [Prompt] section for the default value",
              few_shots = "see [Prompt] section for the default value",
              chat_input = "See [Prompt Section for default value]",
              stream = true,
              api_key = 'OPENAI_API_KEY',
              optional = {
                  -- pass any additional parameters you want to send to OpenAI request,
                  -- e.g.
                  -- stop = { 'end' },
                  -- max_tokens = 256,
                  -- top_p = 0.9,
                  -- reasoning_effort = 'minimal'
              },
          },
      }
      
      
      provider_options = {
          openai = {
              optional = {
                  max_tokens = 256,
              },
          },
      }
      
      
      provider_options = {
          claude = {
              max_tokens = 512,
              model = 'claude-3-5-haiku-20241022',
              system = "see [Prompt] section for the default value",
              few_shots = "see [Prompt] section for the default value",
              chat_input = "See [Prompt Section for default value]",
              stream = true,
              api_key = 'ANTHROPIC_API_KEY',
              end_point = 'https://api.anthropic.com/v1/messages',
              optional = {
                  -- pass any additional parameters you want to send to claude request,
                  -- e.g.
                  -- stop_sequences = nil,
              },
          },
      }
      
      
      provider_options = {
          codestral = {
              model = 'codestral-latest',
              end_point = 'https://codestral.mistral.ai/v1/fim/completions',
              api_key = 'CODESTRAL_API_KEY',
              stream = true,
              template = {
                  prompt = "See [Prompt Section for default value]",
                  suffix = "See [Prompt Section for default value]",
              },
              optional = {
                  stop = nil, -- the identifier to stop the completion generation
                  max_tokens = nil,
              },
          },
      }
      
      
      provider_options = {
          codestral = {
              optional = {
                  max_tokens = 256,
                  stop = { '\n\n' },
              },
          },
      }
      
      
      provider_options = {
          gemini = {
              model = 'gemini-2.0-flash',
              system = "see [Prompt] section for the default value",
              few_shots = "see [Prompt] section for the default value",
              chat_input = "See [Prompt Section for default value]",
              stream = true,
              api_key = 'GEMINI_API_KEY',
              end_point = 'https://generativelanguage.googleapis.com/v1beta/models',
              optional = {},
          },
      }
      
      
      provider_options = {
          gemini = {
              optional = {
                  generationConfig = {
                      maxOutputTokens = 256,
                      -- When using `gemini-2.5-flash`, it is recommended to entirely
                      -- disable thinking for faster completion retrieval.
                      thinkingConfig = {
                          thinkingBudget = 0,
                      },
                  },
                  safetySettings = {
                      {
                          -- HARM_CATEGORY_HATE_SPEECH,
                          -- HARM_CATEGORY_HARASSMENT
                          -- HARM_CATEGORY_SEXUALLY_EXPLICIT
                          category = 'HARM_CATEGORY_DANGEROUS_CONTENT',
                          -- BLOCK_NONE
                          threshold = 'BLOCK_ONLY_HIGH',
                      },
                  },
              },
          },
      }
      
      
      provider_options = {
          openai_compatible = {
              model = 'mistralai/devstral-small',
              system = "see [Prompt] section for the default value",
              few_shots = "see [Prompt] section for the default value",
              chat_input = "See [Prompt Section for default value]",
              stream = true,
              end_point = 'https://openrouter.ai/api/v1/chat/completions',
              api_key = 'OPENROUTER_API_KEY',
              name = 'Openrouter',
              optional = {
                  stop = nil,
                  max_tokens = nil,
              },
          }
      }
      
      
      provider_options = {
          openai_fim_compatible = {
              model = 'deepseek-chat',
              end_point = 'https://api.deepseek.com/beta/completions',
              api_key = 'DEEPSEEK_API_KEY',
              name = 'Deepseek',
              stream = true,
              template = {
                  prompt = "See [Prompt Section for default value]",
                  suffix = "See [Prompt Section for default value]",
              },
              -- a list of functions to transform the endpoint, header, and request body
              transform = {},
              -- Custom function to extract LLM-generated text from JSON output
              get_text_fn = {}
              optional = {
                  stop = nil,
                  max_tokens = nil,
              },
          }
      }
      
      
      provider_options = {
          openai_fim_compatible = {
              optional = {
                  max_tokens = 256,
                  stop = { '\n\n' },
              },
          },
      }
      
      
      provider_options.openai_compatible.name = 'Fireworks'
      
      
      require('minuet').setup {
          presets = {
              preset_1 = {
                  -- Configuration for cloud-based requests with large context window
                  context_window = 20000,
                  request_timeout = 4,
                  throttle = 3000,
                  debounce = 1000,
                  provider = 'openai_compatible',
                  provider_options = {
                      openai_compatible = {
                          model = 'llama-3.3-70b-versatile',
                          api_key = 'GROQ_API_KEY',
                          name = 'Groq'
                      }
                  }
              },
              preset_2 = {
                  -- Configuration for local model with smaller context window
                  provider = 'openai_fim_compatible',
                  context_window = 2000,
                  throttle = 400,
                  debounce = 100,
                  provider_options = {
                      openai_fim_compatible = {
                          api_key = 'TERM',
                          name = 'Ollama',
                          end_point = 'http://localhost:11434/v1/completions',
                          model = 'qwen2.5-coder:7b',
                          optional = {
                              max_tokens = 256,
                              top_p = 0.9
                          }
                      }
                  }
              }
          }
      }
      
      
      {
          -- accept whole completion
          require('minuet.virtualtext').action.accept,
          -- accept by line
          require('minuet.virtualtext').action.accept_line,
          -- accept n lines (prompts for number)
          require('minuet.virtualtext').action.accept_n_lines,
          require('minuet.virtualtext').action.next,
          require('minuet.virtualtext').action.prev,
          require('minuet.virtualtext').action.dismiss,
          -- whether the virtual text is visible in current buffer
          require('minuet.virtualtext').action.is_visible,
      }
      
      
      require('lualine').setup {
          sections = {
              lualine_x = {
                  {
                      require 'minuet.lualine',
                      -- the follwing is the default configuration
                      -- the name displayed in the lualine. Set to "provider", "model" or "both"
                      -- display_name = 'both',
                      -- separator between provider and model name for option "both"
                      -- provider_model_separator = ':',
                      -- whether show display_name when no completion requests are active
                      -- display_on_idle = false,
                  },
                  'encoding',
                  'fileformat',
                  'filetype',
              },
          },
      }
      
      
      local kind_icons = {
          Number = '󰎠',
          Array = '',
          Variable = '',
          -- and other icons
          -- LLM Provider icons
          claude = '󰋦',
          openai = '󱢆',
          codestral = '󱎥',
          gemini = '',
          Groq = '',
          Openrouter = '󱂇',
          Ollama = '󰳆',
          ['Llama.cpp'] = '󰳆',
          Deepseek = ''
          -- FALLBACK
          fallback = '',
      }
      
      local source_icons = {
          minuet = '󱗻',
          nvim_lsp = '',
          lsp = '',
          buffer = '',
          luasnip = '',
          snippets = '',
          path = '',
          git = '',
          tags = '',
          -- FALLBACK
          fallback = '󰜚',
      }
      
      local cmp = require 'cmp'
      cmp.setup {
          formatting = {
              format = function(entry, vim_item)
                  -- Kind icons
                  -- This concatenates the icons with the name of the item kind
                  vim_item.kind = string.format('%s %s', kind_icons[vim_item.kind] or kind_icons.fallback, vim_item.kind)
                  -- Source
                  vim_item.menu = source_icons[entry.source.name] or source_icons.fallback
                  return vim_item
              end,
          },
      }
      
      
      local kind_icons = {
          -- LLM Provider icons
          claude = '󰋦',
          openai = '󱢆',
          codestral = '󱎥',
          gemini = '',
          Groq = '',
          Openrouter = '󱂇',
          Ollama = '󰳆',
          ['Llama.cpp'] = '󰳆',
          Deepseek = ''
      }
      
      require('blink-cmp').setup {
          appearance = {
              use_nvim_cmp_as_default = true,
              nerd_font_variant = 'normal',
              kind_icons = kind_icons
          },
      }
      
      
      
      local source_icons = {
          minuet = '󱗻',
          orgmode = '',
          otter = '󰼁',
          nvim_lsp = '',
          lsp = '',
          buffer = '',
          luasnip = '',
          snippets = '',
          path = '',
          git = '',
          tags = '',
          cmdline = '󰘳',
          latex_symbols = '',
          cmp_nvim_r = '󰟔',
          codeium = '󰩂',
          -- FALLBACK
          fallback = '󰜚',
      }
      
      require('blink-cmp').setup {
          appearance = {
              use_nvim_cmp_as_default = true,
              nerd_font_variant = 'normal',
              kind_icons = kind_icons
          },
          completion = {
              menu = {
                  draw = {
                      columns = {
                          { 'label', 'label_description', gap = 1 },
                          { 'kind_icon', 'kind' },
                          { 'source_icon' },
                      },
                      components = {
                          source_icon = {
                              -- don't truncate source_icon
                              ellipsis = false,
                              text = function(ctx)
                                  return source_icons[ctx.source_name:lower()] or source_icons.fallback
                              end,
                              highlight = 'BlinkCmpSource',
                          },
                      },
                  },
              },
          }
      }
      
      
      local cmp = require 'cmp'
      opts.mapping = {
          ['<CR>'] = cmp.mapping(function(fallback)
              -- use the internal non-blocking call to check if cmp is visible
              if cmp.core.view:visible() then
                  cmp.confirm { select = true }
              else
                  fallback()
              end
          end),
      }
      
      
      {
          'milanglacier/minuet-ai.nvim',
          config = function()
              require('minuet').setup {
                  -- Your configuration options here
              }
          end
      },
      {
          'nvim-cmp',
          optional = true,
          opts = function(_, opts)
              -- if you wish to use autocomplete
              table.insert(opts.sources, 1, {
                  name = 'minuet',
                  group_index = 1,
                  priority = 100,
              })
      
              opts.performance = {
                  -- It is recommended to increase the timeout duration due to
                  -- the typically slower response speed of LLMs compared to
                  -- other completion sources. This is not needed when you only
                  -- need manual completion.
                  fetching_timeout = 2000,
              }
      
              opts.mapping = vim.tbl_deep_extend('force', opts.mapping or {}, {
                  -- if you wish to use manual complete
                  ['<A-y>'] = require('minuet').make_cmp_map(),
              })
          end,
      }
      
      
      -- set the following line in your config/options.lua
      vim.g.lazyvim_blink_main = true
      
      {
          'milanglacier/minuet-ai.nvim',
          config = function()
              require('minuet').setup {
                  -- Your configuration options here
              }
          end,
      },
      {
          'saghen/blink.cmp',
          optional = true,
          opts = {
              keymap = {
                  ['<A-y>'] = {
                      function(cmp)
                          cmp.show { providers = { 'minuet' } }
                      end,
                  },
              },
              sources = {
                  -- if you want to use auto-complete
                  default =  { 'minuet' },
                  providers = {
                      minuet = {
                          name = 'minuet',
                          module = 'minuet.blink',
                          score_offset = 100,
                      },
                  },
              },
          },
      }
      
    end,
  },
  {
    "yetone/avante.nvim",
    config = function()
      
      {
        "yetone/avante.nvim",
        -- if you want to build from source then do `make BUILD_FROM_SOURCE=true`
        -- ⚠️ must add this setting! ! !
        build = vim.fn.has("win32") ~= 0
            and "powershell -ExecutionPolicy Bypass -File Build.ps1 -BuildFromSource false"
            or "make",
        event = "VeryLazy",
        version = false, -- Never set this value to "*"! Never!
        ---@module 'avante'
        ---@type avante.Config
        opts = {
          -- add any opts here
          -- this file can contain specific instructions for your project
          instructions_file = "avante.md",
          -- for example
          provider = "claude",
          providers = {
            claude = {
              endpoint = "https://api.anthropic.com",
              model = "claude-sonnet-4-20250514",
              timeout = 30000, -- Timeout in milliseconds
                extra_request_body = {
                  temperature = 0.75,
                  max_tokens = 20480,
                },
            },
            moonshot = {
              endpoint = "https://api.moonshot.ai/v1",
              model = "kimi-k2-0711-preview",
              timeout = 30000, -- Timeout in milliseconds
              extra_request_body = {
                temperature = 0.75,
                max_tokens = 32768,
              },
            },
          },
        },
        dependencies = {
          "nvim-lua/plenary.nvim",
          "MunifTanjim/nui.nvim",
          --- The below dependencies are optional,
          "nvim-mini/mini.pick", -- for file_selector provider mini.pick
          "nvim-telescope/telescope.nvim", -- for file_selector provider telescope
          "hrsh7th/nvim-cmp", -- autocompletion for avante commands and mentions
          "ibhagwan/fzf-lua", -- for file_selector provider fzf
          "stevearc/dressing.nvim", -- for input provider dressing
          "folke/snacks.nvim", -- for input provider snacks
          "nvim-tree/nvim-web-devicons", -- or echasnovski/mini.icons
          "zbirenbaum/copilot.lua", -- for providers='copilot'
          {
            -- support for image pasting
            "HakonHarnes/img-clip.nvim",
            event = "VeryLazy",
            opts = {
              -- recommended settings
              default = {
                embed_image_as_base64 = false,
                prompt_for_file_name = false,
                drag_and_drop = {
                  insert_mode = true,
                },
                -- required for Windows users
                use_absolute_path = true,
              },
            },
          },
          {
            -- Make sure to set this up properly if you have lazy=true
            'MeanderingProgrammer/render-markdown.nvim',
            opts = {
              file_types = { "markdown", "Avante" },
            },
            ft = { "markdown", "Avante" },
          },
        },
      }
      
      
      local add, later, now = MiniDeps.add, MiniDeps.later, MiniDeps.now
      
      add({
        source = 'yetone/avante.nvim',
        monitor = 'main',
        depends = {
          'nvim-lua/plenary.nvim',
          'MunifTanjim/nui.nvim',
          'echasnovski/mini.icons'
        },
        hooks = { post_checkout = function() vim.cmd('make') end }
      })
      --- optional
      add({ source = 'hrsh7th/nvim-cmp' })
      add({ source = 'zbirenbaum/copilot.lua' })
      add({ source = 'HakonHarnes/img-clip.nvim' })
      add({ source = 'MeanderingProgrammer/render-markdown.nvim' })
      
      later(function() require('render-markdown').setup({...}) end)
      later(function()
        require('img-clip').setup({...}) -- config img-clip
        require("copilot").setup({...}) -- setup copilot to your liking
        require("avante").setup({...}) -- config for avante.nvim
      end)
      
      
      -- deps:
      require('cmp').setup ({
        -- use recommended settings from above
      })
      require('img-clip').setup ({
        -- use recommended settings from above
      })
      require('copilot').setup ({
        -- use recommended settings from above
      })
      require('render-markdown').setup ({
        -- use recommended settings from above
      })
      require('avante').setup({
        -- Example: Using snacks.nvim as input provider
        input = {
          provider = "snacks", -- "native" | "dressing" | "snacks"
          provider_opts = {
            -- Snacks input configuration
            title = "Avante Input",
            icon = " ",
            placeholder = "Enter your API key...",
          },
        },
        -- Your other config here!
      })
      
      
      > -- views can only be fully collapsed with the global statusline
      > vim.opt.laststatus = 3
      > 
      
      {
        ---@alias Provider "claude" | "openai" | "azure" | "gemini" | "cohere" | "copilot" | string
        ---@type Provider
        provider = "claude", -- The provider used in Aider mode or in the planning phase of Cursor Planning Mode
        ---@alias Mode "agentic" | "legacy"
        ---@type Mode
        mode = "agentic", -- The default mode for interaction. "agentic" uses tools to automatically generate code, "legacy" uses the old planning method to generate code.
        -- WARNING: Since auto-suggestions are a high-frequency operation and therefore expensive,
        -- currently designating it as `copilot` provider is dangerous because: https://github.com/yetone/avante.nvim/issues/1048
        -- Of course, you can reduce the request frequency by increasing `suggestion.debounce`.
        auto_suggestions_provider = "claude",
        providers = {
          claude = {
            endpoint = "https://api.anthropic.com",
            model = "claude-3-5-sonnet-20241022",
            extra_request_body = {
              temperature = 0.75,
              max_tokens = 4096,
            },
          },
        },
        ---Specify the special dual_boost mode
        ---1. enabled: Whether to enable dual_boost mode. Default to false.
        ---2. first_provider: The first provider to generate response. Default to "openai".
        ---3. second_provider: The second provider to generate response. Default to "claude".
        ---4. prompt: The prompt to generate response based on the two reference outputs.
        ---5. timeout: Timeout in milliseconds. Default to 60000.
        ---How it works:
        --- When dual_boost is enabled, avante will generate two responses from the first_provider and second_provider respectively. Then use the response from the first_provider as provider1_output and the response from the second_provider as provider2_output. Finally, avante will generate a response based on the prompt and the two reference outputs, with the default Provider as normal.
        ---Note: This is an experimental feature and may not work as expected.
        dual_boost = {
          enabled = false,
          first_provider = "openai",
          second_provider = "claude",
          prompt = "Based on the two reference outputs below, generate a response that incorporates elements from both but reflects your own judgment and unique perspective. Do not provide any explanation, just give the response directly. Reference Output 1: [{{provider1_output}}], Reference Output 2: [{{provider2_output}}]",
          timeout = 60000, -- Timeout in milliseconds
        },
        behaviour = {
          auto_suggestions = false, -- Experimental stage
          auto_set_highlight_group = true,
          auto_set_keymaps = true,
          auto_apply_diff_after_generation = false,
          support_paste_from_clipboard = false,
          minimize_diff = true, -- Whether to remove unchanged lines when applying a code block
          enable_token_counting = true, -- Whether to enable token counting. Default to true.
          auto_approve_tool_permissions = false, -- Default: show permission prompts for all tools
          -- Examples:
          -- auto_approve_tool_permissions = true,                -- Auto-approve all tools (no prompts)
          -- auto_approve_tool_permissions = {"bash", "replace_in_file"}, -- Auto-approve specific tools only
        },
        prompt_logger = { -- logs prompts to disk (timestamped, for replay/debugging)
          enabled = true, -- toggle logging entirely
          log_dir = vim.fn.stdpath("cache") .. "/avante_prompts", -- directory where logs are saved
          fortune_cookie_on_success = false, -- shows a random fortune after each logged prompt (requires `fortune` installed)
          next_prompt = {
            normal = "<C-n>", -- load the next (newer) prompt log in normal mode
            insert = "<C-n>",
          },
          prev_prompt = {
            normal = "<C-p>", -- load the previous (older) prompt log in normal mode
            insert = "<C-p>",
          },
        },
        mappings = {
          --- @class AvanteConflictMappings
          diff = {
            ours = "co",
            theirs = "ct",
            all_theirs = "ca",
            both = "cb",
            cursor = "cc",
            next = "]x",
            prev = "[x",
          },
          suggestion = {
            accept = "<M-l>",
            next = "<M-]>",
            prev = "<M-[>",
            dismiss = "<C-]>",
          },
          jump = {
            next = "]]",
            prev = "[[",
          },
          submit = {
            normal = "<CR>",
            insert = "<C-s>",
          },
          cancel = {
            normal = { "<C-c>", "<Esc>", "q" },
            insert = { "<C-c>" },
          },
          sidebar = {
            apply_all = "A",
            apply_cursor = "a",
            retry_user_request = "r",
            edit_user_request = "e",
            switch_windows = "<Tab>",
            reverse_switch_windows = "<S-Tab>",
            remove_file = "d",
            add_file = "@",
            close = { "<Esc>", "q" },
            close_from_input = nil, -- e.g., { normal = "<Esc>", insert = "<C-d>" }
          },
        },
        selection = {
          enabled = true,
          hint_display = "delayed",
        },
        windows = {
          ---@type "right" | "left" | "top" | "bottom"
          position = "right", -- the position of the sidebar
          wrap = true, -- similar to vim.o.wrap
          width = 30, -- default % based on available width
          sidebar_header = {
            enabled = true, -- true, false to enable/disable the header
            align = "center", -- left, center, right for title
            rounded = true,
          },
          spinner = {
            editing = { "⡀", "⠄", "⠂", "⠁", "⠈", "⠐", "⠠", "⢀", "⣀", "⢄", "⢂", "⢁", "⢈", "⢐", "⢠", "⣠", "⢤", "⢢", "⢡", "⢨", "⢰", "⣰", "⢴", "⢲", "⢱", "⢸", "⣸", "⢼", "⢺", "⢹", "⣹", "⢽", "⢻", "⣻", "⢿", "⣿" },
            generating = { "·", "✢", "✳", "∗", "✻", "✽" }, -- Spinner characters for the 'generating' state
            thinking = { "🤯", "🙄" }, -- Spinner characters for the 'thinking' state
          },
          input = {
            prefix = "> ",
            height = 8, -- Height of the input window in vertical layout
          },
          edit = {
            border = "rounded",
            start_insert = true, -- Start insert mode when opening the edit window
          },
          ask = {
            floating = false, -- Open the 'AvanteAsk' prompt in a floating window
            start_insert = true, -- Start insert mode when opening the ask window
            border = "rounded",
            ---@type "ours" | "theirs"
            focus_on_apply = "ours", -- which diff to focus after applying
          },
        },
        highlights = {
          ---@type AvanteConflictHighlights
          diff = {
            current = "DiffText",
            incoming = "DiffAdd",
          },
        },
        --- @class AvanteConflictUserConfig
        diff = {
          autojump = true,
          ---@type string | fun(): any
          list_opener = "copen",
          --- Override the 'timeoutlen' setting while hovering over a diff (see :help timeoutlen).
          --- Helps to avoid entering operator-pending mode with diff mappings starting with `c`.
          --- Disable by setting to -1.
          override_timeoutlen = 500,
        },
        suggestion = {
          debounce = 600,
          throttle = 600,
        },
      }
      
      
            selector = {
              --- @alias avante.SelectorProvider "native" | "fzf_lua" | "mini_pick" | "snacks" | "telescope" | fun(selector: avante.ui.Selector): nil
              --- @type avante.SelectorProvider
              provider = "fzf",
              -- Options override for custom providers
              provider_opts = {},
            }
      
      
            selector = {
              ---@param selector avante.ui.Selector
              provider = function(selector)
                local items = selector.items ---@type avante.ui.SelectorItem[]
                local title = selector.title ---@type string
                local on_select = selector.on_select ---@type fun(selected_item_ids: string[]|nil): nil
      
                --- your customized picker logic here
              end,
            }
      
      
      {
        input = {
          provider = "native", -- Uses vim.ui.input
          provider_opts = {},
        }
      }
      
      
      {
        input = {
          provider = "dressing",
          provider_opts = {},
        }
      }
      
      
      -- With lazy.nvim
      { "stevearc/dressing.nvim" }
      
      
      {
        input = {
          provider = "snacks",
          provider_opts = {
            -- Additional snacks.input options
            title = "Avante Input",
            icon = " ",
          },
        }
      }
      
      
      -- With lazy.nvim
      { "folke/snacks.nvim" }
      
      
      {
        input = {
          ---@param input avante.ui.Input
          provider = function(input)
            local title = input.title ---@type string
            local default = input.default ---@type string
            local conceal = input.conceal ---@type boolean
            local on_submit = input.on_submit ---@type fun(result: string|nil): nil
      
            --- your customized input logic here
          end,
        }
      }
      
      
            compat = {
              "avante_commands",
              "avante_mentions",
              "avante_files",
            }
      
      
      {
        shortcuts = {
          {
            name = "refactor",
            description = "Refactor code with best practices",
            details = "Automatically refactor code to improve readability, maintainability, and follow best practices while preserving functionality",
            prompt = "Please refactor this code following best practices, improving readability and maintainability while preserving functionality."
          },
          {
            name = "test",
            description = "Generate unit tests",
            details = "Create comprehensive unit tests covering edge cases, error scenarios, and various input conditions",
            prompt = "Please generate comprehensive unit tests for this code, covering edge cases and error scenarios."
          },
          -- Add more custom shortcuts...
        }
      }
      
      
            default = {
              ...
              "avante_commands",
              "avante_mentions",
              "avante_shortcuts",
              "avante_files",
            }
      
      
            providers = {
              avante_commands = {
                name = "avante_commands",
                module = "blink.compat.source",
                score_offset = 90, -- show at a higher priority than lsp
                opts = {},
              },
              avante_files = {
                name = "avante_files",
                module = "blink.compat.source",
                score_offset = 100, -- show at a higher priority than lsp
                opts = {},
              },
              avante_mentions = {
                name = "avante_mentions",
                module = "blink.compat.source",
                score_offset = 1000, -- show at a higher priority than lsp
                opts = {},
              },
              avante_shortcuts = {
                name = "avante_shortcuts",
                module = "blink.compat.source",
                score_offset = 1000, -- show at a higher priority than lsp
                opts = {},
              }
              ...
          }
      
      
      > bedrock = {
      >   model = "us.anthropic.claude-3-5-sonnet-20241022-v2:0",
      >   aws_profile = "bedrock",
      >   aws_region = "us-east-1",
      > },
      > 
      
      return {
        {
          'nvim-neo-tree/neo-tree.nvim',
          config = function()
            require('neo-tree').setup({
              filesystem = {
                commands = {
                  avante_add_files = function(state)
                    local node = state.tree:get_node()
                    local filepath = node:get_id()
                    local relative_path = require('avante.utils').relative_path(filepath)
      
                    local sidebar = require('avante').get()
      
                    local open = sidebar:is_open()
                    -- ensure avante sidebar is open
                    if not open then
                      require('avante.api').ask()
                      sidebar = require('avante').get()
                    end
      
                    sidebar.file_selector:add_selected_file(relative_path)
      
                    -- remove neo tree buffer
                    if not open then
                      sidebar.file_selector:remove_selected_file('neo-tree filesystem [1]')
                    end
                  end,
                },
                window = {
                  mappings = {
                    ['oa'] = 'avante_add_files',
                  },
                },
              },
            })
          end,
        },
      }
      
      
           behaviour = {
             enable_fastapply = true,  -- Enable Fast Apply feature
           },
           -- ... other configuration
         
      
         providers = {
           morph = {
             model = "morph-v3-large",
           },
         }
         
      
      provider = "ollama",
      providers = {
        ollama = {
          endpoint = "http://localhost:11434",
          model = "qwq:32b",
        },
      }
      
      
      {
        provider = "gemini-cli",
        -- other configuration options...
      }
      
      
      {
        provider = "claude-code",
        -- other configuration options...
      }
      
      
      {
        acp_providers = {
          ["gemini-cli"] = {
            command = "gemini",
            args = { "--experimental-acp" },
            env = {
              NODE_NO_WARNINGS = "1",
              GEMINI_API_KEY = os.getenv("GEMINI_API_KEY"),
            },
          },
          ["claude-code"] = {
            command = "npx",
            args = { "@zed-industries/claude-code-acp" },
            env = {
              NODE_NO_WARNINGS = "1",
              ANTHROPIC_API_KEY = os.getenv("ANTHROPIC_API_KEY"),
            },
          },
        },
        -- other configuration options...
      }
      
      
        rag_service = { -- RAG Service configuration
          enabled = false, -- Enables the RAG service
          host_mount = os.getenv("HOME"), -- Host mount path for the rag service (Docker will mount this path)
          runner = "docker", -- Runner for the RAG service (can use docker or nix)
          llm = { -- Language Model (LLM) configuration for RAG service
            provider = "openai", -- LLM provider
            endpoint = "https://api.openai.com/v1", -- LLM API endpoint
            api_key = "OPENAI_API_KEY", -- Environment variable name for the LLM API key
            model = "gpt-4o-mini", -- LLM model name
            extra = nil, -- Additional configuration options for LLM
          },
          embed = { -- Embedding model configuration for RAG service
            provider = "openai", -- Embedding provider
            endpoint = "https://api.openai.com/v1", -- Embedding API endpoint
            api_key = "OPENAI_API_KEY", -- Environment variable name for the embedding API key
            model = "text-embedding-3-large", -- Embedding model name
            extra = nil, -- Additional configuration options for the embedding model
          },
          docker_extra_args = "", -- Extra arguments to pass to the docker command
        },
      
      
      web_search_engine = {
        provider = "tavily", -- tavily, serpapi, google, kagi, brave, or searxng
        proxy = nil, -- proxy support, e.g., http://127.0.0.1:7890
      }
      
      
      providers = {
        claude = {
          endpoint = "https://api.anthropic.com",
          model = "claude-sonnet-4-20250514",
          timeout = 30000, -- Timeout in milliseconds
          disable_tools = true, -- disable tools!
          extra_request_body = {
            temperature = 0,
            max_tokens = 4096,
          }
        }
      }
      
      
      {
        disabled_tools = { "python" },
      }
      
      
      {
        custom_tools = {
          {
            name = "run_go_tests",  -- Unique name for the tool
            description = "Run Go unit tests and return results",  -- Description shown to AI
            command = "go test -v ./...",  -- Shell command to execute
            param = {  -- Input parameters (optional)
              type = "table",
              fields = {
                {
                  name = "target",
                  description = "Package or directory to test (e.g. './pkg/...' or './internal/pkg')",
                  type = "string",
                  optional = true,
                },
              },
            },
            returns = {  -- Expected return values
              {
                name = "result",
                description = "Result of the fetch",
                type = "string",
              },
              {
                name = "error",
                description = "Error message if the fetch was not successful",
                type = "string",
                optional = true,
              },
            },
            func = function(params, on_log, on_complete)  -- Custom function to execute
              local target = params.target or "./..."
              return vim.fn.system(string.format("go test -v %s", target))
            end,
          },
        },
      }
      
      
      vim.api.nvim_create_autocmd("User", {
        pattern = "ToggleMyPrompt",
        callback = function() require("avante.config").override({system_prompt = "MY CUSTOM SYSTEM PROMPT"}) end,
      })
      
      vim.keymap.set("n", "<leader>am", function() vim.api.nvim_exec_autocmds("User", { pattern = "ToggleMyPrompt" }) end, { desc = "avante: toggle my prompt" })
      
      
      -- Example: Override with prompts from a specific directory
      require("avante").setup({
        override_prompt_dir = vim.fn.expand("~/.config/nvim/avante_prompts"),
      })
      
      -- Example: Override with prompts from a function (dynamic directory)
      require("avante").setup({
        override_prompt_dir = function()
          -- Your logic to determine the prompt directory
          return vim.fn.expand("~/.config/nvim/my_dynamic_prompts")
        end,
      })
      
      
      require('avante').setup({
        rules = {
          project_dir = '.avante/rules', -- relative to project root, can also be an absolute path
          global_dir = '~/.config/avante/rules', -- absolute path
        },
      })
      
      
      {
          "yetone/avante.nvim",
          event = "VeryLazy",
          keys = {
              {
                  "<leader>a+",
                  function()
                      local tree_ext = require("avante.extensions.nvim_tree")
                      tree_ext.add_file()
                  end,
                  desc = "Select file in NvimTree",
                  ft = "NvimTree",
              },
              {
                  "<leader>a-",
                  function()
                      local tree_ext = require("avante.extensions.nvim_tree")
                      tree_ext.remove_file()
                  end,
                  desc = "Deselect file in NvimTree",
                  ft = "NvimTree",
              },
          },
          opts = {
              --- other configurations
              selector = {
                  exclude_auto_select = { "NvimTree" },
              },
          },
      }
      
      
      {
        mode = "legacy", -- Switch from "agentic" to "legacy"
        -- ... your other configuration options
      }
      
      
      {
        mode = "agentic",
        disabled_tools = { "bash", "python" }, -- Disable specific tools
        -- ... your other configuration options
      }
      
    end,
  },
  {
    "Kurama622/llm.nvim",
    config = function()
      
      {
          "MeanderingProgrammer/render-markdown.nvim",
          dependencies = {
            {
              "nvim-treesitter/nvim-treesitter",
              branch = "main",
              config = function()
                vim.api.nvim_create_autocmd("FileType", {
                  pattern = { "llm", "markdown" },
                  callback = function()
                    vim.treesitter.start(0, "markdown")
                  end,
                })
              end,
            },
            "nvim-mini/mini.icons",
          }, -- if you use standalone mini plugins
          ft = { "markdown", "llm" },
      
          config = function()
            require("render-markdown").setup({
              restart_highlighter = true,
              heading = {
                enabled = true,
                sign = false,
                position = "overlay", -- inline | overlay
                icons = { "󰎤 ", "󰎧 ", "󰎪 ", "󰎭 ", "󰎱 ", "󰎳 " },
                signs = { "󰫎 " },
                width = "block",
                left_margin = 0,
                left_pad = 0,
                right_pad = 0,
                min_width = 0,
                border = false,
                border_virtual = false,
                border_prefix = false,
                above = "▄",
                below = "▀",
                backgrounds = {},
                foregrounds = {
                  "RenderMarkdownH1",
                  "RenderMarkdownH2",
                  "RenderMarkdownH3",
                  "RenderMarkdownH4",
                  "RenderMarkdownH5",
                  "RenderMarkdownH6",
                },
              },
              dash = {
                enabled = true,
                icon = "─",
                width = 0.5,
                left_margin = 0.5,
                highlight = "RenderMarkdownDash",
              },
              code = { style = "normal" },
            })
          end,
        }
      
      
        {
          "Kurama622/llm.nvim",
          dependencies = { "nvim-lua/plenary.nvim", "MunifTanjim/nui.nvim"},
          cmd = { "LLMSessionToggle", "LLMSelectedTextHandler", "LLMAppHandler" },
          config = function()
            require("llm").setup({
              url = "https://models.inference.ai.azure.com/chat/completions",
              model = "gpt-4o-mini",
              api_type = "openai"
            })
          end,
          keys = {
            { "<leader>ac", mode = "n", "<cmd>LLMSessionToggle<cr>" },
          },
        }
      
      
      require("mini.deps").setup()
      MiniDeps.add({
              source = "Kurama622/llm.nvim",
              depends = { "nvim-lua/plenary.nvim", "MunifTanjim/nui.nvim" },
              cmd = { "LLMSessionToggle", "LLMSelectedTextHandler", "LLMAppHandler" },
      })
      
      require("llm").setup({
              url = "https://models.inference.ai.azure.com/chat/completions",
              model = "gpt-4o-mini",
              api_type = "openai"
      })
      
      
      local function local_llm_streaming_handler(chunk, ctx, F)
        if not chunk then
          return ctx.assistant_output
        end
        local tail = chunk:sub(-1, -1)
        if tail:sub(1, 1) ~= "}" then
          ctx.line = ctx.line .. chunk
        else
          ctx.line = ctx.line .. chunk
          local status, data = pcall(vim.json.decode, ctx.line)
          if not status or not data.message.content then
            return ctx.assistant_output
          end
          ctx.assistant_output = ctx.assistant_output .. data.message.content
          F.WriteContent(ctx.bufnr, ctx.winid, data.message.content)
          ctx.line = ""
        end
        return ctx.assistant_output
      end
      
      local function local_llm_parse_handler(chunk)
        local assistant_output = chunk.message.content
        return assistant_output
      end
      
      return {
        {
          "Kurama622/llm.nvim",
          dependencies = { "nvim-lua/plenary.nvim", "MunifTanjim/nui.nvim" },
          cmd = { "LLMSessionToggle", "LLMSelectedTextHandler" },
          config = function()
            require("llm").setup({
              url = "http://localhost:11434/api/chat", -- your url
              model = "llama3.2:1b",
      
              streaming_handler = local_llm_streaming_handler,
              app_handler = {
                WordTranslate = {
                  handler = tools.flexi_handler,
                  prompt = "Translate the following text to Chinese, please only return the translation",
                  opts = {
                    parse_handler = local_llm_parse_handler,
                    exit_on_move = true,
                    enter_flexible_window = false,
                  },
                },
              }
            })
          end,
          keys = {
            { "<leader>ac", mode = "n", "<cmd>LLMSessionToggle<cr>" },
          },
        }
      }
      
    end,
  },
  {
    "3v0k4/exit.nvim",
    config = function()
      
      use {
        '3v0k4/exit.nvim', tag = '0.4.1',
      }
      
      
      -- init.lua:
      {
        '3v0k4/exit.nvim', tag = '0.4.1',
      }
      
      -- plugins/exit.lua:
      return {
        '3v0k4/exit.nvim', tag = '0.4.1',
      }
      
    end,
  },
  {
    "k2589/lluminate.nvim",
    config = function()
      
      use {
        'k2589/LLuMinate.nvim',
        config = function()
          require('lluminate').setup()
        end
      }
      
      
      {
        'k2589/LLuMinate.nvim',
        config = function()
          require('lluminate').setup()
        end
      },
      
      
      require('lluminate').setup({
        include_definition = false,  -- Include symbol definitions in the enriched context
        include_hover = true,       -- Include hover information in the enriched context
        include_diagnostics = true,
        diagnostic_levels = {
              "Error",
              "Warning",
              "Information",
              "Hint"
          },
        diagnostic_scope = "selection" -- Can be "selection" (full selection), "line" (first line of selection), or "file" (full file)
      })
      
    end,
  },
  {
    "supermaven-inc/supermaven-nvim",
    config = function()
      
      require("lazy").setup({
          {
            "supermaven-inc/supermaven-nvim",
            config = function()
              require("supermaven-nvim").setup({})
            end,
          },
      }, {})
      
      
      use {
        "supermaven-inc/supermaven-nvim",
        config = function()
          require("supermaven-nvim").setup({})
        end,
      }
      
      
      require("supermaven-nvim").setup({
        keymaps = {
          accept_suggestion = "<Tab>",
          clear_suggestion = "<C-]>",
          accept_word = "<C-j>",
        },
        ignore_filetypes = { cpp = true }, -- or { "cpp", }
        color = {
          suggestion_color = "#ffffff",
          cterm = 244,
        },
        log_level = "info", -- set to "off" to disable logging completely
        disable_inline_completion = false, -- disables inline completion for use with cmp
        disable_keymaps = false, -- disables built in keymaps for more manual control
        condition = function()
          return false
        end -- condition to check for stopping supermaven, `true` means to stop supermaven when the condition is true.
      })
      
      
      require("supermaven-nvim").setup({
        condition = function()
          return string.match(vim.fn.expand("%:t"), "foo.sh")
        end,
      })
      
      
      -- cmp.lua
      cmp.setup {
        ...
        sources = {
          { name = "supermaven" },
        }
        ...
      }
      
      
      -- lspkind.lua
      local lspkind = require("lspkind")
      lspkind.init({
        symbol_map = {
          Supermaven = "",
        },
      })
      
      vim.api.nvim_set_hl(0, "CmpItemKindSupermaven", {fg ="#6CC644"})
      
      
      -- cmp.lua
      cmp.setup {
        ...
        formatting = {
          format = lspkind.cmp_format({
            mode = "symbol",
            max_width = 50,
            symbol_map = { Supermaven = "" }
          })
        }
        ...
      }
      
      
      require("supermaven-nvim").setup({
        disable_keymaps = true
      })
      
      ...
      
      M.expand = function(fallback)
        local luasnip = require('luasnip')
        local suggestion = require('supermaven-nvim.completion_preview')
      
        if luasnip.expandable() then
          luasnip.expand()
        elseif suggestion.has_suggestion() then
          suggestion.on_accept_suggestion()
        else
          fallback()
        end
      end
      
      
      local api = require("supermaven-nvim.api")
      
      api.start() -- starts supermaven-nvim
      api.stop() -- stops supermaven-nvim
      api.restart() -- restarts supermaven-nvim if it is running, otherwise starts it
      api.toggle() -- toggles supermaven-nvim
      api.is_running() -- returns true if supermaven-nvim is running
      api.use_free_version() -- switch to the free version
      api.use_pro() -- switch to the pro version
      api.logout() -- log out of supermaven
      api.show_log() -- show logs for supermaven-nvim
      api.clear_log() -- clear logs for supermaven-nvim
      
    end,
  },
  {
    "milanglacier/yarepl.nvim/blob/main/extensions/README.md",
  },
  {
    "davidyz/vectorcode",
  },
  {
    "dlants/magenta.nvim",
    config = function()
      
      {
          "dlants/magenta.nvim",
          lazy = false, -- you could also bind to <leader>mt
          build = "npm install --frozen-lockfile",
          opts = {},
      },
      
      
      local vim = vim
      local Plug = vim.fn['plug#']
      
      vim.call('plug#begin')
      Plug('dlants/magenta.nvim', {
        ['do'] = 'npm install --frozen-lockfile',
      })
      vim.call('plug#end')
      
      require('magenta').setup({})
      
      
      require('magenta').setup({
        profiles = {
        {
          name = "claude-4",
          provider = "anthropic",
          model = "claude-4-sonnet-latest",
          fastModel = "claude-3-5-haiku-latest", -- optional, defaults provided
          apiKeyEnvVar = "ANTHROPIC_API_KEY",
          thinking = {
            enabled = true,
            budgetTokens = 1024 -- optional, defaults to 1024, must be >= 1024
          }
        },
        {
          name = "claude-max",
          provider = "anthropic",
          model = "claude-3-7-sonnet-latest",
          fastModel = "claude-3-5-haiku-latest",
          authType = "max" -- Use Anthropic OAuth instead of API key
          -- No apiKeyEnvVar needed for max auth
        },
        {
          name = "gpt-5",
          provider = "openai",
          model = "gpt-5",
          fastModel = "gpt-5-mini",
          apiKeyEnvVar = "OPENAI_API_KEY"
        },
        {
          name = "copilot-claude",
          provider = "copilot",
          model = "claude-3.7-sonnet",
          fastModel = "claude-3-5-haiku-latest", -- optional, defaults provided
          -- No apiKeyEnvVar needed - uses existing Copilot authentication
        },
        -- open chat sidebar on left or right side
        sidebarPosition = "left",
        -- can be changed to "telescope" or "snacks"
        picker = "fzf-lua",
        -- enable default keymaps shown below
        defaultKeymaps = true,
        -- maximum number of sub-agents that can run concurrently (default: 3)
        maxConcurrentSubagents = 3,
        -- volume for notification chimes (range: 0.0 to 1.0, default: 0.3)
        -- set to 0.0 to disable chimes entirely
        chimeVolume = 0.3,
        -- glob patterns for files that should be auto-approved for getFile tool
        -- (bypasses user approval for hidden/gitignored files matching these patterns)
        getFileAutoAllowGlobs = { "node_modules/*" }, -- default includes node_modules
        -- keymaps for the sidebar input buffer
        sidebarKeymaps = {
          normal = {
            ["<CR>"] = ":Magenta send<CR>",
          }
        },
        -- keymaps for the inline edit input buffer
        -- if keymap is set to function, it accepts a target_bufnr param
        inlineKeymaps =  {
          normal = {
            ["<CR>"] = function(target_bufnr)
              vim.cmd("Magenta submit-inline-edit " .. target_bufnr)
            end,
          },
        },
        -- configure edit prediction options
        editPrediction = {
          -- Use a dedicated profile for predictions (optional)
          -- If not specified, uses the current active profile's model
          profile = {
            provider = "anthropic",
            model = "claude-3-5-haiku-latest",
            apiKeyEnvVar = "ANTHROPIC_API_KEY"
          },
          -- Maximum number of changes to track for context (default: 10)
          changeTrackerMaxChanges = 20,
          -- Token budget for including recent changes (default: 1000)
          recentChangeTokenBudget = 1500,
          -- Customize the system prompt (optional)
          -- systemPrompt = "Your custom prediction system prompt here...",
          -- Add instructions to the default system prompt (optional)
          systemPromptAppend = "Focus on completing function calls and variable declarations."
        },
        -- configure MCP servers for external tool integrations
        mcpServers = {
          fetch = {
            command = "uvx",
            args = { "mcp-server-fetch" }
          },
          playwright = {
            command = "npx",
            args = {
              "@playwright/mcp@latest"
            }
          },
          -- HTTP-based MCP server example
          httpServer = {
            url = "http://localhost:8000/mcp",
            requestInit = {
              headers = {
                Authorization = "Bearer your-token-here",
              },
            },
          }
        }
      })
      
      
      profiles = {
        {
          name = "claude-3-7",
          provider = "anthropic",
          model = "claude-3-7-sonnet-latest",
          fastModel = "claude-3-5-haiku-latest", -- optional, defaults provided
          apiKeyEnvVar = "ANTHROPIC_API_KEY"
        },
        {
          name = "custom",
          provider = "anthropic",
          model = "claude-3-7-sonnet-latest",
          fastModel = "claude-3-5-haiku-latest",
          apiKeyEnvVar = "CUSTOM_API_KEY_ENV_VAR",
          baseUrl = "custom anthropic endpoint"
        }
      }
      
      
      {
        name = "copilot",
        provider = "copilot",
        model = "claude-3.7-sonnet"  -- or "gpt-5"
      }
      
      
      {
        name = "claude-max",
        provider = "anthropic",
        model = "claude-3-7-sonnet-latest",
        authType = "max"
        -- No apiKeyEnvVar needed
      }
      
      
      editPrediction = {
        -- Use a dedicated profile for predictions (independent of main profiles)
        profile = {
          provider = "anthropic",
          model = "claude-4-sonnet-latest",
          apiKeyEnvVar = "ANTHROPIC_API_KEY",
          -- baseUrl = "custom-endpoint", -- optional
        },
      
        -- Maximum number of changes to track for context (default: 10)
        changeTrackerMaxChanges = 20,
      
        -- Token budget for including recent changes (default: 1000)
        -- Higher values include more history but use more tokens
        recentChangeTokenBudget = 1500,
      
        -- Replace the default system prompt entirely
        -- systemPrompt = "Your custom prediction system prompt here...",
      
        -- Append to the default system prompt instead of replacing it
        systemPromptAppend = "Additional instructions to improve predictions..."
      }
      
      
      require('magenta').setup({
        chimeVolume = 0.2, -- 20% volume (range: 0.0 to 1.0)
        -- ... other options
      })
      
      
      local Actions = require("magenta.actions")
      
      -- Chat and thread management
      vim.keymap.set(
        "n",
        "<leader>mn",
        ":Magenta new-thread<CR>",
        {silent = true, noremap = true, desc = "Create new Magenta thread"}
      )
      
      vim.keymap.set(
        "n",
        "<leader>mc",
        ":Magenta clear<CR>",
        {silent = true, noremap = true, desc = "Clear Magenta state"}
      )
      
      vim.keymap.set(
        "n",
        "<leader>ma",
        ":Magenta abort<CR>",
        {silent = true, noremap = true, desc = "Abort current Magenta operation"}
      )
      
      vim.keymap.set(
        "n",
        "<leader>mt",
        ":Magenta toggle<CR>",
        {silent = true, noremap = true, desc = "Toggle Magenta window"}
      )
      
      -- Context management
      vim.keymap.set(
        "n",
        "<leader>mb", -- like "magenta buffer"?
        Actions.add_buffer_to_context,
        { noremap = true, silent = true, desc = "Add current buffer to Magenta context" }
      )
      
      vim.keymap.set(
        "n",
        "<leader>mf",
        Actions.pick_context_files,
        { noremap = true, silent = true, desc = "Select files to add to Magenta context" }
      )
      
      vim.keymap.set(
        "v",
        "<leader>mp",
        ":Magenta paste-selection<CR>",
        {silent = true, noremap = true, desc = "Send selection to Magenta"}
      )
      
      -- Inline edit
      vim.keymap.set(
        "n",
        "<leader>mi",
        ":Magenta start-inline-edit<CR>",
        {silent = true, noremap = true, desc = "Inline edit"}
      )
      
      vim.keymap.set(
        "v",
        "<leader>mi",
        ":Magenta start-inline-edit-selection<CR>",
        {silent = true, noremap = true, desc = "Inline edit selection"}
      )
      
      vim.keymap.set(
        "n",
        "<leader>mr",
        ":Magenta replay-inline-edit<CR>",
        {silent = true, noremap = true, desc = "Replay last inline edit"}
      )
      
      vim.keymap.set(
        "v",
        "<leader>mr",
        ":Magenta replay-inline-edit-selection<CR>",
        {silent = true, noremap = true, desc = "Replay last inline edit on selection"}
      )
      
      vim.keymap.set(
        "n",
        "<leader>m.",
        ":Magenta replay-inline-edit<CR>",
        {silent = true, noremap = true, desc = "Replay last inline edit"}
      )
      
      vim.keymap.set(
        "v",
        "<leader>m.",
        ":Magenta replay-inline-edit-selection<CR>",
        {silent = true, noremap = true, desc = "Replay last inline edit on selection"}
      )
      
      -- Provider selection
      vim.keymap.set(
        "n",
        "<leader>mp",
        Actions.pick_provider,
        { noremap = true, silent = true, desc = "Select provider and model" }
      )
      
      -- Edit prediction
      vim.keymap.set(
        "i",
        "<S-C-l>",
        "<Cmd>Magenta predict-edit<CR>",
        {silent = true, noremap = true, desc = "Predict/accept edit"}
      )
      
      vim.keymap.set(
        "n",
        "<S-C-l>",
        "<Cmd>Magenta predict-edit<CR>",
        {silent = true, noremap = true, desc = "Predict/accept edit"}
      )
      
      
        {
          "ibhagwan/fzf-lua",
          lazy = false,
          config = function()
            require("fzf-lua").setup({
             -- ...
            })
            require("fzf-lua").register_ui_select()
          end,
        -- ...
          }
      
      
      require('magenta').setup({
        customCommands = {
          {
            name = "@nedit",
            text = "DO NOT MAKE ANY EDITS TO CODE. Do not use any tools that allow you to edit code. Do not execute bash commands which edit code. NO EDITING WHATSOEVER OR ELSE.",
            description = "Disable all code editing functionality"
          },
          {
            name = "@careful",
            text = "Be extra careful and double-check your work before making any changes.",
            description = "Request extra caution"
          },
          {
            name = "@perf",
            text = "Focus on performance optimization. Profile the code and suggest improvements for speed and memory usage.",
            description = "Performance optimization focus"
          }
        },
        -- ... other options
      })
      
      
      mcpServers = {
        fetch = {
          command = "uvx",
          args = { "mcp-server-fetch" },
          env = {
            CUSTOM_VAR = "value"
          }
        }
      }
      
      
      mcpServers = {
        httpServer = {
          url = "http://localhost:8000/mcp",
          requestInit = {
            headers = {
              Authorization = "Bearer your-token-here",
            },
          },
        }
      }
      
      
      mcpServers = {
        mcphub = {
          url = "http://localhost:37373/mcp"
        }
      }
      
    end,
  },
  {
    "StanAngeloff/claudius.nvim",
    config = function()
      
      {
          "StanAngeloff/claudius.nvim",
          opts = {},
      }
      
      
      require("claudius").setup({
          provider = "claude",  -- AI provider: "claude", "openai", or "vertex"
          model = nil,  -- Uses provider defaults if nil (see below)
          -- Claude default: "claude-3-7-sonnet-20250219"
          -- OpenAI default: "gpt-4o"
          -- Vertex default: "gemini-2.5-pro-preview-05-06"
          parameters = {
              max_tokens = nil,  -- Set to nil to use default (4000)
              temperature = nil,  -- Set to nil to use default (0.7)
              timeout = 120, -- Default cURL request timeout in seconds
              connect_timeout = 10, -- Default cURL connection timeout in seconds
              vertex = {
                  project_id = nil,  -- Google Cloud project ID (required for Vertex AI)
                  location = "us-central1",  -- Google Cloud region
                  thinking_budget = nil, -- Optional. Budget for model thinking, in tokens. `nil` or `0` disables thinking. Values `>= 1` enable thinking with the specified budget (integer part taken).
              },
          },
          highlights = {
              system = "Special",    -- highlight group or hex color (e.g., "#80a0ff") for system messages
              user = "Normal",       -- highlight group or hex color for user messages
              assistant = "Comment"  -- highlight group or hex color for assistant messages
          },
          role_style = "bold,underline",  -- style applied to role markers like @You:
          ruler = {
              char = "━",           -- character used for the separator line
              hl = "NonText"        -- highlight group or hex color for the separator
          },
          signs = {
              enabled = false,  -- enable sign column highlighting for roles (disabled by default)
              char = "▌",       -- default vertical bar character
              system = {
                  char = nil,   -- use default char
                  hl = true,    -- inherit from highlights.system, set false to disable, or provide specific group/hex color
              },
              user = {
                  char = "▏",   -- use default char
                  hl = true,    -- inherit from highlights.user, set false to disable, or provide specific group/hex color
              },
              assistant = {
                  char = nil,   -- use default char
                  hl = true,    -- inherit from highlights.assistant, set false to disable, or provide specific group/hex color
              }
          },
          editing = {
              disable_textwidth = true,  -- Whether to disable textwidth in chat buffers
              auto_write = false,        -- Whether to automatically write the buffer after changes
          },
          pricing = {
              enabled = true,  -- Whether to show pricing information in notifications
          },
          notify = {
              enabled = true,      -- Enable/disable notifications
              timeout = 8000,      -- How long notifications stay visible (ms)
              max_width = 60,      -- Maximum width of notification windows
              padding = 1,         -- Padding around notification text
              border = "rounded",  -- Border style (same as nvim_open_win)
              title = nil,         -- Default title (nil for none)
          },
          text_object = "m",  -- Default text object key, set to false to disable
          keymaps = {
              normal = {
                  send = "<C-]>",       -- Key to send message in normal mode
                  cancel = "<C-c>",     -- Key to cancel ongoing request
                  next_message = "]m",  -- Jump to next message
                  prev_message = "[m",  -- Jump to previous message
              },
              insert = {
                  send = "<C-]>"  -- Key to send message in insert mode
              },
              enabled = true  -- Set to false to disable all keymaps
          }
      })
      
      
      -- Example custom keymaps
      vim.keymap.set('n', '<Leader>cs', '<cmd>ClaudiusSend<cr>')
      vim.keymap.set('n', '<Leader>cc', '<cmd>ClaudiusCancel<cr>')
      vim.keymap.set('i', '<C-s>', '<cmd>ClaudiusSendAndInsert<cr>')
      vim.keymap.set('n', '<Leader>cn', '<cmd>ClaudiusNextMessage<cr>')
      vim.keymap.set('n', '<Leader>cp', '<cmd>ClaudiusPrevMessage<cr>')
      
      
      -- Example Lualine setup
      require('lualine').setup {
        options = {
          -- ... your other options
        },
        sections = {
          lualine_a = {'mode'},
          -- ... other sections
          lualine_x = {{ "claudius", icon = "🧠" }, 'encoding', 'filetype'}, -- Add Claudius model component with icon
          -- ... other sections
        },
        -- ...
      }
      
       ` and ` 
      
      greeting = "Hello, World!"  -- Must be global (no local keyword)
      count = 42
      
      
      function greet(name)
          return string.format("Hello, %s!", name)
      end
      
    end,
  },
  {
    "heilgar/nochat.nvim",
    config = function()
      
      {
          "heilgar/nochat.nvim",
          dependencies = {
              "nvim-telescope/telescope.nvim",
              "nvim-lua/plenary.nvim"
          },
          config = function()
              require("nochat").setup({
                  -- Your configuration here (see Configuration section)
              })
          end
      }
      
      
      use {
          "heilgar/nochat.nvim",
          requires = {
              "nvim-telescope/telescope.nvim",
              "nvim-lua/plenary.nvim"
          },
          config = function()
              require("nochat").setup({
                  -- Your configuration here (see Configuration section)
              })
          end
      }
      
      
      require("nochat").setup({
          -- Default provider and model (will be overridden by telescope selections)
          provider = "anthropic", -- or "openai", "ollama"
          model = "claude-3-sonnet-20240229",
      
          -- Window appearance
          window = {
              position = "floating", -- "floating", "right", "left", "bottom", "top", "tab"
              width = 0.8,     -- Percentage of screen width
              height = 0.7,    -- Percentage of screen height
              border = "rounded",
              title = " NoChat ",
              input_height = 5, -- Height of input box in lines
              winhighlight = {
                  output = "", -- e.g. "Normal:NoChatOutput"
                  input = ""   -- e.g. "Normal:NoChatInput"
              }
          },
      
          -- API keys (can also be set as environment variables)
          api_keys = {
              anthropic = "your-anthropic-api-key", -- or use ANTHROPIC_API_KEY env var
              openai = "your-openai-api-key", -- or use OPENAI_API_KEY env var
          },
      
          -- Ollama configuration
          ollama = {
              host = "http://localhost:11434", -- Default Ollama server address
          },
      
          -- Define available models for each provider
          providers = {
              anthropic = {
                  models = {
                      "claude-3-opus-20240229",
                      "claude-3-sonnet-20240229",
                      "claude-3-haiku-20240307",
                  },
              },
              openai = {
                  models = {
                      "gpt-4-turbo",
                      "gpt-4",
                      "gpt-3.5-turbo",
                  },
              },
              ollama = {
                  models = {
                      "llama3",
                      "mistral",
                      "gemma",
                      "codellama",
                  },
              },
          },
      
          -- Keymaps (set to false to disable defaults)
          keymaps = {
              toggle = "<leader>nc",
              select_provider = "<leader>np",
              select_model = "<leader>nm",
              clear_conversation = "<leader>nc",
              export_selection = "<leader>ne",
              position_floating = "<leader>nf",
              position_right = "<leader>nr",
              position_left = "<leader>nl",
              position_bottom = "<leader>nb",
              position_top = "<leader>nt",
              position_tab = "<leader>nn",
          },
      
          -- Set to true to disable default keymaps
          no_default_keymaps = false,
      })
      
      
      -- Change to a left split
      :lua require('nochat').set_window_position('left')
      
      -- Change to floating mode
      :lua require('nochat').set_window_position('floating')
      
    end,
  },
  {
    "julwrites/llm-nvim",
    config = function()
      
      use 'julwrites/llm-nvim'
      
      
      -- Example lazy.nvim configuration
      return {
        {
          'julwrites/llm-nvim',
          -- Optional: Specify dependencies if needed, e.g., for UI components
          -- dependencies = { 'nvim-lua/plenary.nvim' },
          config = function()
            -- Configure the plugin
            require('llm').setup({
              -- Specify the default LLM model to use
              model = 'gpt-4o', -- Or 'claude-3-haiku-20240307', 'llama3', etc.
      
              -- Define a default system prompt (optional)
              system_prompt = 'You are a helpful Neovim assistant.',
      
              -- Disable default key mappings if you prefer to set your own
              -- no_mappings = true,
      
              -- Enable debug logging (optional)
              -- debug = true,
      
              -- Enable or disable automatic updates for the underlying `llm` CLI tool.
              -- Defaults to `false`.
              -- auto_update_cli = false,
      
              -- Set the interval in days for checking for `llm` CLI updates.
              -- Defaults to `7`.
              -- auto_update_interval_days = 7,
            })
      
            -- Example custom key mappings (if no_mappings = true or for overrides)
            -- vim.keymap.set('n', '<leader>lp', '<Plug>(llm-prompt)', { desc = "LLM Prompt" })
            -- vim.keymap.set('v', '<leader>ls', '<Plug>(llm-selection)', { desc = "LLM Selection" })
            -- vim.keymap.set('n', '<leader>lt', '<Plug>(llm-toggle)', { desc = "LLM Toggle Manager" })
          end
        }
      }
      
      
      -- Setup with configuration options
      require('llm').setup({
        model = 'gpt-4o',                          -- Default model to use
        system_prompt = 'You are a helpful assistant.', -- Default system prompt
        no_mappings = false,                       -- Set to true to disable default mappings
        debug = false,                             -- Set to true to enable debug output
        auto_update_cli = false,                   -- Enable/disable CLI auto-updates (default: false)
        auto_update_interval_days = 7,             -- Interval in days for CLI update checks (default: 7)
      })
      
      -- Custom mappings
      vim.keymap.set('n', '<leader>lp', '<Plug>(llm-prompt)')
      vim.keymap.set('v', '<leader>ls', '<Plug>(llm-selection)')
      vim.keymap.set('n', '<leader>le', '<Plug>(llm-explain)')
      vim.keymap.set('n', '<leader>lm', '<Plug>(llm-models)') -- Note: <Plug>(llm-select-model) is deprecated
      
      
      -- Toggle unified manager
      vim.keymap.set('n', '<leader>ll', '<Cmd>LLMToggle<CR>', { desc = "Toggle LLM Manager" })
      
      -- Basic prompt
      vim.keymap.set('n', '<leader>lp', '<Cmd>LLM<Space>', { desc = "LLM Prompt" })
      
      -- Explain current buffer
      vim.keymap.set('n', '<leader>le', '<Cmd>LLM explain<CR>', { desc = "Explain Code" })
      
      -- Prompt with visual selection
      vim.keymap.set('v', '<leader>ls', '<Cmd>LLM selection<CR>', { desc = "LLM Selection" })
      
      -- Interactive fragments
      vim.keymap.set('n', '<leader>lf', '<Cmd>LLM fragments<CR>', { desc = "LLM with Fragments" })
      
    end,
  },
  {
    "azorng/goose.nvim",
    config = function()
      
      {
        "azorng/goose.nvim",
        config = function()
          require("goose").setup({})
        end,
        dependencies = {
          "nvim-lua/plenary.nvim",
          {
            "MeanderingProgrammer/render-markdown.nvim",
            opts = {
              anti_conceal = { enabled = false },
            },
          }
        },
      }
      
      
      -- Default configuration with all available options
      require('goose').setup({
        prefered_picker = nil,                     -- 'telescope', 'fzf', 'mini.pick', 'snacks', if nil, it will use the best available picker
        default_global_keymaps = true,             -- If false, disables all default global keymaps
        keymap = {
          global = {
            toggle = '<leader>gg',                 -- Open goose. Close if opened
            open_input = '<leader>gi',             -- Opens and focuses on input window on insert mode
            open_input_new_session = '<leader>gI', -- Opens and focuses on input window on insert mode. Creates a new session
            open_output = '<leader>go',            -- Opens and focuses on output window
            toggle_focus = '<leader>gt',           -- Toggle focus between goose and last window
            close = '<leader>gq',                  -- Close UI windows
            toggle_fullscreen = '<leader>gf',      -- Toggle between normal and fullscreen mode
            select_session = '<leader>gs',         -- Select and load a goose session
            goose_mode_chat = '<leader>gmc',       -- Set goose mode to `chat`. (Tool calling disabled. No editor context besides selections)
            goose_mode_auto = '<leader>gma',       -- Set goose mode to `auto`. (Default mode with full agent capabilities)
            configure_provider = '<leader>gp',     -- Quick provider and model switch from predefined list
            diff_open = '<leader>gd',              -- Opens a diff tab of a modified file since the last goose prompt
            diff_next = '<leader>g]',              -- Navigate to next file diff
            diff_prev = '<leader>g[',              -- Navigate to previous file diff
            diff_close = '<leader>gc',             -- Close diff view tab and return to normal editing
            diff_revert_all = '<leader>gra',       -- Revert all file changes since the last goose prompt
            diff_revert_this = '<leader>grt',      -- Revert current file changes since the last goose prompt
          },
          window = {
            submit = '<cr>',                     -- Submit prompt (normal mode)
            submit_insert = '<cr>',              -- Submit prompt (insert mode)
            close = '<esc>',                     -- Close UI windows
            stop = '<C-c>',                      -- Stop goose while it is running
            next_message = ']]',                 -- Navigate to next message in the conversation
            prev_message = '[[',                 -- Navigate to previous message in the conversation
            mention_file = '@',                  -- Pick a file and add to context. See File Mentions section
            toggle_pane = '<tab>',               -- Toggle between input and output panes
            prev_prompt_history = '<up>',        -- Navigate to previous prompt in history
            next_prompt_history = '<down>'       -- Navigate to next prompt in history
          }
        },
        ui = {
          window_width = 0.35,                   -- Width as percentage of editor width
          input_height = 0.15,                   -- Input height as percentage of window height
          fullscreen = false,                    -- Start in fullscreen mode (default: false)
          layout = "right",                      -- Options: "center" or "right"
          floating_height = 0.8,                 -- Height as percentage of editor height for "center" layout
          display_model = true,                  -- Display model name on top winbar
          display_goose_mode = true              -- Display mode on top winbar: auto|chat
        },
        providers = {
          --[[
          Define available providers and their models for quick model switching
          anthropic|azure|bedrock|databricks|google|groq|ollama|openai|openrouter
          Example:
          openrouter = {
            "anthropic/claude-3.5-sonnet",
            "openai/gpt-4.1",
          },
          ollama = {
            "cogito:14b"
          }
          --]]
        }
      })
      
    end,
  },
  {
    "mozanunal/sllm.nvim",
    config = function()
      
      {
        "mozanunal/sllm.nvim",
        dependencies = {
          "echasnovski/mini.notify",
          "echasnovski/mini.pick",
        },
        config = function()
          require("sllm").setup({
            -- your custom options here
          })
        end,
      }
      
      
      use({
        "mozanunal/sllm.nvim",
        requires = { "echasnovski/mini.notify", "echasnovski/mini.pick" },
        config = function()
          require("sllm").setup({
            -- your custom options here
          })
        end,
      })
      
      
      require("sllm").setup({
        llm_cmd                  = "llm", -- command or path for the llm CLI
        default_model            = "gpt-4.1", -- default llm model (set to "default" to use llm's default model)
        show_usage               = true, -- append usage stats to responses
        on_start_new_chat        = true, -- start fresh chat on setup
        reset_ctx_each_prompt    = true, -- clear file context each ask
        window_type              = "vertical", -- Default. Options: "vertical", "horizontal", "float"
        -- function for item selection (like vim.ui.select)
        pick_func                = require("mini.pick").ui_select,
        -- function for notifications (like vim.notify)
        notify_func              = require("mini.notify").make_notify(),
        -- function for inputs (like vim.ui.input)
        input_func               = vim.ui.input,
        -- See the "Customizing Keymaps" section for more details
        keymaps = {
          -- Change a default keymap
          ask_llm = "<leader>a",
          -- Disable a default keymap
          add_url_to_ctx = false,
          -- Other keymaps will use their default values
        },
      })
      
      
      -- In your setup() call:
      require("sllm").setup({
        keymaps = {
          -- CHANGE: Use <leader>a for asking the LLM instead of <leader>ss
          ask_llm = "<leader>a",
      
          -- DISABLE: I don't use the "add URL" or "add tool" features
          add_url_to_ctx = false,
          add_tool_to_ctx = nil, -- `nil` also works for disabling
        },
      })
      
      
      -- In your setup() call:
      require("sllm").setup({
        keymaps = false,
      })
      
      -- Now you can define your own from scratch
      local sllm = require("sllm")
      vim.keymap.set({"n", "v"}, "<leader>a", sllm.ask_llm, { desc = "Ask LLM [custom]" })
      
    end,
  },
  {
    "chatvim/chatvim.nvim",
    config = function()
      
      {
        "chatvim/chatvim.nvim",
        build = "npm install",
        config = function()
          require("chatvim")
        end,
      },
      
      
      use {
        "chatvim/chatvim.nvim",
        run = "npm install",
        config = function()
          require("chatvim")
        end,
      }
      
      
      local opts = { noremap = true, silent = true }
      vim.api.nvim_set_keymap("n", "<Leader>cvc", ":ChatvimComplete<CR>", opts)
      vim.api.nvim_set_keymap("n", "<Leader>cvs", ":ChatvimStop<CR>", opts)
      vim.api.nvim_set_keymap("n", "<Leader>cvw", ":ChatvimWrite<CR>", opts)
      vim.api.nvim_set_keymap("n", "<Leader>cvnn", ":ChatvimNew<CR>", opts)
      vim.api.nvim_set_keymap("n", "<Leader>cvnl", ":ChatvimNewLeft<CR>", opts)
      vim.api.nvim_set_keymap("n", "<Leader>cvnr", ":ChatvimNewRight<CR>", opts)
      vim.api.nvim_set_keymap("n", "<Leader>cvnb", ":ChatvimNewBottom<CR>", opts)
      vim.api.nvim_set_keymap("n", "<Leader>cvnt", ":ChatvimNewTop<CR>", opts)
      
    end,
  },
  {
    "Julian/lean.nvim",
    config = function()
      
      {
        'Julian/lean.nvim',
        event = { 'BufReadPre *.lean', 'BufNewFile *.lean' },
      
        dependencies = {
          'neovim/nvim-lspconfig',
          'nvim-lua/plenary.nvim',
      
          -- optional dependencies:
      
          -- a completion engine
          --    hrsh7th/nvim-cmp or Saghen/blink.cmp are popular choices
      
          -- 'nvim-telescope/telescope.nvim', -- for 2 Lean-specific pickers
          -- 'andymass/vim-matchup',          -- for enhanced % motion behavior
          -- 'andrewradev/switch.vim',        -- for switch support
          -- 'tomtom/tcomment_vim',           -- for commenting
        },
      
        ---@type lean.Config
        opts = { -- see below for full configuration options
          mappings = true,
        }
      }
      
      
      require('lean').setup{ mappings = true }
      
      
        ---@module 'lean'
        ---@type lean.Config
        require('lean').setup {
          -- Enable suggested mappings?
          --
          -- false by default, true to enable
          mappings = false,
      
          -- Enable the Lean language server(s)?
          --
          -- false to disable, otherwise should be a table of options to pass to `leanls`
          --
          -- See :help vim.lsp.Config for details.
          lsp = {
            init_options = {
              -- See Lean.Lsp.InitializationOptions for details and further options.
      
              -- Time (in milliseconds) which must pass since latest edit until elaboration begins.
              -- Lower values may make editing feel faster at the cost of higher CPU usage.
              -- Note that lean.nvim changes the Lean default for this value!
              editDelay = 0,
      
              -- Whether to signal that widgets are supported.
              hasWidgets = true,
            }
          },
      
          ft = {
            -- A list of patterns which will be used to protect any matching
            -- Lean file paths from being accidentally modified (by marking the
            -- buffer as `nomodifiable`).
            nomodifiable = {
                -- by default, this list includes the Lean standard libraries,
                -- as well as files within dependency directories (e.g. `_target`)
                -- Set this to an empty table to disable.
            }
          },
      
          -- Abbreviation support
          abbreviations = {
            -- Enable expanding of unicode abbreviations?
            enable = true,
            -- additional abbreviations:
            extra = {
              -- Add a \wknight abbreviation to insert ♘
              --
              -- Note that the backslash is implied, and that you of
              -- course may also use a snippet engine directly to do
              -- this if so desired.
              wknight = '♘',
            },
            -- Change if you don't like the backslash
            -- (comma is a popular choice on French keyboards)
            leader = '\\',
          },
      
          -- Infoview support
          infoview = {
            -- Automatically open an infoview on entering a Lean buffer?
            -- Should be a function that will be called anytime a new Lean file
            -- is opened. Return true to open an infoview, otherwise false.
            -- Setting this to `true` is the same as `function() return true end`,
            -- i.e. autoopen for any Lean file, or setting it to `false` is the
            -- same as `function() return false end`, i.e. never autoopen.
            autoopen = true,
      
            -- Set infoview windows' starting dimensions.
            -- Windows are opened horizontally or vertically depending on spacing.
            width = 50,
            height = 20,
      
            -- Set the infoviews' orientation to be dynamic based on screen layout
            -- or fixed to a vertical or horizontal orientation
            -- auto | vertical | horizontal
            orientation = "auto",
      
            -- Put the infoview on the top or bottom when horizontal?
            -- top | bottom
            horizontal_position = "bottom",
      
            -- Always open the infoview window in a separate tabpage.
            -- Might be useful if you are using a screen reader and don't want too
            -- many dynamic updates in the terminal at the same time.
            -- Note that `height` and `width` will be ignored in this case.
            separate_tab = false,
      
            -- Show indicators for pin locations when entering an infoview window?
            -- always | never | auto (= only when there are multiple pins)
            indicators = "auto",
          },
      
          -- Progress bar support
          progress_bars = {
            -- Enable the progress bars?
            -- By default, this is `true` if satellite.nvim is not installed, otherwise
            -- it is turned off, as when satellite.nvim is present this information would
            -- be duplicated.
            enable = true,  -- see above for default
            -- What character should be used for the bars?
            character = '│',
            -- Use a different priority for the signs
            priority = 10,
          },
      
          -- Redirect Lean's stderr messages somewhere (to a buffer by default)
          stderr = {
            enable = true,
            -- height of the window
            height = 5,
            -- a callback which will be called with (multi-line) stderr output
            -- e.g., use:
            --   on_lines = function(lines) vim.notify(lines) end
            -- if you want to redirect stderr to `vim.notify`.
            -- The default implementation will redirect to a dedicated stderr
            -- window.
            on_lines = nil,
          },
        }
      
    end,
  },
  {
    "nvim-flutter/flutter-tools.nvim",
    config = function()
      
      use {
          'nvim-flutter/flutter-tools.nvim',
          requires = {
              'nvim-lua/plenary.nvim',
              'stevearc/dressing.nvim', -- optional for vim.ui.select
          },
      }
      
      
      {
          'nvim-flutter/flutter-tools.nvim',
          lazy = false,
          dependencies = {
              'nvim-lua/plenary.nvim',
              'stevearc/dressing.nvim', -- optional for vim.ui.select
          },
          config = true,
      }
      
      
      require("flutter-tools").setup {} -- use defaults
      
      
      
      -- alternatively you can override the default configs
      require("flutter-tools").setup {
        ui = {
          -- the border type to use for all floating windows, the same options/formats
          -- used for ":h nvim_open_win" e.g. "single" | "shadow" | {<table-of-eight-chars>}
          border = "rounded",
          -- This determines whether notifications are show with `vim.notify` or with the plugin's custom UI
          -- please note that this option is eventually going to be deprecated and users will need to
          -- depend on plugins like `nvim-notify` instead.
          notification_style = 'native' | 'plugin'
        },
        decorations = {
          statusline = {
            -- set to true to be able use the 'flutter_tools_decorations.app_version' in your statusline
            -- this will show the current version of the flutter app from the pubspec.yaml file
            app_version = false,
            -- set to true to be able use the 'flutter_tools_decorations.device' in your statusline
            -- this will show the currently running device if an application was started with a specific
            -- device
            device = false,
            -- set to true to be able use the 'flutter_tools_decorations.project_config' in your statusline
            -- this will show the currently selected project configuration
            project_config = false,
          }
        },
        debugger = { -- integrate with nvim dap + install dart code debugger
          enabled = false,
          -- if empty dap will not stop on any exceptions, otherwise it will stop on those specified
          -- see |:help dap.set_exception_breakpoints()| for more info
          exception_breakpoints = {},
          -- Whether to call toString() on objects in debug views like hovers and the
          -- variables list.
          -- Invoking toString() has a performance cost and may introduce side-effects,
          -- although users may expected this functionality. null is treated like false.
          evaluate_to_string_in_debug_views = true,
          -- You can use the `debugger.register_configurations` to register custom runner configuration (for example for different targets or flavor). Plugin automatically registers the default configuration, but you can override it or add new ones.
          -- register_configurations = function(paths)
          --   require("dap").configurations.dart = {
          --     -- your custom configuration
          --   }
          -- end,
        },
        flutter_path = "<full/path/if/needed>", -- <-- this takes priority over the lookup
        flutter_lookup_cmd = nil, -- example "dirname $(which flutter)" or "asdf where flutter"
        root_patterns = { ".git", "pubspec.yaml" }, -- patterns to find the root of your flutter project
        fvm = false, -- takes priority over path, uses <workspace>/.fvm/flutter_sdk if enabled
        default_run_args= nil, -- Default options for run command (i.e `{ flutter = "--no-version-check" }`). Configured separately for `dart run` and `flutter run`.
        widget_guides = {
          enabled = false,
        },
        closing_tags = {
          highlight = "ErrorMsg", -- highlight for the closing tag
          prefix = ">", -- character to use for close tag e.g. > Widget
          priority = 10, -- priority of virtual text in current line
          -- consider to configure this when there is a possibility of multiple virtual text items in one line
          -- see `priority` option in |:help nvim_buf_set_extmark| for more info
          enabled = true -- set to false to disable
        },
        dev_log = {
          enabled = true,
          filter = nil, -- optional callback to filter the log
          -- takes a log_line as string argument; returns a boolean or nil;
          -- the log_line is only added to the output if the function returns true
          notify_errors = false, -- if there is an error whilst running then notify the user
          open_cmd = "15split", -- command to use to open the log buffer
          focus_on_open = true, -- focus on the newly opened log window
        },
        dev_tools = {
          autostart = false, -- autostart devtools server if not detected
          auto_open_browser = false, -- Automatically opens devtools in the browser
        },
        outline = {
          open_cmd = "30vnew", -- command to use to open the outline buffer
          auto_open = false -- if true this will open the outline automatically when it is first populated
        },
        lsp = {
          color = { -- show the derived colours for dart variables
            enabled = false, -- whether or not to highlight color variables at all, only supported on flutter >= 2.10
            background = false, -- highlight the background
            background_color = nil, -- required, when background is transparent (i.e. background_color = { r = 19, g = 17, b = 24},)
            foreground = false, -- highlight the foreground
            virtual_text = true, -- show the highlight using virtual text
            virtual_text_str = "■", -- the virtual text character to highlight
          },
          on_attach = my_custom_on_attach,
          capabilities = my_custom_capabilities, -- e.g. lsp_status capabilities
          --- OR you can specify a function to deactivate or change or control how the config is created
          capabilities = function(config)
            config.specificThingIDontWant = false
            return config
          end,
          -- see the link below for details on each option:
          -- https://github.com/dart-lang/sdk/blob/master/pkg/analysis_server/tool/lsp_spec/README.md#client-workspace-configuration
          settings = {
            showTodos = true,
            completeFunctionCalls = true,
            analysisExcludedFolders = {"<path-to-flutter-sdk-packages>"},
            renameFilesWithClasses = "prompt", -- "always"
            enableSnippets = true,
            updateImportsOnRename = true, -- Whether to update imports and other directives when files are renamed. Required for `FlutterRename` command.
          }
        }
      }
      
      
      -- .nvim.lua
      -- If you have more than one setup configured you will be prompted when you run
      -- your app to select which one you want to use
      require('flutter-tools').setup_project({
        {
          name = 'Development', -- an arbitrary name that you provide so you can recognise this config
          flavor = 'DevFlavor', -- your flavour
          target = 'lib/main_dev.dart', -- your target
          cwd = 'example',      -- the working directory for the project. Optional, defaults to the LSP root directory.
          device = 'pixel6pro', -- the device ID, which you can get by running `flutter devices`
          dart_define = {
            API_URL = 'https://dev.example.com/api',
            IS_DEV = true,
          },
          pre_run_callback = nil, -- optional callback to run before the configuration
          -- exposes a table containing name, target, flavor and device in the arguments
          dart_define_from_file = 'config.json' -- the path to a JSON configuration file
        },
        {
          name = 'Web',
          device = 'chrome',
          flavor = 'WebApp',
          web_port = "4000",
          additional_args = { "--wasm" }
        },
        {
          name = 'Profile',
          flutter_mode = 'profile', -- possible values: `debug`, `profile` or `release`, defaults to `debug`
        }
      })
      
      
      require('flutter-tools').setup_project({
        name = 'Development',
        flavor = 'DevFlavor',
        device = 'pixel6pro',
        target = 'lib/main_dev.dart',
        dart_define = { ... },
        dart_define_from_file = 'config.json'
      })
      
      
      function _G.statusLine()
        return vim.g.flutter_tools_decorations.app_version
      end
      vim.opt.statusline ='%!v:statusLine()'
      
      
      require("telescope").load_extension("flutter")
      
      
      -- with lazy
      return  { 'mfussenegger/nvim-dap' }
      
    end,
  },
  {
    "brendalf/mix.nvim",
    config = function()
      
      use { 'brendalf/mix.nvim', requires = { "nvim-lua/plenary.nvim" } }
      
      
      require("mix").setup()
      
    end,
  },
  {
    "AckslD/swenv.nvim",
    config = function()
      
      use 'AckslD/swenv.nvim'
      
      
      require('swenv.api').pick_venv()
      
      
      require('swenv.api').get_current_venv()
      
      
      require('swenv.api').set_venv('venv_fuzzy_name')
      
      
      require('swenv.api').auto_venv()
      
      
      
      require('swenv').setup({
          -- attempt to auto create and set a venv from dependencies
          auto_create_venv = true,
          -- name of venv directory to create if using pip
          auto_create_venv_dir = ".venv"
      })
      
      
      
      vim.api.nvim_create_autocmd("FileType", {
          pattern = {"python"},
          callback = function()
              require('swenv.api').auto_venv()
          end
      })
      
      
      require('swenv').setup({
        -- Should return a list of tables with a `name` and a `path` entry each.
        -- Gets the argument `venvs_path` set below.
        -- By default just lists the entries in `venvs_path`.
        get_venvs = function(venvs_path)
          return require('swenv.api').get_venvs(venvs_path)
        end,
        -- Path passed to `get_venvs`.
        venvs_path = vim.fn.expand('~/venvs'),
        -- Something to do after setting an environment, for example call vim.cmd.LspRestart
        post_set_venv = nil,
      })
      
      
      post_set_venv = function()
        local client = vim.lsp.get_clients({ name = "basedpyright" })[1]
        if not client then
          return
        end
        local venv = require("swenv.api").get_current_venv()
        if not venv then
          return
        end
        local venv_python = venv.path .. "/bin/python"
        if client.settings then
          client.settings = vim.tbl_deep_extend("force", client.settings, { python = { pythonPath = venv_python } })
        else
          client.config.settings =
              vim.tbl_deep_extend("force", client.config.settings, { python = { pythonPath = venv_python } })
        end
        client.notify("workspace/didChangeConfiguration", { settings = nil })
      end,
      
      
      sections = {
          ...
          lualine_a = 'swenv' -- uses default options
          lualine_x = { 'swenv', icon = '<icon>' } -- passing lualine component options
          ...
      }
      
      
      {
        icon = "",
        color = { fg = "#8fb55e" },
      }
      
      
      {
          "swenv",
          cond = function()
              return vim.bo.filetype == "python"
          end,
      }
      
      
      swenv.setup({
          post_set_venv = function()
              local timer = vim.loop.new_timer()
              -- Check every 250ms if g:coc_status exists
              timer:start(250, 250, vim.schedule_wrap(function()
                  if vim.g.coc_status then
                      timer:stop()
                      vim.cmd([[:CocRestart]])
                  end
              end))
          end
      })
      
    end,
  },
  {
    "roobert/f-string-toggle.nvim",
    config = function()
      
      {
        "roobert/f-string-toggle.nvim",
        config = function()
          require("f-string-toggle").setup({
            key_binding = "<leader>f",
            key_binding_desc = "Toggle f-string",
            filetypes = { "python" },
          })
        end,
      }
      
      
      {
        "roobert/f-string-toggle.nvim",
        keys = {
          { "<leader>fs", function() require("f-string-toggle").toggle_fstring() end, desc = "Toggle f-string" }
        },
        config = function()
          require("f-string-toggle").setup({
            key_binding = false,
          })
        end,
      }
      
      
      vim.keymap.set('n', '<leader>f', function() require('f-string-toggle').toggle_fstring() end, { desc = "Toggle f-string" })
      
    end,
  },
  {
    "gennaro-tedesco/nvim-jqx",
    config = function()
      
      {
        "gennaro-tedesco/nvim-jqx",
        event = {"BufReadPost"},
        ft = { "json", "yaml" },
      },
      
      
      {
          "gennaro-tedesco/nvim-jqx",
          ...
          init = function()
              local jqx = require("nvim-jqx.config")
              jqx.geometry.border = "single"
              jqx.geometry.width = 0.7
              ...
      
              jqx.query_key = "X"         -- keypress to query jq on keys
              jqx.sort = false            -- show the json keys as they appear instead of sorting them alphabetically
              jqx.show_legend = true      -- show key queried as first line in the jqx floating window
              jqx.use_quickfix = false    -- if you prefer the location list
          end,
      }
      
      
      
      local jqx = vim.api.nvim_create_augroup("Jqx", {})
      vim.api.nvim_clear_autocmds({ group = jqx })
      vim.api.nvim_create_autocmd("BufWinEnter", {
      	pattern = { "*.json", "*.yaml" },
      	desc = "preview json and yaml files on open",
      	group = jqx,
      	callback = function()
      		vim.cmd.JqxList()
      	end,
      })
      
    end,
  },
  {
    "nanotee/sqls.nvim",
    config = function()
      
          use 'nanotee/sqls.nvim'
          
      
          paq 'nanotee/sqls.nvim'
          
      
      vim.lsp.config('sqls', {
          -- your custom client configuration
      })
      vim.lsp.enable('sqls')
      
    end,
  },
  {
    "dmmulroy/tsc.nvim",
    config = function()
      
      use('dmmulroy/tsc.nvim')
      
      
      
      require('tsc').setup()
      
      
      {
        auto_open_qflist = true,
        auto_close_qflist = false,
        auto_focus_qflist = false,
        auto_start_watch_mode = false,
        use_trouble_qflist = false,
        use_diagnostics = false,
        run_as_monorepo = false,
        max_tsconfig_files = 20,
        bin_path = utils.find_tsc_bin(),
        enable_progress_notifications = true,
        enable_error_notifications = true,
        flags = {
          noEmit = true,
          project = function()
            return utils.find_nearest_tsconfig()
          end,
          watch = false,
        },
        hide_progress_notifications_from_history = true,
        spinner = { "⣾", "⣽", "⣻", "⢿", "⡿", "⣟", "⣯", "⣷" },
        pretty_errors = true,
      }
      
      
      flags = "--noEmit",
      
      
      vim.keymap.set('n', '<leader>to', ':TSCOpen<CR>')
      vim.keymap.set('n', '<leader>tc', ':TSCClose<CR>')
      
      
      local notify = require('notify')
      
      vim.notify = function(message, level, opts)
        return notify(message, level, opts) -- <-- Important to return the value from `nvim-notify`
      end
      
      
      
      require('tsc').setup({
          run_as_monorepo = true,
      })
      
      
      require('tsc').setup({
          use_trouble_qflist = true,
      })
      
    end,
  },
  {
    "dmmulroy/ts-error-translator.nvim",
    config = function()
      
      { 'dmmulroy/ts-error-translator.nvim' }
      
      
      use('dmmulroy/ts-error-translator.nvim',)
      
      
      require("ts-error-translator").setup()
      
      
      {
        auto_override_publish_diagnostics = true,
      }
      
      
      vim.lsp.handlers["textDocument/publishDiagnostics"] = function(err, result, ctx)
        require("ts-error-translator").translate_diagnostics(err, result, ctx)
        vim.lsp.diagnostic.on_publish_diagnostics(err, result, ctx)
      end
      
    end,
  },
  {
    "chuwy/ucm.nvim",
    config = function()
      
      {
        'chuwy/ucm.nvim',
        dependencies = {
          'nvim-telescope/telescope.nvim',
          'rcarriga/nvim-notify'              -- A temporary requirement
        },
        config = function()
          require('ucm').setup {
            endpoint = 'http://127.0.0.1:6783/local_ucm/api/'
          }
        end
      }
      
    end,
  },
  {
    "niuiic/typst-preview.nvim",
    config = function()
      
      local core = require("core")
      
      local M = {
              settings = {
                      exportPdf = "never",
              },
              root_dir = core.file.root_path,
      }
      
      return M
      
      
      {
      	-- file opened by pdf viewer
      	output_file = function()
      		local core = require("core")
      		return core.file.root_path() .. "/output.pdf"
      	end,
      	-- how to redirect output files
      	redirect_output = function(original_file, output_file)
      		vim.cmd(string.format("silent !ln -s %s %s", original_file, output_file))
      	end,
      	-- how to preview the pdf file
      	preview = function(output_file)
      		local core = require("core")
      		core.job.spawn("mimeopen", {
      			output_file,
      		}, {}, function() end, function() end, function() end)
      	end,
      	-- whether to clean all pdf files on VimLeave
      	clean_temp_pdf = true,
      }
      
    end,
  },
  {
    "simaxme/java.nvim",
    config = function()
      
      -- other lazy stuff
      {
          'simaxme/java.nvim'
      }
      -- other lazy stuff
      
      
      require("java").setup()
      
      
      require("java").setup {
          rename = {
              enable = true, -- enable the functionality for renaming java files
              nvimtree = true, -- enable nvimtree integration
              write_and_close = false -- automatically write and close modified (previously unopened) files after refactoring a java file
          },
          snippets = {
              enable = true -- enable the functionality for java snippets
          },
          root_markers = { -- markers for detecting the package path (the package path should start *after* the marker)
              "main/java/",
              "test/java/"
          }
      }
      
      
      require("simaxme-java").setup()
      
    end,
  },
  {
    "chomosuke/typst-preview.nvim",
    config = function()
      
      {
        'chomosuke/typst-preview.nvim',
        lazy = false, -- or ft = 'typst'
        version = '1.*',
        opts = {}, -- lazy.nvim will implicitly calls `setup {}`
      }
      
      
      use {
        'chomosuke/typst-preview.nvim',
        tag = 'v1.*',
        config = function()
          require 'typst-preview'.setup {}
        end,
      }
      
      
      require 'typst-preview'.setup {
        -- Setting this true will enable logging debug information to
        -- `vim.fn.stdpath 'data' .. '/typst-preview/log.txt'`
        debug = false,
      
        -- Custom format string to open the output link provided with %s
        -- Example: open_cmd = 'firefox %s -P typst-preview --class typst-preview'
        open_cmd = nil,
      
        -- Custom port to open the preview server. Default is random.
        -- Example: port = 8000
        port = 0,
      
        -- Setting this to 'always' will invert black and white in the preview
        -- Setting this to 'auto' will invert depending if the browser has enable
        -- dark mode
        -- Setting this to '{"rest": "<option>","image": "<option>"}' will apply
        -- your choice of color inversion to images and everything else
        -- separately.
        invert_colors = 'never',
      
        -- Whether the preview will follow the cursor in the source file
        follow_cursor = true,
      
        -- Provide the path to binaries for dependencies.
        -- Setting this will skip the download of the binary by the plugin.
        -- Warning: Be aware that your version might be older than the one
        -- required.
        dependencies_bin = {
          ['tinymist'] = nil,
          ['websocat'] = nil
        },
      
        -- A list of extra arguments (or nil) to be passed to previewer.
        -- For example, extra_args = { "--input=ver=draft", "--ignore-system-fonts" }
        extra_args = nil,
      
        -- This function will be called to determine the root of the typst project
        get_root = function(path_of_main_file)
          local root = os.getenv 'TYPST_ROOT'
          if root then
            return root
          end
          return vim.fn.fnamemodify(path_of_main_file, ':p:h')
        end,
      
        -- This function will be called to determine the main file of the typst
        -- project.
        get_main_file = function(path_of_buffer)
          return path_of_buffer
        end,
      }
      
    end,
  },
  {
    "quarto-dev/quarto-nvim",
    config = function()
      
      -- plugins/quarto.lua
      return {
        {
          "quarto-dev/quarto-nvim",
          dependencies = {
            "jmbuhr/otter.nvim",
            "nvim-treesitter/nvim-treesitter",
          },
        },
      }
      
      
      {
          'quarto-dev/quarto-nvim',
          'jmbuhr/otter.nvim',
          'hrsh7th/nvim-cmp',
          'neovim/nvim-lspconfig',
          'nvim-treesitter/nvim-treesitter'
      }
      
      
      require('quarto').setup{
        debug = false,
        closePreviewOnExit = true,
        lspFeatures = {
          enabled = true,
          chunks = "curly",
          languages = { "r", "python", "julia", "bash", "html" },
          diagnostics = {
            enabled = true,
            triggers = { "BufWritePost" },
          },
          completion = {
            enabled = true,
          },
        },
        codeRunner = {
          enabled = true,
          default_method = "slime", -- "molten", "slime", "iron" or <function>
          ft_runners = {}, -- filetype to runner, ie. `{ python = "molten" }`.
          -- Takes precedence over `default_method`
          never_run = { 'yaml' }, -- filetypes which are never sent to a code runner
        },
      }
      
      
      local quarto = require('quarto')
      quarto.setup()
      vim.keymap.set('n', '<leader>qp', quarto.quartoPreview, { silent = true, noremap = true })
      
      
      local runner = require("quarto.runner")
      vim.keymap.set("n", "<localleader>rc", runner.run_cell,  { desc = "run cell", silent = true })
      vim.keymap.set("n", "<localleader>ra", runner.run_above, { desc = "run cell and above", silent = true })
      vim.keymap.set("n", "<localleader>rA", runner.run_all,   { desc = "run all cells", silent = true })
      vim.keymap.set("n", "<localleader>rl", runner.run_line,  { desc = "run line", silent = true })
      vim.keymap.set("v", "<localleader>r",  runner.run_range, { desc = "run visual range", silent = true })
      vim.keymap.set("n", "<localleader>RA", function()
        runner.run_all(true)
      end, { desc = "run all cells of all languages", silent = true })
      
    end,
  },
  {
    "iabdelkareem/csharp.nvim",
    config = function()
      
      {
        "iabdelkareem/csharp.nvim",
        dependencies = {
          "williamboman/mason.nvim", -- Required, automatically installs omnisharp
          "mfussenegger/nvim-dap",
          "Tastyep/structlog.nvim", -- Optional, but highly recommended for debugging
        },
        config = function ()
            require("mason").setup() -- Mason setup must run before csharp, only if you want to use omnisharp
            require("csharp").setup()
        end
      }
      
      
      -- These are the default values
      {
          lsp = {
              -- Sets if you want to use omnisharp as your LSP
              omnisharp = {
              -- When set to false, csharp.nvim won't launch omnisharp automatically.
                  enable = true,
                  -- When set, csharp.nvim won't install omnisharp automatically. Instead, the omnisharp instance in the cmd_path will be used.
                  cmd_path = nil,
                  -- The default timeout when communicating with omnisharp
                  default_timeout = 1000,
                  -- Settings that'll be passed to the omnisharp server
                  enable_editor_config_support = true,
                  organize_imports = true,
                  load_projects_on_demand = false,
                  enable_analyzers_support = true,
                  enable_import_completion = true,
                  include_prerelease_sdks = true,
                  analyze_open_documents_only = false,
                  enable_package_auto_restore = true,
                  -- Launches omnisharp in debug mode
                  debug = false,
              }
              -- Sets if you want to use roslyn as your LSP
              roslyn = {
                  -- When set to true, csharp.nvim will launch roslyn automatically.
                  enable = false,
                  -- Path to the roslyn LSP see 'Roslyn LSP Specific Prerequisites' above.
                  cmd_path = nil,
              }
              -- The capabilities to pass to the omnisharp server
              capabilities = nil,
              -- on_attach function that'll be called when the LSP is attached to a buffer
              on_attach = nil
          },
          logging = {
              -- The minimum log level.
              level = "INFO",
          },
          dap = {
              -- When set, csharp.nvim won't launch install and debugger automatically. Instead, it'll use the debug adapter specified.
              --- @type string?
              adapter_name = nil,
          }
      }
      
      
      require("csharp").fix_usings()
      
      
      -- Listen to LSP Attach
      vim.api.nvim_create_autocmd("LspAttach", {
        callback = function (args)
          local augroup = vim.api.nvim_create_augroup("LspFormatting", {})
          vim.api.nvim_create_autocmd("BufWritePre", {
            group = augroup,
            buffer = args.buf,
            callback = function()
      
              -- Format the code before you run fix usings
              vim.lsp.buf.format({ timeout = 1000, async = false })
      
              -- If the file is C# then run fix usings
              if vim.bo[0].filetype == "cs" then
                require("csharp").fix_usings()
              end
            end,
          })
        end
      })
      
      
      require("csharp").fix_all()
      
      
      -- Not needed with roslyn LSP, use vim.lsp.buf.definition()
      require("csharp").go_to_definition()
      
    end,
  },
  {
    "jim-at-jibba/micropython.nvim",
    config = function()
      
      -- Lua
      vim.keymap.set("n", "<leader>mr", require("micropython_nvim").run)
      
      
      {
          "jim-at-jibba/micropython.nvim",
          dependencies = { "akinsho/toggleterm.nvim", "stevearc/dressing.nvim" },
      }
      
      
      use {
          "jim-at-jibba/micropython.nvim",
          requires = { "akinsho/toggleterm.nvim", "stevearc/dressing.nvim" },
      }
      
      
        local ignore_list = {
          ['.git'] = true,
          ['requirements.txt'] = true,
          ['.ampy'] = true,
          ['.vscode'] = true,
          ['.gitignore'] = true,
          ['project.pymakr'] = true,
          ['env'] = true,
          ['venv'] = true,
          ['__pycache__'] = true,
          ['.python-version'] = true,
          ['.micropy/'] = true,
          ['micropy.json'] = true,
        }
      
      
      
      require("lualine").setup({
          sections = {
              lualine_b = {
                  {
                    require("micropython_nvim").statusline,
                    cond = package.loaded["micropython_nvim"] and require("micropython_nvim").exists,
                  },
              }
          }
      })
      
    end,
  },
  {
    "neolooong/whichpy.nvim",
    config = function()
      
      {
        "neolooong/whichpy.nvim",
        dependencies = {
          -- optional for dap
          -- "mfussenegger/nvim-dap-python",
          -- optional for picker support
          -- "ibhagwan/fzf-lua",
          -- "nvim-telescope/telescope.nvim",
        }
        opts = {},
      }
      
      
        {
          cache_dir = vim.fn.stdpath("cache") .. "/whichpy.nvim",
          update_path_env = false,  -- Whether to modify $PATH when switching interpreters.
          after_handle_select = nil,  -- Equivalent to venv-selector.nvim's on_venv_activate_callback()
          -- after_handle_select = function(selected) vim.print(selected) end,
          picker = {
            name = "builtin",  -- must be one of ("builtin", "fzf-lua", "telescope")
            -- You can customize the picker as follows. For available options, refer to the respective documentation.
            -- ["fzf-lua"] = {
            --   prompt="fzf-lua",
            -- },
            -- telescope = {
            --   prompt_title="telescope",
            -- },
            -- builtin = {
            --   prompt="vim.ui.select",
            -- },
          },
          locator = {
            -- You can disable locator like this
            -- locator_name = { enable = false },
            workspace = {
              display_name = "Workspace",
              search_pattern = ".*env.*", -- `:help lua-patterns`
              depth = 2,
              ignore_dirs = {
                ".git",
                ".mypy_cache",
                ".pytest_cache",
                ".ruff_cache",
                "__pycache__",
                "__pypackages__",
              },
            },
            global = {
              display_name = "Global",
            },
            global_virtual_environment = {
              display_name = "Global Virtual Environment",
              dirs = {
                -- accept following structure
                -- path
                -- { path, vim.uv.os_uname().sysname }
                "~/envs",
                "~/.direnv",
                "~/.venvs",
                "~/.virtualenvs",
                "~/.local/share/virtualenvs",
                { "~/Envs", "Windows_NT" },  -- only search on Windows
                vim.env.WORKON_HOME,
              }
            },
            pyenv = {
              display_name = "Pyenv",
              venv_only = true,
            },
            poetry = {
              display_name = "Poetry",
            },
            pdm = {
              display_name = "PDM",
            },
            conda = {
              display_name = "Conda",
            },
            -- uv = {  -- disabled by default
            --   display_name = "uv",
            -- },
          },
          lsp = {
            pylsp = require("whichpy.lsp.handlers.pylsp").new(),
            pyright = require("whichpy.lsp.handlers.pyright").new(),
            basedpyright = require("whichpy.lsp.handlers.pyright").new(),
          },
        }
        
      
        {
          "nvim-neotest/neotest",
          dependencies = {
            "nvim-neotest/nvim-nio",
            "nvim-neotest/neotest-python",
          },
          config = function()
            local python_adapter = require("neotest-python")({
              python = function()
                local whichpy_python = require("whichpy.envs").current_selected()
                if whichpy_python then
                  return whichpy_python
                end
                return require("neotest-python.base").get_python_command
              end,
            })
            require("neotest").setup({
              adapters = { python_adapter },
            })
          end,
        }
        
      
      require("lualine").setup({
        sections = {
          lualine_x = {
            "whichpy"
          },
        },
      })
      
    end,
  },
  {
    "nvim-java/nvim-java",
    config = function()
      
      return {'nvim-java/nvim-java'}
      
      
      require('java').setup()
      
      
      require('lspconfig').jdtls.setup({})
      
      
      require('java').build.build_workspace()
      
      
      require('java').build.clean_workspace()
      
      
      require('java').runner.built_in.run_app({})
      require('java').runner.built_in.run_app({'arguments', 'to', 'pass', 'to', 'main'})
      
      
      require('java').runner.built_in.stop_app()
      
      
      require('java').runner.built_in.toggle_logs()
      
      
      require('java').dap.config_dap()
      
      
      require('java').test.run_current_class()
      
      
      require('java').test.debug_current_class()
      
      
      require('java').test.run_current_method()
      
      
      require('java').test.debug_current_method()
      
      
      require('java').test.view_last_report()
      
      
      require('java').profile.ui()
      
      
      require('java').refactor.extract_variable()
      
      
      require('java').refactor.extract_variable_all_occurrence()
      
      
      require('java').refactor.extract_constant()
      
      
      require('java').refactor.extract_method()
      
      
      require('java').refactor.extract_field()
      
      
      require('java').settings.change_runtime()
      
      
      require('lspconfig').jdtls.setup({
        settings = {
          java = {
            configuration = {
              runtimes = {
                {
                  name = "JavaSE-21",
                  path = "/opt/jdk-21",
                  default = true,
                }
              }
            }
          }
        }
      })
      
      
      {
        --  list of file that exists in root of the project
        root_markers = {
          'settings.gradle',
          'settings.gradle.kts',
          'pom.xml',
          'build.gradle',
          'mvnw',
          'gradlew',
          'build.gradle',
          'build.gradle.kts',
          '.git',
        },
      
        jdtls = {
          version = 'v1.43.0',
        },
      
        lombok = {
          version = 'nightly',
        },
      
        -- load java test plugins
        java_test = {
          enable = true,
          version = '0.40.1',
        },
      
        -- load java debugger plugins
        java_debug_adapter = {
          enable = true,
          version = '0.58.1',
        },
      
        spring_boot_tools = {
          enable = true,
          version = '1.55.1',
        },
      
        jdk = {
          -- install jdk using mason.nvim
          auto_install = true,
          version = '17.0.2',
        },
      
        notifications = {
          -- enable 'Configuring DAP' & 'DAP configured' messages on start up
          dap = true,
        },
      
        -- We do multiple verifications to make sure things are in place to run this
        -- plugin
        verification = {
          -- nvim-java checks for the order of execution of following
          -- * require('java').setup()
          -- * require('lspconfig').jdtls.setup()
          -- IF they are not executed in the correct order, you will see a error
          -- notification.
          -- Set following to false to disable the notification if you know what you
          -- are doing
          invalid_order = true,
      
          -- nvim-java checks if the require('java').setup() is called multiple
          -- times.
          -- IF there are multiple setup calls are executed, an error will be shown
          -- Set following property value to false to disable the notification if
          -- you know what you are doing
          duplicate_setup_calls = true,
      
          -- nvim-java checks if nvim-java/mason-registry is added correctly to
          -- mason.nvim plugin.
          -- IF it's not registered correctly, an error will be thrown and nvim-java
          -- will stop setup
          invalid_mason_registry = false,
        },
      
        mason = {
          -- These mason registries will be prepended to the existing mason
          -- configuration
          registries = {
            'github:nvim-java/mason-registry',
          },
        },
      }
      
      
    end,
  },
  {
    "jinzhongjia/zig-lamp",
  },
  {
    "kiyoon/python-import.nvim",
    config = function()
      
        {
          "kiyoon/python-import.nvim",
          -- build = "pipx install . --force",
          build = "uv tool install . --force --reinstall",
          keys = {
            {
              "<M-CR>",
              function()
                require("python_import.api").add_import_current_word_and_notify()
              end,
              mode = { "i", "n" },
              silent = true,
              desc = "Add python import",
              ft = "python",
            },
            {
              "<M-CR>",
              function()
                require("python_import.api").add_import_current_selection_and_notify()
              end,
              mode = "x",
              silent = true,
              desc = "Add python import",
              ft = "python",
            },
            {
              "<space>i",
              function()
                require("python_import.api").add_import_current_word_and_move_cursor()
              end,
              mode = "n",
              silent = true,
              desc = "Add python import and move cursor",
              ft = "python",
            },
            {
              "<space>i",
              function()
                require("python_import.api").add_import_current_selection_and_move_cursor()
              end,
              mode = "x",
              silent = true,
              desc = "Add python import and move cursor",
              ft = "python",
            },
            {
              "<space>tr",
              function()
                require("python_import.api").add_rich_traceback()
              end,
              silent = true,
              desc = "Add rich traceback",
              ft = "python",
            },
          },
          opts = {
            -- Example 1:
              -- Default behaviour for `tqdm` is `from tqdm.auto import tqdm`.
              -- If you want to change it to `import tqdm`, you can set `import = {"tqdm"}` and `import_from = {tqdm = vim.NIL}` here.
              -- If you want to change it to `from tqdm import tqdm`, you can set `import_from = {tqdm = "tqdm"}` here.
      
            -- Example 2:
              -- Default behaviour for `logger` is `import logging`, ``, `logger = logging.getLogger(__name__)`.
              -- If you want to change it to `import my_custom_logger`, ``, `logger = my_custom_logger.get_logger()`,
              -- you can set `statement_after_imports = {logger = {"import my_custom_logger", "", "logger = my_custom_logger.get_logger()"}}` here.
            extend_lookup_table = {
              ---@type string[]
              import = {
                -- "tqdm",
              },
      
              ---@type table<string, string|vim.NIL>
              import_as = {
                -- These are the default values. Here for demonstration.
                -- np = "numpy",
                -- pd = "pandas",
              },
      
              ---@type table<string, string|vim.NIL>
              import_from = {
                -- tqdm = vim.NIL,
                -- tqdm = "tqdm",
              },
      
              ---@type table<string, string[]|vim.NIL>
              statement_after_imports = {
                -- logger = { "import my_custom_logger", "", "logger = my_custom_logger.get_logger()" },
              },
            },
      
            ---Return nil to indicate no match is found and continue with the default lookup
            ---Return a table to stop the lookup and use the returned table as the result
            ---Return an empty table to stop the lookup. This is useful when you want to add to wherever you need to.
            ---@type fun(winnr: integer, word: string, ts_node: TSNode?): string[]?
            custom_function = function(winnr, word, ts_node)
              -- if vim.endswith(word, "_DIR") then
              --   return { "from my_module import " .. word }
              -- end
            end,
          },
        },
        "rcarriga/nvim-notify",   -- optional
      
    end,
  },
  {
    "kiyoon/haskell-scope-highlighting.nvim",
    config = function()
      
        {
          "kiyoon/haskell-scope-highlighting.nvim",
          dependencies = {
            "nvim-treesitter/nvim-treesitter",
          },
          init = function()
            -- Consider disabling other highlighting
            vim.cmd [[autocmd FileType haskell syntax off]]
            vim.cmd [[autocmd FileType haskell TSDisable highlight]]
          end
        },
      
      
      local i = 1
      repeat
        -- orange = #dc9271
        local color = string.format("%d guifg=#%02x%02x%02x",i,
          220 - (i*10)% 220,
          92 - (i*20) % 92,
          72 + (i*20) % 184
        )
        vim.cmd("hi HaskellVariableDeclaredWithinParent"..color)
        vim.cmd("hi HaskellParentScope"..i.." guibg=#2d353b")
        i = i + 1
      until (i > 10)
      
    end,
  },
  {
    "apyra/nvim-unity",
    config = function()
      
      {
        "apyra/nvim-unity-sync",
        lazy = false,
        config = function()
          require("unity.plugin").setup()
        end,
      }
      
      
      local lspconfig = require("lspconfig")
      lspconfig.omnisharp.setup {
        on_attach = nvlsp.on_attach,
        capabilities = nvlsp.capabilities,
        cmd = {
          "dotnet",
          vim.fn.stdpath "data" .. "\\mason\\packages\\omnisharp\\libexec\\OmniSharp.dll",
        },
        settings = {
          FormattingOptions = {
            EnableEditorConfigSupport = false,
            OrganizeImports = true,
          },
          Sdk = {
            IncludePrereleases = true,
          },
        },
      }
      
      
      {
        "nvim-treesitter/nvim-treesitter",
        opts = {
          ensure_installed = {
            "c_sharp",
          },
        },
      }
      
      
      {
        "github/copilot.vim",
        lazy = false,
        config = function()
          vim.g.copilot_no_tab_map = true
          vim.g.copilot_assume_mapped = true
        end,
      }
      
      
      map("i", "<C-l>", function()
        vim.fn.feedkeys(vim.fn["copilot#Accept"](), "")
      end, { desc = "Copilot Accept", noremap = true, silent = true })
      
      
      use {
        'tpope/vim-fugitive',
        config = function()
          -- Optional config
        end
      }
      
      
      {
        "kevinhwang91/nvim-ufo",
        -- your config here
      }
      
      
      require("luasnip.loaders.from_lua").load({ paths = "~/.config/nvim/lua/snippets" })
      
      
      require("luasnip.loaders.from_lua").lazy_load({
        paths = vim.fn.stdpath("config") .. "/lua/snippets"
      })
      
      
      -- cs.lua
      local ls = require("luasnip")
      local s, t, i = ls.snippet, ls.text_node, ls.insert_node
      
      return {
        s("start", { t("void Start() {"), t({"", "    "}), i(1), t({"", "}"}) }),
        s("update", { t("void Update() {"), t({"", "    "}), i(1), t({"", "}"}) }),
        s("awake", { t("void Awake() {"), t({"", "    "}), i(1), t({"", "}"}) }),
        s("fixedupdate", { t("void FixedUpdate() {"), t({"", "    "}), i(1), t({"", "}"}) }),
        s("onenable", { t("void OnEnable() {"), t({"", "    "}), i(1), t({"", "}"}) }),
        s("ondisable", { t("void OnDisable() {"), t({"", "    "}), i(1), t({"", "}"}) }),
        s("ontriggerenter", { t("void OnTriggerEnter(Collider other) {"), t({"", "    "}), i(1), t({"", "}"}) }),
        s("oncollisionenter", { t("void OnCollisionEnter(Collision collision) {"), t({"", "    "}), i(1), t({"", "}"}) }),
        s("serializefield", { t("[SerializeField] private "), i(1, "Type"), t(" "), i(2, "variableName"), t(";") }),
        s("publicfield", { t("public "), i(1, "Type"), t(" "), i(2, "variableName"), t(";") }),
        s("log", { t('Debug.Log("'), i(1, "message"), t('");') }),
        s("class", {
          t("using UnityEngine;"), t({"", ""}),
          t("public class "), i(1, "ClassName"), t(" : MonoBehaviour"),
          t({"", "{"}),
          t({"", "    "}), i(2, "// Your code here"),
          t({"", "}"}),
        }),
      }
      
    end,
  },
  {
    "atomicptr/defold.nvim",
    config = function()
      
          -- ...
      
          launcher = {
              type = "terminal",
      
              executable = "/usr/bin/my-custom-terminal",
      
              terminal = {
                  class_argument = "--app-id=",
                  run_argument = "-e",
              },
          },
      
          -- ...
      
      
      {
          "atomicptr/defold.nvim",
          lazy = false,
      
          -- (Optional) Required when using the debugger
          dependencies = {
              "mfussenegger/nvim-dap",
          },
      
          opts = {
              -- config options, see below
          },
      }
      
      
      local defold = require "defold"
      defold.setup(config) -- config options, see below
      
      
      local config = {
          defold = {
              -- Automatically set defold.nvim as the default editor in Defold (default: true)
              set_default_editor = true,
      
              -- Automatically fetch dependencies on launch (default: true)
              auto_fetch_dependencies = true,
      
              -- Enable hot reloading when saving scripts in Neovim (default: true)
              hot_reload_enabled = true,
          },
      
      
          launcher = {
              -- How to run neovim "neovide" or "terminal" (default: neovide)
              type = "neovide",
      
              -- path to your neovim or terminal executable (optional)
              executable = nil,
      
              -- extra arguments passed to the `executable` (or neovide)
              extra_arguments = nil,
      
              -- configure how the terminal is run (optional)
              terminal = {
                  -- argument to define how to set the class name of the terminal, usually something like "--class="
                  class_argument = nil,
      
                  -- argument to define how to run neovim, usually "-e"
                  run_argument = nil,
              }
          },
      
          debugger = {
              -- Enable the debugger (default: true)
              enable = true,
      
              -- Use a custom executable for the debugger (default: nil)
              custom_executable = nil,
      
              -- Add custom arguments to the debugger (default: nil)
              custom_arguments = nil,
          },
      
          babashka = {
              -- Use a custom executable for babashka (default: nil)
              custom_executable = nil,
          },
      
          -- Force the plugin to be always enabled (even if we can't find the game.project file) (default: false)
          force_plugin_enabled = false,
      }
      
      local defold = require "defold"
      defold.setup(config)
      
      
      local defold = require "defold"
      local root = defold.plugin_root()
      
    end,
  },
  {
    "romus204/go-tagger.nvim",
    config = function()
      
      {
        "romus204/go-tagger.nvim",
        config = function()
          require("go-tagger").setup({
            skip_private = true, -- Skip unexported fields (starting with lowercase)
          })
        end,
      }
      
      
      use {
        "romus204/go-tagger.nvim",
        config = function()
          require("go-tagger").setup()
        end,
      }
      
      
      require("go-tagger").setup({
        skip_private = true -- default: true
      })
      
      
      vim.keymap.set("v", "<leader>at", ":AddGoTags<CR>", { desc = "Add Go struct tags", silent = true })
      vim.keymap.set("v", "<leader>rt", ":RemoveGoTags<CR>", { desc = "Remove Go struct tags", silent = true })
      
    end,
  },
  {
    "ray-x/go.nvim",
    config = function()
      
      use 'ray-x/go.nvim'
      use 'ray-x/guihua.lua' -- recommended if need floating window support
      use 'neovim/nvim-lspconfig'
      use 'nvim-treesitter/nvim-treesitter'
      
      
      {
        "ray-x/go.nvim",
        dependencies = {  -- optional packages
          "ray-x/guihua.lua",
          "neovim/nvim-lspconfig",
          "nvim-treesitter/nvim-treesitter",
        },
        opts = {
          -- lsp_keymaps = false,
          -- other options
        },
        config = function(lp, opts)
          require("go").setup(opts)
          local format_sync_grp = vim.api.nvim_create_augroup("GoFormat", {})
          vim.api.nvim_create_autocmd("BufWritePre", {
            pattern = "*.go",
            callback = function()
            require('go.format').goimports()
            end,
            group = format_sync_grp,
          })
        end,
        event = {"CmdlineEnter"},
        ft = {"go", 'gomod'},
        build = ':lua require("go.install").update_all_sync()' -- if you need to install/update all binaries
      }
      
      
      lua <<EOF
      local format_sync_grp = vim.api.nvim_create_augroup("GoFormat", {})
      vim.api.nvim_create_autocmd("BufWritePre", {
        pattern = "*.go",
        callback = function()
         require('go.format').goimports()
        end,
        group = format_sync_grp,
      })
      
      EOF
      
      
      require('go').setup()
      
      
      require("go.format").gofmt()  -- gofmt only
      require("go.format").goimports()  -- goimports + gofmt
      
      
      -- Run gofmt on save
      
      local format_sync_grp = vim.api.nvim_create_augroup("GoFormat", {})
      vim.api.nvim_create_autocmd("BufWritePre", {
        pattern = "*.go",
        callback = function()
         require('go.format').gofmt()
        end,
        group = format_sync_grp,
      })
      
      
      -- Run gofmt + goimports on save
      
      local format_sync_grp = vim.api.nvim_create_augroup("goimports", {})
      vim.api.nvim_create_autocmd("BufWritePre", {
        pattern = "*.go",
        callback = function()
         require('go.format').goimports()
        end,
        group = format_sync_grp,
      })
      
      
      lua.require('go.comment').gen() -- or your favorite key binding and setup placeholder "no more complaint ;P"
      
      
      local capabilities = require('cmp_nvim_lsp').default_capabilities(vim.lsp.protocol.make_client_capabilities())
      require('go').setup({
        -- other setups ....
        lsp_cfg = {
          capabilities = capabilities,
          -- other setups
        },
      })
      
      
        dap_enrich_config = function(config, on_config)
            local final_config = vim.deepcopy(finalConfig)
            final_config.env['NEW_ENV_VAR'] = 'env-var-value'
            -- load .env file for your project
            local workspacefolder = vim.lsp.buf.list_workspace_folders()[1] or vim.fn.getcwd()
            local envs_from_file = require('go.env').load_env(workspacefolder .. 'your_project_dot_env_file_name')
            final_config = vim.tbl_extend("force", final_config, envs_from_file)
            on_config(final_config)
        end
        
      
      require('go').setup({
      
        disable_defaults = false, -- true|false when true set false to all boolean settings and replace all tables
        remap_commands = {}, -- Vim commands to remap or disable, e.g. `{ GoFmt = "GoFormat", GoDoc = false }`
        -- settings with {}; string will be set to ''. user need to setup ALL the settings
        -- It is import to set ALL values in your own config if set value to true otherwise the plugin may not work
        go='go', -- go command, can be go[default] or e.g. go1.18beta1
        goimports ='gopls', -- goimports command, can be gopls[default] or either goimports or golines if need to split long lines
        gofmt = 'gopls', -- gofmt through gopls: alternative is gofumpt, goimports, golines, gofmt, etc
        fillstruct = 'gopls',  -- set to fillstruct if gopls fails to fill struct
        max_line_len = 0, -- max line length in golines format, Target maximum line length for golines
        tag_transform = false, -- can be transform option("snakecase", "camelcase", etc) check gomodifytags for details and more options
        tag_options = 'json=omitempty', -- sets options sent to gomodifytags, i.e., json=omitempty
        gotests_template = "", -- sets gotests -template parameter (check gotests for details)
        gotests_template_dir = "", -- sets gotests -template_dir parameter (check gotests for details)
        gotest_case_exact_match = true, -- true: run test with ^Testname$, false: run test with TestName
        comment_placeholder = '' ,  -- comment_placeholder your cool placeholder e.g. 󰟓       
        icons = {breakpoint = '🧘', currentpos = '🏃'},  -- setup to `false` to disable icons setup
        verbose = false,  -- output loginf in messages
        lsp_semantic_highlights = false, -- use highlights from gopls, disable by default as gopls/nvim not compatible
        lsp_cfg = false, -- true: use non-default gopls setup specified in go/lsp.lua
                         -- false: do nothing
                         -- if lsp_cfg is a table, merge table with with non-default gopls setup in go/lsp.lua, e.g.
                         -- lsp_cfg = {settings={gopls={matcher='CaseInsensitive', ['local'] = 'your_local_module_path', gofumpt = true }}}
        lsp_gofumpt = true, -- true: set default gofmt in gopls format to gofumpt
                            -- false: do not set default gofmt in gopls format to gofumpt
        lsp_on_attach = nil, -- nil: use on_attach function defined in go/lsp.lua,
                             --      when lsp_cfg is true
                             -- if lsp_on_attach is a function: use this function as on_attach function for gopls
        lsp_keymaps = true,  -- set to false to disable gopls/lsp keymap
        lsp_codelens = true,  -- set to false to disable codelens, true by default, you can use a function
                              -- function(bufnr)
                              --    vim.api.nvim_buf_set_keymap(bufnr, "n", "<space>F", "<cmd>lua vim.lsp.buf.formatting()<CR>", {noremap=true, silent=true})
                              -- end
                              -- to setup a table of codelens
      
        golangci_lint = {
          default = 'standard', -- set to one of { 'standard', 'fast', 'all', 'none' }
          -- disable = {'errcheck', 'staticcheck'}, -- linters to disable empty by default
          -- enable = {'govet', 'ineffassign','revive', 'gosimple'}, -- linters to enable; empty by default
          config = nil,        -- set to a config file path
          no_config = false,   -- true: golangci-lint --no-config
          -- disable = {},     -- linters to disable empty by default, e.g. {'errcheck', 'staticcheck'}
          -- enable = {},      -- linters to enable; empty by default, set to e.g. {'govet', 'ineffassign','revive', 'gosimple'}
          -- enable_only = {}, -- linters to enable only; empty by default, set to e.g. {'govet', 'ineffassign','revive', 'gosimple'}
          severity = vim.diagnostic.severity.INFO, -- severity level of the diagnostics
        },
        null_ls = {    -- check null-ls integration in readme
          golangci_lint = {
            method = {"NULL_LS_DIAGNOSTICS_ON_SAVE", "NULL_LS_DIAGNOSTICS_ON_OPEN"}, -- when it should run
            severity = vim.diagnostic.severity.INFO, -- severity level of the diagnostics
          },
          gotest = {
            method = {"NULL_LS_DIAGNOSTICS_ON_SAVE"}, -- when it should run
            severity = vim.diagnostic.severity.WARN, -- severity level of the diagnostics
          },
        },
        diagnostic = {  -- set diagnostic to false to disable vim.diagnostic.config setup,
                        -- true: default nvim setup
          hdlr = false, -- hook lsp diag handler and send diag to quickfix
          underline = true,
          virtual_text = { spacing = 2, prefix = '' }, -- virtual text setup
          signs = {'', '', '', ''},  -- set to true to use default signs, an array of 4 to specify custom signs
          update_in_insert = false,
        },
        -- if you need to setup your ui for input and select, you can do it here
        -- go_input = require('guihua.input').input -- set to vim.ui.input to disable guihua input
        -- go_select = require('guihua.select').select -- vim.ui.select to disable guihua select
        lsp_document_formatting = true,
        -- set to true: use gopls to format
        -- false if you want to use other formatter tool(e.g. efm, nulls)
        lsp_inlay_hints = {
          enable = true, -- this is the only field apply to neovim > 0.10
        },
        gopls_cmd = nil, -- if you need to specify gopls path and cmd, e.g {"/home/user/lsp/gopls", "-logfile","/var/log/gopls.log" }
        gopls_remote_auto = true, -- add -remote=auto to gopls
        gocoverage_sign = "█",
        sign_priority = 5, -- change to a higher number to override other signs
        dap_debug = true, -- set to false to disable dap
        dap_debug_keymap = true, -- true: use keymap for debugger defined in go/dap.lua
                                 -- false: do not use keymap in go/dap.lua.  you must define your own.
                                 -- Windows: Use Visual Studio keymap
        dap_debug_gui = {}, -- bool|table put your dap-ui setup here set to false to disable
        dap_debug_vt = { enabled = true, enabled_commands = true, all_frames = true }, -- bool|table put your dap-virtual-text setup here set to false to disable
      
        dap_port = 38697, -- can be set to a number, if set to -1 go.nvim will pick up a random port
        dap_timeout = 15, --  see dap option initialize_timeout_sec = 15,
        dap_retries = 20, -- see dap option max_retries
        dap_enrich_config = nil, -- see dap option enrich_config
        build_tags = "tag1,tag2", -- set default build tags
        textobjects = true, -- enable default text objects through treesittter-text-objects
        test_runner = 'go', -- one of {`go`,  `dlv`, `ginkgo`, `gotestsum`}
        verbose_tests = true, -- set to add verbose flag to tests deprecated, see '-v' option
        run_in_floaterm = false, -- set to true to run in a float window. :GoTermClose closes the floatterm
                                 -- float term recommend if you use gotestsum ginkgo with terminal color
      
        floaterm = {   -- position
          posititon = 'auto', -- one of {`top`, `bottom`, `left`, `right`, `center`, `auto`}
          width = 0.45, -- width of float window if not auto
          height = 0.98, -- height of float window if not auto
          title_colors = 'nord', -- default to nord, one of {'nord', 'tokyo', 'dracula', 'rainbow', 'solarized ', 'monokai'}
                                    -- can also set to a list of colors to define colors to choose from
                                    -- e.g {'#D8DEE9', '#5E81AC', '#88C0D0', '#EBCB8B', '#A3BE8C', '#B48EAD'}
        },
        trouble = false, -- true: use trouble to open quickfix
        test_efm = false, -- errorfomat for quickfix, default mix mode, set to true will be efm only
        luasnip = false, -- enable included luasnip snippets. you can also disable while add lua/snips folder to luasnip load
        --  Do not enable this if you already added the path, that will duplicate the entries
        on_jobstart = function(cmd) _=cmd end, -- callback for stdout
        on_stdout = function(err, data) _, _ = err, data end, -- callback when job started
        on_stderr = function(err, data)  _, _ = err, data  end, -- callback for stderr
        on_exit = function(code, signal, output)  _, _, _ = code, signal, output  end, -- callback for jobexit, output : string
        iferr_vertical_shift = 4, -- defines where the cursor will end up vertically from the begining of if err statement
        iferr_less_highlight = false, -- set to true to make 'if err != nil' statements less highlighted (grayed out)
      })
      
      
      vim.cmd("autocmd FileType go nmap <Leader><Leader>l GoLint")
      vim.cmd("autocmd FileType go nmap <Leader>gc :lua require('go.comment').gen()")
      
      
      -- .gonvim/init.lua project config
      
      return {
        go = "go", -- set to go1.18beta1 if necessary
        goimports = "gopls", -- if set to 'gopls' will use gopls format, also goimports
        gofmt = "gofumpt", -- if set to gopls will use gopls format
        null_ls_document_formatting_disable = true
      }
      
      
        require "nvim-treesitter.configs".setup {
          incremental_selection = {
            enable = enable,
            keymaps = {
              -- mappings for incremental selection (visual mappings)
              init_selection = "gnn", -- maps in normal mode to init the node/scope selection
              node_incremental = "grn", -- increment to the upper named parent
              scope_incremental = "grc", -- increment to the upper scope (as defined in locals.scm)
              node_decremental = "grm" -- decrement to the previous node
            }
          },
      
          textobjects = {
            -- syntax-aware textobjects
            enable = enable,
            lsp_interop = {
              enable = enable,
              peek_definition_code = {
                ["DF"] = "@function.outer",
                ["DF"] = "@class.outer"
              }
            },
            keymaps = {
              ["iL"] = {
                -- you can define your own textobjects directly here
                go = "(function_definition) @function",
              },
              -- or you use the queries from supported languages with textobjects.scm
              ["af"] = "@function.outer",
              ["if"] = "@function.inner",
              ["aC"] = "@class.outer",
              ["iC"] = "@class.inner",
              ["ac"] = "@conditional.outer",
              ["ic"] = "@conditional.inner",
              ["ae"] = "@block.outer",
              ["ie"] = "@block.inner",
              ["al"] = "@loop.outer",
              ["il"] = "@loop.inner",
              ["is"] = "@statement.inner",
              ["as"] = "@statement.outer",
              ["ad"] = "@comment.outer",
              ["am"] = "@call.outer",
              ["im"] = "@call.inner"
            },
            move = {
              enable = enable,
              set_jumps = true, -- whether to set jumps in the jumplist
              goto_next_start = {
                ["]m"] = "@function.outer",
                ["]]"] = "@class.outer"
              },
              goto_next_end = {
                ["]M"] = "@function.outer",
                ["]["] = "@class.outer"
              },
              goto_previous_start = {
                ["[m"] = "@function.outer",
                ["[["] = "@class.outer"
              },
              goto_previous_end = {
                ["[M"] = "@function.outer",
                ["[]"] = "@class.outer"
              }
            },
            select = {
              enable = enable,
              keymaps = {
                -- You can use the capture groups defined in textobjects.scm
                ["af"] = "@function.outer",
                ["if"] = "@function.inner",
                ["ac"] = "@class.outer",
                ["ic"] = "@class.inner",
                -- Or you can define your own textobjects like this
                ["iF"] = {
                  python = "(function_definition) @function",
                  cpp = "(function_definition) @function",
                  c = "(function_definition) @function",
                  java = "(method_declaration) @function",
                  go = "(method_declaration) @function"
                }
              }
            },
            swap = {
              enable = enable,
              swap_next = {
                ["<leader>a"] = "@parameter.inner"
              },
              swap_previous = {
                ["<leader>A"] = "@parameter.inner"
              }
            }
          }
        }
      
      
      gopls = {
          capabilities = {
            textDocument = {
              completion = {
                completionItem = {
                  commitCharactersSupport = true,
                  deprecatedSupport = true,
                  documentationFormat = { 'markdown', 'plaintext' },
                  preselectSupport = true,
                  insertReplaceSupport = true,
                  labelDetailsSupport = true,
                  snippetSupport = true,
                  resolveSupport = {
                    properties = {
                      'documentation',
                      'details',
                      'additionalTextEdits',
                    },
                  },
                },
                contextSupport = true,
                dynamicRegistration = true,
              },
            },
          },
          filetypes = { 'go', 'gomod', 'gosum', 'gotmpl', 'gohtmltmpl', 'gotexttmpl' },
          message_level = vim.lsp.protocol.MessageType.Error,
          cmd = {
            'gopls', -- share the gopls instance if there is one already
            '-remote.debug=:0',
          },
          root_dir = function(fname)
            local has_lsp, lspconfig = pcall(require, 'lspconfig')
            if has_lsp then
              local util = lspconfig.util
              return util.root_pattern('go.work', 'go.mod')(fname)
                or util.root_pattern('.git')(fname)
                or util.path.dirname(fname)
            end
          end,
          flags = { allow_incremental_sync = true, debounce_text_changes = 500 },
          settings = {
            gopls = {
              -- more settings: https://github.com/golang/tools/blob/master/gopls/doc/settings.md
              -- not supported
              analyses = {
                unreachable = true,
                nilness = true,
                unusedparams = true,
                useany = true,
                unusedwrite = true,
                ST1003 = true,
                undeclaredname = true,
                fillreturns = true,
                nonewvars = true,
                fieldalignment = false,
                shadow = true,
              },
              codelenses = {
                generate = true, -- show the `go generate` lens.
                gc_details = true, -- Show a code lens toggling the display of gc's choices.
                test = true,
                tidy = true,
                vendor = true,
                regenerate_cgo = true,
                upgrade_dependency = true,
              },
              hints = {
                assignVariableTypes = true,
                compositeLiteralFields = true,
                compositeLiteralTypes = true,
                constantValues = true,
                functionTypeParameters = true,
                parameterNames = true,
                rangeVariableTypes = true,
              },
              usePlaceholders = true,
              completeUnimported = true,
              staticcheck = true,
              matcher = 'Fuzzy',
              diagnosticsDelay = '500ms',
              symbolMatcher = 'fuzzy',
              semanticTokens = false,  -- either enable semantic tokens or use treesitter
              noSemanticTokens = true, -- disable semantic string tokens so we can use treesitter highlight injection
      
              ['local'] = get_current_gomod(),
              gofumpt = _GO_NVIM_CFG.lsp_gofumpt or false, -- true|false, -- turn on for new repos, gofmpt is good but also create code turmoils
              buildFlags = { '-tags', 'integration' },
            },
          },
          -- NOTE: it is important to add handler to formatting handlers
          -- the async formatter will call these handlers when gopls responed
          -- without these handlers, the file will not be saved
          handlers = {
            [range_format] = function(...)
              vim.lsp.handlers[range_format](...)
              if vfn.getbufinfo('%')[1].changed == 1 then
                vim.cmd('noautocmd write')
              end
            end,
            [formatting] = function(...)
              vim.lsp.handlers[formatting](...)
              if vfn.getbufinfo('%')[1].changed == 1 then
                vim.cmd('noautocmd write')
              end
            end,
          },
        }
      
      
      -- in your init.lua
      -- lazy spec
      {
        'ray-x/go.nvim',
        dependencies = {
          'ray-x/guihua.lua', -- optional
          'nvim-treesitter/nvim-treesitter',
          'neovim/nvim-lspconfig',
        },
        opts = {}  -- by default lsp_cfg = false
        -- opts = { lsp_cfg = true } -- use go.nvim will setup gopls
        config = function(lp, opts)
          require("go").setup(opts)
          --
          -- format config here
          --
          local gopls_cfg = require('go.lsp').config()
          -- gopls_cfg.filetypes = { 'go', 'gomod'}, -- override settings
          vim.lsp.config.gopls = gopls_cfg
          vim.lsp.enable('gopls')
        end
      }
      
      
      require("mason").setup()
      require("mason-lspconfig").setup()
      require('lspconfig').gopls.setup({
         -- your gopls setup
      })
      
      
      -- setup your go.nvim
      -- make sure lsp_cfg is disabled
      require("mason").setup()
      require("mason-lspconfig").setup()
      require('go').setup{
        lsp_cfg = false
        -- other setups...
      }
      local cfg = require'go.lsp'.config() -- config() return the go.nvim gopls setup
      
      require('lspconfig').gopls.setup(cfg)
      
      
      local null_ls = require("null-ls")
      local sources = {
        null_ls.builtins.diagnostics.revive,
        null_ls.builtins.formatting.golines.with({
          extra_args = {
            "--max-len=180",
            "--base-formatter=gofumpt",
          },
        })
      }
      -- for go.nvim
      local gotest = require("go.null_ls").gotest()
      local gotest_codeaction = require("go.null_ls").gotest_action()
      local golangci_lint = require("go.null_ls").golangci_lint()
      table.insert(sources, gotest)
      table.insert(sources, golangci_lint)
      table.insert(sources, gotest_codeaction)
      null_ls.setup({ sources = sources, debounce = 1000, default_timeout = 5000 })
      
      -- alternatively
      null_ls.register(gotest)
      
    end,
  },
  {
    "crusj/structrue-go.nvim",
    config = function()
      
      use {
      	'crusj/structrue-go.nvim',
      	branch = "main"
      }
      
      
      require"structrue-go".setup()
      
      
      require"structrue-go".setup({
      	show_others_method = true, -- bool show methods of struct whose not in current file
      	show_filename = true, -- bool
      	number = "no", -- show number: no | nu | rnu
      	fold_open_icon = " ",
      	fold_close_icon = " ",
      	cursor_symbol_hl = "guibg=Gray guifg=White", -- symbol hl under cursor,
      	indent = "┠",  -- Hierarchical indent icon, nil or empty will be a tab
      	position = "botright", -- window position,default botright,also can set float
      	symbol = { -- symbol style
      		filename = {
      		    hl = "guifg=#0096C7", -- highlight symbol
      		    icon = " " -- symbol icon
      		},
      		package = {
      		    hl = "guifg=#0096C7",
      		    icon = " "
      		},
      		import = {
      		    hl = "guifg=#0096C7",
      		    icon = " ◈ "
      		},
      		const = {
      		    hl = "guifg=#E44755",
      		    icon = " π ",
      		},
      		variable = {
      		    hl = "guifg=#52A5A2",
      		    icon = " ◈ ",
      		},
      		func = {
      		    hl = "guifg=#CEB996",
      		    icon = "  ",
      		},
      		interface = {
      		    hl = "guifg=#00B4D8",
      		    icon = "❙ "
      		},
      		type = {
      		    hl = "guifg=#00B4D8",
      		    icon = "▱ ",
      		},
      		struct = {
      		    hl = "guifg=#00B4D8",
      		    icon = "❏ ",
      		},
      		field = {
      		    hl = "guifg=#CEB996",
      		    icon = " ▪ "
      		},
      		method_current = {
      		    hl = "guifg=#CEB996",
      		    icon = " ƒ "
      		},
      		method_others = {
      		    hl = "guifg=#CEB996",
      		    icon = "  "
      		},
      	},
      	keymap = {
      		toggle = "<leader>m", -- toggle structure-go window
      		show_others_method_toggle = "H", -- show or hidden the methods of struct whose not in current file
      		symbol_jump = "<CR>", -- jump to then symbol file under cursor
      		center_symbol = "\\f", -- Center the highlighted symbol
      		fold_toggle = "\\z",
      		refresh = "R", -- refresh symbols
      		preview_open = "P", -- preview  symbol context open
      		preview_close = "\\p" -- preview  symbol context close
      	},
      	fold = { -- fold symbols
      		import = true,
      		const = false,
      		variable = false,
      		type = false,
      		interface = false,
      		func = false,
      	},
      })
      
      
    end,
  },
  {
    "crispgm/nvim-go",
    config = function()
      
      " dependencies
      use('nvim-lua/plenary.nvim')
      
      " nvim-go
      use('crispgm/nvim-go')
      
      " (optional) if you enable nvim-notify
      use('rcarriga/nvim-notify')
      
      " (recommend) LSP config
      use('neovim/nvim-lspconfig')
      
      
      require('go').config.update_tool('quicktype', function(tool)
          tool.pkg_mgr = 'yarn'
      end)
      
      
      -- setup nvim-go
      require('go').setup({})
      
      -- setup lsp client
      require('lspconfig').gopls.setup({})
      
      
      require('go').setup({
          -- notify: use nvim-notify
          notify = false,
          -- auto commands
          auto_format = true,
          auto_lint = true,
          -- linters: revive, errcheck, staticcheck, golangci-lint
          linter = 'revive',
          -- linter_flags: e.g., {revive = {'-config', '/path/to/config.yml'}}
          linter_flags = {},
          -- lint_prompt_style: qf (quickfix), vt (virtual text)
          lint_prompt_style = 'qf',
          -- formatter: goimports, gofmt, gofumpt, lsp
          formatter = 'goimports',
          -- maintain cursor position after formatting loaded buffer
          maintain_cursor_pos = false,
          -- test flags: -count=1 will disable cache
          test_flags = {'-v'},
          test_timeout = '30s',
          test_env = {},
          -- show test result with popup window
          test_popup = true,
          test_popup_auto_leave = false,
          test_popup_width = 80,
          test_popup_height = 10,
          -- test open
          test_open_cmd = 'edit',
          -- struct tags
          tags_name = 'json',
          tags_options = {'json=omitempty'},
          tags_transform = 'snakecase',
          tags_flags = {'-skip-unexported'},
          -- quick type
          quick_type_flags = {'--just-types'},
      })
      
      
      function! LintIssuesCount()
          if exists('g:nvim_go#lint_issues_count')
              return g:nvim_go#lint_issues_count
          endif
      endfunction
      call airline#parts#define_function('nvim_go', 'LintIssuesCount')
      call airline#parts#define_condition('nvim_go', '&filetype == "go"')
      let g:airline_section_warning = airline#section#create_right(['nvim_go'])
      
      
      function! LintIssuesCount()
          if exists('g:nvim_go#lint_issues_count') && &filetype == 'go'
              return g:nvim_go#lint_issues_count
          endif
      endfunction
      let g:lightline = {
        \ 'colorscheme': 'wombat',
        \ 'active': {
        \   'left': [ [ 'mode', 'paste' ],
        \             [ 'readonly', 'filename', 'modified', 'lintcount' ] ]
        \ },
        \ 'component_function': {
        \   'lintcount': 'LintIssuesCount'
        \ },
        \ }
      
      
      require('hardline').setup({
          -- ...
          sections = {
              {
                  class = 'error',
                  item = function()
                      if
                          vim.bo.filetype == 'go'
                          and vim.g['nvim_go#lint_issues_count'] ~= nil
                      then
                          return vim.g['nvim_go#lint_issues_count']
                      else
                          return ''
                      end
                  end,
              },
          -- ...
          }
      
      
      local NvimGo = vim.api.nvim_create_augroup("NvimGo", {
        clear = true,
      })
      vim.api.nvim_create_autocmd({ "User" }, {
        pattern = "NvimGoLintPopupPost",
        group = NvimGo,
        command = "wincmd p",
      })
      
    end,
  },
  {
    "edolphin-ydf/goimpl.nvim",
  },
  {
    "olexsmir/gopher.nvim/",
  },
  {
    "rafaelsq/nvim-goc.lua",
    config = function()
      
      
      -- if set, when we switch between buffers, it will not split more than once. It will switch to the existing buffer instead
      vim.opt.switchbuf = 'useopen'
      
      local goc = require'nvim-goc'
      goc.setup({ verticalSplit = false })  -- default to horizontal
      
      
      vim.keymap.set('n', '<Leader>gcf', goc.Coverage, {silent=true})       -- run for the whole File
      vim.keymap.set('n', '<Leader>gct', goc.CoverageFunc, {silent=true})   -- run only for a specific Test unit
      vim.keymap.set('n', '<Leader>gcc', goc.ClearCoverage, {silent=true})  -- clear coverage highlights
      
      -- If you need custom arguments, you can supply an array as in the example below.
      -- vim.keymap.set('n', '<Leader>gcf', function() goc.Coverage({ "-race", "-count=1" }) end, {silent=true})
      -- vim.keymap.set('n', '<Leader>gct', function() goc.CoverageFunc({ "-race", "-count=1" }) end, {silent=true})
      
      vim.keymap.set('n', ']a', goc.Alternate, {silent=true})
      vim.keymap.set('n', '[a', goc.AlternateSplit, {silent=true})          -- set verticalSplit=true for vertical
      
      cf = function(testCurrentFunction)
        local cb = function(path, index)
          if path then
      
            -- `xdg-open|open` command performs the same function as double-clicking on the file.
            -- change from `xdg-open` to `open` on MacOSx
            vim.cmd(":silent exec \"!xdg-open file://" .. path .. "\\\\#file" .. index .. "\"")
          end
        end
      
        if testCurrentFunction then
          goc.CoverageFunc(nil, cb, 0)
        else
          goc.Coverage(nil, cb)
        end
      end
      
      -- If you want to open it in your browser, you can use the commands below.
      -- You need to create a callback function to configure which command to use to open the HTML.
      -- On Linux, `xdg-open` is generally used, on MacOSx it's just `open`.
      vim.keymap.set('n', '<leader>gca', cf, {silent=true})
      vim.keymap.set('n', '<Leader>gcb', function() cf(true) end, {silent=true})
      
      -- default colors
      -- vim.api.nvim_set_hl(0, 'GocNormal', {link='Comment'})
      -- vim.api.nvim_set_hl(0, 'GocCovered', {link='String'})
      -- vim.api.nvim_set_hl(0, 'GocUncovered', {link='Error'})
      
    end,
  },
  {
    "crusj/hierarchy-tree-go.nvim",
    config = function()
      
      use {
      	'crusj/hierarchy-tree-go.nvim',
      	requires= 'neovim/nvim-lspconfig'
      }
      
      
      require("hierarchy-tree-go").setup()
      
      
      
      require("hierarchy-tree-go").setup({
      	icon = {
      		fold = "", -- fold icon
      		unfold = "", -- unfold icon
      		func = "₣", -- symbol
      		last = '☉', -- last level icon
      	},
      	hl = {
      		current_module = "guifg=Green", -- highlight cwd module line
      		others_module = "guifg=Black", -- highlight others module line
      		cursorline = "guibg=Gray guifg=White" -- hl  window cursorline
      	},
      	keymap = {
      		--global keymap
      		incoming = "<space>fi", -- call incoming under cursorword
      		outgoing = "<space>fo", -- call outgoing under cursorword
      		open = "<space>ho", -- open hierarchy win
      		close = "<space>hc", -- close hierarchy win
      		-- focus: if hierarchy win is valid but is not current win, set to current win
      		-- focus: if hierarchy win is valid and is current win, close
      		-- focus  if hierarchy win not existing,open and focus
      		focus = "<space>fu",
      
      		-- bufkeymap
      		expand = "o", -- expand or collapse hierarchy
      		jump = "<CR>", -- jump
      		move = "<space><space>" -- switch the hierarchy window position, must be current win
      	}
      })
      
      
    end,
  },
  {
    "yanskun/gotests.nvim",
    config = function()
      
      {
        "yanskun/gotests.nvim",
        ft = "go",
        config = function()
          require("gotests").setup()
        end,
      },
      
      
      use {
        'yanskun/gotests.nvim',
        ft = 'go',
        config = function()
          require('gotests').setup()
        end
      }
      
    end,
  },
  {
    "maxandron/goplements.nvim",
    config = function()
      
      {
        "maxandron/goplements.nvim",
        ft = "go",
        opts = {
          -- your configuration comes here
          -- or leave it empty to use the default settings
          -- refer to the configuration section below
        },
      }
      
      
      local defaults = {
        -- The prefixes prepended to the type names
        prefix = {
          interface = "implemented by: ",
          struct = "implements: ",
        },
        -- Whether to display the package name along with the type name (i.e., builtins.error vs error)
        display_package = false,
        -- The namespace to use for the extmarks (no real reason to change this except for testing)
        namespace_name = "goplements",
        -- The highlight group to use (if you want to change the default colors)
        -- The default links to DiagnosticHint
        highlight = "Goplements",
      }
      
    end,
  },
  {
    "Snikimonkd/cmp-go-pkgs",
    config = function()
      
      return {
          "hrsh7th/nvim-cmp",
          dependencies = {
              "Snikimonkd/cmp-go-pkgs",
          },
          config = function()
              local cmp = require("cmp")
      
              cmp.setup({
                  sources = {
                      { name = "go_pkgs" },
                  },
      			matching = { disallow_symbol_nonprefix_matching = false }, -- to use . and / in urls
              })
          end,
      },
      
      
      return {
          "hrsh7th/nvim-cmp",
          dependencies = {
              "Snikimonkd/cmp-go-pkgs",
          },
          config = function()
              local cmp = require("cmp")
              local lspkind = require("lspkind")
      
              cmp.setup({
                  sources = {
                      { name = "go_pkgs" },
                  },
                  formatting = {
                      format = lspkind.cmp_format({
                          with_text = true,
                          menu = {
                              go_pkgs = "[pkgs]",
                          },
                      }),
                  },
              })
          end,
      },
      
    end,
  },
  {
    "Yu-Leo/gosigns.nvim",
    config = function()
      
      {
          "Yu-Leo/gosigns.nvim",
          ft = "go",
          cmd = {"GosignsEnable", "GosignsDisable", "GosignsToggle"},
          opts = {}, -- for default options. Refer to the configuration section for custom setup.
      }
      
      
      ---@class gosigns.OptsSignsChar
      ---@field public char string
      ---@field public hl string
      local OptsSignsChar = {}
      
      ---@class gosigns.OptsSigns
      ---@field public priority integer
      ---@field public chars table<string, gosigns.OptsSignsChar>
      local OptsSigns = {}
      
      ---@class gosigns.Opts
      ---@field public signs gosigns.OptsSigns
      local defaults = {
        -- Config for signs in left-hand column
        signs = {
          -- https://neovim.io/doc/user/sign.html#sign-priority
          priority = 10,
          -- Config for chars by object types.
          -- To turn off the type set `nil` value
          chars = {
            -- Interfaces with implementations
            interface = {
              char = "↓",
              hl = "Comment",
            },
            -- Interface methods that have implementations
            method_elem = {
              char = "↓",
              hl = "Comment",
            },
            -- Structures that implement interfaces
            struct = {
              char = "↑",
              hl = "Comment",
            },
            -- Structures methods that implement interface methods
            method_declaration = {
              char = "↑",
              hl = "Comment",
            },
            -- Comments starting with `go:`. See https://go.dev/doc/comment#syntax
            go_comment = {
              char = "⭘",
              hl = "Comment",
            },
          },
        },
      }
      
      
      -- Enable gosigns
      require("gosigns").enable()
      
      -- Disable gosigns
      require("gosigns").disable()
      
      -- Toggle gosigns
      require("gosigns").toggle()
      
      -- Redraw gosigns for bufnr
      require("gosigns").redraw(bufnr)
      
    end,
  },
  {
    "Yu-Leo/cmp-go-pkgs",
    config = function()
      
      {
        "hrsh7th/nvim-cmp",
      
        dependencies = {
          "Yu-Leo/cmp-go-pkgs",
        },
      
        config = function()
          local cmp = require("cmp")
          cmp.setup({
            sources = {
              { name = "go_pkgs" },
            },
          })
        end,
      }
      
      
      vim.api.nvim_create_autocmd({ "LspAttach" }, {
        pattern = { "*.go" },
        callback = function(args)
          require("cmp_go_pkgs").init_items(args)
        end,
      })
      
    end,
  },
  {
    "fredrikaverpil/godoc.nvim",
    config = function()
      
      {
          "fredrikaverpil/godoc.nvim",
          version = "*",
          dependencies = {
              { "nvim-telescope/telescope.nvim" }, -- optional
              { "folke/snacks.nvim" }, -- optional
              { "echasnovski/mini.pick" }, -- optional
              { "ibhagwan/fzf-lua" }, -- optional
              {
                  "nvim-treesitter/nvim-treesitter",
                  opts = {
                    ensure_installed = { "go" },
                  },
              },
          },
          build = "go install github.com/lotusirous/gostdsym/stdsym@latest", -- optional
          cmd = { "GoDoc" }, -- optional
          opts = {}, -- see further down below for configuration
      }
      
      
      local godoc = require("godoc")
      
      ---@type godoc.types.GoDocConfig
      {
          adapters = {
              -- for details, see lua/godoc/adapters/go.lua
              {
                  name = "go",
                  opts = {
                      command = "GoDoc", -- the vim command to invoke Go documentation
                      get_syntax_info = function()
                          return {
                              filetype = "godoc", -- filetype for the buffer
                              language = "go", -- tree-sitter parser, for syntax highlighting
                          }
                      end,
                  },
              },
          },
          window = {
              type = "split", -- split | vsplit
          },
          picker = {
              type = "native", -- native (vim.ui.select) | telescope | snacks | mini | fzf_lua
      
              -- see respective picker in lua/godoc/pickers for available options
              native = {},
              telescope = {},
              snacks = {},
              mini = {},
              fzf_lua = {},
          },
      }
      
      
      {
          "fredrikaverpil/godoc.nvim",
          version = "*",
          dependencies = {
              {
                  "nvim-treesitter/nvim-treesitter",
                  opts = {
                    ensure_installed = { "go", "mylang", "python" },
                  },
              },
              { "someuser/pydoc.nvim" }, -- third-party
          },
          opts = {
              adapters = {
                  -- built-in
                  { name = "go" },
      
                  -- built-in, but with user-override
                  { name = "go", opts = { command = "MyCustomCommand" }, },
      
                  -- user-provided (note the omission of a 'name' field)
                  {
                      command = "MyDoc",
                      get_items = function()
                          return vim.fn.systemlist("mylang doc --list")
                      end,
                      get_content = function(choice)
                          return vim.fn.systemlist("mylang doc " .. choice)
                      end,
                      get_syntax_info = function()
                          return {
                              filetype = "mydoc", -- filetype for buffer that is opened
                              language = "mylang" -- tree-sitter parser
                          }
                      end
                  },
      
                  -- user-provided (another example)
                  {
                      command = "DadJokes",
                      get_items = function()
                          return { "coffee", "pasta" }
                      end,
                      get_content = function(choice)
                          local db = {
                              coffee = {
                                  "What did the coffee report to the police?",
                                  "A mugging!"
                              },
                              pasta = {
                                  "What do you call a fake noodle?",
                                  "An impasta!"
                              },
                          }
                          return db[choice]
                      end,
                      get_syntax_info = function()
                          return {
                              filetype = "text",
                              language = "text",
                          }
                      end,
                  },
      
                  -- third-party
                  {
                      setup = function()
                          opts = {...} -- third-party opts
                          return require("pydoc.nvim").setup(opts)
                      end,
                  },
      
                  -- third-party with user-override
                  {
                      setup = function()
                          opts = {...} -- third-party opts
                          return require("pydoc.nvim").setup(opts)
                      end,
                      opts = {
                          command = "CustomPyDocCommand",
                      },
                  },
              }
          },
      }
      
      
      --- @class GoDocAdapter
      --- @field command string The vim command name to register
      --- @field get_items fun(): string[] Function that returns a list of available items
      --- @field get_content fun(choice: string): string[] Function that returns the content
      --- @field get_syntax_info fun(): GoDocSyntaxInfo Function that returns syntax info
      --- @field goto_definition? fun(choice: string, picker_gotodef_fun: fun()?): nil Function that returns the definition location
      --- @field health? fun(): GoDocHealthCheck[] Optional health check function
      
      
      --- @class GoDocAdapterOpts
      --- @field command? string Override the command name
      --- @field get_items? fun(): string[] Override the get_items function
      --- @field get_content? fun(choice: string): string[] Override the get_content function
      --- @field get_syntax_info? fun(): GoDocSyntaxInfo Override the get_syntax_info function
      --- @field goto_definition? fun(choice: string, picker_gotodef_fun: fun()?): nil Override the get_definition function
      --- @field health? fun(): GoDocHealthCheck[] Override the health check function
      --- @field [string] any Other adapter-specific options
      
    end,
  },
  {
    "someone-stole-my-name/yaml-companion.nvim",
    config = function()
      
      use {
        "someone-stole-my-name/yaml-companion.nvim",
        requires = {
            { "neovim/nvim-lspconfig" },
            { "nvim-lua/plenary.nvim" },
            { "nvim-telescope/telescope.nvim" },
        },
        config = function()
          require("telescope").load_extension("yaml_schema")
        end,
      }
      
      
      {
        -- Built in file matchers
        builtin_matchers = {
          -- Detects Kubernetes files based on content
          kubernetes = { enabled = true },
          cloud_init = { enabled = true }
        },
      
        -- Additional schemas available in Telescope picker
        schemas = {
          --{
            --name = "Kubernetes 1.22.4",
            --uri = "https://raw.githubusercontent.com/yannh/kubernetes-json-schema/master/v1.22.4-standalone-strict/all.json",
          --},
        },
      
        -- Pass any additional options that will be merged in the final LSP config
        lspconfig = {
          flags = {
            debounce_text_changes = 150,
          },
          settings = {
            redhat = { telemetry = { enabled = false } },
            yaml = {
              validate = true,
              format = { enable = true },
              hover = true,
              schemaStore = {
                enable = true,
                url = "https://www.schemastore.org/api/json/catalog.json",
              },
              schemaDownload = { enable = true },
              schemas = {},
              trace = { server = "debug" },
            },
          },
        },
      }
      
      
      local cfg = require("yaml-companion").setup({
        -- Add any options here, or leave empty to use the default settings
        -- lspconfig = {
        --   cmd = {"yaml-language-server"}
        -- },
      })
      require("lspconfig")["yamlls"].setup(cfg)
      
      
      require("yaml-companion").open_ui_select()
      
      
      local function get_schema()
        local schema = require("yaml-companion").get_buf_schema(0)
        if schema.result[1].name == "none" then
          return ""
        end
        return schema.result[1].name
      end
      
    end,
  },
  {
    "cuducos/yaml.nvim",
    config = function()
      
      {
        "cuducos/yaml.nvim",
        ft = { "yaml" }, -- optional
        dependencies = {
          "folke/snacks.nvim", -- optional
          "nvim-telescope/telescope.nvim", -- optional
          "ibhagwan/fzf-lua" -- optional
        },
      }
      
      
      use {
        "cuducos/yaml.nvim",
        ft = { "yaml" }, -- optional
        requires = {
          "folke/snacks.nvim", -- optional
          "nvim-telescope/telescope.nvim" -- optional
          "ibhagwan/fzf-lua" --optional
        },
      }
      
      
      {
        "nvim-treesitter/nvim-treesitter",
        build = ":TSUpdate",
        config = function()
          require("nvim-treesitter.configs").setup({
            ensure_installed = { "yaml" },
            },
        })
        end,
      }
      
      
      require("yaml_nvim").setup({ ft = { "yaml",  "other yaml filetype" } })
      
      
      vim.api.nvim_create_autocmd({ "BufEnter", "CursorMoved" }, {
        pattern = { "*.yaml" },
        callback = function()
          vim.opt_local.winbar = require("yaml_nvim").get_yaml_key_and_value()
        end,
      })
      
      
      vim.api.nvim_create_autocmd({ "BufEnter", "FileType" }, {
        group = vim.api.nvim_create_augroup("bufent_winbar", { clear = true }),
        callback = function(opts)
          if vim.bo[opts.buf].filetype == "yaml" then
            vim.api.nvim_create_autocmd({ "CursorMoved" }, {
              group = vim.api.nvim_create_augroup("curs_winbar", { clear = true }),
              callback = function()
                vim.opt_local.winbar = require("yaml_nvim").get_yaml_key_and_value()
              end,
            })
          else
            vim.opt_local.winbar = ""
            vim.api.nvim_create_augroup("curs_winbar", { clear = true })
          end
        end,
      })
      
      
      require("lualine").setup({
        sections = {
          lualine_x = { require("yaml_nvim").get_yaml_key_and_value },
          -- etc
        }
      })
      
    end,
  },
  {
    "rest-nvim/rest.nvim",
    config = function()
      
      {
        "rest-nvim/rest.nvim",
        dependencies = {
          "nvim-treesitter/nvim-treesitter",
          opts = function (_, opts)
            opts.ensure_installed = opts.ensure_installed or {}
            table.insert(opts.ensure_installed, "http")
          end,
        }
      }
      
       -->
      <!-- use { -->
      <!--   "rest-nvim/rest.nvim", -->
      <!--   rocks = { "nvim-nio", "mimetypes", "xml2lua", "fidget.nvim", "tree-sitter-http" }, -->
      <!-- } -->
      <!-- 
      
      ---@type rest.Opts
      vim.g.rest_nvim = {
          -- ...
      }
      
      
      ---rest.nvim default configuration
      ---@class rest.Config
      local default_config = {
          ---@type table<string, fun():string> Table of custom dynamic variables
          custom_dynamic_variables = {},
          ---@class rest.Config.Request
          request = {
              ---@type boolean Skip SSL verification, useful for unknown certificates
              skip_ssl_verification = false,
              ---Default request hooks
              ---@class rest.Config.Request.Hooks
              hooks = {
                  ---@type boolean Encode URL before making request
                  encode_url = true,
                  ---@type string Set `User-Agent` header when it is empty
                  user_agent = "rest.nvim v" .. require("rest-nvim.api").VERSION,
                  ---@type boolean Set `Content-Type` header when it is empty and body is provided
                  set_content_type = true,
              },
          },
          ---@class rest.Config.Response
          response = {
              ---Default response hooks
              ---@class rest.Config.Response.Hooks
              hooks = {
                  ---@type boolean Decode the request URL segments on response UI to improve readability
                  decode_url = true,
                  ---@type boolean Format the response body using `gq` command
                  format = true,
              },
          },
          ---@class rest.Config.Clients
          clients = {
              ---@class rest.Config.Clients.Curl
              curl = {
                  ---Statistics to be shown, takes cURL's `--write-out` flag variables
                  ---See `man curl` for `--write-out` flag
                  ---@type RestStatisticsStyle[]
                  statistics = {
                      { id = "time_total", winbar = "take", title = "Time taken" },
                      { id = "size_download", winbar = "size", title = "Download size" },
                  },
                  ---Curl-secific request/response hooks
                  ---@class rest.Config.Clients.Curl.Opts
                  opts = {
                      ---@type boolean Add `--compressed` argument when `Accept-Encoding` header includes
                      ---`gzip`
                      set_compressed = false,
                      ---@type table<string, Certificate> Table containing certificates for each domains
                      certificates = {},
                  },
              },
          },
          ---@class rest.Config.Cookies
          cookies = {
              ---@type boolean Whether enable cookies support or not
              enable = true,
              ---@type string Cookies file path
              path = vim.fs.joinpath(vim.fn.stdpath("data") --[[@as string]], "rest-nvim.cookies"),
          },
          ---@class rest.Config.Env
          env = {
              ---@type boolean
              enable = true,
              ---@type string
              pattern = ".*%.env.*",
              ---@type fun():string[]
              find = function()
                  local config = require("rest-nvim.config")
                  return vim.fs.find(function(name, _)
                      return name:match(config.env.pattern)
                  end, {
                      path = vim.fn.getcwd(),
                      type = "file",
                      limit = math.huge,
                  })
              end,
          },
          ---@class rest.Config.UI
          ui = {
              ---@type boolean Whether to set winbar to result panes
              winbar = true,
              ---@class rest.Config.UI.Keybinds
              keybinds = {
                  ---@type string Mapping for cycle to previous result pane
                  prev = "H",
                  ---@type string Mapping for cycle to next result pane
                  next = "L",
              },
          },
          ---@class rest.Config.Highlight
          highlight = {
              ---@type boolean Whether current request highlighting is enabled or not
              enable = true,
              ---@type number Duration time of the request highlighting in milliseconds
              timeout = 750,
          },
          ---@see vim.log.levels
          ---@type integer log level
          _log_level = vim.log.levels.WARN,
      }
      
      
      -- first load extension
      require("telescope").load_extension("rest")
      -- then use it, you can also use the `:Telescope rest select_env` command
      require("telescope").extensions.rest.select_env()
      
      
      -- Just add a component in your lualine config
      {
        sections = {
          lualine_x = {
            "rest"
          }
        }
      }
      
      -- To use a custom icon and color
      {
        sections = {
          lualine_x = {
            {
              "rest",
              icon = "",
              fg = "#428890"
            }
          }
        }
      }
      
    end,
  },
  {
    "lima1909/resty.nvim",
    config = function()
      
        use {
          "lima1909/resty.nvim",
          requires = { "nvim-lua/plenary.nvim" },
        }
        
      
        {
          "lima1909/resty.nvim",
          dependencies = { "nvim-lua/plenary.nvim" },
        },
        
      
      local ctx = {
          -- result of the current request
          -- body = '{}', status = 200, headers = {}, exit = 0, global_variables = {}
          result = ...,
          -- set global variables with key and value
          set = function(key, value) end,
          -- parse the JSON body
          json_body = function() end,
          -- jq to the body
          jq_body = function(filter) end,
      }
      
      
      vim.keymap.set({"n","v"},"<leader>rr", ":Resty run<CR>",{desc="[R]esty [R]un request under the cursor"})
      vim.keymap.set({"n","v"},"<leader>rv", ":Resty favorite<CR>",{desc="[R]esty [V]iew favorites"})
      
    end,
  },
  {
    "mistweaverco/kulala.nvim",
    config = function()
      
      require("lazy").setup({
        {
          "mistweaverco/kulala.nvim",
          keys = {
            { "<leader>Rs", desc = "Send request" },
            { "<leader>Ra", desc = "Send all requests" },
            { "<leader>Rb", desc = "Open scratchpad" },
          },
          ft = {"http", "rest"},
          opts = {
            global_keymaps = false,
            global_keymaps_prefix = "<leader>R",
            kulala_keymaps_prefix = "",
          },
        },
      })
      
    end,
  },
  {
    "heilgar/nvim-http-client",
    config = function()
      
      {
          "heilgar/nvim-http-client",
          dependencies = {
              "nvim-lua/plenary.nvim",
              "hrsh7th/nvim-cmp", -- Optional but recommended for enhanced autocompletion
              "nvim-telescope/telescope.nvim", -- Optional for better environment selection
          },
          event = "VeryLazy",
          ft = { "http", "rest" },
          config = function()
              require("http_client").setup({
                  -- Default configuration (works out of the box)
                  default_env_file = '.env.json',
                  request_timeout = 30000,
                  split_direction = "right",
                  create_keybindings = true,
                  
                  -- Profiling (timing metrics for requests)
                  profiling = {
                      enabled = true,
                      show_in_response = true,
                      detailed_metrics = true,
                  },
                  
                  -- Default keybindings (can be customized)
                  keybindings = {
                      select_env_file = "<leader>hf",
                      set_env = "<leader>he",
                      run_request = "<leader>hr",
                      stop_request = "<leader>hx",
                      toggle_verbose = "<leader>hv",
                      toggle_profiling = "<leader>hp",
                      dry_run = "<leader>hd",
                      copy_curl = "<leader>hc",
                      save_response = "<leader>hs",
                  },
              })
              
              -- Set up Telescope integration if available
              if pcall(require, "telescope") then
                  require("telescope").load_extension("http_client")
              end
          end
      }
      
    end,
  },
  {
    "ray-x/web-tools.nvim",
    config = function()
      
      require'web-tools'.setup({
        keymaps = {
          rename = nil,  -- by default use same setup of lspconfig
          repeat_rename = '.', -- . to repeat
        },
        hurl = {  -- hurl default
          show_headers = false, -- do not show http headers
          floating = false,   -- use floating windows (need guihua.lua)
          json5 = false,      -- use json5 parser require json5 treesitter
          formatters = {  -- format the result by filetype
            json = { 'jq' },
            html = { 'prettier', '--parser', 'html' },
          },
        },
      })
      
    end,
  },
  {
    "roobert/tailwindcss-colorizer-cmp.nvim",
  },
  {
    "luckasRanarison/tailwind-tools.nvim",
    config = function()
      
      -- tailwind-tools.lua
      return {
        "luckasRanarison/tailwind-tools.nvim",
        name = "tailwind-tools",
        build = ":UpdateRemotePlugins",
        dependencies = {
          "nvim-treesitter/nvim-treesitter",
          "nvim-telescope/telescope.nvim", -- optional
          "neovim/nvim-lspconfig", -- optional
        },
        opts = {} -- your configuration
      }
      
      
      require("tailwind-tools").setup({
        -- your configuration
      })
      
      
      ---@type TailwindTools.Option
      {
        server = {
          override = true, -- setup the server from the plugin if true
          settings = { -- shortcut for `settings.tailwindCSS`
            -- experimental = {
            --   classRegex = { "tw\\('([^']*)'\\)" }
            -- },
            -- includeLanguages = {
            --   elixir = "phoenix-heex",
            --   heex = "phoenix-heex",
            -- },
          },
          on_attach = function(client, bufnr) end, -- callback executed when the language server gets attached to a buffer
          root_dir = function(fname) end, -- overrides the default function for resolving the root directory
        },
        document_color = {
          enabled = true, -- can be toggled by commands
          kind = "inline", -- "inline" | "foreground" | "background"
          inline_symbol = "󰝤 ", -- only used in inline mode
          debounce = 200, -- in milliseconds, only applied in insert mode
        },
        conceal = {
          enabled = false, -- can be toggled by commands
          min_length = nil, -- only conceal classes exceeding the provided length
          symbol = "󱏿", -- only a single character is allowed
          highlight = { -- extmark highlight options, see :h 'highlight'
            fg = "#38BDF8",
          },
        },
        keymaps = {
          smart_increment = { -- increment tailwindcss units using <C-a> and <C-x>
            enabled = true,
            units = {  -- see lua/tailwind/units.lua to see all the defaults
              {
                prefix = "border",
                values = { "2", "4", "6", "8" },
              },
              -- ...
            }
          }
        },
        cmp = {
          highlight = "foreground", -- color preview style, "foreground" | "background"
        },
        telescope = {
          utilities = {
            callback = function(name, class) end, -- callback used when selecting an utility class in telescope
          },
        },
        -- see the extension section to learn more
        extension = {
          queries = {}, -- a list of filetypes having custom `class` queries
          patterns = { -- a map of filetypes to Lua pattern lists
            -- rust = { "class=[\"']([^\"']+)[\"']" },
            -- javascript = { "clsx%(([^)]+)%)" },
          },
        },
      }
      
      
      -- nvim-cmp.lua
      return {
        "hrsh7th/nvim-cmp",
        dependencies = {
          "tailwind-tools",
          "onsails/lspkind-nvim",
          -- ...
        },
        opts = function()
          return {
            -- ...
            formatting = {
              format = require("lspkind").cmp_format({
                before = require("tailwind-tools.cmp").lspkind_format
              }),
            },
          }
        end,
      },
      
      
      {
        extension = {
          queries = { "myfiletype" },
        }
      }
      
      
      {
        extension = {
          patterns = {
            javascript = { "clsx%(([^)]+)%)" },
          },
        }
      }
      
    end,
  },
  {
    "cjodo/convert.nvim",
    config = function()
      
      return {
          'cjodo/convert.nvim',
          dependencies = {
              'MunifTanjim/nui.nvim'
          },
          keys = {
              { "<leader>cn", "<cmd>ConvertFindNext<CR>", desc = "Find next convertable unit" },
              { "<leader>cc", "<cmd>ConvertFindCurrent<CR>", desc = "Find convertable unit in current line" },
              -- Add "v" to enable converting a selected region
              { "<leader>ca", "<cmd>ConvertAll<CR>", mode = {"n", "v"}, desc = "Convert all of a specified unit" },
          },
      }
      
      
      use {
          'cjodo/convert.nvim',
          requires = { 'MunifTanjim/nui.nvim' },
          config = function()
              require('convert').setup()
              vim.keymap.set('n', '<leader>cn', '<cmd>ConvertFindNext<CR>', { desc = 'Find next convertible unit' })
              vim.keymap.set('n', '<leader>cc', '<cmd>ConvertFindCurrent<CR>', { desc = 'Find convertible unit in current line' })
              vim.keymap.set({ 'n', 'v' }, '<leader>ca', '<cmd>ConvertAll<CR>', { desc = 'Convert all of a specified unit' })
          end
      }
      
      
      
      config = function()
          local convert = require('convert')
          -- defaults
          convert.setup({
              keymaps = {
                  focus_next = { "j", "<Down>", "<Tab>" },
                  focus_prev = { "k", "<Up>", "<S-Tab>" },
                  close = { "<Esc>", "<C-c>", 'qq' },
                  submit = { "<CR>", "<Space>" },
              },
              modes = { "color", "size", "numbers" } -- available conversion modes
          })
      end
      
      
    end,
  },
  {
    "farias-hecdin/CSSVarViewer",
    config = function()
      
      {
          'farias-hecdin/CSSVarViewer',
          ft = "css",
          config = true,
          -- If you want to configure some options, replace the previous line with:
          -- config = function()
          -- end,
      }
      
      
      require('CSSVarViewer').setup({
        parent_search_limit = 5,-- <number> Parent search limit (number of levels to search upwards).
        filename_to_track = "main", -- <string> Name of the file to track (e.g. "main" for main.css).
        disable_keymaps = false, -- <boolean> Indicates whether keymaps are disabled.
      })
      
    end,
  },
  {
    "farias-hecdin/CSSVarHighlight",
    config = function()
      
      {
          'farias-hecdin/CSSVarHighlight',
          ft = "css",
          dependencies = {"echasnovski/mini.hipatterns"},
          config = true,
          -- If you want to configure some options, replace the previous line with:
          -- config = function()
          -- end,
      }
      
      
      local hipatterns = require("mini.hipatterns")
      
      hipatterns.setup({
          -- Your other settings...
          highlighters = {
              -- Your other settings...
              css_variables = require("CSSVarHighlight").get_settings()
          }
      })
      
      
      require('CSSVarHighlight').setup({
        parent_search_limit = 5, -- <number> Parent search limit (number of levels to search upwards).
        filename_to_track = "main", -- <string> Name of the file to track (e.g. "main" for main.css).
        variable_pattern = "%-%-[-_%w]*color[-_%w]*", -- <string> Pattern to search for variables containing "color".
        initial_variable_color = "#000000", -- <string> Initial color for variables (in hex format, e.g. "#000000" for black).
        disable_keymaps = false, -- <boolean> Indicates whether keymaps are disabled.
      })
      
    end,
  },
  {
    "BibekBhusal0/nvim-shadcn",
    config = function()
      
      {
        'BibekBhusal/nvim-shadcn',
        dependencies = {
          'nvim-telescope/telescope.nvim'
        },
        config = function()
          require('nvim-shadcn').setup({
            -- Configuration options here
          })
        end
      }
      
      
      require('nvim-shadcn').setup({
        default_installer = 'npm',
      
        format = {
          doc = 'https://ui.shadcn.com/docs/components/%s', -- or https://mynaui.com/components/%s
          npm = 'npx shadcn@latest add %s',
          pnpm = 'pnpm dlx shadcn@latest add %s',
          yarn = 'npx shadcn@latest add %s',
          bun = 'bunx --bun shadcn@latest add %s',
        },
      
        verbose = false,
        important = { 'button', 'card', 'checkbox', 'tooltip' }, -- this will be added when running `:ShadcnAddImportant`
      
        keys = { -- for telescope
          i = { doc = '<C-o>' },
          n = { doc = '<C-o>' },
        },
      
        init_command = {
          commands = {
            npm = 'npx shadcn@latest init',
            pnpm = 'pnpm dlx shadcn@latest init',
            yarn = 'npx shadcn@latest init',
            bun = 'bunx --bun shadcn@latest init',
          },
          flags = { defaults = false, force = false },
          default_color = 'Gray', -- Must be capitalized
        },
      
        telescope_config = {
          sorting_strategy = 'ascending',
          layout_config = {
            prompt_position = 'top',
            ...
          },
          prompt_title = 'Shadcn UI components',
        },
      })
      
      
      require('nvim-shadcn').setup({
          format = {
              solid = 'npx shadcn-solid@latest add %s',
              doc = 'https://shadcn-solid.com/docs/components/%s', -- Just URL format here
          },
          keys = {
              n = { solid = '<C-s>' }, -- using <C-s> in telescope will use solid for installing
              i = { solid = '<C-s>' },
          },
      
          --  default_installer = 'solid',
      })
      
      
      vim.keymap.set('n', '<leader>sa', ':ShadcnAdd<CR>', { noremap = true, silent = true })
      vim.keymap.set('n', '<leader>si', ':ShadcnInit<CR>', { noremap = true, silent = true })
      vim.keymap.set('n', '<leader>sI', ':ShadcnAddImportant<CR>', { noremap = true, silent = true })
      
      
      {
          'BibekBhusal0/nvim-shadcn',
          opts = {},
          cmd = { 'ShadcnAdd' },
          keys = {
              { '<leader>sa', ':ShadcnAdd<CR>', desc = 'Add shadcn component' },
              { '<leader>si', ':ShadcnInit<CR>', desc = 'Init shadcn' },
              { '<leader>sI', ':ShadcnAddImportant<CR>', desc = 'Add important shadcn component' },
          }
      }
      
      
      require('nvim-shadcn').setup({
          keys = {
              i = { yarn = '<C-y>' },
              n = { yarn = '<C-y>' }
          },
          ...
      })
      
    end,
  },
  {
    "azratul/expose-localhost.nvim",
    config = function()
      
      {
        "azratul/expose-localhost.nvim",
      }
      
      
      use {
        "azratul/expose-localhost.nvim",
      }
      
      
      require("expose-localhost").expose(3000, "cloudflared")
      
      
      :lua require("expose-localhost").health()
      
      
      :checkhealth expose-localhost
      
    end,
  },
  {
    "ellisonleao/glow.nvim",
    config = function()
      
      use {"ellisonleao/glow.nvim", config = function() require("glow").setup() end}
      
      
      {"ellisonleao/glow.nvim", config = true, cmd = "Glow"}
      
      
      {
        glow_path = "", -- will be filled automatically with your glow bin in $PATH, if any
        install_path = "~/.local/bin", -- default path for installing glow binary
        border = "shadow", -- floating window border config
        style = "dark|light", -- filled automatically with your current editor background, you can override using glow json style
        pager = false,
        width = 80,
        height = 100,
        width_ratio = 0.7, -- maximum width of the Glow window compared to the nvim window size (overrides `width`)
        height_ratio = 0.7,
      }
      
      
      require('glow').setup({
        -- your override config
      })
      
      
      require('glow').setup({
        style = "dark",
        width = 120,
      })
      
    end,
  },
  {
    "iamcco/markdown-preview.nvim",
    config = function()
      
      -- install without yarn or npm
      {
          "iamcco/markdown-preview.nvim",
          cmd = { "MarkdownPreviewToggle", "MarkdownPreview", "MarkdownPreviewStop" },
          ft = { "markdown" },
          build = function() vim.fn["mkdp#util#install"]() end,
      }
      
      -- install with yarn or npm
      {
        "iamcco/markdown-preview.nvim",
        cmd = { "MarkdownPreviewToggle", "MarkdownPreview", "MarkdownPreviewStop" },
        build = "cd app && yarn install",
        init = function()
          vim.g.mkdp_filetypes = { "markdown" }
        end,
        ft = { "markdown" },
      },
      
      
      
      -- install without yarn or npm
      use({
          "iamcco/markdown-preview.nvim",
          run = function() vim.fn["mkdp#util#install"]() end,
      })
      
      use({ "iamcco/markdown-preview.nvim", run = "cd app && npm install", setup = function() vim.g.mkdp_filetypes = { "markdown" } end, ft = { "markdown" }, })
      
    end,
  },
  {
    "davidgranstrom/nvim-markdown-preview",
  },
  {
    "jghauser/auto-pandoc.nvim",
    config = function()
      
      use {
        'jghauser/auto-pandoc.nvim',
      }
      
      
      {
          "jghauser/auto-pandoc.nvim",
          ft = "markdown",
      }
      
      
      vim.api.nvim_create_autocmd("BufEnter", {
        pattern = "*.md",
        callback = function()
          keymap.set("n", "go", function()
            require("auto-pandoc").run_pandoc()
          end, { silent = true, buffer = 0 })
        end,
        group = vim.api.nvim_create_augroup("setAutoPandocKeymap", {}),
        desc = "Set keymap for auto-pandoc",
      })
      
    end,
  },
  {
    "jghauser/follow-md-links.nvim",
    config = function()
      
      use {
        'jghauser/follow-md-links.nvim'
      }
      
      
      vim.keymap.set('n', '<bs>', ':edit #<cr>', { silent = true })
      
    end,
  },
  {
    "jubnzv/mdeval.nvim",
    config = function()
      
      require 'mdeval'.setup()
      
      
      vim.g.markdown_fenced_languages = {'python', 'cpp'}
      
      
      require 'mdeval'.setup({
        -- Don't ask before executing code blocks
        require_confirmation=false,
        -- Change code blocks evaluation options.
        eval_options = {
          -- Set custom configuration for C++
          cpp = {
            command = {"clang++", "-std=c++20", "-O0"},
            default_header = [[
          #include <iostream>
          #include <vector>
          using namespace std;
            ]]
          },
          -- Add new configuration for Racket
          racket = {
            command = {"racket"},        -- Command to run interpreter
            language_code = "racket",    -- Markdown language code
            exec_type = "interpreted",   -- compiled or interpreted
            extension = "rkt",           -- File extension for temporary files
          },
        },
      })
      
      
      vim.api.nvim_set_keymap('n', '<leader>c',
                              "<cmd>lua require 'mdeval'.eval_code_block()<CR>",
                              {silent = true, noremap = true})
      
    end,
  },
  {
    "kdheepak/panvimdoc",
  },
  {
    "frabjous/knap",
    config = function()
      
      require "paq" {
          "savq/paq-nvim";
          "frabjous/knap";
      }
      
      
      -- set shorter name for keymap function
      local kmap = vim.keymap.set
      
      -- F5 processes the document once, and refreshes the view
      kmap({ 'n', 'v', 'i' },'<F5>', function() require("knap").process_once() end)
      
      -- F6 closes the viewer application, and allows settings to be reset
      kmap({ 'n', 'v', 'i' },'<F6>', function() require("knap").close_viewer() end)
      
      -- F7 toggles the auto-processing on and off
      kmap({ 'n', 'v', 'i' },'<F7>', function() require("knap").toggle_autopreviewing() end)
      
      -- F8 invokes a SyncTeX forward search, or similar, where appropriate
      kmap({ 'n', 'v', 'i' },'<F8>', function() require("knap").forward_jump() end)
      
      
      local gknapsettings = {
          texoutputext = "pdf",
          textopdf = "pdflatex -synctex=1 -halt-on-error -interaction=batchmode %docroot%",
          textopdfviewerlaunch = "mupdf %outputfile%",
          textopdfviewerrefresh = "kill -HUP %pid%"
      }
      vim.g.knap_settings = gknapsettings
      
      
      local gknapsettings = {
          ...
          delay = 100,
          ...
      }
      vim.g.knap_settings = gknapsettings
      
      
      {
          htmloutputext = "html",
          htmltohtml = "none",
          htmltohtmlviewerlaunch = "falkon %outputfile%",
          htmltohtmlviewerrefresh = "none",
          mdoutputext = "html",
          mdtohtml = "pandoc --standalone %docroot% -o %outputfile%",
          mdtohtmlviewerlaunch = "falkon %outputfile%",
          mdtohtmlviewerrefresh = "none",
          mdtopdf = "pandoc %docroot% -o %outputfile%",
          mdtopdfviewerlaunch = "sioyek %outputfile%",
          mdtopdfviewerrefresh = "none",
          markdownoutputext = "html",
          markdowntohtml = "pandoc --standalone %docroot% -o %outputfile%",
          markdowntohtmlviewerlaunch = "falkon %outputfile%",
          markdowntohtmlviewerrefresh = "none",
          markdowntopdf = "pandoc %docroot% -o %outputfile%",
          markdowntopdfviewerlaunch = "sioyek %outputfile%",
          markdowntopdfviewerrefresh = "none",
          texoutputext = "pdf",
          textopdf = "pdflatex -interaction=batchmode -halt-on-error -synctex=1 %docroot%",
          textopdfviewerlaunch = "sioyek --inverse-search 'nvim --headless -es --cmd \"lua require('\"'\"'knaphelper'\"'\"').relayjump('\"'\"'%servername%'\"'\"','\"'\"'%1'\"'\"',%2,%3)\"' --new-window %outputfile%",
          textopdfviewerrefresh = "none",
          textopdfforwardjump = "sioyek --inverse-search 'nvim --headless -es --cmd \"lua require('\"'\"'knaphelper'\"'\"').relayjump('\"'\"'%servername%'\"'\"','\"'\"'%1'\"'\"',%2,%3)\"' --reuse-window --forward-search-file %srcfile% --forward-search-line %line% %outputfile%",
          textopdfshorterror = "A=%outputfile% ; LOGFILE=\"${A%.pdf}.log\" ; rubber-info \"$LOGFILE\" 2>&1 | head -n 1",
          delay = 250
      }
      
      
      _G.xelatexcheck = function()
          local isxelatex = false
          local fifteenlines = vim.api.nvim_buf_get_lines(0,0,15,false)
          for l,line in ipairs(fifteenlines) do
              if (line:lower():match("xelatex")) or
                 (line:match("\\usepackage[^}]*mathspec")) or
                 (line:match("\\usepackage[^}]*fontspec")) or
                 (line:match("\\usepackage[^}]*unicode-math")) then
                 isxelatex = true
                 break
             end
          end
          if (isxelatex) then
              local knapsettings = vim.b.knap_settings or {}
              knapsettings["textopdf"] =
                  'xelatex -interaction=batchmode -halt-on-error -synctex=1 %docroot%'
              vim.b.knap_settings = knapsettings
          end
      end
      vim.api.nvim_create_autocmd({'BufRead'}, {pattern = {'*.tex'}, callback = xelatexcheck})
      
      
      local gknapsettings = {
          mdtohtml = "pandoc -f markdown --standalone -o %outputfile%",
          mdtohtmlbufferasstdin = true
      }
      vim.g.knap_settings = gknapsettings
      
    end,
  },
  {
    "jbyuki/carrot.nvim",
    config = function()
      
      local buf = vim.api.nvim_create_buf(false, true)
      local parser = vim.treesitter.get_parser(buf, "markdown")
      assert(parser, "The markdown parser is not installed.")
      print("OK")
      
      
      use "jbyuki/carrot.nvim"
      
    end,
  },
  {
    "AckslD/nvim-FeMaco.lua",
    config = function()
      
      use {
        'AckslD/nvim-FeMaco.lua',
        config = 'require("femaco").setup()',
      }
      
      
      require('femaco').setup({
        -- should prepare a new buffer and return the winid
        -- by default opens a floating window
        -- provide a different callback to change this behaviour
        -- @param opts: the return value from float_opts
        prepare_buffer = function(opts)
          local buf = vim.api.nvim_create_buf(false, false)
          return vim.api.nvim_open_win(buf, true, opts)
        end,
        -- should return options passed to nvim_open_win
        -- @param code_block: data about the code-block with the keys
        --   * range
        --   * lines
        --   * lang
        float_opts = function(code_block)
          return {
            relative = 'cursor',
            width = clip_val(5, 120, vim.api.nvim_win_get_width(0) - 10),  -- TODO how to offset sign column etc?
            height = clip_val(5, #code_block.lines, vim.api.nvim_win_get_height(0) - 6),
            anchor = 'NW',
            row = 0,
            col = 0,
            style = 'minimal',
            border = 'rounded',
            zindex = 1,
          }
        end,
        -- return filetype to use for a given lang
        -- lang can be nil
        ft_from_lang = function(lang)
          return lang
        end,
        -- what to do after opening the float
        post_open_float = function(winnr)
          vim.wo.signcolumn = 'no'
        end
        -- create the path to a temporary file
        create_tmp_filepath = function(filetype)
          return os.tmpname()
        end,
        -- if a newline should always be used, useful for multiline injections
        -- which separators needs to be on separate lines such as markdown, neorg etc
        -- @param base_filetype: The filetype which FeMaco is called from, not the
        -- filetype of the injected language (this is the current buffer so you can
        -- get it from vim.bo.filetyp).
        ensure_newline = function(base_filetype)
          return false
        end,
        -- Return true if the indentation should be normalized. Useful when the
        -- injected language inherits indentation from the construction scope (e.g. an
        -- inline multiline sql string). If true, the leading indentation is detected,
        -- stripped, and restored before/after editing.
        --
        -- @param base_filetype: The filetype which FeMaco is called from, not the
        -- filetype of the injected language (this is the current buffer, so you can
        -- get it from vim.bo.filetype).
        normalize_indent = function (base_filetype)
          return false
        end
      })
      
    end,
  },
  {
    "Nedra1998/nvim-mdlink",
    config = function()
      
      use { 'Nedra1998/nvim-mdlink' }
      
      
      { 'Nedra1998/nvim-mdlink' }
      
      
      require('nvim-mdlink').setup({
        keymap = true,
        cmp = true
      })
      
      
      local has_mdlink, mdlink = pcall(require, "nvim-mdlink.cmp")
      if has_mdlink then
        require('cmp').register_source("mdlink", mdlink.new())
      end
      
      
      require('cmp').setup {
        sources = {
          { name = 'mdlink' }
        }
      }
      
    end,
  },
  {
    "nfrid/markdown-togglecheck",
    config = function()
      
      {
        'nfrid/markdown-togglecheck',
        dependencies = { 'nfrid/treesitter-utils' },
        ft = { 'markdown' },
      }
      
      
      require('markdown-togglecheck').setup({
        -- create empty checkbox on item without any while toggling
        create = true,
        -- remove checked checkbox instead of unckecking it while toggling
        remove = false,
      })
      
      
      -- toggle checked / create checkbox if it doesn't exist
      vim.keymap.set('n', '<leader>nn', require('markdown-togglecheck').toggle, { desc = 'Toggle Checkmark' });
      -- toggle checkbox (it doesn't remember toggle state and always creates [ ])
      vim.keymap.set('n', '<leader>nN', require('markdown-togglecheck').toggle_box, { desc = 'Toggle Checkbox' });
      
      
      local function toggle()
          vim.go.operatorfunc = "v:lua.require'markdown-togglecheck'.toggle"
          return 'g@l'
      end
      
      local function toggle_box()
          vim.go.operatorfunc = "v:lua.require'markdown-togglecheck'.toggle_box"
          return 'g@l'
      end
      
      vim.keymap.set('n', '<leader>nn', toggle, { expr = true, desc = 'Toggle Checkmark' })
      vim.keymap.set('n', '<leader>nN', toggle_box, { expr = true, desc = 'Toggle Checkbox' })
      
    end,
  },
  {
    "toppair/peek.nvim",
    config = function()
      
      {
          "toppair/peek.nvim",
          event = { "VeryLazy" },
          build = "deno task --quiet build:fast",
          config = function()
              require("peek").setup()
              vim.api.nvim_create_user_command("PeekOpen", require("peek").open, {})
              vim.api.nvim_create_user_command("PeekClose", require("peek").close, {})
          end,
      },
      
      
      -- default config:
      require('peek').setup({
        auto_load = true,         -- whether to automatically load preview when
                                  -- entering another markdown buffer
        close_on_bdelete = true,  -- close preview window on buffer delete
      
        syntax = true,            -- enable syntax highlighting, affects performance
      
        theme = 'dark',           -- 'dark' or 'light'
      
        update_on_change = true,
      
        app = 'webview',          -- 'webview', 'browser', string or a table of strings
                                  -- explained below
      
        filetype = { 'markdown' },-- list of filetypes to recognize as markdown
      
        -- relevant if update_on_change is true
        throttle_at = 200000,     -- start throttling when file exceeds this
                                  -- amount of bytes in size
        throttle_time = 'auto',   -- minimum amount of time in milliseconds
                                  -- that has to pass before starting new render
      })
      
      
      vim.api.nvim_create_user_command('PeekOpen', require('peek').open, {})
      vim.api.nvim_create_user_command('PeekClose', require('peek').close, {})
      
      
      local peek = require('peek')
      
      vim.api.nvim_create_user_command('PeekOpen', function()
        if not peek.is_open() and vim.bo[vim.api.nvim_get_current_buf()].filetype == 'markdown' then
          vim.fn.system('i3-msg split horizontal')
          peek.open()
        end
      end, {})
      
      vim.api.nvim_create_user_command('PeekClose', function()
        if peek.is_open() then
          peek.close()
          vim.fn.system('i3-msg move left')
        end
      end, {})
      
    end,
  },
  {
    "yaocccc/nvim-hl-mdcodeblock.lua",
    config = function()
      
          -- packer
          require('packer').startup({
              -- ...
              use {
                  'yaocccc/nvim-hl-mdcodeblock.lua',
                  after = 'nvim-treesitter',
                  config = function ()
                      require('hl-mdcodeblock').setup({
                          -- option
                      })
                  end
              }
          })
      
      
          {
              hl_group = "MDCodeBlock",   -- default highlight group
              events = {                  -- refresh event
                  "FileChangedShellPost",
                  "Syntax",
                  "TextChanged",
                  "TextChangedI",
                  "InsertLeave",
                  "WinScrolled",
                  "BufEnter",
              },
              padding_right = 4,          -- always append 4 space at lineend
              timer_delay = 20,           -- refresh delay(ms)
              query_by_ft = {             -- special parser query by filetype
                  markdown = {            -- filetype
                      'markdown',         -- parser
                      '(fenced_code_block) @codeblock', -- query
                  },
                  rmd = {                 -- filetype
                      'markdown',         -- parser
                      '(fenced_code_block) @codeblock', -- query
                  },
              },
              minumum_len = 100,          -- minimum len to highlight (number | function)
              -- minumum_len = function () return math.max(math.floor(vim.api.nvim_win_get_width(0) * 0.8), 100) end
          }
      
    end,
  },
  {
    "kiran94/edit-markdown-table.nvim",
    config = function()
      
      {
          'kiran94/edit-markdown-table.nvim',
          config = true,
          dependencies = { "nvim-treesitter/nvim-treesitter" },
          cmd = "EditMarkdownTable",
      },
      
      
      :lua require('edit-markdown-table').edit_cell() -- or :EditMarkdownTable
      
      
      require("dressing").setup({
          input = {
              enabled = true,
              start_in_insert = false,
              win_options = {
                  winblend = 0,
                  wrap = true,
              },
          }
      })
      
    end,
  },
  {
    "richardbizik/nvim-toc",
    config = function()
      
      require('nvim-toc').generate_md_toc("list")
      require('nvim-toc').generate_md_toc("numbered")
      
      
      require("nvim-toc").setup({
        toc_header = "Table of Contents"
      })
      
    end,
  },
  {
    "Zeioth/markmap.nvim",
    config = function()
      
      --  [markdown markmap]
      --  https://github.com/Zeioth/markmap.nvim
      {
        "Zeioth/markmap.nvim",
        build = "yarn global add markmap-cli",
        cmd = { "MarkmapOpen", "MarkmapSave", "MarkmapWatch", "MarkmapWatchStop" },
        opts = {
          html_output = "/tmp/markmap.html", -- (default) Setting a empty string "" here means: [Current buffer path].html
          hide_toolbar = false, -- (default)
          grace_period = 3600000 -- (default) Stops markmap watch after 60 minutes. Set it to 0 to disable the grace_period.
        },
        config = function(_, opts) require("markmap").setup(opts) end
      },
      
    end,
  },
  {
    "tadmccorkle/markdown.nvim",
    config = function()
      
        {
          "tadmccorkle/markdown.nvim",
          ft = "markdown", -- or 'event = "VeryLazy"'
          opts = {
            -- configuration here or empty for defaults
          },
        }
        
      
        use({
          "tadmccorkle/markdown.nvim",
          config = function()
            require("markdown").setup({
              -- configuration here or empty for defaults
            })
          end,
        })
        
      
        { "tadmccorkle/markdown.nvim",
          config = function()
            require("markdown").setup({
              -- configuration here or empty for defaults
            })
          end,
        };
        
      
      {
        -- Disable all keymaps by setting mappings field to 'false'.
        -- Selectively disable keymaps by setting corresponding field to 'false'.
        mappings = {
          inline_surround_toggle = "gs", -- (string|boolean) toggle inline style
          inline_surround_toggle_line = "gss", -- (string|boolean) line-wise toggle inline style
          inline_surround_delete = "ds", -- (string|boolean) delete emphasis surrounding cursor
          inline_surround_change = "cs", -- (string|boolean) change emphasis surrounding cursor
          link_add = "gl", -- (string|boolean) add link
          link_follow = "gx", -- (string|boolean) follow link
          go_curr_heading = "]c", -- (string|boolean) set cursor to current section heading
          go_parent_heading = "]p", -- (string|boolean) set cursor to parent section heading
          go_next_heading = "]]", -- (string|boolean) set cursor to next section heading
          go_prev_heading = "[[", -- (string|boolean) set cursor to previous section heading
        },
        inline_surround = {
          -- For the emphasis, strong, strikethrough, and code fields:
          -- * 'key': used to specify an inline style in toggle, delete, and change operations
          -- * 'txt': text inserted when toggling or changing to the corresponding inline style
          emphasis = {
            key = "i",
            txt = "*",
          },
          strong = {
            key = "b",
            txt = "**",
          },
          strikethrough = {
            key = "s",
            txt = "~~",
          },
          code = {
            key = "c",
            txt = "`",
          },
        },
        link = {
          paste = {
            enable = true, -- whether to convert URLs to links on paste
          },
        },
        toc = {
          -- Comment text to flag headings/sections for omission in table of contents.
          omit_heading = "toc omit heading",
          omit_section = "toc omit section",
          -- Cycling list markers to use in table of contents.
          -- Use '.' and ')' for ordered lists.
          markers = { "-" },
        },
        -- Hook functions allow for overriding or extending default behavior.
        -- Called with a table of options and a fallback function with default behavior.
        -- Signature: fun(opts: table, fallback: fun())
        hooks = {
          -- Called when following links. Provided the following options:
          -- * 'dest' (string): the link destination
          -- * 'use_default_app' (boolean|nil): whether to open the destination with default application
          --   (refer to documentation on <Plug> mappings for explanation of when this option is used)
          follow_link = nil,
        },
        on_attach = nil, -- (fun(bufnr: integer)) callback when plugin attaches to a buffer
      }
      
      
      on_attach = function(bufnr)
        local map = vim.keymap.set
        local opts = { buffer = bufnr }
        map({ 'n', 'i' }, '<M-l><M-o>', '<Cmd>MDListItemBelow<CR>', opts)
        map({ 'n', 'i' }, '<M-L><M-O>', '<Cmd>MDListItemAbove<CR>', opts)
        map('n', '<M-c>', '<Cmd>MDTaskToggle<CR>', opts)
        map('x', '<M-c>', ':MDTaskToggle<CR>', opts)
      end,
      
      
      on_attach = function(bufnr)
        local function toggle(key)
          return "<Esc>gv<Cmd>lua require'markdown.inline'"
            .. ".toggle_emphasis_visual'" .. key .. "'<CR>"
        end
      
        vim.keymap.set("x", "<C-b>", toggle("b"), { buffer = bufnr })
        vim.keymap.set("x", "<C-i>", toggle("i"), { buffer = bufnr })
      end,
      
      
        {
          "nvim-treesitter/nvim-treesitter",
          dependencies = { "tadmccorkle/markdown.nvim" },
          config = function()
            require("nvim-treesitter.configs").setup({
              ensure_installed = { "markdown", "markdown_inline", --[[ other parsers you need ]] },
              markdown = {
                enable = true,
                -- configuration here or nothing for defaults
              },
            })
          end,
        }
        
      
        use({
          "nvim-treesitter/nvim-treesitter",
          requires = { { "tadmccorkle/markdown.nvim" } },
          config = function()
            require("nvim-treesitter.configs").setup({
              ensure_installed = { "markdown", "markdown_inline", --[[ other parsers you need ]] },
              markdown = {
                enable = true,
                -- configuration here or nothing for defaults
              },
            })
          end,
        })
        
      
        { "nvim-treesitter/nvim-treesitter",
          requires = { "tadmccorkle/markdown.nvim" },
          config = function()
            require("nvim-treesitter.configs").setup({
              ensure_installed = { "markdown", "markdown_inline", --[[ other parsers you need ]] },
              markdown = {
                enable = true,
                -- configuration here or nothing for defaults
              },
            })
          end,
        };
        
      
      local configs = require("nvim-treesitter.configs")
      
      configs.setup({
        ensure_installed = { "markdown", "markdown_inline", --[[ other parsers you need ]] },
        markdown = {
          enable = true, -- must be specified to enable markdown.nvim as a module
          -- configuration here or nothing for defaults
        },
      })
      
    end,
  },
  {
    "mpas/marp-nvim",
    config = function()
      
        use({
          "mpas/marp-nvim",
        }),
      
      
        {
          "mpas/marp-nvim",
        },
      
      
        {
          "mpas/marp-nvim",
          config = function()
            require("marp").setup({
              port = 8080,
              wait_for_response_timeout = 30,
              wait_for_response_delay = 1,
            })
          end,
        },
      
      
      {
        port = 8080, -- the port on which the Marp server should listen
        wait_for_response_timeout = 30, -- how long to wait for a response from the server before giving up
        wait_for_response_delay = 1, -- how long to wait between attempts to connect to the server
      }
      
      
      vim.keymap.set("n", "<leader>MT", "<cmd>MarpToggle<cr>", { noremap = true, silent = true })
      vim.keymap.set("n", "<leader>MS", "<cmd>MarpStatus<cr>", { noremap = true, silent = true })
      ...
      
    end,
  },
  {
    "Myzel394/easytables.nvim",
    config = function()
      
      use "Myzel394/easytables.nvim"
      
      
      require("easytables").setup {
        -- Your configuration comes here
      }
      
      
      {
          table = {
              -- Whether to enable the header by default
              header_enabled_by_default = true,
              window = {
                  preview_title = "Table Preview",
                  prompt_title = "Cell content",
                  -- Either "auto" to automatically size the window, or a string
                  -- in the format of "<width>x<height>" (e.g. "20x10")
                  size = "auto"
              },
              cell = {
                  -- Min width of a cell (excluding padding)
                  min_width = 3,
                  -- Filler character for empty cells
                  filler = " ",
                  align = "left",
              },
              -- Characters used to draw the table
              -- Do not worry about multibyte characters, they are handled correctly
              border = {
                  top_left = "┌",
                  top_right = "┐",
                  bottom_left = "└",
                  bottom_right = "┘",
                  horizontal = "─",
                  vertical = "│",
                  left_t = "├",
                  right_t = "┤",
                  top_t = "┬",
                  bottom_t = "┴",
                  cross = "┼",
                  header_left_t = "╞",
                  header_right_t = "╡",
                  header_bottom_t = "╧",
                  header_cross = "╪",
                  header_horizontal = "═",
              }
          },
          export = {
              markdown = {
                  -- Padding around the cell content, applied BOTH left AND right
                  -- E.g: padding = 1, content = "foo" -> " foo "
                  padding = 1,
                  -- What markdown characters are used for the export, you probably
                  -- don't want to change these
                  characters = {
                      horizontal = "-",
                      vertical = "|",
                      -- Filler for padding
                      filler = " "
                  }
              }
          },
          set_mappings = function(buf)
              vim.api.nvim_buf_set_keymap(
                  buf,
                  "n",
                  "<Left>",
                  ":JumpLeft<CR>",
                  {}
              )
              vim.api.nvim_buf_set_keymap(
                  buf,
                  "n",
                  "<S-Left>",
                  ":SwapWithLeftCell<CR>",
                  {}
              )
      
              vim.api.nvim_buf_set_keymap(
                  buf,
                  "n",
                  "<Right>",
                  ":JumpRight<CR>",
                  {}
              )
              vim.api.nvim_buf_set_keymap(
                  buf,
                  "n",
                  "<S-Right>",
                  ":SwapWithRightCell<CR>",
                  {}
              )
      
              vim.api.nvim_buf_set_keymap(
                  buf,
                  "n",
                  "<Up>",
                  ":JumpUp<CR>",
                  {}
              )
              vim.api.nvim_buf_set_keymap(
                  buf,
                  "n",
                  "<S-Up>",
                  ":SwapWithUpperCell<CR>",
                  {}
              )
      
              vim.api.nvim_buf_set_keymap(
                  buf,
                  "n",
                  "<Down>",
                  ":JumpDown<CR>",
                  {}
              )
              vim.api.nvim_buf_set_keymap(
                  buf,
                  "n",
                  "<S-Down>",
                  ":SwapWithLowerCell<CR>",
                  {}
              )
      
              vim.api.nvim_buf_set_keymap(
                  buf,
                  "n",
                  "<Tab>",
                  ":JumpToNextCell<CR>",
                  {}
              )
              vim.api.nvim_buf_set_keymap(
                  buf,
                  "n",
                  "<S-Tab>",
                  ":JumpToPreviousCell<CR>",
                  {}
              )
      
              vim.api.nvim_buf_set_keymap(
                  buf,
                  "n",
                  "<C-Left>",
                  ":SwapWithLeftColumn<CR>",
                  {}
              )
              vim.api.nvim_buf_set_keymap(
                  buf,
                  "n",
                  "<C-Right>",
                  ":SwapWithRightColumn<CR>",
                  {}
              )
              vim.api.nvim_buf_set_keymap(
                  buf,
                  "n",
                  "<C-Up>",
                  ":SwapWithUpperRow<CR>",
                  {}
              )
              vim.api.nvim_buf_set_keymap(
                  buf,
                  "n",
                  "<C-Down>",
                  ":SwapWithLowerRow<CR>",
                  {}
              )
          end
      
      }
      
    end,
  },
  {
    "MeanderingProgrammer/render-markdown.nvim",
    config = function()
      
      {
          'MeanderingProgrammer/render-markdown.nvim',
          dependencies = { 'nvim-treesitter/nvim-treesitter', 'nvim-mini/mini.nvim' }, -- if you use the mini.nvim suite
          -- dependencies = { 'nvim-treesitter/nvim-treesitter', 'nvim-mini/mini.icons' }, -- if you use standalone mini plugins
          -- dependencies = { 'nvim-treesitter/nvim-treesitter', 'nvim-tree/nvim-web-devicons' }, -- if you prefer nvim-web-devicons
          ---@module 'render-markdown'
          ---@type render.md.UserConfig
          opts = {},
      }
      
      
      use({
          'MeanderingProgrammer/render-markdown.nvim',
          after = { 'nvim-treesitter' },
          requires = { 'nvim-mini/mini.nvim', opt = true }, -- if you use the mini.nvim suite
          -- requires = { 'nvim-mini/mini.icons', opt = true }, -- if you use standalone mini plugins
          -- requires = { 'nvim-tree/nvim-web-devicons', opt = true }, -- if you prefer nvim-web-devicons
          config = function()
              require('render-markdown').setup({})
          end,
      })
      
      
      require('render-markdown').setup({
          completions = { lsp = { enabled = true } },
      })
      
      
      require('render-markdown').setup({
          completions = { coq = { enabled = true } },
      })
      
      
      require('render-markdown').setup({
          -- Whether markdown should be rendered by default.
          enabled = true,
          -- Vim modes that will show a rendered view of the markdown file, :h mode(), for all enabled
          -- components. Individual components can be enabled for other modes. Remaining modes will be
          -- unaffected by this plugin.
          render_modes = { 'n', 'c', 't' },
          -- Maximum file size (in MB) that this plugin will attempt to render.
          -- File larger than this will effectively be ignored.
          max_file_size = 10.0,
          -- Milliseconds that must pass before updating marks, updates occur.
          -- within the context of the visible window, not the entire buffer.
          debounce = 100,
          -- Pre configured settings that will attempt to mimic various target user experiences.
          -- User provided settings will take precedence.
          -- | obsidian | mimic Obsidian UI                                          |
          -- | lazy     | will attempt to stay up to date with LazyVim configuration |
          -- | none     | does nothing                                               |
          preset = 'none',
          -- The level of logs to write to file: vim.fn.stdpath('state') .. '/render-markdown.log'.
          -- Only intended to be used for plugin development / debugging.
          log_level = 'error',
          -- Print runtime of main update method.
          -- Only intended to be used for plugin development / debugging.
          log_runtime = false,
          -- Filetypes this plugin will run on.
          file_types = { 'markdown' },
          -- Takes buffer as input, if it returns true this plugin will not attach to the buffer.
          ignore = function()
              return false
          end,
          -- Whether markdown should be rendered when nested inside markdown, i.e. markdown code block
          -- inside markdown file.
          nested = true,
          -- Additional events that will trigger this plugin's render loop.
          change_events = {},
          -- Whether the treesitter highlighter should be restarted after this plugin attaches to its
          -- first buffer for the first time. May be necessary if this plugin is lazy loaded to clear
          -- highlights that have been dynamically disabled.
          restart_highlighter = false,
          injections = {
              -- Out of the box language injections for known filetypes that allow markdown to be interpreted
              -- in specified locations, see :h treesitter-language-injections.
              -- Set enabled to false in order to disable.
      
              gitcommit = {
                  enabled = true,
                  query = [[
                      ((message) @injection.content
                          (#set! injection.combined)
                          (#set! injection.include-children)
                          (#set! injection.language "markdown"))
                  ]],
              },
          },
          patterns = {
              -- Highlight patterns to disable for filetypes, i.e. lines concealed around code blocks
      
              markdown = {
                  disable = true,
                  directives = {
                      { id = 17, name = 'conceal_lines' },
                      { id = 18, name = 'conceal_lines' },
                  },
              },
          },
          anti_conceal = {
              -- This enables hiding added text on the line the cursor is on.
              enabled = true,
              -- Modes to disable anti conceal feature.
              disabled_modes = false,
              -- Number of lines above cursor to show.
              above = 0,
              -- Number of lines below cursor to show.
              below = 0,
              -- Which elements to always show, ignoring anti conceal behavior. Values can either be
              -- booleans to fix the behavior or string lists representing modes where anti conceal
              -- behavior will be ignored. Valid values are:
              --   bullet
              --   callout
              --   check_icon, check_scope
              --   code_background, code_border, code_language
              --   dash
              --   head_background, head_border, head_icon
              --   indent
              --   link
              --   quote
              --   sign
              --   table_border
              --   virtual_lines
              ignore = {
                  code_background = true,
                  indent = true,
                  sign = true,
                  virtual_lines = true,
              },
          },
          padding = {
              -- Highlight to use when adding whitespace, should match background.
              highlight = 'Normal',
          },
          latex = {
              -- Turn on / off latex rendering.
              enabled = true,
              -- Additional modes to render latex.
              render_modes = false,
              -- Executable used to convert latex formula to rendered unicode.
              -- If a list is provided the first command available on the system is used.
              converter = { 'utftex', 'latex2text' },
              -- Highlight for latex blocks.
              highlight = 'RenderMarkdownMath',
              -- Determines where latex formula is rendered relative to block.
              -- | above  | above latex block                               |
              -- | below  | below latex block                               |
              -- | center | centered with latex block (must be single line) |
              position = 'center',
              -- Number of empty lines above latex blocks.
              top_pad = 0,
              -- Number of empty lines below latex blocks.
              bottom_pad = 0,
          },
          on = {
              -- Called when plugin initially attaches to a buffer.
              attach = function() end,
              -- Called before adding marks to the buffer for the first time.
              initial = function() end,
              -- Called after plugin renders a buffer.
              render = function() end,
              -- Called after plugin clears a buffer.
              clear = function() end,
          },
          completions = {
              -- Settings for blink.cmp completions source
              blink = { enabled = false },
              -- Settings for coq_nvim completions source
              coq = { enabled = false },
              -- Settings for in-process language server completions
              lsp = { enabled = false },
              filter = {
                  callout = function()
                      -- example to exclude obsidian callouts
                      -- return value.category ~= 'obsidian'
                      return true
                  end,
                  checkbox = function()
                      return true
                  end,
              },
          },
          heading = {
              -- Useful context to have when evaluating values.
              -- | level    | the number of '#' in the heading marker         |
              -- | sections | for each level how deeply nested the heading is |
      
              -- Turn on / off heading icon & background rendering.
              enabled = true,
              -- Additional modes to render headings.
              render_modes = false,
              -- Turn on / off atx heading rendering.
              atx = true,
              -- Turn on / off setext heading rendering.
              setext = true,
              -- Turn on / off sign column related rendering.
              sign = true,
              -- Replaces '#+' of 'atx_h._marker'.
              -- Output is evaluated depending on the type.
              -- | function | `value(context)`              |
              -- | string[] | `cycle(value, context.level)` |
              icons = { '󰲡 ', '󰲣 ', '󰲥 ', '󰲧 ', '󰲩 ', '󰲫 ' },
              -- Determines how icons fill the available space.
              -- | right   | '#'s are concealed and icon is appended to right side                      |
              -- | inline  | '#'s are concealed and icon is inlined on left side                        |
              -- | overlay | icon is left padded with spaces and inserted on left hiding additional '#' |
              position = 'overlay',
              -- Added to the sign column if enabled.
              -- Output is evaluated by `cycle(value, context.level)`.
              signs = { '󰫎 ' },
              -- Width of the heading background.
              -- | block | width of the heading text |
              -- | full  | full width of the window  |
              -- Can also be a list of the above values evaluated by `clamp(value, context.level)`.
              width = 'full',
              -- Amount of margin to add to the left of headings.
              -- Margin available space is computed after accounting for padding.
              -- If a float < 1 is provided it is treated as a percentage of available window space.
              -- Can also be a list of numbers evaluated by `clamp(value, context.level)`.
              left_margin = 0,
              -- Amount of padding to add to the left of headings.
              -- Output is evaluated using the same logic as 'left_margin'.
              left_pad = 0,
              -- Amount of padding to add to the right of headings when width is 'block'.
              -- Output is evaluated using the same logic as 'left_margin'.
              right_pad = 0,
              -- Minimum width to use for headings when width is 'block'.
              -- Can also be a list of integers evaluated by `clamp(value, context.level)`.
              min_width = 0,
              -- Determines if a border is added above and below headings.
              -- Can also be a list of booleans evaluated by `clamp(value, context.level)`.
              border = false,
              -- Always use virtual lines for heading borders instead of attempting to use empty lines.
              border_virtual = false,
              -- Highlight the start of the border using the foreground highlight.
              border_prefix = false,
              -- Used above heading for border.
              above = '▄',
              -- Used below heading for border.
              below = '▀',
              -- Highlight for the heading icon and extends through the entire line.
              -- Output is evaluated by `clamp(value, context.level)`.
              backgrounds = {
                  'RenderMarkdownH1Bg',
                  'RenderMarkdownH2Bg',
                  'RenderMarkdownH3Bg',
                  'RenderMarkdownH4Bg',
                  'RenderMarkdownH5Bg',
                  'RenderMarkdownH6Bg',
              },
              -- Highlight for the heading and sign icons.
              -- Output is evaluated using the same logic as 'backgrounds'.
              foregrounds = {
                  'RenderMarkdownH1',
                  'RenderMarkdownH2',
                  'RenderMarkdownH3',
                  'RenderMarkdownH4',
                  'RenderMarkdownH5',
                  'RenderMarkdownH6',
              },
              -- Define custom heading patterns which allow you to override various properties based on
              -- the contents of a heading.
              -- The key is for healthcheck and to allow users to change its values, value type below.
              -- | pattern    | matched against the heading text @see :h lua-patterns |
              -- | icon       | optional override for the icon                        |
              -- | background | optional override for the background                  |
              -- | foreground | optional override for the foreground                  |
              custom = {},
          },
          paragraph = {
              -- Useful context to have when evaluating values.
              -- | text | text value of the node |
      
              -- Turn on / off paragraph rendering.
              enabled = true,
              -- Additional modes to render paragraphs.
              render_modes = false,
              -- Amount of margin to add to the left of paragraphs.
              -- If a float < 1 is provided it is treated as a percentage of available window space.
              -- Output is evaluated depending on the type.
              -- | function | `value(context)` |
              -- | number   | `value`          |
              left_margin = 0,
              -- Amount of padding to add to the first line of each paragraph.
              -- Output is evaluated using the same logic as 'left_margin'.
              indent = 0,
              -- Minimum width to use for paragraphs.
              min_width = 0,
          },
          code = {
              -- Turn on / off code block & inline code rendering.
              enabled = true,
              -- Additional modes to render code blocks.
              render_modes = false,
              -- Turn on / off sign column related rendering.
              sign = true,
              -- Whether to conceal nodes at the top and bottom of code blocks.
              conceal_delimiters = true,
              -- Turn on / off language heading related rendering.
              language = true,
              -- Determines where language icon is rendered.
              -- | right | right side of code block |
              -- | left  | left side of code block  |
              position = 'left',
              -- Whether to include the language icon above code blocks.
              language_icon = true,
              -- Whether to include the language name above code blocks.
              language_name = true,
              -- Whether to include the language info above code blocks.
              language_info = true,
              -- Amount of padding to add around the language.
              -- If a float < 1 is provided it is treated as a percentage of available window space.
              language_pad = 0,
              -- A list of language names for which background highlighting will be disabled.
              -- Likely because that language has background highlights itself.
              -- Use a boolean to make behavior apply to all languages.
              -- Borders above & below blocks will continue to be rendered.
              disable_background = { 'diff' },
              -- Width of the code block background.
              -- | block | width of the code block  |
              -- | full  | full width of the window |
              width = 'full',
              -- Amount of margin to add to the left of code blocks.
              -- If a float < 1 is provided it is treated as a percentage of available window space.
              -- Margin available space is computed after accounting for padding.
              left_margin = 0,
              -- Amount of padding to add to the left of code blocks.
              -- If a float < 1 is provided it is treated as a percentage of available window space.
              left_pad = 0,
              -- Amount of padding to add to the right of code blocks when width is 'block'.
              -- If a float < 1 is provided it is treated as a percentage of available window space.
              right_pad = 0,
              -- Minimum width to use for code blocks when width is 'block'.
              min_width = 0,
              -- Determines how the top / bottom of code block are rendered.
              -- | none  | do not render a border                               |
              -- | thick | use the same highlight as the code body              |
              -- | thin  | when lines are empty overlay the above & below icons |
              -- | hide  | conceal lines unless language name or icon is added  |
              border = 'hide',
              -- Used above code blocks to fill remaining space around language.
              language_border = '█',
              -- Added to the left of language.
              language_left = '',
              -- Added to the right of language.
              language_right = '',
              -- Used above code blocks for thin border.
              above = '▄',
              -- Used below code blocks for thin border.
              below = '▀',
              -- Turn on / off inline code related rendering.
              inline = true,
              -- Icon to add to the left of inline code.
              inline_left = '',
              -- Icon to add to the right of inline code.
              inline_right = '',
              -- Padding to add to the left & right of inline code.
              inline_pad = 0,
              -- Highlight for code blocks.
              highlight = 'RenderMarkdownCode',
              -- Highlight for code info section, after the language.
              highlight_info = 'RenderMarkdownCodeInfo',
              -- Highlight for language, overrides icon provider value.
              highlight_language = nil,
              -- Highlight for border, use false to add no highlight.
              highlight_border = 'RenderMarkdownCodeBorder',
              -- Highlight for language, used if icon provider does not have a value.
              highlight_fallback = 'RenderMarkdownCodeFallback',
              -- Highlight for inline code.
              highlight_inline = 'RenderMarkdownCodeInline',
              -- Determines how code blocks & inline code are rendered.
              -- | none     | { enabled = false }                           |
              -- | normal   | { language = false }                          |
              -- | language | { disable_background = true, inline = false } |
              -- | full     | uses all default values                       |
              style = 'full',
          },
          dash = {
              -- Turn on / off thematic break rendering.
              enabled = true,
              -- Additional modes to render dash.
              render_modes = false,
              -- Replaces '---'|'***'|'___'|'* * *' of 'thematic_break'.
              -- The icon gets repeated across the window's width.
              icon = '─',
              -- Width of the generated line.
              -- | <number> | a hard coded width value |
              -- | full     | full width of the window |
              -- If a float < 1 is provided it is treated as a percentage of available window space.
              width = 'full',
              -- Amount of margin to add to the left of dash.
              -- If a float < 1 is provided it is treated as a percentage of available window space.
              left_margin = 0,
              -- Highlight for the whole line generated from the icon.
              highlight = 'RenderMarkdownDash',
          },
          document = {
              -- Turn on / off document rendering.
              enabled = true,
              -- Additional modes to render document.
              render_modes = false,
              -- Ability to conceal arbitrary ranges of text based on lua patterns, @see :h lua-patterns.
              -- Relies entirely on user to set patterns that handle their edge cases.
              conceal = {
                  -- Matched ranges will be concealed using character level conceal.
                  char_patterns = {},
                  -- Matched ranges will be concealed using line level conceal.
                  line_patterns = {},
              },
          },
          bullet = {
              -- Useful context to have when evaluating values.
              -- | level | how deeply nested the list is, 1-indexed          |
              -- | index | how far down the item is at that level, 1-indexed |
              -- | value | text value of the marker node                     |
      
              -- Turn on / off list bullet rendering
              enabled = true,
              -- Additional modes to render list bullets
              render_modes = false,
              -- Replaces '-'|'+'|'*' of 'list_item'.
              -- If the item is a 'checkbox' a conceal is used to hide the bullet instead.
              -- Output is evaluated depending on the type.
              -- | function   | `value(context)`                                    |
              -- | string     | `value`                                             |
              -- | string[]   | `cycle(value, context.level)`                       |
              -- | string[][] | `clamp(cycle(value, context.level), context.index)` |
              icons = { '●', '○', '◆', '◇' },
              -- Replaces 'n.'|'n)' of 'list_item'.
              -- Output is evaluated using the same logic as 'icons'.
              ordered_icons = function(ctx)
                  local value = vim.trim(ctx.value)
                  local index = tonumber(value:sub(1, #value - 1))
                  return ('%d.'):format(index > 1 and index or ctx.index)
              end,
              -- Padding to add to the left of bullet point.
              -- Output is evaluated depending on the type.
              -- | function | `value(context)` |
              -- | integer  | `value`          |
              left_pad = 0,
              -- Padding to add to the right of bullet point.
              -- Output is evaluated using the same logic as 'left_pad'.
              right_pad = 0,
              -- Highlight for the bullet icon.
              -- Output is evaluated using the same logic as 'icons'.
              highlight = 'RenderMarkdownBullet',
              -- Highlight for item associated with the bullet point.
              -- Output is evaluated using the same logic as 'icons'.
              scope_highlight = {},
          },
          checkbox = {
              -- Checkboxes are a special instance of a 'list_item' that start with a 'shortcut_link'.
              -- There are two special states for unchecked & checked defined in the markdown grammar.
      
              -- Turn on / off checkbox state rendering.
              enabled = true,
              -- Additional modes to render checkboxes.
              render_modes = false,
              -- Render the bullet point before the checkbox.
              bullet = false,
              -- Padding to add to the right of checkboxes.
              right_pad = 1,
              unchecked = {
                  -- Replaces '[ ]' of 'task_list_marker_unchecked'.
                  icon = '󰄱 ',
                  -- Highlight for the unchecked icon.
                  highlight = 'RenderMarkdownUnchecked',
                  -- Highlight for item associated with unchecked checkbox.
                  scope_highlight = nil,
              },
              checked = {
                  -- Replaces '[x]' of 'task_list_marker_checked'.
                  icon = '󰱒 ',
                  -- Highlight for the checked icon.
                  highlight = 'RenderMarkdownChecked',
                  -- Highlight for item associated with checked checkbox.
                  scope_highlight = nil,
              },
              -- Define custom checkbox states, more involved, not part of the markdown grammar.
              -- As a result this requires neovim >= 0.10.0 since it relies on 'inline' extmarks.
              -- The key is for healthcheck and to allow users to change its values, value type below.
              -- | raw             | matched against the raw text of a 'shortcut_link'           |
              -- | rendered        | replaces the 'raw' value when rendering                     |
              -- | highlight       | highlight for the 'rendered' icon                           |
              -- | scope_highlight | optional highlight for item associated with custom checkbox |
              -- stylua: ignore
              custom = {
                  todo = { raw = '[-]', rendered = '󰥔 ', highlight = 'RenderMarkdownTodo', scope_highlight = nil },
              },
          },
          quote = {
              -- Turn on / off block quote & callout rendering.
              enabled = true,
              -- Additional modes to render quotes.
              render_modes = false,
              -- Replaces '>' of 'block_quote'.
              icon = '▋',
              -- Whether to repeat icon on wrapped lines. Requires neovim >= 0.10. This will obscure text
              -- if incorrectly configured with :h 'showbreak', :h 'breakindent' and :h 'breakindentopt'.
              -- A combination of these that is likely to work follows.
              -- | showbreak      | '  ' (2 spaces)   |
              -- | breakindent    | true              |
              -- | breakindentopt | '' (empty string) |
              -- These are not validated by this plugin. If you want to avoid adding these to your main
              -- configuration then set them in win_options for this plugin.
              repeat_linebreak = false,
              -- Highlight for the quote icon.
              -- If a list is provided output is evaluated by `cycle(value, level)`.
              highlight = {
                  'RenderMarkdownQuote1',
                  'RenderMarkdownQuote2',
                  'RenderMarkdownQuote3',
                  'RenderMarkdownQuote4',
                  'RenderMarkdownQuote5',
                  'RenderMarkdownQuote6',
              },
          },
          pipe_table = {
              -- Turn on / off pipe table rendering.
              enabled = true,
              -- Additional modes to render pipe tables.
              render_modes = false,
              -- Pre configured settings largely for setting table border easier.
              -- | heavy  | use thicker border characters     |
              -- | double | use double line border characters |
              -- | round  | use round border corners          |
              -- | none   | does nothing                      |
              preset = 'none',
              -- Determines how individual cells of a table are rendered.
              -- | overlay | writes completely over the table, removing conceal behavior and highlights |
              -- | raw     | replaces only the '|' characters in each row, leaving the cells unmodified |
              -- | padded  | raw + cells are padded to maximum visual width for each column             |
              -- | trimmed | padded except empty space is subtracted from visual width calculation      |
              cell = 'padded',
              -- Adjust the computed width of table cells using custom logic.
              cell_offset = function()
                  return 0
              end,
              -- Amount of space to put between cell contents and border.
              padding = 1,
              -- Minimum column width to use for padded or trimmed cell.
              min_width = 0,
              -- Characters used to replace table border.
              -- Correspond to top(3), delimiter(3), bottom(3), vertical, & horizontal.
              -- stylua: ignore
              border = {
                  '┌', '┬', '┐',
                  '├', '┼', '┤',
                  '└', '┴', '┘',
                  '│', '─',
              },
              -- Turn on / off top & bottom lines.
              border_enabled = true,
              -- Always use virtual lines for table borders instead of attempting to use empty lines.
              -- Will be automatically enabled if indentation module is enabled.
              border_virtual = false,
              -- Gets placed in delimiter row for each column, position is based on alignment.
              alignment_indicator = '━',
              -- Highlight for table heading, delimiter, and the line above.
              head = 'RenderMarkdownTableHead',
              -- Highlight for everything else, main table rows and the line below.
              row = 'RenderMarkdownTableRow',
              -- Highlight for inline padding used to add back concealed space.
              filler = 'RenderMarkdownTableFill',
              -- Determines how the table as a whole is rendered.
              -- | none   | { enabled = false }        |
              -- | normal | { border_enabled = false } |
              -- | full   | uses all default values    |
              style = 'full',
          },
          callout = {
              -- Callouts are a special instance of a 'block_quote' that start with a 'shortcut_link'.
              -- The key is for healthcheck and to allow users to change its values, value type below.
              -- | raw        | matched against the raw text of a 'shortcut_link', case insensitive |
              -- | rendered   | replaces the 'raw' value when rendering                             |
              -- | highlight  | highlight for the 'rendered' text and quote markers                 |
              -- | quote_icon | optional override for quote.icon value for individual callout       |
              -- | category   | optional metadata useful for filtering                              |
      
              note      = { raw = '[!NOTE]',      rendered = '󰋽 Note',      highlight = 'RenderMarkdownInfo',    category = 'github'   },
              tip       = { raw = '[!TIP]',       rendered = '󰌶 Tip',       highlight = 'RenderMarkdownSuccess', category = 'github'   },
              important = { raw = '[!IMPORTANT]', rendered = '󰅾 Important', highlight = 'RenderMarkdownHint',    category = 'github'   },
              warning   = { raw = '[!WARNING]',   rendered = '󰀪 Warning',   highlight = 'RenderMarkdownWarn',    category = 'github'   },
              caution   = { raw = '[!CAUTION]',   rendered = '󰳦 Caution',   highlight = 'RenderMarkdownError',   category = 'github'   },
              -- Obsidian: https://help.obsidian.md/Editing+and+formatting/Callouts
              abstract  = { raw = '[!ABSTRACT]',  rendered = '󰨸 Abstract',  highlight = 'RenderMarkdownInfo',    category = 'obsidian' },
              summary   = { raw = '[!SUMMARY]',   rendered = '󰨸 Summary',   highlight = 'RenderMarkdownInfo',    category = 'obsidian' },
              tldr      = { raw = '[!TLDR]',      rendered = '󰨸 Tldr',      highlight = 'RenderMarkdownInfo',    category = 'obsidian' },
              info      = { raw = '[!INFO]',      rendered = '󰋽 Info',      highlight = 'RenderMarkdownInfo',    category = 'obsidian' },
              todo      = { raw = '[!TODO]',      rendered = '󰗡 Todo',      highlight = 'RenderMarkdownInfo',    category = 'obsidian' },
              hint      = { raw = '[!HINT]',      rendered = '󰌶 Hint',      highlight = 'RenderMarkdownSuccess', category = 'obsidian' },
              success   = { raw = '[!SUCCESS]',   rendered = '󰄬 Success',   highlight = 'RenderMarkdownSuccess', category = 'obsidian' },
              check     = { raw = '[!CHECK]',     rendered = '󰄬 Check',     highlight = 'RenderMarkdownSuccess', category = 'obsidian' },
              done      = { raw = '[!DONE]',      rendered = '󰄬 Done',      highlight = 'RenderMarkdownSuccess', category = 'obsidian' },
              question  = { raw = '[!QUESTION]',  rendered = '󰘥 Question',  highlight = 'RenderMarkdownWarn',    category = 'obsidian' },
              help      = { raw = '[!HELP]',      rendered = '󰘥 Help',      highlight = 'RenderMarkdownWarn',    category = 'obsidian' },
              faq       = { raw = '[!FAQ]',       rendered = '󰘥 Faq',       highlight = 'RenderMarkdownWarn',    category = 'obsidian' },
              attention = { raw = '[!ATTENTION]', rendered = '󰀪 Attention', highlight = 'RenderMarkdownWarn',    category = 'obsidian' },
              failure   = { raw = '[!FAILURE]',   rendered = '󰅖 Failure',   highlight = 'RenderMarkdownError',   category = 'obsidian' },
              fail      = { raw = '[!FAIL]',      rendered = '󰅖 Fail',      highlight = 'RenderMarkdownError',   category = 'obsidian' },
              missing   = { raw = '[!MISSING]',   rendered = '󰅖 Missing',   highlight = 'RenderMarkdownError',   category = 'obsidian' },
              danger    = { raw = '[!DANGER]',    rendered = '󱐌 Danger',    highlight = 'RenderMarkdownError',   category = 'obsidian' },
              error     = { raw = '[!ERROR]',     rendered = '󱐌 Error',     highlight = 'RenderMarkdownError',   category = 'obsidian' },
              bug       = { raw = '[!BUG]',       rendered = '󰨰 Bug',       highlight = 'RenderMarkdownError',   category = 'obsidian' },
              example   = { raw = '[!EXAMPLE]',   rendered = '󰉹 Example',   highlight = 'RenderMarkdownHint' ,   category = 'obsidian' },
              quote     = { raw = '[!QUOTE]',     rendered = '󱆨 Quote',     highlight = 'RenderMarkdownQuote',   category = 'obsidian' },
              cite      = { raw = '[!CITE]',      rendered = '󱆨 Cite',      highlight = 'RenderMarkdownQuote',   category = 'obsidian' },
          },
          link = {
              -- Turn on / off inline link icon rendering.
              enabled = true,
              -- Additional modes to render links.
              render_modes = false,
              -- How to handle footnote links, start with a '^'.
              footnote = {
                  -- Turn on / off footnote rendering.
                  enabled = true,
                  -- Replace value with superscript equivalent.
                  superscript = true,
                  -- Added before link content.
                  prefix = '',
                  -- Added after link content.
                  suffix = '',
              },
              -- Inlined with 'image' elements.
              image = '󰥶 ',
              -- Inlined with 'email_autolink' elements.
              email = '󰀓 ',
              -- Fallback icon for 'inline_link' and 'uri_autolink' elements.
              hyperlink = '󰌹 ',
              -- Applies to the inlined icon as a fallback.
              highlight = 'RenderMarkdownLink',
              -- Applies to WikiLink elements.
              wiki = {
                  icon = '󱗖 ',
                  body = function()
                      return nil
                  end,
                  highlight = 'RenderMarkdownWikiLink',
                  scope_highlight = nil,
              },
              -- Define custom destination patterns so icons can quickly inform you of what a link
              -- contains. Applies to 'inline_link', 'uri_autolink', and wikilink nodes. When multiple
              -- patterns match a link the one with the longer pattern is used.
              -- The key is for healthcheck and to allow users to change its values, value type below.
              -- | pattern   | matched against the destination text                            |
              -- | icon      | gets inlined before the link text                               |
              -- | kind      | optional determines how pattern is checked                      |
              -- |           | pattern | @see :h lua-patterns, is the default if not set       |
              -- |           | suffix  | @see :h vim.endswith()                                |
              -- | priority  | optional used when multiple match, uses pattern length if empty |
              -- | highlight | optional highlight for 'icon', uses fallback highlight if empty |
              custom = {
                  web = { pattern = '^http', icon = '󰖟 ' },
                  discord = { pattern = 'discord%.com', icon = '󰙯 ' },
                  github = { pattern = 'github%.com', icon = '󰊤 ' },
                  gitlab = { pattern = 'gitlab%.com', icon = '󰮠 ' },
                  google = { pattern = 'google%.com', icon = '󰊭 ' },
                  neovim = { pattern = 'neovim%.io', icon = ' ' },
                  reddit = { pattern = 'reddit%.com', icon = '󰑍 ' },
                  stackoverflow = { pattern = 'stackoverflow%.com', icon = '󰓌 ' },
                  wikipedia = { pattern = 'wikipedia%.org', icon = '󰖬 ' },
                  youtube = { pattern = 'youtube%.com', icon = '󰗃 ' },
              },
          },
          sign = {
              -- Turn on / off sign rendering.
              enabled = true,
              -- Applies to background of sign text.
              highlight = 'RenderMarkdownSign',
          },
          inline_highlight = {
              -- Mimics Obsidian inline highlights when content is surrounded by double equals.
              -- The equals on both ends are concealed and the inner content is highlighted.
      
              -- Turn on / off inline highlight rendering.
              enabled = true,
              -- Additional modes to render inline highlights.
              render_modes = false,
              -- Applies to background of surrounded text.
              highlight = 'RenderMarkdownInlineHighlight',
          },
          indent = {
              -- Mimic org-indent-mode behavior by indenting everything under a heading based on the
              -- level of the heading. Indenting starts from level 2 headings onward by default.
      
              -- Turn on / off org-indent-mode.
              enabled = false,
              -- Additional modes to render indents.
              render_modes = false,
              -- Amount of additional padding added for each heading level.
              per_level = 2,
              -- Heading levels <= this value will not be indented.
              -- Use 0 to begin indenting from the very first level.
              skip_level = 1,
              -- Do not indent heading titles, only the body.
              skip_heading = false,
              -- Prefix added when indenting, one per level.
              icon = '▎',
              -- Priority to assign to extmarks.
              priority = 0,
              -- Applied to icon.
              highlight = 'RenderMarkdownIndent',
          },
          html = {
              -- Turn on / off all HTML rendering.
              enabled = true,
              -- Additional modes to render HTML.
              render_modes = false,
              comment = {
                  -- Turn on / off HTML comment concealing.
                  conceal = true,
                  -- Optional text to inline before the concealed comment.
                  text = nil,
                  -- Highlight for the inlined text.
                  highlight = 'RenderMarkdownHtmlComment',
              },
              -- HTML tags whose start and end will be hidden and icon shown.
              -- The key is matched against the tag name, value type below.
              -- | icon            | optional icon inlined at start of tag           |
              -- | highlight       | optional highlight for the icon                 |
              -- | scope_highlight | optional highlight for item associated with tag |
              tag = {},
          },
          win_options = {
              -- Window options to use that change between rendered and raw view.
      
              -- @see :h 'conceallevel'
              conceallevel = {
                  -- Used when not being rendered, get user setting.
                  default = vim.o.conceallevel,
                  -- Used when being rendered, concealed text is completely hidden.
                  rendered = 3,
              },
              -- @see :h 'concealcursor'
              concealcursor = {
                  -- Used when not being rendered, get user setting.
                  default = vim.o.concealcursor,
                  -- Used when being rendered, show concealed text in all modes.
                  rendered = '',
              },
          },
          overrides = {
              -- More granular configuration mechanism, allows different aspects of buffers to have their own
              -- behavior. Values default to the top level configuration if no override is provided. Supports
              -- the following fields:
              --   enabled, render_modes, max_file_size, debounce, anti_conceal, bullet, callout, checkbox,
              --   code, dash, document, heading, html, indent, inline_highlight, latex, link, padding,
              --   paragraph, pipe_table, quote, sign, win_options, yaml
      
              -- Override for different buflisted values, @see :h 'buflisted'.
              buflisted = {},
              -- Override for different buftype values, @see :h 'buftype'.
              buftype = {
                  nofile = {
                      render_modes = true,
                      padding = { highlight = 'NormalFloat' },
                      sign = { enabled = false },
                  },
              },
              -- Override for different filetype values, @see :h 'filetype'.
              filetype = {},
          },
          custom_handlers = {
              -- Mapping from treesitter language to user defined handlers.
              -- @see [Custom Handlers](doc/custom-handlers.md)
          },
          yaml = {
              -- Turn on / off all yaml rendering.
              enabled = true,
              -- Additional modes to render yaml.
              render_modes = false,
          },
      })
      
      
      require('render-markdown').setup({
          heading = {
              -- Useful context to have when evaluating values.
              -- | level    | the number of '#' in the heading marker         |
              -- | sections | for each level how deeply nested the heading is |
      
              -- Turn on / off heading icon & background rendering.
              enabled = true,
              -- Additional modes to render headings.
              render_modes = false,
              -- Turn on / off atx heading rendering.
              atx = true,
              -- Turn on / off setext heading rendering.
              setext = true,
              -- Turn on / off sign column related rendering.
              sign = true,
              -- Replaces '#+' of 'atx_h._marker'.
              -- Output is evaluated depending on the type.
              -- | function | `value(context)`              |
              -- | string[] | `cycle(value, context.level)` |
              icons = { '󰲡 ', '󰲣 ', '󰲥 ', '󰲧 ', '󰲩 ', '󰲫 ' },
              -- Determines how icons fill the available space.
              -- | right   | '#'s are concealed and icon is appended to right side                      |
              -- | inline  | '#'s are concealed and icon is inlined on left side                        |
              -- | overlay | icon is left padded with spaces and inserted on left hiding additional '#' |
              position = 'overlay',
              -- Added to the sign column if enabled.
              -- Output is evaluated by `cycle(value, context.level)`.
              signs = { '󰫎 ' },
              -- Width of the heading background.
              -- | block | width of the heading text |
              -- | full  | full width of the window  |
              -- Can also be a list of the above values evaluated by `clamp(value, context.level)`.
              width = 'full',
              -- Amount of margin to add to the left of headings.
              -- Margin available space is computed after accounting for padding.
              -- If a float < 1 is provided it is treated as a percentage of available window space.
              -- Can also be a list of numbers evaluated by `clamp(value, context.level)`.
              left_margin = 0,
              -- Amount of padding to add to the left of headings.
              -- Output is evaluated using the same logic as 'left_margin'.
              left_pad = 0,
              -- Amount of padding to add to the right of headings when width is 'block'.
              -- Output is evaluated using the same logic as 'left_margin'.
              right_pad = 0,
              -- Minimum width to use for headings when width is 'block'.
              -- Can also be a list of integers evaluated by `clamp(value, context.level)`.
              min_width = 0,
              -- Determines if a border is added above and below headings.
              -- Can also be a list of booleans evaluated by `clamp(value, context.level)`.
              border = false,
              -- Always use virtual lines for heading borders instead of attempting to use empty lines.
              border_virtual = false,
              -- Highlight the start of the border using the foreground highlight.
              border_prefix = false,
              -- Used above heading for border.
              above = '▄',
              -- Used below heading for border.
              below = '▀',
              -- Highlight for the heading icon and extends through the entire line.
              -- Output is evaluated by `clamp(value, context.level)`.
              backgrounds = {
                  'RenderMarkdownH1Bg',
                  'RenderMarkdownH2Bg',
                  'RenderMarkdownH3Bg',
                  'RenderMarkdownH4Bg',
                  'RenderMarkdownH5Bg',
                  'RenderMarkdownH6Bg',
              },
              -- Highlight for the heading and sign icons.
              -- Output is evaluated using the same logic as 'backgrounds'.
              foregrounds = {
                  'RenderMarkdownH1',
                  'RenderMarkdownH2',
                  'RenderMarkdownH3',
                  'RenderMarkdownH4',
                  'RenderMarkdownH5',
                  'RenderMarkdownH6',
              },
              -- Define custom heading patterns which allow you to override various properties based on
              -- the contents of a heading.
              -- The key is for healthcheck and to allow users to change its values, value type below.
              -- | pattern    | matched against the heading text @see :h lua-patterns |
              -- | icon       | optional override for the icon                        |
              -- | background | optional override for the background                  |
              -- | foreground | optional override for the foreground                  |
              custom = {},
          },
      })
      
      
      require('render-markdown').setup({
          paragraph = {
              -- Useful context to have when evaluating values.
              -- | text | text value of the node |
      
              -- Turn on / off paragraph rendering.
              enabled = true,
              -- Additional modes to render paragraphs.
              render_modes = false,
              -- Amount of margin to add to the left of paragraphs.
              -- If a float < 1 is provided it is treated as a percentage of available window space.
              -- Output is evaluated depending on the type.
              -- | function | `value(context)` |
              -- | number   | `value`          |
              left_margin = 0,
              -- Amount of padding to add to the first line of each paragraph.
              -- Output is evaluated using the same logic as 'left_margin'.
              indent = 0,
              -- Minimum width to use for paragraphs.
              min_width = 0,
          },
      })
      
      
      require('render-markdown').setup({
          code = {
              -- Turn on / off code block & inline code rendering.
              enabled = true,
              -- Additional modes to render code blocks.
              render_modes = false,
              -- Turn on / off sign column related rendering.
              sign = true,
              -- Whether to conceal nodes at the top and bottom of code blocks.
              conceal_delimiters = true,
              -- Turn on / off language heading related rendering.
              language = true,
              -- Determines where language icon is rendered.
              -- | right | right side of code block |
              -- | left  | left side of code block  |
              position = 'left',
              -- Whether to include the language icon above code blocks.
              language_icon = true,
              -- Whether to include the language name above code blocks.
              language_name = true,
              -- Whether to include the language info above code blocks.
              language_info = true,
              -- Amount of padding to add around the language.
              -- If a float < 1 is provided it is treated as a percentage of available window space.
              language_pad = 0,
              -- A list of language names for which background highlighting will be disabled.
              -- Likely because that language has background highlights itself.
              -- Use a boolean to make behavior apply to all languages.
              -- Borders above & below blocks will continue to be rendered.
              disable_background = { 'diff' },
              -- Width of the code block background.
              -- | block | width of the code block  |
              -- | full  | full width of the window |
              width = 'full',
              -- Amount of margin to add to the left of code blocks.
              -- If a float < 1 is provided it is treated as a percentage of available window space.
              -- Margin available space is computed after accounting for padding.
              left_margin = 0,
              -- Amount of padding to add to the left of code blocks.
              -- If a float < 1 is provided it is treated as a percentage of available window space.
              left_pad = 0,
              -- Amount of padding to add to the right of code blocks when width is 'block'.
              -- If a float < 1 is provided it is treated as a percentage of available window space.
              right_pad = 0,
              -- Minimum width to use for code blocks when width is 'block'.
              min_width = 0,
              -- Determines how the top / bottom of code block are rendered.
              -- | none  | do not render a border                               |
              -- | thick | use the same highlight as the code body              |
              -- | thin  | when lines are empty overlay the above & below icons |
              -- | hide  | conceal lines unless language name or icon is added  |
              border = 'hide',
              -- Used above code blocks to fill remaining space around language.
              language_border = '█',
              -- Added to the left of language.
              language_left = '',
              -- Added to the right of language.
              language_right = '',
              -- Used above code blocks for thin border.
              above = '▄',
              -- Used below code blocks for thin border.
              below = '▀',
              -- Turn on / off inline code related rendering.
              inline = true,
              -- Icon to add to the left of inline code.
              inline_left = '',
              -- Icon to add to the right of inline code.
              inline_right = '',
              -- Padding to add to the left & right of inline code.
              inline_pad = 0,
              -- Highlight for code blocks.
              highlight = 'RenderMarkdownCode',
              -- Highlight for code info section, after the language.
              highlight_info = 'RenderMarkdownCodeInfo',
              -- Highlight for language, overrides icon provider value.
              highlight_language = nil,
              -- Highlight for border, use false to add no highlight.
              highlight_border = 'RenderMarkdownCodeBorder',
              -- Highlight for language, used if icon provider does not have a value.
              highlight_fallback = 'RenderMarkdownCodeFallback',
              -- Highlight for inline code.
              highlight_inline = 'RenderMarkdownCodeInline',
              -- Determines how code blocks & inline code are rendered.
              -- | none     | { enabled = false }                           |
              -- | normal   | { language = false }                          |
              -- | language | { disable_background = true, inline = false } |
              -- | full     | uses all default values                       |
              style = 'full',
          },
      })
      
      
      require('render-markdown').setup({
          dash = {
              -- Turn on / off thematic break rendering.
              enabled = true,
              -- Additional modes to render dash.
              render_modes = false,
              -- Replaces '---'|'***'|'___'|'* * *' of 'thematic_break'.
              -- The icon gets repeated across the window's width.
              icon = '─',
              -- Width of the generated line.
              -- | <number> | a hard coded width value |
              -- | full     | full width of the window |
              -- If a float < 1 is provided it is treated as a percentage of available window space.
              width = 'full',
              -- Amount of margin to add to the left of dash.
              -- If a float < 1 is provided it is treated as a percentage of available window space.
              left_margin = 0,
              -- Highlight for the whole line generated from the icon.
              highlight = 'RenderMarkdownDash',
          },
      })
      
      
      require('render-markdown').setup({
          bullet = {
              -- Useful context to have when evaluating values.
              -- | level | how deeply nested the list is, 1-indexed          |
              -- | index | how far down the item is at that level, 1-indexed |
              -- | value | text value of the marker node                     |
      
              -- Turn on / off list bullet rendering
              enabled = true,
              -- Additional modes to render list bullets
              render_modes = false,
              -- Replaces '-'|'+'|'*' of 'list_item'.
              -- If the item is a 'checkbox' a conceal is used to hide the bullet instead.
              -- Output is evaluated depending on the type.
              -- | function   | `value(context)`                                    |
              -- | string     | `value`                                             |
              -- | string[]   | `cycle(value, context.level)`                       |
              -- | string[][] | `clamp(cycle(value, context.level), context.index)` |
              icons = { '●', '○', '◆', '◇' },
              -- Replaces 'n.'|'n)' of 'list_item'.
              -- Output is evaluated using the same logic as 'icons'.
              ordered_icons = function(ctx)
                  local value = vim.trim(ctx.value)
                  local index = tonumber(value:sub(1, #value - 1))
                  return ('%d.'):format(index > 1 and index or ctx.index)
              end,
              -- Padding to add to the left of bullet point.
              -- Output is evaluated depending on the type.
              -- | function | `value(context)` |
              -- | integer  | `value`          |
              left_pad = 0,
              -- Padding to add to the right of bullet point.
              -- Output is evaluated using the same logic as 'left_pad'.
              right_pad = 0,
              -- Highlight for the bullet icon.
              -- Output is evaluated using the same logic as 'icons'.
              highlight = 'RenderMarkdownBullet',
              -- Highlight for item associated with the bullet point.
              -- Output is evaluated using the same logic as 'icons'.
              scope_highlight = {},
          },
      })
      
      
      require('render-markdown').setup({
          checkbox = {
              -- Checkboxes are a special instance of a 'list_item' that start with a 'shortcut_link'.
              -- There are two special states for unchecked & checked defined in the markdown grammar.
      
              -- Turn on / off checkbox state rendering.
              enabled = true,
              -- Additional modes to render checkboxes.
              render_modes = false,
              -- Render the bullet point before the checkbox.
              bullet = false,
              -- Padding to add to the right of checkboxes.
              right_pad = 1,
              unchecked = {
                  -- Replaces '[ ]' of 'task_list_marker_unchecked'.
                  icon = '󰄱 ',
                  -- Highlight for the unchecked icon.
                  highlight = 'RenderMarkdownUnchecked',
                  -- Highlight for item associated with unchecked checkbox.
                  scope_highlight = nil,
              },
              checked = {
                  -- Replaces '[x]' of 'task_list_marker_checked'.
                  icon = '󰱒 ',
                  -- Highlight for the checked icon.
                  highlight = 'RenderMarkdownChecked',
                  -- Highlight for item associated with checked checkbox.
                  scope_highlight = nil,
              },
              -- Define custom checkbox states, more involved, not part of the markdown grammar.
              -- As a result this requires neovim >= 0.10.0 since it relies on 'inline' extmarks.
              -- The key is for healthcheck and to allow users to change its values, value type below.
              -- | raw             | matched against the raw text of a 'shortcut_link'           |
              -- | rendered        | replaces the 'raw' value when rendering                     |
              -- | highlight       | highlight for the 'rendered' icon                           |
              -- | scope_highlight | optional highlight for item associated with custom checkbox |
              -- stylua: ignore
              custom = {
                  todo = { raw = '[-]', rendered = '󰥔 ', highlight = 'RenderMarkdownTodo', scope_highlight = nil },
              },
          },
      })
      
      
      require('render-markdown').setup({
          quote = {
              -- Turn on / off block quote & callout rendering.
              enabled = true,
              -- Additional modes to render quotes.
              render_modes = false,
              -- Replaces '>' of 'block_quote'.
              icon = '▋',
              -- Whether to repeat icon on wrapped lines. Requires neovim >= 0.10. This will obscure text
              -- if incorrectly configured with :h 'showbreak', :h 'breakindent' and :h 'breakindentopt'.
              -- A combination of these that is likely to work follows.
              -- | showbreak      | '  ' (2 spaces)   |
              -- | breakindent    | true              |
              -- | breakindentopt | '' (empty string) |
              -- These are not validated by this plugin. If you want to avoid adding these to your main
              -- configuration then set them in win_options for this plugin.
              repeat_linebreak = false,
              -- Highlight for the quote icon.
              -- If a list is provided output is evaluated by `cycle(value, level)`.
              highlight = {
                  'RenderMarkdownQuote1',
                  'RenderMarkdownQuote2',
                  'RenderMarkdownQuote3',
                  'RenderMarkdownQuote4',
                  'RenderMarkdownQuote5',
                  'RenderMarkdownQuote6',
              },
          },
      })
      
      
      require('render-markdown').setup({
          pipe_table = {
              -- Turn on / off pipe table rendering.
              enabled = true,
              -- Additional modes to render pipe tables.
              render_modes = false,
              -- Pre configured settings largely for setting table border easier.
              -- | heavy  | use thicker border characters     |
              -- | double | use double line border characters |
              -- | round  | use round border corners          |
              -- | none   | does nothing                      |
              preset = 'none',
              -- Determines how individual cells of a table are rendered.
              -- | overlay | writes completely over the table, removing conceal behavior and highlights |
              -- | raw     | replaces only the '|' characters in each row, leaving the cells unmodified |
              -- | padded  | raw + cells are padded to maximum visual width for each column             |
              -- | trimmed | padded except empty space is subtracted from visual width calculation      |
              cell = 'padded',
              -- Adjust the computed width of table cells using custom logic.
              cell_offset = function()
                  return 0
              end,
              -- Amount of space to put between cell contents and border.
              padding = 1,
              -- Minimum column width to use for padded or trimmed cell.
              min_width = 0,
              -- Characters used to replace table border.
              -- Correspond to top(3), delimiter(3), bottom(3), vertical, & horizontal.
              -- stylua: ignore
              border = {
                  '┌', '┬', '┐',
                  '├', '┼', '┤',
                  '└', '┴', '┘',
                  '│', '─',
              },
              -- Turn on / off top & bottom lines.
              border_enabled = true,
              -- Always use virtual lines for table borders instead of attempting to use empty lines.
              -- Will be automatically enabled if indentation module is enabled.
              border_virtual = false,
              -- Gets placed in delimiter row for each column, position is based on alignment.
              alignment_indicator = '━',
              -- Highlight for table heading, delimiter, and the line above.
              head = 'RenderMarkdownTableHead',
              -- Highlight for everything else, main table rows and the line below.
              row = 'RenderMarkdownTableRow',
              -- Highlight for inline padding used to add back concealed space.
              filler = 'RenderMarkdownTableFill',
              -- Determines how the table as a whole is rendered.
              -- | none   | { enabled = false }        |
              -- | normal | { border_enabled = false } |
              -- | full   | uses all default values    |
              style = 'full',
          },
      })
      
      
      require('render-markdown').setup({
          callout = {
              -- Callouts are a special instance of a 'block_quote' that start with a 'shortcut_link'.
              -- The key is for healthcheck and to allow users to change its values, value type below.
              -- | raw        | matched against the raw text of a 'shortcut_link', case insensitive |
              -- | rendered   | replaces the 'raw' value when rendering                             |
              -- | highlight  | highlight for the 'rendered' text and quote markers                 |
              -- | quote_icon | optional override for quote.icon value for individual callout       |
              -- | category   | optional metadata useful for filtering                              |
      
              note      = { raw = '[!NOTE]',      rendered = '󰋽 Note',      highlight = 'RenderMarkdownInfo',    category = 'github'   },
              tip       = { raw = '[!TIP]',       rendered = '󰌶 Tip',       highlight = 'RenderMarkdownSuccess', category = 'github'   },
              important = { raw = '[!IMPORTANT]', rendered = '󰅾 Important', highlight = 'RenderMarkdownHint',    category = 'github'   },
              warning   = { raw = '[!WARNING]',   rendered = '󰀪 Warning',   highlight = 'RenderMarkdownWarn',    category = 'github'   },
              caution   = { raw = '[!CAUTION]',   rendered = '󰳦 Caution',   highlight = 'RenderMarkdownError',   category = 'github'   },
              -- Obsidian: https://help.obsidian.md/Editing+and+formatting/Callouts
              abstract  = { raw = '[!ABSTRACT]',  rendered = '󰨸 Abstract',  highlight = 'RenderMarkdownInfo',    category = 'obsidian' },
              summary   = { raw = '[!SUMMARY]',   rendered = '󰨸 Summary',   highlight = 'RenderMarkdownInfo',    category = 'obsidian' },
              tldr      = { raw = '[!TLDR]',      rendered = '󰨸 Tldr',      highlight = 'RenderMarkdownInfo',    category = 'obsidian' },
              info      = { raw = '[!INFO]',      rendered = '󰋽 Info',      highlight = 'RenderMarkdownInfo',    category = 'obsidian' },
              todo      = { raw = '[!TODO]',      rendered = '󰗡 Todo',      highlight = 'RenderMarkdownInfo',    category = 'obsidian' },
              hint      = { raw = '[!HINT]',      rendered = '󰌶 Hint',      highlight = 'RenderMarkdownSuccess', category = 'obsidian' },
              success   = { raw = '[!SUCCESS]',   rendered = '󰄬 Success',   highlight = 'RenderMarkdownSuccess', category = 'obsidian' },
              check     = { raw = '[!CHECK]',     rendered = '󰄬 Check',     highlight = 'RenderMarkdownSuccess', category = 'obsidian' },
              done      = { raw = '[!DONE]',      rendered = '󰄬 Done',      highlight = 'RenderMarkdownSuccess', category = 'obsidian' },
              question  = { raw = '[!QUESTION]',  rendered = '󰘥 Question',  highlight = 'RenderMarkdownWarn',    category = 'obsidian' },
              help      = { raw = '[!HELP]',      rendered = '󰘥 Help',      highlight = 'RenderMarkdownWarn',    category = 'obsidian' },
              faq       = { raw = '[!FAQ]',       rendered = '󰘥 Faq',       highlight = 'RenderMarkdownWarn',    category = 'obsidian' },
              attention = { raw = '[!ATTENTION]', rendered = '󰀪 Attention', highlight = 'RenderMarkdownWarn',    category = 'obsidian' },
              failure   = { raw = '[!FAILURE]',   rendered = '󰅖 Failure',   highlight = 'RenderMarkdownError',   category = 'obsidian' },
              fail      = { raw = '[!FAIL]',      rendered = '󰅖 Fail',      highlight = 'RenderMarkdownError',   category = 'obsidian' },
              missing   = { raw = '[!MISSING]',   rendered = '󰅖 Missing',   highlight = 'RenderMarkdownError',   category = 'obsidian' },
              danger    = { raw = '[!DANGER]',    rendered = '󱐌 Danger',    highlight = 'RenderMarkdownError',   category = 'obsidian' },
              error     = { raw = '[!ERROR]',     rendered = '󱐌 Error',     highlight = 'RenderMarkdownError',   category = 'obsidian' },
              bug       = { raw = '[!BUG]',       rendered = '󰨰 Bug',       highlight = 'RenderMarkdownError',   category = 'obsidian' },
              example   = { raw = '[!EXAMPLE]',   rendered = '󰉹 Example',   highlight = 'RenderMarkdownHint' ,   category = 'obsidian' },
              quote     = { raw = '[!QUOTE]',     rendered = '󱆨 Quote',     highlight = 'RenderMarkdownQuote',   category = 'obsidian' },
              cite      = { raw = '[!CITE]',      rendered = '󱆨 Cite',      highlight = 'RenderMarkdownQuote',   category = 'obsidian' },
          },
      })
      
      
      require('render-markdown').setup({
          link = {
              -- Turn on / off inline link icon rendering.
              enabled = true,
              -- Additional modes to render links.
              render_modes = false,
              -- How to handle footnote links, start with a '^'.
              footnote = {
                  -- Turn on / off footnote rendering.
                  enabled = true,
                  -- Replace value with superscript equivalent.
                  superscript = true,
                  -- Added before link content.
                  prefix = '',
                  -- Added after link content.
                  suffix = '',
              },
              -- Inlined with 'image' elements.
              image = '󰥶 ',
              -- Inlined with 'email_autolink' elements.
              email = '󰀓 ',
              -- Fallback icon for 'inline_link' and 'uri_autolink' elements.
              hyperlink = '󰌹 ',
              -- Applies to the inlined icon as a fallback.
              highlight = 'RenderMarkdownLink',
              -- Applies to WikiLink elements.
              wiki = {
                  icon = '󱗖 ',
                  body = function()
                      return nil
                  end,
                  highlight = 'RenderMarkdownWikiLink',
                  scope_highlight = nil,
              },
              -- Define custom destination patterns so icons can quickly inform you of what a link
              -- contains. Applies to 'inline_link', 'uri_autolink', and wikilink nodes. When multiple
              -- patterns match a link the one with the longer pattern is used.
              -- The key is for healthcheck and to allow users to change its values, value type below.
              -- | pattern   | matched against the destination text                            |
              -- | icon      | gets inlined before the link text                               |
              -- | kind      | optional determines how pattern is checked                      |
              -- |           | pattern | @see :h lua-patterns, is the default if not set       |
              -- |           | suffix  | @see :h vim.endswith()                                |
              -- | priority  | optional used when multiple match, uses pattern length if empty |
              -- | highlight | optional highlight for 'icon', uses fallback highlight if empty |
              custom = {
                  web = { pattern = '^http', icon = '󰖟 ' },
                  discord = { pattern = 'discord%.com', icon = '󰙯 ' },
                  github = { pattern = 'github%.com', icon = '󰊤 ' },
                  gitlab = { pattern = 'gitlab%.com', icon = '󰮠 ' },
                  google = { pattern = 'google%.com', icon = '󰊭 ' },
                  neovim = { pattern = 'neovim%.io', icon = ' ' },
                  reddit = { pattern = 'reddit%.com', icon = '󰑍 ' },
                  stackoverflow = { pattern = 'stackoverflow%.com', icon = '󰓌 ' },
                  wikipedia = { pattern = 'wikipedia%.org', icon = '󰖬 ' },
                  youtube = { pattern = 'youtube%.com', icon = '󰗃 ' },
              },
          },
      })
      
      
      require('render-markdown').setup({
          sign = {
              -- Turn on / off sign rendering.
              enabled = true,
              -- Applies to background of sign text.
              highlight = 'RenderMarkdownSign',
          },
      })
      
      
      require('render-markdown').setup({
          indent = {
              -- Mimic org-indent-mode behavior by indenting everything under a heading based on the
              -- level of the heading. Indenting starts from level 2 headings onward by default.
      
              -- Turn on / off org-indent-mode.
              enabled = false,
              -- Additional modes to render indents.
              render_modes = false,
              -- Amount of additional padding added for each heading level.
              per_level = 2,
              -- Heading levels <= this value will not be indented.
              -- Use 0 to begin indenting from the very first level.
              skip_level = 1,
              -- Do not indent heading titles, only the body.
              skip_heading = false,
              -- Prefix added when indenting, one per level.
              icon = '▎',
              -- Priority to assign to extmarks.
              priority = 0,
              -- Applied to icon.
              highlight = 'RenderMarkdownIndent',
          },
      })
      
      
      > require('render-markdown').setup({
      >     file_types = { 'markdown', 'vimwiki' },
      > })
      > 
      
      > vim.treesitter.language.register('markdown', 'vimwiki')
      > 
      
      > require('obsidian').setup({
      >     ui = { enable = false },
      > })
      > 
      
      > return {
      >     'MeanderingProgrammer/render-markdown.nvim',
      >     cmd = { 'RenderMarkdown' },
      >     dependencies = { 'nvim-treesitter/nvim-treesitter', 'nvim-mini/mini.nvim' },
      >     config = function()
      >         require('obsidian').get_client().opts.ui.enable = false
      >         vim.api.nvim_buf_clear_namespace(0, vim.api.nvim_get_namespaces()['ObsidianUI'], 0, -1)
      >         require('render-markdown').setup({})
      >     end,
      > }
      > 
    end,
  },
  {
    "arminveres/md-pdf.nvim",
    config = function()
      
      {
          'arminveres/md-pdf.nvim',
          branch = 'main', -- you can assume that main is somewhat stable until releases will be made
          lazy = true,
          keys = {
              {
                  "<leader>,",
                  function() require("md-pdf").convert_md_to_pdf() end,
                  desc = "Markdown preview",
              },
          },
          ---@type md-pdf.config
          opts = {},
      }
      
      
      require('md-pdf').setup() -- default options, or
      require('md-pdf').setup({
          --- Set margins around document
          margins = "1.5cm",
          -- tango, pygments are quite nice for white on white
          highlight = "tango",
          -- Generate a table of contents, on by default
          toc = true,
          -- Define a custom preview command, enabling hooks and other custom logic
          preview_cmd = function() return 'firefox' end,
          -- if true, then the markdown file is continuously converted on each write, even if the
          -- file viewer closed, e.g., Firefox is "closed" once the document is opened in it.
          ignore_viewer_state = false,
          -- Specify font, `nil` uses the default font of the theme
          fonts = nil,
          -- or, where all or only some options can be specified. NOTE: those that are `nil` can be left
          -- out completely
          fonts = {
              main_font = nil,
              sans_font = "DejaVuSans",
              mono_font = "IosevkaTerm Nerd Font Mono",
              math_font = nil,
          },
          -- Custom options passed to `pandoc` CLI call, can be ignored for setup
          pandoc_user_args = nil,
          -- or
          pandoc_user_args = {
              -- short
              "-V KEY[:VALUE]",
              -- long options
              "--standalone=[true|false]",
          },
          --- Path to output. Needs to be always relative, e.g.: "./", "../", "./out" or simply "out", but
          --- not absolute e.g.: "/"!
          output_path = "",
          -- PDF converter engine
          pdf_engine = "pdflatex",
      })
      
      -- setup mapping
      vim.keymap.set("n", "<Space>,", function()
          require('md-pdf').convert_md_to_pdf()
      end)
      
    end,
  },
  {
    "ChuufMaster/markdown-toc",
    config = function()
      
      return {
        {
          'ChuufMaster/markdown-toc',
          opts = {
      
            -- The heading level to match (i.e the number of "#"s to match to) max 6
            heading_level_to_match = -1,
      
            -- Set to True display a dropdown to allow you to select the heading level
            ask_for_heading_level = false,
      
            -- TOC default string
            -- WARN
            toc_format = '%s- [%s](<%s#%s>)',
          }
        },
      }
      
      
      {
        -- The heading level to match (i.e the number of "#"s to match to)
        heading_level_to_match = -1,
      
        -- Set to display a dropdown to allow you to select the heading level
        ask_for_heading_level = true,
      
        -- TOC default string
        -- The first %s is for indenting/tabs
        -- The sencond %s is for the original headings text
        -- The third %s is for the markdown files path that the TOC is being generated
        -- from
        -- The forth %s is for the target heading using the markdown rules
        toc_format = '%s- [%s](<%s#%s>)',
      }
      
    end,
  },
  {
    "OXY2DEV/markview.nvim",
    config = function()
      
      > {
      >     preview = {
      >         icon_provider = "internal", -- "mini" or "devicons"
      >     }
      > }
      > 
      
      > {
      >     "nvim-treesitter/nvim-treesitter",
      >     dependencies = { "OXY2DEV/markview.nvim" },
      >     lazy = false,
      >
      >     -- ... All other options.
      > },
      > 
      
      -- For `plugins/markview.lua` users.
      return {
          "OXY2DEV/markview.nvim",
          lazy = false,
      
         -- For `nvim-treesitter` users.
          priority = 49,
      
          -- For blink.cmp's completion
          -- source
          -- dependencies = {
          --     "saghen/blink.cmp"
          -- },
      };
      
      
      -- For `plugins.lua` users.
      {
          "OXY2DEV/markview.nvim",
          lazy = false,
      
         -- For `nvim-treesitter` users.
          priority = 49,
      
          -- For blink.cmp's completion
          -- source
          -- dependencies = {
          --     "saghen/blink.cmp"
          -- },
      },
      
      
      local MiniDeps = require("mini.deps");
      
      MiniDeps.add({
          source = "OXY2DEV/markview.nvim",
      
          -- For blink.cmp's completion
          -- source
          -- depends = {
          --     "saghen/blink.cmp"
          -- },
      });
      
      
      return {
          "OXY2DEV/markview.nvim",
          branch = "dev",
          lazy = false
      };
      
      
      --- Configuration table for `markview.nvim`.
      ---@class mkv.config
      ---
      ---@field experimental config.experimental | fun(): config.experimental
      ---@field highlight_groups { [string]: config.hl } | fun(): { [string]: config.hl }
      ---@field html config.html | fun(): config.html
      ---@field latex config.latex | fun(): config.latex
      ---@field markdown config.markdown | fun(): config.markdown
      ---@field markdown_inline config.markdown_inline | fun(): config.markdown_inline
      ---@field preview config.preview | fun(): config.preview
      ---@field renderers config.renderer[] | fun(): config.renderer[]
      ---@field typst config.typst | fun(): config.typst
      ---@field yaml config.yaml | fun(): config.yaml
      mkv.config = {
          experimental = {
              date_formats = {},
              date_time_formats = {},
      
              text_filetypes = {},
              read_chunk_size = 1000,
              link_open_alerts = false,
              prefer_nvim = true,
              file_open_command = "tabnew",
      
              list_empty_line_tolerance = 3
          },
          highlight_groups = {},
          preview = {
              enable = true,
              filetypes = { "md", "rmd", "quarto" },
              ignore_buftypes = { "nofile" },
              ignore_previews = {},
      
              modes = { "n", "no", "c" },
              hybrid_modes = {},
              debounce = 50,
              draw_range = { vim.o.lines, vim.o.lines },
              edit_range = { 1, 0 },
      
              callbacks = {},
      
              splitview_winopts = { split = "left" }
          },
          renderers = {},
      
          html = {
              enable = true,
      
              container_elements = {},
              headings = {},
              void_elements = {},
          },
          latex = {
              enable = true,
      
              blocks = {},
              commands = {},
              escapes = {},
              fonts = {},
              inlines = {},
              parenthesis = {},
              subscripts = {},
              superscripts = {},
              symbols = {},
              texts = {}
          },
          markdown = {
              enable = true,
      
              block_quotes = {},
              code_blocks = {},
              headings = {},
              horizontal_rules = {},
              list_items = {},
              metadata_plus = {},
              metadata_minus = {},
              tables = {}
          },
          markdown_inline = {
              enable = true,
      
              block_references = {},
              checkboxes = {},
              emails = {},
              embed_files = {},
              entities = {},
              escapes = {},
              footnotes = {},
              highlights = {},
              hyperlinks = {},
              images = {},
              inline_codes = {},
              internal_links = {},
              uri_autolinks = {}
          },
          typst = {
              enable = true,
      
              codes = {},
              escapes = {},
              headings = {},
              labels = {},
              list_items = {},
              math_blocks = {},
              math_spans = {},
              raw_blocks = {},
              raw_spans = {},
              reference_links = {},
              subscripts = {},
              superscript = {},
              symbols = {},
              terms = {},
              url_links = {}
          },
          yaml = {
              enable = true,
      
              properties = {}
          }
      }
      
      
      vim.api.nvim_create_autocmd("User", {
          pattern = "MarkviewAttach",
          callback = function (event)
              --- This will have all the data you need.
              local data = event.data;
      
              vim.print(data);
          end
      })
      
      
      local presets = require("markview.presets");
      
      require("markview").setup({
          markdown = {
              headings = presets.headings.slanted
          }
      });
      
      
      -- Load the checkboxes module.
      require("markview.extras.checkboxes").setup();
      
    end,
  },
  {
    "Kicamon/markdown-table-mode.nvim",
    config = function()
      
      {
        'Kicamon/markdown-table-mode.nvim',
        config = function()
          require('markdown-table-mode').setup()
        end
      }
      
      
      require('markdown-table-mode').setup({
        filetype = {
          '*.md',
        },
        options = {
          insert = true, -- when typing "|"
          insert_leave = true, -- when leaving insert
          pad_separator_line = false, -- add space in separator line
          alig_style = 'default', -- default, left, center, right
        },
      })
      
    end,
  },
  {
    "SCJangra/table-nvim",
    config = function()
      
      {
        'SCJangra/table-nvim',
        ft = 'markdown',
        opts = {},
      }
      
      
      {
        padd_column_separators = true,   -- Insert a space around column separators.
        mappings = {                     -- next and prev work in Normal and Insert mode. All other mappings work in Normal mode.
          next = '<TAB>',                -- Go to next cell.
          prev = '<S-TAB>',              -- Go to previous cell.
          insert_row_up = '<A-k>',       -- Insert a row above the current row.
          insert_row_down = '<A-j>',     -- Insert a row below the current row.
          move_row_up = '<A-S-k>',       -- Move the current row up.
          move_row_down = '<A-S-j>',     -- Move the current row down.
          insert_column_left = '<A-h>',  -- Insert a column to the left of current column.
          insert_column_right = '<A-l>', -- Insert a column to the right of current column.
          move_column_left = '<A-S-h>',  -- Move the current column to the left.
          move_column_right = '<A-S-l>', -- Move the current column to the right.
          insert_table = '<A-t>',        -- Insert a new table.
          insert_table_alt = '<A-S-t>',  -- Insert a new table that is not surrounded by pipes.
          delete_column = '<A-d>',       -- Delete the column under cursor.
        }
      }
      
    end,
  },
  {
    "brianhuster/live-preview.nvim",
    config = function()
      
      {
          'brianhuster/live-preview.nvim',
          dependencies = {
              -- You can choose one of the following pickers
              'nvim-telescope/telescope.nvim',
              'ibhagwan/fzf-lua',
              'echasnovski/mini.pick',
      		'folke/snacks.nvim',
          },
      }
      
      
      MiniDeps.add({
          source = 'brianhuster/live-preview.nvim',
          depends = { 
              -- You can choose one of the following pickers
              'nvim-telescope/telescope.nvim',
              'ibhagwan/fzf-lua',
              'echasnovski/mini.pick',
      		'folke/snacks.nvim',
          }, 
      })
      
      
      --- Lua
      vim.o.autowriteall = true
      vim.api.nvim_create_autocmd({ 'InsertLeavePre', 'TextChanged', 'TextChangedP' }, {
          pattern = '*', callback = function()
              vim.cmd('silent! write')
          end
      })
      
      
      require('livepreview.config').set()
      
    end,
  },
  {
    "timantipov/md-table-tidy.nvim",
    config = function()
      
      return { "timantipov/md-table-tidy.nvim",
          -- default config
          opts = {
            padding = 1,        -- number of spaces for cell padding
            key = "<leader>tt", -- key for command :TableTidy<CR>
          }
      }
      
    end,
  },
  {
    "nvim-telescope/telescope-bibtex.nvim",
    config = function()
      
      use { "nvim-telescope/telescope-bibtex.nvim",
        requires = {
          {'nvim-telescope/telescope.nvim'},
        },
        config = function ()
          require"telescope".load_extension("bibtex")
        end,
      }
      
      
      require"telescope".setup {
        ...
      
        extensions = {
          bibtex = {
            -- Depth for the *.bib file
            depth = 1,
            -- Custom format for citation label
            custom_formats = {},
            -- Format to use for citation label.
            -- Try to match the filetype by default, or use 'plain'
            format = '',
            -- Path to global bibliographies (placed outside of the project)
            global_files = {},
            -- Define the search keys to use in the picker
            search_keys = { 'author', 'year', 'title' },
            -- Template for the formatted citation
            citation_format = '{{author}} ({{year}}), {{title}}.',
            -- Only use initials for the authors first name
            citation_trim_firstname = true,
            -- Max number of authors to write in the formatted citation
            -- following authors will be replaced by "et al."
            citation_max_auth = 2,
            -- Context awareness disabled by default
            context = false,
            -- Fallback to global/directory .bib files if context not found
            -- This setting has no effect if context = false
            context_fallback = true,
            -- Wrapping in the preview window is disabled by default
            wrap = false,
            -- user defined mappings
            mappings = {
                i = {
                  ["<CR>"] = bibtex_actions.key_append('%s'), -- format is determined by filetype if the user has not set it explictly
                  ["<C-e>"] = bibtex_actions.entry_append,
                  ["<C-c>"] = bibtex_actions.citation_append('{{author}} ({{year}}), {{title}}.'),
                }
            },
          },
        }
      }
      
      
      require"telescope".setup {
        ...
      
        extensions = {
          bibtex = {
            -- Use context awareness
            context = true,
            -- Use non-contextual behavior if no context found
            -- This setting has no effect if context = false
            context_fallback = true,
          },
        }
      }
      
      
      require"telescope".setup {
        ...
      
        extensions = {
          bibtex = {
            -- Custom format for citation label
            custom_formats = {
              {id = 'myCoolFormat', cite_marker = '#%s#'}
            },
            format = 'myCoolFormat',
          },
        }
      }
      
      
      search_keys = { 'publisher','author', 'label' }
      
      
      citation_format = "[[^@{{label}}]]: {{author}} ({{year}}), {{title}}.",
      
      
      local bibtex_actions = require('telescope-bibtex.actions')
      
      mappings = {
        i = {
          ["<C-a>"] = bibtex_actions.key_append([[\citep{%s}]]), -- a string with %s to be replaced by the citation key
          ["<C-b>"] = bibtex_actions.citation_append('[^@{{label}}]: {{author}}, {{title}}, {{journal}}, {{year}}, vol. {{volume}}, no. {{number}}, p. {{pages}}.'), -- a string with keys in {{}} to be replaced
          ["<C-c>"] = bibtex_actions.entry_append(), -- entry_append does not take any arguments
        }
      }
      
    end,
  },
  {
    "Thiago4532/mdmath.nvim",
    config = function()
      
      {
          'Thiago4532/mdmath.nvim',
          dependencies = {
              'nvim-treesitter/nvim-treesitter',
          },
          opts = {...}
      
          -- The build is already done by default in lazy.nvim, so you don't need
          -- the next line, but you can use the command `:MdMath build` to rebuild
          -- if the build fails for some reason.
          -- build = ':MdMath build'
      },
      
      
      opts = {
          -- Filetypes that the plugin will be enabled by default.
          filetypes = {'markdown'},
          -- Color of the equation, can be a highlight group or a hex color.
          -- Examples: 'Normal', '#ff0000'
          foreground = 'Normal',
          -- Hide the text when the equation is under the cursor.
          anticonceal = true,
          -- Hide the text when in the Insert Mode.
          hide_on_insert = true,
          -- Enable dynamic size for non-inline equations.
          dynamic = true,
          -- Configure the scale of dynamic-rendered equations.
          dynamic_scale = 1.0,
          -- Interval between updates (milliseconds).
          update_interval = 400,
      
          -- Internal scale of the equation images, increase to prevent blurry images when increasing terminal
          -- font, high values may produce aliased images.
          -- WARNING: This do not affect how the images are displayed, only how many pixels are used to render them.
          --          See `dynamic_scale` to modify the displayed size.
          internal_scale = 1.0,
      }
      
    end,
  },
  {
    "gbprod/phpactor.nvim",
    config = function()
      
      -- Lua
      {
        {
          "gbprod/phpactor.nvim",
          ft = "php",
          dependencies = {
            "nvim-lua/plenary.nvim",
            "neovim/nvim-lspconfig",
            -- If the update/install notification doesn't show properly,
            -- you should also add here UI plugins like "folke/noice.nvim" or "stevearc/dressing.nvim"
          },
          opts = {
            -- you're options goes here
          },
        },
      }
      
      
      {
        install = {
          path = vim.fn.stdpath("data") .. "/opt/",
          branch = "master",
          bin = vim.fn.stdpath("data") .. "/opt/phpactor/bin/phpactor",
          php_bin = "php",
          composer_bin = "composer",
          git_bin = "git",
          check_on_startup = "none",
        },
        lspconfig = {
          enabled = true,
          options = {},
        },
      }
      
    end,
  },
  {
    "ta-tikoma/php.easy.nvim",
    config = function()
      
          {
              'ta-tikoma/php.easy.nvim',
              config = true,
              keys = {
                  {'-#', '<CMD>PHPEasyAttribute<CR>', ft = 'php'},
                  {'-b', '<CMD>PHPEasyDocBlock<CR>', ft = 'php'},
                  {'-r', '<CMD>PHPEasyReplica<CR>', ft = 'php'},
                  {'-c', '<CMD>PHPEasyCopy<CR>', ft = 'php'},
                  {'-d', '<CMD>PHPEasyDelete<CR>', ft = 'php'},
                  {'-uu', '<CMD>PHPEasyRemoveUnusedUses<CR>', ft = 'php'},
                  {'-e', '<CMD>PHPEasyExtends<CR>', ft = 'php'},
                  {'-i', '<CMD>PHPEasyImplements<CR>', ft = 'php'},
                  {'--i', '<CMD>PHPEasyInitInterface<CR>', ft = 'php'},
                  {'--c', '<CMD>PHPEasyInitClass<CR>', ft = 'php'},
                  {'--ac', '<CMD>PHPEasyInitAbstractClass<CR>', ft = 'php'},
                  {'--t', '<CMD>PHPEasyInitTrait<CR>', ft = 'php'},
                  {'--e', '<CMD>PHPEasyInitEnum<CR>', ft = 'php'},
                  {'-c', '<CMD>PHPEasyAppendConstant<CR>', ft = 'php', mode = {'n', 'v'}},
                  {'-p', '<CMD>PHPEasyAppendProperty<CR>', ft = 'php', mode = {'n', 'v'}},
                  {'-m', '<CMD>PHPEasyAppendMethod<CR>', ft = 'php', mode = {'n', 'v'}},
                  {'__', '<CMD>PHPEasyAppendConstruct<CR>', ft = 'php'},
                  {'_i', '<CMD>PHPEasyAppendInvoke<CR>', ft = 'php'},
                  {'-a', '<CMD>PHPEasyAppendArgument<CR>', ft = 'php'},
              }
          },
      
      
          {
              'ta-tikoma/php.easy.nvim',
              dependencies = {
                  'L3MON4D3/LuaSnip',
              },
              opts = {
                  onAppend = {
                      engine = 'LuaSnip'
                  }
              },
              keys = {
                  ...
              }
          },
      
      
      {
          regex = { -- regex for parse php file
              tab = '    ',
              startTab = '^' .. tab,
              visibility = startTab .. '\\(public\\|protected\\|private\\|\\)\\s\\{1}',
              static = '\\(static\\s\\|\\)',
              readonly = '\\(readonly\\s\\|\\)',
              constant = visibility .. 'const ',
              property = visibility .. static .. readonly .. '\\(?*\\w\\+\\s\\|\\)\\$',
              method = visibility .. static .. 'function',
              construct = method .. ' __construct(',
              methodEnd = startTab .. '}',
              comment = startTab .. '\\/',
              commentMiddle = startTab .. '\\*',
              commentEnd = startTab .. '\\s\\*',
              any = startTab .. '[p}]\\{1}',
              variable = '\\(' .. tab .. '\\)\\+\\$\\w\\+\\s\\{1}=\\s\\{1}',
              object = '^\\(final class\\|abstract class\\|class\\|interface\\|trait\\|enum\\)\\s\\{1}',
          },
          onSave = { -- on save php file action
              removeUnusedUses = true -- remove unused uses (then use lsp: intelephense)
          },
          onAppend = { -- on append entity
              engine = 'defalut' -- how to insert template. 'default' - just string, 'LuaSinp' - via 'L3MON4D3/LuaSnip'
          }
      }
      
      
      
          {
              'quolpr/quicktest.nvim',
              config = function()
                  local qt = require("quicktest")
                  local root_patterns = { ".git" }
                  local root_dir = vim.fs.dirname(vim.fs.find(root_patterns, { upward = true })[1])
                  qt.setup({
                      adapters = {
                          require("php-easy-nvim.quicktest.adapters.phpunit")({
                              command = root_dir .. "vendor/bin/phpunit",
                          })
                      },
                      use_baleia = false
                  })
              end,
              dependencies = {
                  "nvim-lua/plenary.nvim",
                  "MunifTanjim/nui.nvim",
              },
              keys = {
                  ...
              }
          }
      
      
          {
              'quolpr/quicktest.nvim',
              config = function()
                  local qt = require("quicktest")
                  local root_patterns = { ".git", "phpunit.sh" }
                  local root_dir = vim.fs.dirname(vim.fs.find(root_patterns, { upward = true })[1])
                  qt.setup({
                      adapters = {
                          require("php-easy-nvim.quicktest.adapters.phpunit")({
                              command = root_dir .. "phpunit.sh",
                          })
                      },
                      use_baleia = false
                  })
              end,
              dependencies = {
                  "nvim-lua/plenary.nvim",
                  "MunifTanjim/nui.nvim",
              },
              keys = {
                  ...
              }
          }
      
    end,
  },
  {
    "TheLeoP/powershell.nvim",
    config = function()
      
      use {
          "TheLeoP/powershell.nvim"
      }
      
      
      {
          "TheLeoP/powershell.nvim",
          ---@type powershell.user_config
          opts = {
            bundle_path = 'path/to/your/bundle_path/'
          }
      }
      
      
      require('powershell').setup({
        bundle_path = vim.fn.stdpath "data" .. "/mason/packages/powershell-editor-services",
      })
      
      
      -- This is the default configuration
      require('powershell').setup({
        shell = "pwsh",
        bundle_path = "",
        feature_flags = {},
        lsp_log_level = "Warning",
        capabilities = vim.lsp.protocol.make_client_capabilities(),
        init_options = vim.empty_dict() --[[@as table]],
        settings = vim.empty_dict() --[[@as table]],
        handlers = base_handlers, -- see lua/powershell/handlers.lua
        commands = base_commands, -- see lua/powershell/commands.lua
        root_dir = function(buf)
          local current_file_dir = fs.dirname(api.nvim_buf_get_name(buf))
          return fs.dirname(fs.find({ ".git" }, { upward = true, path = current_file_dir })[1]) or current_file_dir
        end,
      })
      
      
      require('powershell').toggle_term()
      
      
      -- this should go in `~/.config/nvim/ftplugin/ps1.lua` or inside a `FileType` autocmd
      vim.keymap.set("n", "<leader>P", function() require("powershell").toggle_term() end)
      
      
      -- this should go anywhere in your config. For example in your `init.lua` or next to the `require('powershell').setup()` call
      local augroup = vim.api.nvim_create_augroup("personal-powershell", { clear = true })
      vim.api.nvim_create_autocmd("User", {
        group = augroup,
        pattern = "powershell.nvim-term",
        callback = function(opts)
          vim.keymap.set("n", "<leader>P", function()
            require("powershell").toggle_term()
          end, { buffer = opts.data.buf })
        end,
      })
      
      
      require('powershell').eval()
      
      
      -- this should go in `~/.config/nvim/ftplugin/ps1.lua` or inside a `FileType` autocmd
      vim.keymap.set({ "n", "x" }, "<leader>E", function() require("powershell").eval() end)
      
      
      dap.configurations.ps1 = {
        {
          name = "PowerShell: Launch Current File",
          type = "ps1",
          request = "launch",
          script = "${file}",
        },
        {
          name = "PowerShell: Launch Script",
          type = "ps1",
          request = "launch",
          script = function()
            return coroutine.create(function(co)
              vim.ui.input({
                prompt = 'Enter path or command to execute, for example: "${workspaceFolder}/src/foo.ps1" or "Invoke-Pester"',
                completion = "file",
              }, function(selected) coroutine.resume(co, selected) end)
            end)
          end,
        },
        {
          name = "PowerShell: Attach to PowerShell Host Process",
          type = "ps1",
          request = "attach",
          processId = "${command:pickProcess}",
        },
      }
      
    end,
  },
  {
    "Who5673/who5673-nasm",
  },
  {
    "potamides/pantran.nvim",
    config = function()
      
      use {
        "potamides/pantran.nvim"
      }
      
      
      local opts = {noremap = true, silent = true, expr = true}
      vim.keymap.set("n", "<leader>tr", pantran.motion_translate, opts)
      vim.keymap.set("n", "<leader>trr", function() return pantran.motion_translate() .. "_" end, opts)
      vim.keymap.set("x", "<leader>tr", pantran.motion_translate, opts)
      
      
      local opts = {noremap = true, silent = true, expr = true}
      vim.api.nvim_set_keymap("n", "<leader>tr", [[luaeval("require('pantran').motion_translate()")]], opts)
      vim.api.nvim_set_keymap("n", "<leader>trr", [[luaeval("require('pantran').motion_translate() .. '_'")]], opts)
      vim.api.nvim_set_keymap("x", "<leader>tr", [[luaeval("require('pantran').motion_translate()")]], opts)
      
      
      require("pantran").setup{
        -- Default engine to use for translation. To list valid engine names run
        -- `:lua =vim.tbl_keys(require("pantran.engines"))`.
        default_engine = "argos",
        -- Configuration for individual engines goes here.
        engines = {
          yandex = {
            -- Default languages can be defined on a per engine basis. In this case
            -- `:lua require("pantran.async").run(function()
            -- vim.pretty_print(require("pantran.engines").yandex:languages()) end)`
            -- can be used to list available language identifiers.
            default_source = "auto",
            default_target = "en"
          },
        },
        controls = {
          mappings = {
            edit = {
              n = {
                -- Use this table to add additional mappings for the normal mode in
                -- the translation window. Either strings or function references are
                -- supported.
                ["j"] = "gj",
                ["k"] = "gk"
              },
              i = {
                -- Similar table but for insert mode. Using 'false' disables
                -- existing keybindings.
                ["<C-y>"] = false,
                ["<C-a>"] = require("pantran.ui.actions").yank_close_translation
              }
            },
            -- Keybindings here are used in the selection window.
            select = {
              n = {
                -- ...
              }
            }
          }
        }
      }
      
    end,
  },
  {
    "niuiic/translate.nvim",
    config = function()
      
      local function trans_to_zh()
      	require("translate").translate({
      		get_command = function(input)
      			return {
      				"trans",
      				"-e",
      				"bing",
      				"-b",
      				":zh",
      				input,
      			}
      		end,
              -- input | clipboard | selection
      		input = "selection",
              -- open_float | notify | copy | insert | replace
      		output = { "open_float" },
      		resolve_result = function(result)
      			if result.code ~= 0 then
      				return nil
      			end
      
      			return string.match(result.stdout, "(.*)\n")
      		end,
      	})
      end
      
      local function trans_to_en()
      	require("translate").translate({
      		get_command = function(input)
      			return {
      				"trans",
      				"-e",
      				"bing",
      				"-b",
      				":en",
      				input,
      			}
      		end,
      		input = "selection",
      		output = { "replace" },
      		resolve_result = function(result)
      			if result.code ~= 0 then
      				return nil
      			end
      
      			return string.match(result.stdout, "(.*)\n")
      		end,
      	})
      end
      
    end,
  },
  {
    "tanloong/interlaced.nvim",
    config = function()
      
      {
        "tanloong/interlaced.nvim",
        config = function() require("interlaced") end,
        ft = "text",
      }
      
      
      vim.g.interlaced = {
        keymaps = {
          { "n", ",", "push_up"},
          { "n", "<", "push_up_pair"},
          { "n", "e", "push_up_left_part"},
          { "n", ".", "pull_below"},
          { "n", ">", "pull_below_pair"},
          { "n", "d", "push_down_right_part"},
          { "n", "D", "push_down"},
          { "n", "s", "leave_alone"},
          { "n", "[e", "swap_with_above"},
          { "n", "]e", "swap_with_below"},
          { "n", "U", "undo"},
          { "n", "R", "redo"},
          { "n", "J", "navigate_down"},
          { "n", "K", "navigate_up"},
          { "n", "md", "dump"},
          { "n", "ml", "load"},
          { "n", "gn", "next_unaligned"},
          { "n", "gN", "prev_unaligned"},
          { "n", "mt", "match_toggle"},
          { "n", "m;", "list_matches"},
          { "n", "ma", "match_add"},
          { "v", "ma", "match_add_visual"},
        },
        setup_mappings_now = false,
        separators = { ["1"] = "", ["2"] = " " },
        lang_num = 2,
        enable_keybindings_hook = function()
          -- disable coc to avoid lag on :w
          if vim.g.did_coc_loaded ~= nil then vim.cmd [[CocDisable]] end
          -- disable the undo history saving, which is time-consuming and causes lag
          vim.opt_local.undofile = false
          -- pcall(vim.cmd.nunmap, "j")
          -- pcall(vim.cmd.nunmap, "k")
          -- pcall(vim.cmd.nunmap, "gj")
          -- pcall(vim.cmd.nunmap, "gk")
          -- vim.opt_local.undolevels = -1
          vim.opt_local.signcolumn = "no"
          vim.opt_local.relativenumber = false
          vim.opt_local.number = false
          require "interlaced".action.load()
          require "interlaced".ShowChunkNr()
        end,
        sound_feedback = false,
      }
      
    end,
  },
  {
    "sontungexpt/vietnamese.nvim",
    config = function()
      
      {
          "sontungexpt/vietnamese.nvim",
          dependencies = {
              -- if you want to map jj or any key to escape
              "sontungexpt/bim.nvim",
          },nvim-web-devicons
          event = "InsertEnter",
          config = function(
              require("vietnamese").setup()
          end,
      }
      
      
      use {
          "sontungexpt/vietnamese.nvim",
          config = function()
              require("vietnamese").setup()
          end,
      }
      
      
      
      require("vietnamese").setup({
          enabled = true,
          -- "old" | "modern"
          orthography = "modern", -- Default tone strategy
          input_method = "telex", -- Default input method
          excluded = {
              filetypes = {
                  "nvimtree", -- File types to exclude
                  "help",
              }, -- File types to exclude
              buftypes = {
                  "nowrite",
                  "quickfix",
                  "prompt",
              }, -- Buffer types to excludek
          },
          custom_methods =
              -- Tự tạo riêng intput methods của mình
              -- Tạm thời mọi người đừng tự tạo bởi vì mình chưa test (này edge case nên để sau)
              -- Còn néu muôn tạo thì mọi người làm giống trong file config của telex là được
      
              name = {
      
                  -- nhớ import ENUM_DIACRITIC from vietnamese.constant trên đầu file config để lấy enum
                  -- local ENUM_DIACRITIC = require("vietnamese.constant").Diacritic
      
                  tone_keys = {
                      ["s"] = ENUM_DIACRITIC.Acute,
                      ["f"] = ENUM_DIACRITIC.Grave,
                      ["r"] = ENUM_DIACRITIC.Hook,
                      ["x"] = ENUM_DIACRITIC.Tilde,
                      ["j"] = ENUM_DIACRITIC.Dot,
                  },
                  tone_removal_keys = {
                      ["z"] = true,
                  },
                  shape_keys = {
                      w = {
                          a = ENUM_DIACRITIC.Breve,
                          o = ENUM_DIACRITIC.Horn,
                          u = ENUM_DIACRITIC.Horn,
                          e = ENUM_DIACRITIC.Circumflex,
                      },
      
                      a = {
                          a = ENUM_DIACRITIC.Circumflex,
                      },
      
                      e = {
                          e = ENUM_DIACRITIC.Circumflex,
                      },
      
                      o = {
                          o = ENUM_DIACRITIC.Circumflex,
                      },
      
                      d = {
                          d = ENUM_DIACRITIC.HorizontalStroke,
                      },
                  },
      
                  -- Check if a character is a valid input character to make a Vietnamese character
                  --
                  is_diacritic_pressed = function(char)
                      return char:lower():match("[sfrxjzawdeo]") ~= nil
                  end,
              }
      
      
          },
      })
      
      
    end,
  },
  {
    "kiyoon/Korean-IME.nvim",
    config = function()
      
        {
          "kiyoon/Korean-IME.nvim",
          keys = {
            -- lazy load on 한영전환
            {
              "<f12>",
              function()
                require("korean_ime").change_mode()
              end,
              mode = { "i", "n", "x", "s" },
              desc = "한/영",
            },
          },
          config = function()
            require("korean_ime").setup()
      
            vim.keymap.set("i", "<f9>", function()
              require("korean_ime").convert_hanja()
            end, { noremap = true, silent = true, desc = "한자" })
          end,
        },
      
      
      {
        sections = {
          -- ...
          lualine_z = {
            {
              function()
                if not package.loaded["korean_ime"] then
                  return ""
                end
                local mode = require("korean_ime").get_mode()
                if mode == "en" then
                  return "A "
                elseif mode == "ko" then
                  return "한"
                end
              end,
            },
          },
        }
      }
      
      
      -- Karabiner 이용해 Right Command를 F18로 매핑함.
      -- 주의: 단순 예시입니다. string.match 부분을 본인 UI에 맞게 수정해야합니다.
      -- tmux 안에서는 동작하지 않으니 마찬가지로 사용자 tmux UI에 맞게 수정해야합니다.
      hs.hotkey.bind({}, "f18", function()
        local input_source = hs.keycodes.currentSourceID()
        local current_app = hs.application.frontmostApplication()
        print(current_app:name())
      
        if current_app:name() == "WezTerm" then
          -- get current window title
          local window_title = current_app:focusedWindow():title()
          -- ends with vi/vim/nvim
          -- e.g. [1/2] vi
          print(window_title)
          if
            string.match(window_title, " vi$")
            or string.match(window_title, " vim$")
            or string.match(window_title, " nvim$")
            or string.match(window_title, "^vi$")
            or string.match(window_title, "^vim$")
            or string.match(window_title, "^nvim$")
          then
            print("vim")
            local output, status, type, rc = hs.execute("/opt/homebrew/bin/wezterm cli get-text --escapes")
            if
              status == true
              and type == "exit"
              and rc == 0
              and output ~= nil
              and string.match(output, [[nvim .%[38:2::98:114:164m.%[49m─]])
            then
              print("not in command mode")
              if input_source ~= "com.apple.keylayout.ABC" then
                hs.keycodes.currentSourceID("com.apple.keylayout.ABC")
              end
              hs.eventtap.keyStroke({}, "f12")
              return
            end
          end
        end
      
        if input_source == "com.apple.keylayout.ABC" then
          hs.keycodes.currentSourceID("com.apple.inputmethod.Korean.2SetKorean")
        elseif input_source == "com.apple.inputmethod.Korean.2SetKorean" then
          hs.keycodes.currentSourceID("com.apple.keylayout.ABC")
        else
          hs.keycodes.currentSourceID("com.apple.inputmethod.Korean.2SetKorean")
        end
      end)
      
    end,
  },
  {
    "doodleEsc/translator.nvim",
    config = function()
      
      {
          "doodleEsc/translator.nvim",
          dependencies = {
              "MunifTanjim/nui.nvim",
              "nvim-lua/plenary.nvim",
          },
          config = function()
              require("translator").setup({
                  -- your configuration comes here
                  -- if you want to use default configuration, you can omit this
              })
          end,
      }
      
      
      require("translator").setup({
          -- Translation engine configuration
          translate_engine = {
              base_url = "https://api.openai.com/v1",
              api_key = os.getenv("OPENAI_API_KEY"), -- Set your OpenAI API key in environment variable
              model = "gpt-3.5-turbo",
              temperature = 0.8,
              streaming = true, -- Enable streaming translation
          },
          -- Language detection engine configuration
          detect_engine = {
              base_url = "https://api.openai.com/v1",
              api_key = os.getenv("OPENAI_API_KEY"),
              model = "gpt-3.5-turbo",
          },
          -- UI configuration
          ui = {
              width = 0.8, -- Window width (80% of screen)
              height = 0.4, -- Window height (40% of screen)
              border = {
                  style = "rounded",
                  text = {
                      top_source = " Source ",
                      top_target = " Translation ",
                      top_align = "center",
                  },
              },
          },
          -- Translation settings
          proxy = nil, -- Set proxy if needed
          prompt = "Translate the following text from $SOURCE_LANG to $TARGET_LANG, no explanations.:\n
    end,
  },
  {
    "nvim-treesitter/nvim-treesitter",
    config = function()
      
      require('lazy').setup({
        'nvim-treesitter/nvim-treesitter',
        lazy = false,
        branch = 'main',
        build = ':TSUpdate'
      })
      
      
      require'nvim-treesitter'.setup {
        -- Directory to install parsers and queries to
        install_dir = vim.fn.stdpath('data') .. '/site'
      }
      
      
      require'nvim-treesitter'.install { 'rust', 'javascript', 'zig' }
      
      
      require('nvim-treesitter').install({ 'rust', 'javascript', 'zig' }):wait(300000) -- wait max. 5 minutes
      
      
      vim.api.nvim_create_autocmd('FileType', {
        pattern = { '<filetype>' },
        callback = function() vim.treesitter.start() end,
      })
      
      
      vim.wo.foldexpr = 'v:lua.vim.treesitter.foldexpr()'
      
      
      vim.bo.indentexpr = "v:lua.require'nvim-treesitter'.indentexpr()"
      
      
      vim.api.nvim_create_autocmd('User', { pattern = 'TSUpdate',
      callback = function()
        require('nvim-treesitter.parsers').zimbu = {
          install_info = {
            url = 'https://github.com/zimbulang/tree-sitter-zimbu',
            revision = <sha>, -- commit hash for revision to check out; HEAD if missing
            -- optional entries:
            branch = 'develop', -- only needed if different from default branch
            location = 'parser', -- only needed if the parser is in subdirectory of a "monorepo"
            generate = true, -- only needed if repo does not contain pre-generated `src/parser.c`
            generate_from_json = false, -- only needed if repo does not contain `src/grammar.json` either
            queries = 'queries/neovim', -- also install queries from given directory
          },
        }
      end})
      
      
          install_info = {
            path = '~/parsers/tree-sitter-zimbu',
            -- optional entries
            location = 'parser',
            generate = true,
            generate_from_json = false,
            queries = 'queries/neovim', -- symlink queries from given directory
          },
      
      
      vim.treesitter.language.register('zimbu', { 'zu' })
      
      
      vim.api.nvim_create_autocmd('User', { pattern = 'TSUpdate',
      callback = function()
        require('nvim-treesitter.parsers').lua.install_info.generate = true
      end})
      
    end,
  },
  {
    "nvim-treesitter/nvim-treesitter-textobjects",
    config = function()
      
      {
        "nvim-treesitter/nvim-treesitter-textobjects",
      }
      
      
      -- configuration
      require("nvim-treesitter-textobjects").setup {
        select = {
          -- Automatically jump forward to textobj, similar to targets.vim
          lookahead = true,
          -- You can choose the select mode (default is charwise 'v')
          --
          -- Can also be a function which gets passed a table with the keys
          -- * query_string: eg '@function.inner'
          -- * method: eg 'v' or 'o'
          -- and should return the mode ('v', 'V', or '<c-v>') or a table
          -- mapping query_strings to modes.
          selection_modes = {
            ['@parameter.outer'] = 'v', -- charwise
            ['@function.outer'] = 'V', -- linewise
            ['@class.outer'] = '<c-v>', -- blockwise
          },
          -- If you set this to `true` (default is `false`) then any textobject is
          -- extended to include preceding or succeeding whitespace. Succeeding
          -- whitespace has priority in order to act similarly to eg the built-in
          -- `ap`.
          --
          -- Can also be a function which gets passed a table with the keys
          -- * query_string: eg '@function.inner'
          -- * selection_mode: eg 'v'
          -- and should return true of false
          include_surrounding_whitespace = false,
        },
      }
      
      -- keymaps
      -- You can use the capture groups defined in `textobjects.scm`
      vim.keymap.set({ "x", "o" }, "af", function()
        require "nvim-treesitter-textobjects.select".select_textobject("@function.outer", "textobjects")
      end)
      vim.keymap.set({ "x", "o" }, "if", function()
        require "nvim-treesitter-textobjects.select".select_textobject("@function.inner", "textobjects")
      end)
      vim.keymap.set({ "x", "o" }, "ac", function()
        require "nvim-treesitter-textobjects.select".select_textobject("@class.outer", "textobjects")
      end)
      vim.keymap.set({ "x", "o" }, "ic", function()
        require "nvim-treesitter-textobjects.select".select_textobject("@class.inner", "textobjects")
      end)
      -- You can also use captures from other query groups like `locals.scm`
      vim.keymap.set({ "x", "o" }, "as", function()
        require "nvim-treesitter-textobjects.select".select_textobject("@local.scope", "locals")
      end)
      
      
      -- keymaps
      vim.keymap.set("n", "<leader>a", function()
        require("nvim-treesitter-textobjects.swap").swap_next "@parameter.inner"
      end)
      vim.keymap.set("n", "<leader>A", function()
        require("nvim-treesitter-textobjects.swap").swap_previous "@parameter.outer"
      end)
      
      
      -- configuration
      require("nvim-treesitter-textobjects").setup {
        move = {
          -- whether to set jumps in the jumplist
          set_jumps = true,
        },
      }
      
      -- keymaps
      -- You can use the capture groups defined in `textobjects.scm`
      vim.keymap.set({ "n", "x", "o" }, "]m", function()
        require("nvim-treesitter-textobjects.move").goto_next_start("@function.outer", "textobjects")
      end)
      vim.keymap.set({ "n", "x", "o" }, "]]", function()
        require("nvim-treesitter-textobjects.move").goto_next_start("@class.outer", "textobjects")
      end)
      -- You can also pass a list to group multiple queries.
      vim.keymap.set({ "n", "x", "o" }, "]o", function()
        move.goto_next_start({"@loop.inner", "@loop.outer"}, "textobjects")
      end)
      -- You can also use captures from other query groups like `locals.scm` or `folds.scm`
      vim.keymap.set({ "n", "x", "o" }, "]s", function()
        require("nvim-treesitter-textobjects.move").goto_next_start("@local.scope", "locals")
      end)
      vim.keymap.set({ "n", "x", "o" }, "]z", function()
        require("nvim-treesitter-textobjects.move").goto_next_start("@fold", "folds")
      end)
      
      vim.keymap.set({ "n", "x", "o" }, "]M", function()
        require("nvim-treesitter-textobjects.move").goto_next_end("@function.outer", "textobjects")
      end)
      vim.keymap.set({ "n", "x", "o" }, "][", function()
        require("nvim-treesitter-textobjects.move").goto_next_end("@class.outer", "textobjects")
      end)
      
      vim.keymap.set({ "n", "x", "o" }, "[m", function()
        require("nvim-treesitter-textobjects.move").goto_previous_start("@function.outer", "textobjects")
      end)
      vim.keymap.set({ "n", "x", "o" }, "[[", function()
        require("nvim-treesitter-textobjects.move").goto_previous_start("@class.outer", "textobjects")
      end)
      
      vim.keymap.set({ "n", "x", "o" }, "[M", function()
        require("nvim-treesitter-textobjects.move").goto_previous_end("@function.outer", "textobjects")
      end)
      vim.keymap.set({ "n", "x", "o" }, "[]", function()
        require("nvim-treesitter-textobjects.move").goto_previous_end("@class.outer", "textobjects")
      end)
      
      -- Go to either the start or the end, whichever is closer.
      -- Use if you want more granular movements
      vim.keymap.set({ "n", "x", "o" }, "]d", function()
        require("nvim-treesitter-textobjects.move").goto_next("@conditional.outer", "textobjects")
      end)
      vim.keymap.set({ "n", "x", "o" }, "[d", function()
        require("nvim-treesitter-textobjects.move").goto_previous("@conditional.outer", "textobjects")
      end)
      
      
      local ts_repeat_move = require "nvim-treesitter-textobjects.repeatable_move"
      
      -- Repeat movement with ; and ,
      -- ensure ; goes forward and , goes backward regardless of the last direction
      vim.keymap.set({ "n", "x", "o" }, ";", ts_repeat_move.repeat_last_move_next)
      vim.keymap.set({ "n", "x", "o" }, ",", ts_repeat_move.repeat_last_move_previous)
      
      -- vim way: ; goes to the direction you were moving.
      -- vim.keymap.set({ "n", "x", "o" }, ";", ts_repeat_move.repeat_last_move)
      -- vim.keymap.set({ "n", "x", "o" }, ",", ts_repeat_move.repeat_last_move_opposite)
      
      -- Optionally, make builtin f, F, t, T also repeatable with ; and ,
      vim.keymap.set({ "n", "x", "o" }, "f", ts_repeat_move.builtin_f_expr, { expr = true })
      vim.keymap.set({ "n", "x", "o" }, "F", ts_repeat_move.builtin_F_expr, { expr = true })
      vim.keymap.set({ "n", "x", "o" }, "t", ts_repeat_move.builtin_t_expr, { expr = true })
      vim.keymap.set({ "n", "x", "o" }, "T", ts_repeat_move.builtin_T_expr, { expr = true })
      
      
      -- This repeats the last query with always previous direction and to the start of the range.
      vim.keymap.set({ "n", "x", "o" }, "<home>", function()
        ts_repeat_move.repeat_last_move({forward = false, start = true})
      end)
      
      -- This repeats the last query with always next direction and to the end of the range.
      vim.keymap.set({ "n", "x", "o" }, "<end>", function()
        ts_repeat_move.repeat_last_move({forward = true, start = false})
      end)
      
      
      for _, mode in ipairs { "x", "o" } do
        vim.keymap.set(mode, "aF", function()
          select.select_textobject("@custom_capture", "textobjects", mode)
        end)
      end
      
    end,
  },
  {
    "RRethy/nvim-treesitter-textsubjects",
    config = function()
      
      require('nvim-treesitter-textsubjects').configure({
          prev_selection = ',',
          keymaps = {
              ['.'] = 'textsubjects-smart',
              [';'] = 'textsubjects-container-outer',
              ['i;'] = 'textsubjects-container-inner',
          },
      })
      
    end,
  },
  {
    "kylechui/nvim-surround",
    config = function()
      
      {
          "kylechui/nvim-surround",
          version = "^3.0.0", -- Use for stability; omit to use `main` branch for the latest features
          event = "VeryLazy",
          config = function()
              require("nvim-surround").setup({
                  -- Configuration here, or leave empty to use defaults
              })
          end
      }
      
      
      use({
          "kylechui/nvim-surround",
          tag = "*", -- Use for stability; omit to use `main` branch for the latest features
          config = function()
              require("nvim-surround").setup({
                  -- Configuration here, or leave empty to use defaults
              })
          end
      })
      
    end,
  },
  {
    "roobert/surround-ui.nvim",
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-surround.md",
  },
  {
    "m-demare/hlargs.nvim",
    config = function()
      
      return {
          'm-demare/hlargs.nvim',
      }
      
      
      use { 'm-demare/hlargs.nvim' }
      
      
      require('hlargs').setup()
      
      
      require('hlargs').setup {
        color = '#ef9062',
        highlight = {},
        excluded_filetypes = {},
        disable = function(lang, bufnr) -- If changed, `excluded_filetypes` will be ignored
          return vim.tbl_contains(opts.excluded_filetypes, lang)
        end,
        paint_arg_declarations = true,
        paint_arg_usages = true,
        paint_catch_blocks = {
          declarations = false,
          usages = false
        },
        extras = {
          named_parameters = false,
          unused_args = false,
        },
        hl_priority = 120,
        excluded_argnames = {
          declarations = {},
          usages = {
            python = { 'self', 'cls' },
            lua = { 'self' }
          }
        },
        performance = {
          parse_delay = 1,
          slow_parse_delay = 50,
          max_iterations = 400,
          max_concurrent_partial_parses = 30,
          debounce = {
            partial_parse = 3,
            partial_insert_mode = 100,
            total_parse = 700,
            slow_parse = 5000
          }
        }
      }
      -- (You may omit the settings whose defaults you're ok with)
      
      
      require('hlargs').enable()
      require('hlargs').disable()
      require('hlargs').toggle()
      
    end,
  },
  {
    "LhKipp/nvim-nu",
    config = function()
      
      {
          'LhKipp/nvim-nu',
          build = ':TSInstall nu',
          opts = {}
      }
      
      
      vim.keymap.set('n', 'K', vim.lsp.buf.hover, { buffer = true })
      
      
      require'nu'.setup{
          use_lsp_features = true, -- requires https://github.com/jose-elias-alvarez/null-ls.nvim
          -- lsp_feature: all_cmd_names is the source for the cmd name completion.
          -- It can be
          --  * a string, which is evaluated by nushell and the returned list is the source for completions (requires plenary.nvim)
          --  * a list, which is the direct source for completions (e.G. all_cmd_names = {"echo", "to csv", ...})
          --  * a function, returning a list of strings and the return value is used as the source for completions
          all_cmd_names = [[help commands | get name | str join "\n"]]
      }
      
    end,
  },
  {
    "desdic/agrolens.nvim",
    config = function()
      
      {
          -- Enable/Disable debug messages (is put in ~/.cache/nvim/agrolens.log)
          debug = false,
      
          -- Some tree-sitter plugins uses hidden buffers
          -- and we can enable those to if we want
          include_hidden_buffers = false,
      
          -- Make sure the query only runs on
          -- same filetype as the current one
          same_type = true,
      
          -- Match a given string or object
          -- Example `:Telescope agrolens query=callings buffers=all same_type=false match=name,object`
          -- this will query all callings but only those who match the word on the cursor
          match = nil,
      
          -- Disable displaying indententations in telescope
          disable_indentation = false,
      
          -- Alias can be used to join several queries into a single name
          -- Example: `aliases = { yamllist = "docker-compose,github-workflow-steps"}`
          aliases = {},
      
          -- Several internal functions can also be overwritten
          --
          -- Default entry maker (telescope only)
          -- entry_maker = agrolens.entry_maker
          --
          -- Default way of finding current directory
          -- cwd = opts.cwd and vim.fn.expand(opts.cwd) or vim.uv.cwd()
          --
          -- Default previewer (telescope only)
          -- previewer = conf.grep_previewer(opts)
          --
          -- Default sorting (telescope only)
          -- sorter = conf.generic_sorter(opts)
      
          -- Default enable devicons
          disable_devicons = false,
      
          -- display length
          display_width = 150,
      
          -- force long path name even when only a single buffer
          force_long_filepath = false,
      
          -- Layout for snacks picker
          snacks_layout = { preview = true },
      }
      
      
      {
          "desdic/agrolens.nvim",
          opts = {
              force_long_filepath = true,
              debug = false,
              same_type = false,
              include_hidden_buffers = false,
              disable_indentation = true,
              aliases = {
                  yamllist = "docker-compose,github-workflow-steps",
                  work = "cheflxchost,github-workflow-steps,pytest,ipam",
                  all = "cheflxchost,pytest,ipam,functions,labels",
              },
          },
          keys = {
              {
                  "zu",
                  function()
                      require("agrolens.fzf").run({
                          query = "functions,labels",
                          buffers = "all",
                          same_type = false,
                      })
                  end,
                  desc = "find functions and labels",
              },
          },
      }
      
      
      "desdic/agrolens.nvim"
      
      
      require "telescope".load_extension("agrolens")
      
      
      require("telescope").extensions = {
          agrolens = {
             debug = false,
             same_type = true,
             include_hidden_buffers = false,
             disable_indentation = false,
             aliases = {}
          }
      }
      
      
      {
          "desdic/agrolens.nvim",
          opts = {
              force_long_filepath = true,
              debug = false,
              same_type = false,
              include_hidden_buffers = false,
              disable_indentation = true,
              aliases = {
                  yamllist = "docker-compose,github-workflow-steps",
                  work = "cheflxchost,github-workflow-steps,pytest,ipam",
                  all = "cheflxchost,pytest,ipam,functions,labels",
              },
          },
          keys = {
              {
                  "zu",
                  function()
                      require("agrolens.snacks").run({
                          query = "functions,labels",
                          buffers = "all",
                          same_type = false,
                      })
                  end,
                  desc = "find functions and labels",
              },
          },
      }
      
      
      require("agrolens").generate({}))
      
    end,
  },
  {
    "IndianBoy42/tree-sitter-just",
    config = function()
      
      use "IndianBoy42/tree-sitter-just"
      
      
      require("nvim-treesitter.parsers").get_parser_configs().just = {
        install_info = {
          url = "https://github.com/IndianBoy42/tree-sitter-just", -- local path or git repo
          files = { "src/parser.c", "src/scanner.c" },
          branch = "main",
          -- use_makefile = true -- this may be necessary on MacOS (try if you see compiler errors)
        },
        maintainers = { "@IndianBoy42" },
      }
      
    end,
  },
  {
    "fei6409/log-highlight.nvim",
    config = function()
      
      {
          'fei6409/log-highlight.nvim',
          opts = {},
      },
      
      
      require('log-highlight').setup {
          ---@type string|string[]: File extensions. Default: 'log'
          extension = 'log',
      
          ---@type string|string[]: File names or full file paths. Default: {}
          filename = {
              'syslog',
          },
      
          ---@type string|string[]: File name/path glob patterns. Default: {}
          pattern = {
              -- Use `%` to escape special characters and match them literally.
              '%/var%/log%/.*',
              'console%-ramoops.*',
              'log.*%.txt',
              'logcat.*',
          },
      
          ---@type table<string, string|string[]>: Custom keywords to highlight.
          ---This allows you to define custom keywords to be highlighted based on
          ---the group.
          ---
          ---The following highlight groups are supported:
          ---    'error', 'warning', 'info', 'debug' and 'pass'.
          ---
          ---The value for each group can be a string or a list of strings.
          ---All groups are empty by default. Keywords are case-sensitive.
          keyword = {
              error = 'ERROR_MSG',
              warning = { 'WARN_X', 'WARN_Y' },
              info = { 'INFORMATION' },
              debug = {},
              pass = {},
          },
      }
      
    end,
  },
  {
    "norcalli/snippets.nvim",
    config = function()
      
      require'snippets'.snippets = {
        -- The _global dictionary acts as a global fallback.
        -- If a key is not found for the specific filetype, then
        --  it will be lookup up in the _global dictionary.
        _global = {
          -- Insert a basic snippet, which is a string.
          todo = "TODO(ashkan): ";
      
          uname = function() return vim.loop.os_uname().sysname end;
          date = os.date;
      
          -- Evaluate at the time of the snippet expansion and insert it. You
          --  can put arbitrary lua functions inside of the =... block as a
          --  dynamic placeholder. In this case, for an anonymous variable
          --  which doesn't take user input and is evaluated at the start.
          epoch = "${=os.time()}";
          -- Equivalent to above.
          epoch = function() return os.time() end;
      
          -- Use the expansion to read the username dynamically.
          note = [[NOTE(${=io.popen("id -un"):read"*l"}): ]];
      
          -- Do the same as above, but by using $1, we can make it user input.
          -- That means that the user will be prompted at the field during expansion.
          -- You can *EITHER* specify an expression as a placeholder for a variable
          --  or a literal string/snippet using `${var:...}`, but not both.
          note = [[NOTE(${1=io.popen("id -un"):read"*l"}): ]];
        };
        lua = {
          -- Snippets can be used inside of placeholders, but the variables used in
          -- the placeholder *must* be used outside of the placeholder. This could
          -- potentially change in the future if someone convinces me it's a good
          -- idea to support it. (it was a deliberate choice)
          req = [[local ${2:$1} = require '$1']];
      
          -- A snippet with a placeholder using :... and multiple variables.
          ["for"] = "for ${1:i}, ${2:v} in ipairs(${3:t}) do\n$0\nend";
          -- This is equivalent to above, but looks nicer (to me) using [[]] strings.
          -- Notice $0 to indicate where the cursor should go at the end of expansion.
          ["for"] = [[
      for ${1:i}, ${2:v} in ipairs(${3:t}) do
        $0
      end]];
        };
        c = {
          -- Variables can be repeated, and the value of what the user puts in will be
          -- expanded at every position where the bare variable is used (i.e. $1, $2...)
          ["#if"] = [[
      #if ${1:CONDITION}
      $0
      #endif // $1
      ]];
      
          -- Here is where we get to advanced usage. The `|...` block is a transformation
          --  which is applied to the result of the variable *at the position*.
          -- Inside of this block, the special variable `S` is defined. Its usage should be
          --  obvious based on its usage in the following snippet. If not, read #Details below.
          --
          -- This is an important note:
          --   Transformations don't apply to every position for repeated variables, only
          --   at which it is defined.
          --
          -- You'll also see at the bottom `${|S[1]:gsub("%s+", "_")}`. This is a transformation
          --  just like above, except that without a variable name, it'll just be evaluated at
          --  the end of the snippet expansion. In this example, it's using the value of variable 1
          --  and replacing whitespace with underscores.
          guard = [[
      #ifndef AK_${1:header name|S.v:upper():gsub("%s+", "_")}_H_
      #define AK_$1_H_
      
      // This is a header for $1
      
      int ${1|S.v:lower():gsub("%s+", "_")} = 123;
      
      $0
      
      #endif // AK_${|S[1]:gsub("%s+", "_")}_H_
      ]];
      
          -- This is also illegal because it makes no sense, adding a transformation
          --  to an expression is redundant.
          -- ["inc"] = [[#include "${=vim.fn.expand("%:t")|S.v:upper()}"]];
      
          -- Just do this instead.
          inc = [[#include "${=vim.fn.expand("%:t"):upper()}"]];
      
          -- The final important note is the use of negative number variables.
          -- Negative variables *never* ask for user input, but otherwise behave
          --  like normal variables.
          -- This can be useful for storing the value of an expression, and repeating
          --  it in multiple locations.
          -- The following snippet will ask for the user's input using `input()` *once*,
          --  but use the value in multiple places.
          user_input = [[hey? ${-1=vim.fn.input("what's up? ")} = ${-1}]];
        };
      }
      
      -- And now for some examples of snippets I actually use.
      local snippets = require'snippets'
      local U = require'snippets.utils'
      snippets.snippets = {
        lua = {
          req = [[local ${2:${1|S.v:match"([^.()]+)[()]*$"}} = require '$1']];
          func = [[function${1|vim.trim(S.v):gsub("^%S"," %0")}(${2|vim.trim(S.v)})$0 end]];
          ["local"] = [[local ${2:${1|S.v:match"([^.()]+)[()]*$"}} = ${1}]];
          -- Match the indentation of the current line for newlines.
          ["for"] = U.match_indentation [[
      for ${1:i}, ${2:v} in ipairs(${3:t}) do
        $0
      end]];
        };
        _global = {
          -- If you aren't inside of a comment, make the line a comment.
          copyright = U.force_comment [[Copyright (C) Ashkan Kiani ${=os.date("%Y")}]];
        };
      }
      
      
      local S = require'snippets'
      local snippets = S.snippets
      snippets.c.guard = "ifndef boooo"
      S.snippets = snippets
      
      
      {
        order     = number;
        is_input  = nil | boolean;
        id        = nil | number | string;
        default   = nil | string | function;
        transform = nil | function;
      }
      
      
      require'snippets.parser'.parse_snippet [[\usepackage[$2]{$1}]] == {
        "\\usepackage[", {default = "",id = 2,is_input = true,order = 2},
          "]{",
          { default = "",id = 1,is_input = true,order = 1},
          "}"
      }
      
      require'snippets.parser'.parse_snippet [[function${1|vim.trim(S.v):gsub("^%S"," %0")}(${2|vim.trim(S.v)})$0 end]] == {
        "function", { default = "",id = 1,is_input = true,order = 1,transform = <function 1>,<metatable> = <1>{}},
          "(", {default = "",id = 2,is_input = true,order = 2,transform = <function 2>,<metatable> = <table 1>},
          ")", {default = "",id = 0,is_input = false,order = 0,<metatable> = <table 1>},
          " end"
      }
      
      
      local U = require'snippets.utils'
      
      local function note_snippet(header)
        -- Put a dummy value for -1 and add a default later.
        local S = [[
      ${-1}:
       $0
         - ashkan, ${=os.date()}]]
        S = U.force_comment(S)
        S = U.match_indentation(S)
        return U.iterate_variables_by_id(S, -1, function(v)
          v.default = header
        end)
      end
      
      require'snippets'.snippets = {
        _global = {
          todo = note_snippet "TODO";
          note = note_snippet "NOTE";
        };
      }
      
      
      require'snippets'.set_ux(require'snippets.inserters.vim_input')
      
    end,
  },
  {
    "L3MON4D3/LuaSnip",
    config = function()
      
        use({
        	"L3MON4D3/LuaSnip",
        	-- follow latest release.
        	tag = "v2.*", -- Replace <CurrentMajor> by the latest released major (first number of latest release)
        	-- install jsregexp (optional!:).
        	run = "make install_jsregexp"
        })
        
      
        {
        	"L3MON4D3/LuaSnip",
        	-- follow latest release.
        	version = "v2.*", -- Replace <CurrentMajor> by the latest released major (first number of latest release)
        	-- install jsregexp (optional!).
        	build = "make install_jsregexp"
        }
        
      
      local ls = require("luasnip")
      
      vim.keymap.set({"i"}, "<C-K>", function() ls.expand() end, {silent = true})
      vim.keymap.set({"i", "s"}, "<C-L>", function() ls.jump( 1) end, {silent = true})
      vim.keymap.set({"i", "s"}, "<C-J>", function() ls.jump(-1) end, {silent = true})
      
      vim.keymap.set({"i", "s"}, "<C-E>", function()
      	if ls.choice_active() then
      		ls.change_choice(1)
      	end
      end, {silent = true})
      
      
          require("luasnip.loaders.from_vscode").lazy_load()
          
      
          -- load snippets from path/of/your/nvim/config/my-cool-snippets
          require("luasnip.loaders.from_vscode").lazy_load({ paths = { "./my-cool-snippets" } })
          
      
          require("luasnip.loaders.from_snipmate").lazy_load()
          
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-snippets.md",
  },
  {
    "smjonas/snippet-converter.nvim",
    config = function()
      
      use {
        "smjonas/snippet-converter.nvim",
        -- SnippetConverter uses semantic versioning. Example: use version = "1.*" to avoid breaking changes on version 1.
        -- Uncomment the next line to follow stable releases only.
        -- tag = "*",
        config = function()
          local template = {
            -- name = "t1", (optionally give your template a name to refer to it in the `ConvertSnippets` command)
            sources = {
              ultisnips = {
                -- Add snippets from (plugin) folders or individual files on your runtimepath...
                "./vim-snippets/UltiSnips",
                "./latex-snippets/tex.snippets",
                -- ...or use absolute paths on your system.
                vim.fn.stdpath("config") .. "/UltiSnips",
              },
              snipmate = {
                "vim-snippets/snippets",
              },
            },
            output = {
              -- Specify the output formats and paths
              vscode_luasnip = {
                vim.fn.stdpath("config") .. "/luasnip_snippets",
              },
            },
          }
      
          require("snippet_converter").setup {
            templates = { template },
            -- To change the default settings (see configuration section in the documentation)
            -- settings = {},
          }
        end
      }
      
    end,
  },
  {
    "dcampos/nvim-snippy",
    config = function()
      
      local map = vim.keymap.set
      
      map({ 'i', 's' }, '<Tab>', function()
          return require('snippy').can_expand_or_advance() and '<Plug>(snippy-expand-or-advance)' or '<Tab>'
      end, { expr = true })
      map({ 'i', 's' }, '<S-Tab>', function()
          return require('snippy').can_jump(-1) and '<Plug>(snippy-previous)' or '<S-Tab>'
      end, { expr = true })
      map('x', '<Tab>', '<Plug>(snippy-cut-text)')
      
      
      require('snippy').setup({
          -- Custom options
      })
      
    end,
  },
  {
    "ellisonleao/carbon-now.nvim",
    config = function()
      
      use {"ellisonleao/carbon-now.nvim", config = function() require('carbon-now').setup() end}
      
      
      {
        "ellisonleao/carbon-now.nvim",
        lazy = true,
        cmd = "CarbonNow",
        ---@param opts cn.ConfigSchema
        opts = { [[ your custom config here ]] }
      }
      
      
      {
        base_url = "https://carbon.now.sh/",
        options = {
          bg = "gray",
          drop_shadow_blur = "68px",
          drop_shadow = false,
          drop_shadow_offset_y = "20px",
          font_family = "Hack",
          font_size = "18px",
          line_height = "133%",
          line_numbers = true,
          theme = "monokai",
          titlebar = "Made with carbon-now.nvim",
          watermark = false,
          width = "680",
          window_theme = "sharp",
          padding_horizontal = "0px",
          padding_vertical = "0px",
        },
      }
      
      
      local carbon = require('carbon-now')
      carbon.setup({
        options = {
          theme = "solarized",
          font_family = "Monoid",
        }
      })
      
      
      vim.keymap.set("v", "<leader>cn", ":CarbonNow<CR>", { silent = true })
      
    end,
  },
  {
    "TobinPalmer/rayso.nvim",
    config = function()
      
      return {
        'TobinPalmer/rayso.nvim',
        cmd = { 'Rayso' },
        config = function()
          require('rayso').setup {}
        end
      }
      
      
      require('rayso').setup {
        base_url = 'https://ray.so/', -- Default URL
        open_cmd = 'firefox', -- On MacOS, will open with open -a firefox.app. Other OS's are untested.
        options = {
          background = true, -- If the screenshot should have a background.
          dark_mode = true, -- If the screenshot should be in dark mode.
          logging_path = '', -- Path to create a log file in.
          logging_file = 'rayso', -- Name of log file, will be a markdown file, ex rayso.md.
          logging_enabled = false, -- If you enable the logging file.
          padding = 32, -- The default padding that the screenshot will have.
          theme = 'crimson', -- Theme
          title = 'Untitled', -- Default title
        }
      }
      
      
      return {
        'TobinPalmer/rayso.nvim',
        config = function()
          require('rayso').setup {
            open_cmd = 'chromium',
            options = {
              logging_path = '/Users/tobin/Documents/Rayso/', -- Notices the trailing slash
              logging_file = 'rayso',
              logging_enabled = true,
              theme = 'midnight',
            },
          }
          vim.keymap.set('v', '<leader>rs', require('lib.create').create_snippet)
        end,
      }
      
      
      ---@param file string
      ---@return boolean
      local function file_exists(file)
        local f = io.open(file, 'rb')
        if f then
      ...
      
      
      -- Gets the open command from the config
      local function get_open_command()
        -- On a mac
        if vim.fn.has('macunix') then
          return 'open -a ' .. M.config.open_cmd .. '.app'
      ...
      
    end,
  },
  {
    "mrcjkb/haskell-snippets.nvim",
    config = function()
      
      local ls = require('luasnip')
      ls.setup {
        -- Add your LuaSnip config
      }
      local haskell_snippets = require('haskell-snippets').all
      ls.add_snippets('haskell', haskell_snippets, { key = 'haskell' })
      
    end,
  },
  {
    "rafamadriz/friendly-snippets",
    config = function()
      
      { "rafamadriz/friendly-snippets" }
      
      
      > {
      >   "L3MON4D3/LuaSnip",
      >   dependencies = { "rafamadriz/friendly-snippets" },
      > }
      > 
      
      use "rafamadriz/friendly-snippets"
      
      
      require'luasnip'.filetype_extend("ruby", {"rails"})
      
      
      -- will exclude all javascript snippets
      require("luasnip.loaders.from_vscode").load {
          exclude = { "javascript" },
      }
      
    end,
  },
  {
    "cvigilv/esqueleto.nvim",
    config = function()
      
      {
        'cvigilv/esqueleto.nvim',
        opts = {},
      }
      
      
      require("packer").startup(function()
        use({
          "cvigilv/esqueleto.nvim",
          config = function()
            require("esqueleto").setup()
          end,
        })
      end)
      
      
      require("paq")({
        { "cvigilv/esqueleto.nvim" },
      })
      
      
      require("esqueleto").setup(
        {
          patterns = { "LICENSE", "python" },
        }
      )
      
      
      ---@class Esqueleto.Config
      ---@field autouse boolean Automatically use templates if its the only one available
      ---@field directories string|table<string> Directory or directories to search for templates
      ---@field patterns function|table<string> Function to get patterns from a directory or list of patterns
      ---@field wildcards Esqueleto.WildcardConfig Wildcard configuration options
      ---@field advanced Esqueleto.AdvancedConfig Advanced configuration options
      
      ---@class Esqueleto.WildcardConfig
      ---@field expand boolean Enable wildcard expansion
      ---@field lookup table<string, function|string> Lookup table for wildcards
      
      ---@class Esqueleto.AdvancedConfig
      ---@field ignored function|table<string> File patterns to ignore template insertion
      ---@field ignore_os_files boolean Ignore OS-specific files
      
      ---@type Esqueleto.Config
      {
        -- Standard options
        autouse = true, -- whether to auto-use a template if it's the only one for a pattern
        directories = { vim.fn.stdpath("config") .. "/skeletons" }, -- template directories
        patterns = function(dir) return vim.fn.readdir(dir) end, -- trigger patterns for file creation,
                                                                 -- file name trigger has priority
      
        -- Wild-card options
        ---@type Esqueleto.WildcardConfig
        wildcards = {
          expand = true, -- whether to expand wild-cards
          lookup = { -- wild-cards look-up table
            -- File-specific
            ["filename"] = function() return vim.fn.expand("%:t:r") end,
            ["fileabspath"] = function() return vim.fn.expand("%:p") end,
            ["filerelpath"] = function() return vim.fn.expand("%:p:~") end,
            ["fileext"] = function() return vim.fn.expand("%:e") end,
            ["filetype"] = function() return vim.bo.filetype end,
      
            -- Datetime-specific
            ["date"] = function() return os.date("%Y%m%d", os.time()) end,
            ["year"] = function() return os.date("%Y", os.time()) end,
            ["month"] = function() return os.date("%m", os.time()) end,
            ["day"] = function() return os.date("%d", os.time()) end,
            ["time"] = function() return os.date("%T", os.time()) end,
      
            -- System-specific
            ["host"] = utils.capture("hostname", false),
            ["user"] = os.getenv("USER"),
      
            -- Github-specific
            ["gh-email"] = utils.capture("git config user.email", false),
            ["gh-user"] = utils.capture("git config user.name", false),
          },
        },
      
        -- Advanced options
        ---@type Esqueleto.AdvancesConfig
        advanced = {
          ignored = {}, -- List of glob patterns or function that determines if a file is ignored
          ignore_os_files = true, -- whether to ignore OS files (e.g. .DS_Store)
        }
      }
      
      
      require("esqueleto").setup(
        {
          patterns = { "LICENSE", "python", "cli.py" },
        }
      )
      
    end,
  },
  {
    "chrisgrieser/nvim-scissors",
    config = function()
      
      -- lazy.nvim
      {
      	"chrisgrieser/nvim-scissors",
      	dependencies = "nvim-telescope/telescope.nvim", -- if using telescope
      	opts = {
      		snippetDir = "path/to/your/snippetFolder",
      	} 
      },
      
      -- packer
      use {
      	"chrisgrieser/nvim-scissors",
      	dependencies = "nvim-telescope/telescope.nvim", -- if using telescope
      	config = function()
      		require("scissors").setup ({
      			snippetDir = "path/to/your/snippetFolder",
      		})
      	end,
      }
      
      
      require("luasnip.loaders.from_vscode").lazy_load {
      	paths = { "path/to/your/snippetFolder" },
      }
      
      
      require("scissors").setup({
      	snippetDir = vim.fn.stdpath("config") .. "/snippets",
      })
      
      
      require("blink.cmp").setup {
      	sources = {
      		providers = {
      			snippets = {
      				opts = {
      					search_paths = { "path/to/your/snippetFolder" },
      				},
      			}
      		}
      	}
      }
      
      
      require("lspconfig").basics_ls.setup({
          settings = {
              snippet = {
                  enable = true,
                  sources = { "path/to/your/snippetFolder" }
              },
          }
      })
      
      
      require("nvim-snippets").setup {
      	search_paths = { "path/to/your/snippetFolder" },
      }
      
      
      vim.g.vsnip_snippet_dir = "path/to/your/snippetFolder"
      -- OR
      vim.g.vsnip_snippet_dirs = { "path/to/your/snippetFolder" }
      
      
      require("yasp").setup {
      	paths = {
      		vim.fn.stdpath("config") .. "/snippets/package.json",
      	},
      	descs = { "user snippets" },
      }
      
      
      vim.keymap.set(
      	"n",
      	"<leader>se",
      	function() require("scissors").editSnippet() end,
      	{ desc = "Snippet: Edit" }
      )
      
      -- when used in visual mode, prefills the selection as snippet body
      vim.keymap.set(
      	{ "n", "x" },
      	"<leader>sa",
      	function() require("scissors").addNewSnippet() end,
      	{ desc = "Snippet: Add" }
      )
      
      
      -- default settings
      require("scissors").setup {
      	snippetDir = vim.fn.stdpath("config") .. "/snippets",
      	editSnippetPopup = {
      		height = 0.4, -- relative to the window, between 0-1
      		width = 0.6,
      		border = getBorder(), -- `vim.o.winborder` on nvim 0.11, otherwise "rounded"
      		keymaps = {
      			-- if not mentioned otherwise, the keymaps apply to normal mode
      			cancel = "q",
      			saveChanges = "<CR>", -- alternatively, can also use `:w`
      			goBackToSearch = "<BS>",
      			deleteSnippet = "<C-BS>",
      			duplicateSnippet = "<C-d>",
      			openInFile = "<C-o>",
      			insertNextPlaceholder = "<C-p>", -- insert & normal mode
      			showHelp = "?",
      		},
      	},
      
      	snippetSelection = {
      		picker = "auto", ---@type "auto"|"telescope"|"snacks"|"vim.ui.select"
      
      		telescope = {
      			-- By default, the query only searches snippet prefixes. Set this to
      			-- `true` to also search the body of the snippets.
      			alsoSearchSnippetBody = false,
      
      			-- accepts the common telescope picker config
      			opts = {
      				layout_strategy = "horizontal",
      				layout_config = {
      					horizontal = { width = 0.9 },
      					preview_width = 0.6,
      				},
      			},
      		},
      
      		-- `snacks` picker configurable via snacks config, 
      		-- see https://github.com/folke/snacks.nvim/blob/main/docs/picker.md
      	},
      
      	-- `none` writes as a minified json file using `vim.encode.json`.
      	-- `yq`/`jq` ensure formatted & sorted json files, which is relevant when
      	-- you version control your snippets. To use a custom formatter, set to a
      	-- list of strings, which will then be passed to `vim.system()`.
      	-- TIP: `jq` is already pre-installed on newer versions of macOS.
      	---@type "yq"|"jq"|"none"|string[]
      	jsonFormatter = "none",
      
      	backdrop = {
      		enabled = true,
      		blend = 50, -- between 0-100
      	},
      	icons = {
      		scissors = "󰩫",
      	},
      }
      
      
      require("luasnip").setup {
      	store_selection_keys = "<Tab>",
      }
      
    end,
  },
  {
    "guilherme-puida/tesoura.nvim",
    config = function()
      
      {
        'guilherme-puida/tesoura.nvim',
        opts = {} -- see the configuration section below.
      }
      
      
      {
        -- highlight snippet content on the documentation window.
        highlight = true,
        -- filetypes where snippets won't be setup.
        ignored_filetypes = {},
        -- set up autocmd to automatically initialize snippets when a new filetype is opened.
        setup_autocmd = false,
        -- your snippets!
        snippets = {},
        -- the nvim_cmp source name.
        source_name = 'tesoura',
      }
      
      
      local snippet = {
        prefix = 'hello',
        body = 'world',
      }
      
      
      local snippet = {
        prefix = 'date',
        body = function() return tostring(os.date '%F') end,
      }
      
      
      local snippets = {
        ['*'] = {
          { prefix = 'copyright', body = 'Copyright (c) 2024 Guilherme Puida Moreira' },
        },
        c = {
          { prefix = '#i', body = '#include "$1"$0' },
        }
      }
      
    end,
  },
  {
    "gennaro-tedesco/nvim-peekup",
  },
  {
    "tversteeg/registers.nvim",
    config = function()
      
      use {
      	"tversteeg/registers.nvim",
      	config = function()
      		require("registers").setup()
      	end,
      }
      
      
      {
      	"tversteeg/registers.nvim",
      	cmd = "Registers",
      	config = true,
      	keys = {
      		{ "\"",    mode = { "n", "v" } },
      		{ "<C-R>", mode = "i" }
      	},
      	name = "registers",
      }
      
      
      use {
          "tversteeg/registers.nvim",
          config = function()
              local registers = require("registers")
              registers.setup({
      
      
              -- Show these registers in the order of the string
              show = "*+\"-/_=#%.0123456789abcdefghijklmnopqrstuvwxyz:",
              -- Show a line at the bottom with registers that aren't filled
              show_empty = true,
              -- Expose the :Registers user command
              register_user_command = true,
              -- Always transfer all selected registers to the system clipboard
              system_clipboard = true,
              -- Don't show whitespace at the begin and end of the register's content
              trim_whitespace = true,
              -- Don't show registers which are exclusively filled with whitespace
              hide_only_whitespace = true,
              -- Show a character next to the register name indicating how the register will be applied
              show_register_types = true,
              bind_keys = {
                  -- Show the window when pressing " in normal mode, applying the selected register as part of a motion, which is the default behavior of Neovim
                  normal    = registers.show_window({ mode = "motion" }),
                  -- Show the window when pressing " in visual mode, applying the selected register as part of a motion, which is the default behavior of Neovim
                  visual    = registers.show_window({ mode = "motion" }),
                  -- Show the window when pressing <C-R> in insert mode, inserting the selected register, which is the default behavior of Neovim
                  insert    = registers.show_window({ mode = "insert" }),
      
                  -- When pressing the key of a register, apply it with a very small delay, which will also highlight the selected register
                  registers = registers.apply_register({ delay = 0.1 }),
                  -- Immediately apply the selected register line when pressing the return key
                  ["<CR>"]  = registers.apply_register(),
                  -- Close the registers window when pressing the Esc key
                  ["<Esc>"] = registers.close_window(),
      
                  -- Move the cursor in the registers window down when pressing <C-n>
                  ["<C-n>"] = registers.move_cursor_down(),
                  -- Move the cursor in the registers window up when pressing <C-p>
                  ["<C-p>"] = registers.move_cursor_up(),
                  -- Move the cursor in the registers window down when pressing <C-j>
                  ["<C-j>"] = registers.move_cursor_down(),
                  -- Move the cursor in the registers window up when pressing <C-k>
                  ["<C-k>"] = registers.move_cursor_up(),
                  -- Clear the register of the highlighted line when pressing <DeL>
                  ["<Del>"] = registers.clear_highlighted_register(),
                  -- Clear the register of the highlighted line when pressing <BS>
                  ["<BS>"]  = registers.clear_highlighted_register(),
              },
              events = {
                  -- When a register line is highlighted, show a preview in the main buffer with how the register will be applied, but only if the register will be inserted or pasted
                  on_register_highlighted = registers.preview_highlighted_register({ if_mode = { "insert", "paste" } }),
              },
              symbols = {
                  -- Show a special character for line breaks
                  newline = "⏎",
                  -- Show space characters without changes
                  space = " ",
                  -- Show a special character for tabs
                  tab = "·",
                  -- The character to show when a register will be applied in a char-wise fashion
                  register_type_charwise = "ᶜ",
                  -- The character to show when a register will be applied in a line-wise fashion
                  register_type_linewise = "ˡ",
                  -- The character to show when a register will be applied in a block-wise fashion
                  register_type_blockwise = "ᵇ",
              },
              window = {
                  -- The window can't be wider than 100 characters
                  max_width = 100,
                  -- Show a small highlight in the sign column for the line the cursor is on
                  highlight_cursorline = true,
                  -- Don't draw a border around the registers window
                  border = "none",
                  -- Apply a tiny bit of transparency to the the window, letting some characters behind it bleed through
                  transparency = 10,
              },
              -- Highlight the sign registers as regular Neovim highlights
              sign_highlights = {
                  cursorlinesign = "CursorLine",
                  signcolumn = "SignColumn",
                  cursorline = "Visual",
                  selection = "Constant",
                  default = "Function",
                  unnamed = "Statement",
                  read_only = "Type",
                  expression = "Exception",
                  black_hole = "Error",
                  alternate_buffer = "Operator",
                  last_search = "Tag",
                  delete = "Special",
                  yank = "Delimiter",
                  history = "Number",
                  named = "Todo",
              },
      
      
              })
          end,
      }
      
    end,
  },
  {
    "AckslD/nvim-neoclip.lua",
    config = function()
      
      require {
        "AckslD/nvim-neoclip.lua",
        dependencies = {
          -- you'll need at least one of these
          -- {'nvim-telescope/telescope.nvim'},
          -- {'ibhagwan/fzf-lua'},
        },
        config = function()
          require('neoclip').setup()
        end,
      }
      
      
      use {
        "AckslD/nvim-neoclip.lua",
        requires = {
          -- you'll need at least one of these
          -- {'nvim-telescope/telescope.nvim'},
          -- {'ibhagwan/fzf-lua'},
        },
        config = function()
          require('neoclip').setup()
        end,
      }
      
      
      require {
        "AckslD/nvim-neoclip.lua",
        dependencies = {
          {'kkharji/sqlite.lua', module = 'sqlite'},
          -- you'll need at least one of these
          -- {'nvim-telescope/telescope.nvim'},
          -- {'ibhagwan/fzf-lua'},
        },
        config = function()
          require('neoclip').setup()
        end,
      }
      
      
      use {
        "AckslD/nvim-neoclip.lua",
        requires = {
          {'kkharji/sqlite.lua', module = 'sqlite'},
          -- you'll need at least one of these
          -- {'nvim-telescope/telescope.nvim'},
          -- {'ibhagwan/fzf-lua'},
        },
        config = function()
          require('neoclip').setup()
        end,
      }
      
      
      require('neoclip').setup({
        history = 1000,
        enable_persistent_history = false,
        length_limit = 1048576,
        continuous_sync = false,
        db_path = vim.fn.stdpath("data") .. "/databases/neoclip.sqlite3",
        filter = nil,
        preview = true,
        prompt = nil,
        default_register = '"',
        default_register_macros = 'q',
        enable_macro_history = true,
        content_spec_column = false,
        disable_keycodes_parsing = false,
        dedent_picker_display = false,
        initial_mode = 'insert',
        on_select = {
      	move_to_front = false,
      	close_telescope = true,
        },
        on_paste = {
      	set_reg = false,
      	move_to_front = false,
      	close_telescope = true,
        },
        on_replay = {
      	set_reg = false,
      	move_to_front = false,
      	close_telescope = true,
        },
        on_custom_action = {
      	close_telescope = true,
        },
        keys = {
      	telescope = {
      	  i = {
      		select = '<cr>',
      		paste = '<c-p>',
      		paste_behind = '<c-k>',
      		replay = '<c-q>',  -- replay a macro
      		delete = '<c-d>',  -- delete an entry
      		edit = '<c-e>',  -- edit an entry
      		custom = {},
      	  },
      	  n = {
      		select = '<cr>',
      		paste = 'p',
      		--- It is possible to map to more than one key.
      		-- paste = { 'p', '<c-p>' },
      		paste_behind = 'P',
      		replay = 'q',
      		delete = 'd',
      		edit = 'e',
      		custom = {},
      	  },
      	},
      	fzf = {
      	  select = 'default',
      	  paste = 'ctrl-p',
      	  paste_behind = 'ctrl-k',
      	  custom = {},
      	},
        },
      })
      
      
      
      require('neoclip').setup({
        ...
        keys = {
          ...
          n = {
            ...
            custom = {
              ['<space>'] = function(opts)
                print(vim.inspect(opts))
              end,
            },
          },
        },
      })
      
      
      require('neoclip').setup({
        ...
        keys = {
          ...
          n = {
            ...
            custom = {
              ['<space>'] = function(opts)
                -- do your stuff
                -- ...
                local handlers = require('neoclip.handlers')
                -- optionally set the registers with the entry
                -- handlers.set_registers(opts.register_names, opts.entry)
                -- optionally paste entry
                -- handlers.paste(opts.entry, 'p')
                -- optionally paste entry behind
                -- handlers.paste(opts.entry, 'P')
              end,
            },
          },
        },
      })
      
      
        local function is_whitespace(line)
          return vim.fn.match(line, [[^\s*$]]) ~= -1
        end
      
        local function all(tbl, check)
          for _, entry in ipairs(tbl) do
            if not check(entry) then
              return false
            end
          end
          return true
        end
        
        require('neoclip').setup{
          ...
          filter = function(data)
            return not all(data.event.regcontents, is_whitespace)
          end,
          ...
        }
        
    end,
  },
  {
    "tenxsoydev/karen-yank.nvim",
    config = function()
      
      use "tenxsoydev/karen-yank.nvim"
      
      
      require("karen-yank").setup()
      
      
      { "tenxsoydev/karen-yank.nvim", config = true },
      
      
      require("karen-yank").setup {
        mappings = {
          -- karen controls the use of registers (and probably talks to the manager when things doesn't work as intended)
          -- map something like `<leader><leader>` if you use the plugin inverted
          karen = "y",
          -- false: delete into black hole by default and use registers with karen key
          -- true: use registers by default and delete into black hole with karen key
          invert = false,
          -- disable all if `true` or a table of keymaps [possible values: {"s"|"S"|"d"|"D"|"c"|"C"|"x"|"X"|"p"|"P"|"y"|"Y"}]
          -- "s"/"S" is not mapped by default, due to it's common utilization for plugins like surround or hop
          disable = { "s", "S" },
        },
        number_regs = {
          -- use number registers for yanks and cuts
          enable = true,
          deduplicate = {
            -- prevent populating multiple number registers with the same entries
            enable = true,
            -- will see `yD` pressed at the beginning of a line as a duplicate of `ydd` pressed in the same line
            ignore_whitespace = true,
          },
        },
      }
      
      
      local actions = require("karen-yank.actions")
      
      ---@param vim_parent "d"|"D"|"c"|"C"|"x"|"X"|"s"|"S"
      actions.cut(vim_parent)
      
      ---@param vim_parent "d"|"D"|"c"|"C"|"x"|"X"|"s"|"S"
      actions.delete(vim_parent)
      
      ---@param kind "motion"|"line"|"trail"
      ---@param opts? { preserve_cursor: boolean, preserve_selection: boolean }
      -- default opts = { preserve_cursor = true, preserve_selection = false }
      actions.yank(kind, opts)
      
      ---@param direction "before"|"after"
      ---@param opts? { black_hole: boolean, preserve_selection: boolean }
      -- default opts = { black_hole = true, preserve_selection = false }
      actions.paste(direction, opts)
      
      -- Example mappings (equivalent to defaults)
      local map = vim.keymap.set
      map("", "d", function() return actions.delete("d") end, { expr = true })
      map("", "yd", function() return actions.cut("d") end, { expr = true })
      map("", "D", function() return actions.delete("D") end, { expr = true })
      map("", "yD", function() return actions.cut("D") end, { expr = true })
      map("", "c", function() return actions.delete("c") end, { expr = true })
      map("", "yc", function() return actions.cut("c") end, { expr = true })
      -- ...
      map("", "y", function() return actions.yank("motion") end, { expr = true })
      map("", "yy", function() return actions.yank("line") end, { expr = true })
      map("", "Y", function() return actions.yank("trail") end, { expr = true })
      --
      map("v", "p", function() return actions.paste(direction, { black_hole = true }) end, { expr = true })
      map("v", "yp", function() return actions.paste(direction, { black_hole = false }) end, { expr = true })
      
    end,
  },
  {
    "desdic/macrothis.nvim",
    config = function()
      
      {
          "desdic/macrothis.nvim",
          opts = {},
          keys = {
              { "<Leader>kkd", function() require('macrothis').delete() end, desc = "delete" },
              { "<Leader>kke", function() require('macrothis').edit() end, desc = "edit" },
              { "<Leader>kkl", function() require('macrothis').load() end, desc = "load" },
              { "<Leader>kkn", function() require('macrothis').rename() end, desc = "rename" },
              { "<Leader>kkq", function() require('macrothis').quickfix() end, desc = "run macro on all files in quickfix" },
              { "<Leader>kkr", function() require('macrothis').run() end, desc = "run macro" },
              { "<Leader>kks", function() require('macrothis').save() end, desc = "save" },
              { "<Leader>kkx", function() require('macrothis').register() end, desc = "edit register" },
              { "<Leader>kkp", function() require('macrothis').copy_register_printable() end, desc = "Copy register as printable" },
              { "<Leader>kkm", function() require('macrothis').copy_macro_printable() end, desc = "Copy macro as printable" },
          }
      },
      
      
      require "telescope".load_extension("macrothis")
      
      
      require("telescope").extensions = {
          macrothis = {}
      }
      
    end,
  },
  {
    "kr40/nvim-macros",
    config = function()
      
      {
        "kr40/nvim-macros",
        cmd = {"MacroSave", "MacroYank", "MacroSelect", "MacroDelete"},
        opts = {
        
          json_file_path = vim.fs.normalize(vim.fn.stdpath("config") .. "/macros.json"), -- Location where the macros will be stored
          default_macro_register = "q", -- Use as default register for :MacroYank and :MacroSave and :MacroSelect Raw functions
          json_formatter = "none", -- can be "none" | "jq" | "yq" used to pretty print the json file (jq or yq must be installed!)
          
        }
      }
      
      
      vim.keymap.set('n', '<Leader>t', '^i-<Space>[<Space>]<Space><Esc>', { remap = true })
      
      
      require('nvim-macros').setup({
          json_file_path = "/your/very/own/path/to/macros.json",
          default_macro_register = "a",
          json_formatter = "jq",
      })
      
    end,
  },
  {
    "cbochs/grapple.nvim",
    config = function()
      
      -- Lua
      vim.keymap.set("n", "<leader>m", require("grapple").toggle)
      vim.keymap.set("n", "<leader>M", require("grapple").toggle_tags)
      
      -- User command
      vim.keymap.set("n", "<leader>1", "<cmd>Grapple select index=1<cr>")
      
      
      {
          "cbochs/grapple.nvim",
          dependencies = {
              { "nvim-tree/nvim-web-devicons", lazy = true }
          },
      }
      
      
      use {
          "cbochs/grapple.nvim",
          requires = { "nvim-tree/nvim-web-devicons" }
      }
      
      
      {
          "cbochs/grapple.nvim",
          opts = {
              scope = "git", -- also try out "git_branch"
          },
          event = { "BufReadPost", "BufNewFile" },
          cmd = "Grapple",
          keys = {
              { "<leader>m", "<cmd>Grapple toggle<cr>", desc = "Grapple toggle tag" },
              { "<leader>M", "<cmd>Grapple toggle_tags<cr>", desc = "Grapple open tags window" },
              { "<leader>n", "<cmd>Grapple cycle_tags next<cr>", desc = "Grapple cycle next tag" },
              { "<leader>p", "<cmd>Grapple cycle_tags prev<cr>", desc = "Grapple cycle previous tag" },
          },
      },
      
      
      {
          "cbochs/grapple.nvim",
          opts = {
              scope = "git", -- also try out "git_branch"
              icons = false, -- setting to "true" requires "nvim-web-devicons"
              status = false,
          },
          keys = {
              { "<leader>a", "<cmd>Grapple toggle<cr>", desc = "Tag a file" },
              { "<c-e>", "<cmd>Grapple toggle_tags<cr>", desc = "Toggle tags menu" },
      
              { "<c-h>", "<cmd>Grapple select index=1<cr>", desc = "Select first tag" },
              { "<c-t>", "<cmd>Grapple select index=2<cr>", desc = "Select second tag" },
              { "<c-n>", "<cmd>Grapple select index=3<cr>", desc = "Select third tag" },
              { "<c-s>", "<cmd>Grapple select index=4<cr>", desc = "Select fourth tag" },
      
              { "<c-s-n>", "<cmd>Grapple cycle_tags next<cr>", desc = "Go to next tag" },
              { "<c-s-p>", "<cmd>Grapple cycle_tags prev<cr>", desc = "Go to previous tag" },
          },
      },
      
      
      {
          "cbochs/grapple.nvim",
          dependencies = {
              { "nvim-tree/nvim-web-devicons" }
          },
          opts = {
              scope = "git_branch",
              icons = true,
              quick_select = "123456789",
          },
          keys = {
              { ";", "<cmd>Grapple toggle_tags<cr>", desc = "Toggle tags menu" },
      
              { "<c-s>", "<cmd>Grapple toggle<cr>", desc = "Toggle tag" },
              { "H", "<cmd>Grapple cycle_tags next<cr>", desc = "Go to next tag" },
              { "L", "<cmd>Grapple cycle_tags prev<cr>", desc = "Go to previous tag" },
          },
      },
      
      
      require("grapple").setup({
          ---Grapple save location
          ---@type string
          save_path = vim.fs.joinpath(vim.fn.stdpath("data"), "grapple"),
      
          ---Default scope to use when managing Grapple tags
          ---For more information, please see the Scopes section
          ---@type string
          scope = "git",
      
          ---User-defined scopes or overrides
          ---For more information about scopes, please see the Scope API section
          ---@type grapple.scope_definition[]
          scopes = {},
      
          ---Default scopes provided by Grapple
          ---For more information about default scopes, please see the Scopes section
          ---Disable by setting scope to "false". For example, { lsp = false }
          ---@type table<string, grapple.scope_definition | boolean>
          default_scopes = { ... }
      
          ---Show icons next to tags or scopes in Grapple windows
          ---Requires "nvim-tree/nvim-web-devicons"
          ---@type boolean
          icons = true,
      
          ---Highlight the current selection in Grapple windows
          ---Also, indicates when a tag path does not exist
          ---@type boolean
          status = true,
      
          ---Position a tag's name should be shown in Grapple windows
          ---@type "start" | "end"
          name_pos = "end",
      
          ---How a tag's path should be rendered in Grapple windows
          ---  "relative": show tag path relative to the scope's resolved path
          ---  "basename": show tag path basename and directory hint
          ---@type "basename" | "relative"
          style = "relative",
      
          ---A string of characters used for quick selecting in Grapple windows
          ---An empty string or false will disable quick select
          ---@type string | boolean
          quick_select = "123456789",
      
          ---Default command to use when selecting a tag
          ---@type fun(path: string)
          command = vim.cmd.edit,
      
          ---Time limit used for pruning unused scope (IDs). If a scope's save file
          ---modified time exceeds this limit, then it will be deleted when a prune
          ---requested. Can be an integer (in seconds) or a string time limit
          ---(e.g. "30d" or "2h" or "15m")
          ---@type integer | string
          prune = "30d",
      
          ---User-defined tags title function for Grapple windows
          ---By default, uses the resolved scope's ID
          ---@type fun(scope: grapple.resolved_scope): string?
          tag_title = nil,
      
          ---User-defined scopes title function for Grapple windows
          ---By default, renders "Grapple Scopes"
          ---@type fun(): string?
          scope_title = nil,
      
          ---User-defined loaded scopes title function for Grapple windows
          ---By default, renders "Grapple Loaded Scopes"
          ---@type fun(): string?
          loaded_title = nil,
      
          ---Additional window options for Grapple windows
          ---See :h nvim_open_win
          ---@type grapple.vim.win_opts
          win_opts = {
              -- Can be fractional
              width = 80,
              height = 12,
              row = 0.5,
              col = 0.5,
      
              relative = "editor",
              border = "single",
              focusable = false,
              style = "minimal",
      
              title = "Grapple", -- fallback title for Grapple windows
              title_pos = "center",
              title_padding = " ", -- custom: adds padding around window title
      
              -- footer = "", -- disable footer
              footer_pos = "center",
          },
      })
      
      
      require("grapple").cycle_tags("next", { scope = "cwd" })
      
      
      -- Tag the current buffer
      require("grapple").tag()
      
      -- Tag a file by its file path
      require("grapple").tag({ path = "some_file.lua" })
      
      -- Tag the current buffer in a different scope
      require("grapple").tag({ scope = "global" })
      
      -- Tag the file path under the cursor
      require("grapple").tag({ path = "<cfile>" })
      
      
      -- Remove a tag on the current buffer
      require("grapple").untag()
      
      -- Remove a tag on a file
      require("grapple").untag({ file_path = "{file_path}" })
      
      -- Remove a tag on the current buffer in a different scope
      require("grapple").untag({ scope = "global" })
      
      
      -- Toggle a tag on the current buffer
      require("grapple").toggle()
      
      
      -- Select the third tag
      require("grapple").select({ index = 3 })
      
      
      -- Cycle to the next tagged file
      require("grapple").cycle_tags("next")
      
      -- Cycle to the previous tagged file
      require("grapple").cycle_tags("prev")
      
      
      -- Cycle to the next scope
      require("grapple").cycle_scopes("next")
      
      -- Cycle to the previous scope
      require("grapple").cycle_scopes("prev")
      
      -- Hide a scope during Grapple setup
      require("grapple").setup({
          default_scopes = {
              cwd = { hidden = true }
          }
      })
      
      
      -- Unload the current scope
      require("grapple").unload()
      
      -- Unload a scope (dynamic)
      require("grapple").unload({ scope = "git" })
      
      -- Unload a specific resolved scope ID
      require("grapple").unload({ id = "~/git" })
      
      
      -- Reset the current scope
      require("grapple").reset()
      
      -- Reset a scope (dynamic)
      require("grapple").reset({ scope = "git" })
      
      -- Reset a specific resolved scope ID
      require("grapple").reset({ id = "~/git" })
      
      
      -- Prune using the default time limit
      require("grapple").prune()
      
      -- Prune longer than 30 days
      require("grapple").prune({ limit = "30d" })
      
      -- Prune longer than 6 hours
      require("grapple").prune({ limit = "6h" })
      
      -- Prune longer than 15 minutes
      require("grapple").prune({ limit = "15m" })
      
      -- Prune longer than 120 seconds
      require("grapple").prune({ limit = "120s" })
      require("grapple").prune({ limit = 120 })
      
      
      -- Open the quickfix window for the current scope
      require("grapple").quickfix()
      
      -- Open the quickfix window for a specified scope
      require("grapple").quickfix("global")
      
      
      -- Check whether the current buffer is tagged or not
      require("grapple").exists()
      
      -- Check for a tag in a different scope
      require("grapple").exists({ scope = "global" })
      
      
      -- Search for a tag by index in the current scope
      require("grapple").find({ index = 1 })
      
      -- Search for a named tag in a different scope
      require("grapple").find({ name = "bob", scope = "global" })
      
      
      -- Define a scope during setup
      require("grapple").setup({
          scope = "cwd_branch",
      
          scopes = {
              {
                  name = "cwd_branch",
                  desc = "Current working directory and git branch",
                  fallback = "cwd",
                  cache = {
                      event = { "BufEnter", "FocusGained" },
                      debounce = 1000, -- ms
                  },
                  resolver = function()
                      local git_files = vim.fs.find(".git", {
                          upward = true,
                          stop = vim.loop.os_homedir(),
                      })
      
                      if #git_files == 0 then
                          return
                      end
      
                      local root = vim.loop.cwd()
      
                      local result = vim.fn.system({ "git", "symbolic-ref", "--short", "HEAD" })
                      local branch = vim.trim(string.gsub(result, "\n", ""))
      
                      local id = string.format("%s:%s", root, branch)
                      local path = root
      
                      return id, path
                  end,
              }
          }
      })
      
      -- Define a scope outside of setup
      require("grapple").define_scope({
          name = "projects",
          desc = "Project directory"
          fallback = "cwd",
          cache = { event = "DirChanged" },
          resolver = function()
              local projects_dir = vim.fs.find("projects", {
                  upwards = true,
                  stop = vim.loop.os_homedir()
              })
      
              if #projects_dir == 0 then
                  return nil, nil, "Not in projects dir"
              end
      
              local path = projects_dir[1]
              local id = path
              return id, path, nil
          end
      })
      
      -- Use the scope
      require("grapple").use_scope("projects")
      
      
      -- Clear the cached value (if any) for the "git" scope
      require("grapple").use_scope("git_branch")
      
      
      -- Use a builtin scope
      require("grapple").setup({
          scope = "git_branch",
      })
      
      -- Define and use a custom scope
      require("grapple").setup({
          scope = "custom",
      
          scopes = {
              {
                  name = "custom",
                  fallback = "cwd",
                  cache = { event = "DirChanged" },
                  resolver = function()
                      local path = vim.env.HOME
                      local id = path
                      return id, path
                  end
              }
          }
      })
      
      -- Disable a default scope
      -- Note: be careful to disable default scopes that are used as fallbacks
      require("grapple").setup({
          default_scopes = {
              lsp = false
          }
      })
      
      
      -- Open the tags window for the current scope
      require("grapple").open_tags()
      
      -- Open the tags window for a different scope
      require("grapple").open_tags("global")
      
      
      -- Open the scopes window
      require("grapple").open_scopes()
      
      
      -- Open the loaded scopes window, show only loaded scopes
      require("grapple").open_loaded()
      
      -- Open the loaded scopes window, show both loaded and unloaded scopes
      require("grapple").open_loaded({ all = true })
      
      
      require("telescope").load_extension("grapple")
      
      
      require("grapple").statusline()
      -- Returns "󰛢 [1] 2  3  4"
      
      require("grapple").name_or_index()
      -- Returns "1" or "bob"
      
      -- Modify the statusline options
      require("grapple").setup({
          statusline = {
              icon = "G",
              active = "|%s|",
              inactive = " %s "
          }
      })
      
      
      require("lualine").setup({
          sections = {
              lualine_b = { "grapple" }
          }
      })
      
      
      require("lualine").setup({
          sections = {
              lualine_b = {
                  {
                      function()
                          return require("grapple").name_or_index()
                      end,
                      cond = function()
                          return package.loaded["grapple"] and require("grapple").exists()
                      end
                  }
              }
          }
      })
      
    end,
  },
  {
    "chentoast/marks.nvim",
    config = function()
      
      require'marks'.setup {
        -- whether to map keybinds or not. default true
        default_mappings = true,
        -- which builtin marks to show. default {}
        builtin_marks = { ".", "<", ">", "^" },
        -- whether movements cycle back to the beginning/end of buffer. default true
        cyclic = true,
        -- whether the shada file is updated after modifying uppercase marks. default false
        force_write_shada = false,
        -- how often (in ms) to redraw signs/recompute mark positions. 
        -- higher values will have better performance but may cause visual lag, 
        -- while lower values may cause performance penalties. default 150.
        refresh_interval = 250,
        -- sign priorities for each type of mark - builtin marks, uppercase marks, lowercase
        -- marks, and bookmarks.
        -- can be either a table with all/none of the keys, or a single number, in which case
        -- the priority applies to all marks.
        -- default 10.
        sign_priority = { lower=10, upper=15, builtin=8, bookmark=20 },
        -- disables mark tracking for specific filetypes. default {}
        excluded_filetypes = {},
        -- disables mark tracking for specific buftypes. default {}
        excluded_buftypes = {},
        -- marks.nvim allows you to configure up to 10 bookmark groups, each with its own
        -- sign/virttext. Bookmarks can be used to group together positions and quickly move
        -- across multiple buffers. default sign is '!@#$%^&*()' (from 0 to 9), and
        -- default virt_text is "".
        bookmark_0 = {
          sign = "⚑",
          virt_text = "hello world",
          -- explicitly prompt for a virtual line annotation when setting a bookmark from this group.
          -- defaults to false.
          annotate = false,
        },
        mappings = {}
      }
      
      
      require'marks'.setup {
        mappings = {
          set_next = "m,",
          next = "m]",
          preview = "m:",
          set_bookmark0 = "m0",
          prev = false -- pass false to disable only this default mapping
        }
      }
      
    end,
  },
  {
    "ThePrimeagen/harpoon",
    config = function()
      
      :lua require("harpoon.mark").add_file()
      
      
      :lua require("harpoon.ui").toggle_quick_menu()
      
      
      :lua require("harpoon.ui").nav_file(3)                  -- navigates to file 3
      
      
      :lua require("harpoon.ui").nav_next()                   -- navigates to next mark
      :lua require("harpoon.ui").nav_prev()                   -- navigates to previous mark
      
      
      lua require("harpoon.term").gotoTerminal(1)             -- navigates to term 1
      
      
      lua require("harpoon.term").sendCommand(1, "ls -La")    -- sends ls -La to tmux window 1
      
      
      lua require('harpoon.cmd-ui').toggle_quick_menu()       -- shows the commands menu
      lua require("harpoon.term").sendCommand(1, 1)           -- sends command 1 to term 1
      
      
      lua require("harpoon.tmux").gotoTerminal(1)             -- goes to the first tmux window
      lua require("harpoon.tmux").sendCommand(1, "ls -La")    -- sends ls -La to tmux window 1
      lua require("harpoon.tmux").sendCommand(1, 1)           -- sends command 1 to tmux window 1
      
      
      lua require("harpoon.tmux").gotoTerminal("{down-of}")   -- focus the pane directly below
      lua require("harpoon.tmux").sendCommand("%3", "ls")     -- send a command to the pane with id '%3'
      
      
      require("telescope").load_extension('harpoon')
      
      
      require("harpoon").setup({ ... })
      
      
      global_settings = {
          -- sets the marks upon calling `toggle` on the ui, instead of require `:w`.
          save_on_toggle = false,
      
          -- saves the harpoon file upon every change. disabling is unrecommended.
          save_on_change = true,
      
          -- sets harpoon to run the command immediately as it's passed to the terminal when calling `sendCommand`.
          enter_on_sendcmd = false,
      
          -- closes any tmux windows harpoon that harpoon creates when you close Neovim.
          tmux_autoclose_windows = false,
      
          -- filetypes that you want to prevent from adding to the harpoon list menu.
          excluded_filetypes = { "harpoon" },
      
          -- set marks specific to each git branch inside git repository
          mark_branch = false,
      
          -- enable tabline with harpoon marks
          tabline = false,
          tabline_prefix = "   ",
          tabline_suffix = "   ",
      }
      
      
      projects = {
          -- Yes $HOME works
          ["$HOME/personal/vim-with-me/server"] = {
              term = {
                  cmds = {
                      "./env && npx ts-node src/index.ts"
                  }
              }
          }
      }
      
      
      require("harpoon").setup({
          menu = {
              width = vim.api.nvim_win_get_width(0) - 4,
          }
      })
      
      
      vim.cmd('highlight! HarpoonInactive guibg=NONE guifg=#63698c')
      vim.cmd('highlight! HarpoonActive guibg=NONE guifg=white')
      vim.cmd('highlight! HarpoonNumberActive guibg=NONE guifg=#7aa2f7')
      vim.cmd('highlight! HarpoonNumberInactive guibg=NONE guifg=#7aa2f7')
      vim.cmd('highlight! TabLineFill guibg=NONE guifg=white')
      
    end,
  },
  {
    "otavioschwanck/arrow.nvim",
    config = function()
      
      return {
        "otavioschwanck/arrow.nvim",
        dependencies = {
          { "nvim-tree/nvim-web-devicons" },
          -- or if using `mini.icons`
          -- { "echasnovski/mini.icons" },
        },
        opts = {
          show_icons = true,
          leader_key = ';', -- Recommended to be a single key
          buffer_leader_key = 'm', -- Per Buffer Mappings
        }
      }
      
      
      use { 'otavioschwanck/arrow.nvim', config = function()
        require('arrow').setup({
          show_icons = true,
          leader_key = ';', -- Recommended to be a single key
          buffer_leader_key = 'm', -- Per Buffer Mappings
        })
      end }
      
      
      {
        show_icons = true,
        always_show_path = false,
        separate_by_branch = false, -- Bookmarks will be separated by git branch
        hide_handbook = false, -- set to true to hide the shortcuts on menu.
        hide_buffer_handbook = false, --set to true to hide shortcuts on buffer menu
        save_path = function()
          return vim.fn.stdpath("cache") .. "/arrow"
        end,
        mappings = {
          edit = "e",
          delete_mode = "d",
          clear_all_items = "C",
          toggle = "s", -- used as save if separate_save_and_remove is true
          open_vertical = "v",
          open_horizontal = "-",
          quit = "q",
          remove = "x", -- only used if separate_save_and_remove is true
          next_item = "]",
          prev_item = "["
        },
        custom_actions = {
          open = function(target_file_name, current_file_name) end, -- target_file_name = file selected to be open, current_file_name = filename from where this was called
          split_vertical = function(target_file_name, current_file_name) end,
          split_horizontal = function(target_file_name, current_file_name) end,
        },
        window = { -- controls the appearance and position of an arrow window (see nvim_open_win() for all options)
          width = "auto",
          height = "auto",
          row = "auto",
          col = "auto",
          border = "double",
        },
        per_buffer_config = {
          lines = 4, -- Number of lines showed on preview.
          sort_automatically = true, -- Auto sort buffer marks.
          satellite = { -- default to nil, display arrow index in scrollbar at every update
            enable = false,
            overlap = true,
            priority = 1000,
          },
          zindex = 10, --default 50
          treesitter_context = nil, -- it can be { line_shift_down = 2 }, currently not usable, for detail see https://github.com/otavioschwanck/arrow.nvim/pull/43#issue-2236320268
        },
        separate_save_and_remove = false, -- if true, will remove the toggle and create the save/remove keymaps.
        leader_key = ";",
        save_key = "cwd", -- what will be used as root to save the bookmarks. Can be also `git_root` and `git_root_bare`.
        global_bookmarks = false, -- if true, arrow will save files globally (ignores separate_by_branch)
        index_keys = "123456789zxcbnmZXVBNM,afghjklAFGHJKLwrtyuiopWRTYUIOP", -- keys mapped to bookmark index, i.e. 1st bookmark will be accessible by 1, and 12th - by c
        full_path_list = { "update_stuff" } -- filenames on this list will ALWAYS show the file path too.
      }
      
      
      vim.keymap.set("n", "H", require("arrow.persist").previous)
      vim.keymap.set("n", "L", require("arrow.persist").next)
      vim.keymap.set("n", "<C-s>", require("arrow.persist").toggle)
      
      
      local statusline = require('arrow.statusline')
      statusline.is_on_arrow_file() -- return nil if current file is not on arrow.  Return the index if it is.
      statusline.text_for_statusline() -- return the text to be shown in the statusline (the index if is on arrow or "" if not)
      statusline.text_for_statusline_with_icons() -- Same, but with an bow and arrow icon ;D
      
      
      function Builder:format_line(indent_markers, arrows, icon, name, node)
        local added_len = 0
        local function add_to_end(t1, t2)
          if not t2 then
            return
          end
          for _, v in ipairs(t2) do
            if added_len > 0 then
              table.insert(t1, { str = M.opts.renderer.icons.padding })
            end
            table.insert(t1, v)
          end
      
          -- first add_to_end don't need padding
          -- hence added_len is calculated at the end to be used next time
          added_len = 0
          for _, v in ipairs(t2) do
            added_len = added_len + #v.str
          end
        end
      
        local line = { indent_markers, arrows }
      
        local arrow_index = 1
        local arrow_filenames = vim.g.arrow_filenames
        if arrow_filenames then
          for i, filename in ipairs(arrow_filenames) do
            if string.sub(node.absolute_path, -#filename) == filename then
              local statusline = require "arrow.statusline"
              arrow_index = statusline.text_for_statusline(_, i)
              line[1].str = string.sub(line[1].str, 1, -3)
              line[2].str = "(" .. arrow_index .. ") "
              line[2].hl = { "ArrowFileIndex" }
              break
            end
          end
        end
      
        add_to_end(line, { icon })
      
        for i = #M.decorators, 1, -1 do
          add_to_end(line, M.decorators[i]:icons_before(node))
        end
      
        add_to_end(line, { name })
      
        for i = #M.decorators, 1, -1 do
          add_to_end(line, M.decorators[i]:icons_after(node))
        end
      
        return line
      end
      
      
      require("arrow.git").refresh_git_branch() -- only if separated_by_branch is true
      require("arrow.persist").load_cache_file()
      
    end,
  },
  {
    "ofirgall/open.nvim",
    config = function()
      
      use { 'ofirgall/open.nvim', requires = 'nvim-lua/plenary.nvim' }
      
      
      -- Leave empty for default values
      require('open').setup {
      }
      
      require('open').setup {
          config = {
              -- Override system opener, the defaults should work out of the box
              system_open = {
                  cmd = "",
                  args = {},
              },
              -- Options to pass to plenary.curl
              curl_opts = {
                  -- compressed = false -- Uncomment this line to disable curl compression
              },
          },
          -- List of disabled openers, 'github' for example see `:help open.default_openers`
          disabled_openers = {
          },
          -- fallback function if no opener succeeds
          fallback = function(text)
              system_open.open(text)
          end,
          -- Override `config` per opener
          openers_config = {
              -- Override `jira` browser for example
              ['jira'] = {
                  system_open = {
                      cmd = 'chromium-browser',
                  },
              },
          },
      }
      
      
      vim.keymap.set('n', 'gx', require('open').open_cword)
      
      
      require('open').register_opener({
          name = 'Example Opener',
          open_fn = function(text)
              return { 'www.example.org' }
          end
      })
      
    end,
  },
  {
    "LeonHeidelbach/trailblazer.nvim",
    config = function()
      
      -- Using packer
      use({
          "LeonHeidelbach/trailblazer.nvim",
          config = function()
              require("trailblazer").setup({
                  -- your custom config goes here
              })
          end,
      })
      
      
      -- Adjust these values to your liking
      {
          lang = "en",
          auto_save_trailblazer_state_on_exit = false,
          auto_load_trailblazer_state_on_enter = false,
          custom_session_storage_dir = "", -- i.e. "~/trail_blazer_sessions/"
          trail_options = {
              -- The trail mark priority sets the global render priority of trail marks in the sign/number
              -- column as well as the highlights within the text (e.g. Treesitter sets a value of 100).
              -- Make sure this value is higher than any other plugin you use to ensure that trail marks
              -- are always visible and don't get overshadowed.
              trail_mark_priority = 10001,
              -- Available modes to cycle through. Remove any you don't need.
              available_trail_mark_modes = {
                  "global_chron",
                  "global_buf_line_sorted",
                  "global_fpath_line_sorted",
                  "global_chron_buf_line_sorted",
                  "global_chron_fpath_line_sorted",
                  "global_chron_buf_switch_group_chron",
                  "global_chron_buf_switch_group_line_sorted",
                  "buffer_local_chron",
                  "buffer_local_line_sorted"
              },
              -- The current / initially selected trail mark selection mode. Choose from one of the
              -- available modes: global_chron, global_buf_line_sorted, global_chron_buf_line_sorted,
              -- global_chron_buf_switch_group_chron, global_chron_buf_switch_group_line_sorted,
              -- buffer_local_chron, buffer_local_line_sorted
              current_trail_mark_mode = "global_chron",
              current_trail_mark_list_type = "quickfix", -- currently only quickfix lists are supported
              trail_mark_list_rows = 10, -- number of rows to show in the trail mark list
              verbose_trail_mark_select = true, -- print current mode notification on mode change
              mark_symbol = "•", --  will only be used if trail_mark_symbol_line_indicators_enabled = true
              newest_mark_symbol = "⬤", -- disable this mark symbol by setting its value to ""
              cursor_mark_symbol = "⬤", -- disable this mark symbol by setting its value to ""
              next_mark_symbol = "⬤", -- disable this mark symbol by setting its value to ""
              previous_mark_symbol = "⬤", -- disable this mark symbol by setting its value to ""
              multiple_mark_symbol_counters_enabled = true,
              number_line_color_enabled = true,
              trail_mark_in_text_highlights_enabled = true,
              trail_mark_symbol_line_indicators_enabled = false, -- show indicators for all trail marks in symbol column
              symbol_line_enabled = true,
              default_trail_mark_stacks = {
                  -- this is the list of trail mark stacks that will be created by default. Add as many
                  -- as you like to this list. You can always create new ones in Neovim by using either
                  -- `:TrailBlazerSwitchTrailMarkStack <name>` or `:TrailBlazerAddTrailMarkStack <name>`
                  "default" -- , "stack_2", ...
              },
              available_trail_mark_stack_sort_modes = {
                  "alpha_asc", -- alphabetical ascending
                  "alpha_dsc", -- alphabetical descending
                  "chron_asc", -- chronological ascending
                  "chron_dsc", -- chronological descending
              },
              -- The current / initially selected trail mark stack sort mode. Choose from one of the
              -- available modes: alpha_asc, alpha_dsc, chron_asc, chron_dsc
              current_trail_mark_stack_sort_mode = "alpha_asc",
              -- Set this to true if you always want to move to the nearest trail mark first before
              -- continuing to peek move in the current selection mode order. This effectively disables
              -- the "current trail mark cursor" to which you would otherwise move first before continuing
              -- to move through your trail mark stack.
              move_to_nearest_before_peek = false,
              move_to_nearest_before_peek_motion_directive_up = "fpath_up", -- "up", "fpath_up" -> For more information see section "TrailBlazerMoveToNearest Motion Directives"
              move_to_nearest_before_peek_motion_directive_down = "fpath_down", -- "down", "fpath_down" -> For more information see section "TrailBlazerMoveToNearest Motion Directives"
              move_to_nearest_before_peek_dist_type = "lin_char_dist", -- "man_dist", "lin_char_dist" -> Manhattan Distance or Linear Character Distance
          },
          event_list = {
              -- Add the events you would like to add custom callbacks for here. For more information see section "Custom Events"
              -- "TrailBlazerTrailMarkStackSaved",
              -- "TrailBlazerTrailMarkStackDeleted",
              -- "TrailBlazerCurrentTrailMarkStackChanged",
              -- "TrailBlazerTrailMarkStackSortModeChanged"
          },
          mappings = { -- rename this to "force_mappings" to completely override default mappings and not merge with them
              nv = { -- Mode union: normal & visual mode. Can be extended by adding i, x, ...
                  motions = {
                      new_trail_mark = '<A-l>',
                      track_back = '<A-b>',
                      peek_move_next_down = '<A-J>',
                      peek_move_previous_up = '<A-K>',
                      move_to_nearest = '<A-n>',
                      toggle_trail_mark_list = '<A-m>',
                  },
                  actions = {
                      delete_all_trail_marks = '<A-L>',
                      paste_at_last_trail_mark = '<A-p>',
                      paste_at_all_trail_marks = '<A-P>',
                      set_trail_mark_select_mode = '<A-t>',
                      switch_to_next_trail_mark_stack = '<A-.>',
                      switch_to_previous_trail_mark_stack = '<A-,>',
                      set_trail_mark_stack_sort_mode = '<A-s>',
                  },
              },
              -- You can also add/move any motion or action to mode specific mappings i.e.:
              -- i = {
              --     motions = {
              --         new_trail_mark = '<C-l>',
              --         ...
              --     },
              --     ...
              -- },
          },
          quickfix_mappings = { -- rename this to "force_quickfix_mappings" to completely override default mappings and not merge with them
              nv = {
                  motions = {
                      qf_motion_move_trail_mark_stack_cursor = "<CR>",
                  },
                  actions = {
                      qf_action_delete_trail_mark_selection = "d",
                      qf_action_save_visual_selection_start_line = "v",
                  },
                  alt_actions = {
                      qf_action_save_visual_selection_start_line = "V",
                  }
              },
              v = {
                  actions = {
                      qf_action_move_selected_trail_marks_down = "<C-j>",
                      qf_action_move_selected_trail_marks_up = "<C-k>",
                  }
              }
          },
          -- Your custom highlight group overrides go here
          -- hl_groups = {} 
      }
      
      
      hl_groups = {
          TrailBlazerTrailMark = {
              -- You can add any valid highlight group attribute to this table
              guifg = "White",
              guibg = "none",
              gui = "bold",
          },
          TrailBlazerTrailMarkNext = {
              guifg = "Green",
              guibg = "none",
              gui = "bold",
          },
          TrailBlazerTrailMarkPrevious = {
              guifg = "Red",
              guibg = "none",
              gui = "bold",
          },
          TrailBlazerTrailMarkCursor = {
              guifg = "Black",
              guibg = "Orange",
              gui = "bold",
          },
          TrailBlazerTrailMarkNewest = {
              guifg = "Black",
              guibg = "LightBlue",
              gui = "bold",
          },
          TrailBlazerTrailMarkCustomOrd = {
              guifg = "Black",
              guibg = "LightSlateBlue",
              gui = "bold",
          },
          TrailBlazerTrailMarkGlobalChron = {
              guifg = "Black",
              guibg = "Red",
              gui = "bold",
          },
          TrailBlazerTrailMarkGlobalBufLineSorted = {
              guifg = "Black",
              guibg = "LightRed",
              gui = "bold",
          },
          TrailBlazerTrailMarkGlobalFpathLineSorted = {
              guifg = "Black",
              guibg = "LightRed",
              gui = "bold",
          },
          TrailBlazerTrailMarkGlobalChronBufLineSorted = {
              guifg = "Black",
              guibg = "Olive",
              gui = "bold",
          },
          TrailBlazerTrailMarkGlobalChronFpathLineSorted = {
              guifg = "Black",
              guibg = "Olive",
              gui = "bold",
          },
          TrailBlazerTrailMarkGlobalChronBufSwitchGroupChron = {
              guifg = "Black",
              guibg = "VioletRed",
              gui = "bold",
          },
          TrailBlazerTrailMarkGlobalChronBufSwitchGroupLineSorted = {
              guifg = "Black",
              guibg = "MediumSpringGreen",
              gui = "bold",
          },
          TrailBlazerTrailMarkBufferLocalChron = {
              guifg = "Black",
              guibg = "Green",
              gui = "bold",
          },
          TrailBlazerTrailMarkBufferLocalLineSorted = {
              guifg = "Black",
              guibg = "LightGreen",
              gui = "bold",
          },
      }
      
      
      require("trailblazer").<function_name>(<args>)
      
      
      -- Register a custom event callback
      vim.api.nvim_create_autocmd("User", {
          pattern = "TrailBlazerTrailMarkStackSaved", -- use any of the below events
          callback = function(event)
              -- your code to process the callback data goes here
              print(vim.inspect(event.data))
          end,
      })
      
    end,
  },
  {
    "tomasky/bookmarks.nvim",
    config = function()
      
      use {
      'tomasky/bookmarks.nvim',
      -- tag = 'release' -- To use the latest release
      }
      
      
      
      use {
        'tomasky/bookmarks.nvim',
        -- after = "telescope.nvim",
        event = "VimEnter",
        config = function()
          require('bookmarks').setup()
        end
      }
      
      
      require('bookmarks').setup {
        -- sign_priority = 8,  --set bookmark sign priority to cover other sign
        save_file = vim.fn.expand "$HOME/.bookmarks", -- bookmarks save file path
        keywords =  {
          ["@t"] = "☑️ ", -- mark annotation startswith @t ,signs this icon as `Todo`
          ["@w"] = "⚠️ ", -- mark annotation startswith @w ,signs this icon as `Warn`
          ["@f"] = "⛏ ", -- mark annotation startswith @f ,signs this icon as `Fix`
          ["@n"] = " ", -- mark annotation startswith @n ,signs this icon as `Note`
        },
        on_attach = function(bufnr)
          local bm = require "bookmarks"
          local map = vim.keymap.set
          map("n","mm",bm.bookmark_toggle) -- add or remove bookmark at current line
          map("n","mi",bm.bookmark_ann) -- add or edit mark annotation at current line
          map("n","mc",bm.bookmark_clean) -- clean all marks in local buffer
          map("n","mn",bm.bookmark_next) -- jump to next mark in local buffer
          map("n","mp",bm.bookmark_prev) -- jump to previous mark in local buffer
          map("n","ml",bm.bookmark_list) -- show marked file list in quickfix window
          map("n","mx",bm.bookmark_clear_all) -- removes all bookmarks
        end
      }
      
      
      require('telescope').load_extension('bookmarks')
      
    end,
  },
  {
    "LintaoAmons/bookmarks.nvim",
    config = function()
      
      -- with lazy.nvim
      return {
        "LintaoAmons/bookmarks.nvim",
        -- pin the plugin at specific version for stability
        -- backup your bookmark sqlite db when there are breaking changes (major version change)
        tag = "3.2.0",
        dependencies = {
          {"kkharji/sqlite.lua"},
          {"nvim-telescope/telescope.nvim"},  -- currently has only telescopes supported, but PRs for other pickers are welcome 
          {"stevearc/dressing.nvim"}, -- optional: better UI
          {"GeorgesAlkhouri/nvim-aider"} -- optional: for Aider integration
        },
        config = function()
          local opts = {} -- check the "./lua/bookmarks/default-config.lua" file for all the options
          require("bookmarks").setup(opts) -- you must call setup to init sqlite db
        end,
      }
      
      -- run :BookmarksInfo to see the running status of the plugin
      
      
      vim.keymap.set({ "n", "v" }, "Bd", function() require("bookmarks.commands").name_of_the_command_function() end, { desc = "Booksmark Clear Line" })
      -- e.g.
      vim.keymap.set({ "n", "v" }, "Bd", function() require("bookmarks.commands").delete_mark_of_current_file() end, { desc = "Booksmark Clear Line" })
      -- or create your custom commands
      vim.api.nvim_create_user_command("BookmarksClearCurrentFile", function() require("bookmarks.commands").delete_mark_of_current_file() end, {})
      
      
      -- Default keybindings in the treeview buffer with the new format
      keymap = {
        ["q"] = {
          action = "quit",
          desc = "Close the tree view window"
        },
        -- ... See more in the default-config.lua
        ["+"] = {
          action = "add_to_aider",
          desc = "Add to Aider"
        },
        -- Example of a custom mapping
        ["<C-o>"] = {
          ---@type Bookmarks.KeymapCustomAction
          action = function(node, info)
            if info.type == 'bookmark' then
              vim.system({'open', info.dirname}, { text = true })
            end
          end,
          desc = "Open the current node with system default software",
        },
      }
      
      
      -- use `nvimtools/hydra.nvim`: https://github.com/anuvyklack/hydra.nvim/issues/104
      local Hydra = require('hydra')
      Hydra({
        name = "Bookmarks",
        mode = 'n',
        body = '<leader>m',
        hint = [[
        Bookmark Navigation
      
        ^  _j_: Next in List     _J_: Next Bookmark
        ^  _k_: Prev in List     _K_: Prev Bookmark
        ^
        ^ _<Esc>_: Exit
        ]],
        heads = {
          { 'j', '<cmd>BookmarksGotoNextInList<cr>' },
          { 'k', '<cmd>BookmarksGotoPrevInList<cr>' },
          { 'J', '<cmd>BookmarksGotoNext<cr>' },
          { 'K', '<cmd>BookmarksGotoPrev<cr>' },
        },
      })
      
      
      vim.keymap.set({ "n", "v" }, "mm", "<cmd>BookmarksMark<cr>", { desc = "Mark current line into active BookmarkList." })
      vim.keymap.set({ "n", "v" }, "mo", "<cmd>BookmarksGoto<cr>", { desc = "Go to bookmark at current active BookmarkList" })
      vim.keymap.set({ "n", "v" }, "ma", "<cmd>BookmarksCommands<cr>", { desc = "Find and trigger a bookmark command." })
      
    end,
  },
  {
    "heilgar/bookmarks.nvim",
    config = function()
      
      {
          "heilgar/bookmarks.nvim",
          dependencies = {
              "kkharji/sqlite.lua",
              "nvim-telescope/telescope.nvim",
              "nvim-lua/plenary.nvim",
          },
          config = function()
              require("bookmarks").setup({
                  -- your configuration comes here
                  -- or leave empty to use defaults
                  default_mappings = true,
                  db_path = vim.fn.stdpath('data') .. '/bookmarks.db'
              })
              require("telescope").load_extension("bookmarks")
          end,
          cmd = {
              "BookmarkAdd",
              "BookmarkRemove",
              "Bookmarks"
          },
          keys = {
              { "<leader>ba", "<cmd>BookmarkAdd<cr>", desc = "Add Bookmark" },
              { "<leader>br", "<cmd>BookmarkRemove<cr>", desc = "Remove Bookmark" },
              { "<leader>bj", desc = "Jump to Next Bookmark" },
              { "<leader>bk", desc = "Jump to Previous Bookmark" },
              { "<leader>bl", "<cmd>Bookmarks<cr>", desc = "List Bookmarks" },
              { "<leader>bs", desc = "Switch Bookmark List" },
          },
      }
      
      
      require("bookmarks").setup({
          -- Storage configuration
          db_path = vim.fn.stdpath('data') .. '/bookmarks.db',  -- Path to SQLite database
      
          -- Branch configuration
          use_branch_specific = false,  -- Enable/disable branch-specific bookmarks (can be toggled at runtime)
      
          -- Keymaps configuration
          default_mappings = true,  -- Set to false to disable default keymaps
      
          -- Custom mappings example (if default_mappings = false):
          mappings = {
              add = "ma",          -- Add bookmark at current line
              delete = "md",       -- Delete bookmark at current line
              list = "ml",         -- List all bookmarks
          }
      })
      
      
      vim.keymap.set('n', '<your-keymap>', require('bookmarks.commands').add_bookmark)
      vim.keymap.set('n', '<your-keymap>', require('bookmarks.commands').remove_bookmark)
      vim.keymap.set('n', '<your-keymap>', require('bookmarks.navigation').jump_to_next)
      vim.keymap.set('n', '<your-keymap>', require('bookmarks.navigation').jump_to_prev)
      vim.keymap.set('n', '<your-keymap>', require('telescope').extensions.bookmarks.list)
      
      
      vim.api.nvim_set_hl(0, "BookmarkHighlight", {
          bg = "#3a3a3a",
          underline = true
      })
      
      vim.api.nvim_set_hl(0, "BookmarkSignHighlight", {
          fg = "#458588",
      })
      
      
      local bookmarks = require("bookmarks")
      
      -- Add bookmark at current line
      bookmarks.add_bookmark()
      
      -- Remove bookmark at current line
      bookmarks.remove_bookmark()
      
      -- Navigate bookmarks in current file
      bookmarks.jump_to_next()
      bookmarks.jump_to_prev()
      
      -- Jump to a specific bookmark
      bookmarks.jump_to_bookmark(filename, line_number)
      
      -- Get all bookmarks
      local storage = require("bookmarks.storage")
      local all_bookmarks = storage.get_bookmarks()
      
      -- Get bookmarks for specific file
      local file_bookmarks = storage.get_file_bookmarks(filename)
      
      
      vim.o.statusline = "%f %h%m%r %=%{v:lua.require('bookmarks').status()}"
      
      
      require('lualine').setup {
        sections = {
          lualine_c = {
            'filename',
            { function() return require('bookmarks').status() end }
          },
          -- ... other sections ...
        }
      }
      
    end,
  },
  {
    "desdic/marlin.nvim",
    config = function()
      
      {
          "desdic/marlin.nvim",
          opts = {},
          config = function(_, opts)
              local marlin = require("marlin")
              marlin.setup(opts)
      
              local keymap = vim.keymap.set
              keymap("n", "<Leader>fa", function() marlin.add() end, {  desc = "add file" })
              keymap("n", "<Leader>fd", function() marlin.remove() end, {  desc = "remove file" })
              keymap("n", "<Leader>fx", function() marlin.remove_all() end, {  desc = "remove all for current project" })
              keymap("n", "<Leader>f]", function() marlin.move_up() end, {  desc = "move up" })
              keymap("n", "<Leader>f[", function() marlin.move_down() end, {  desc = "move down" })
              keymap("n", "<Leader>fs", function() marlin.sort() end, {  desc = "sort" })
              keymap("n", "<Leader>fn", function() marlin.next() end, {  desc = "open next index" })
              keymap("n", "<Leader>fp", function() marlin.prev() end, {  desc = "open previous index" })
              keymap("n", "<Leader><Leader>", function() marlin.toggle() end, {  desc = "toggle cur/last open index" })
      
              for index = 1,4 do
                  keymap("n", "<Leader>"..index, function() marlin.open(index) end, {  desc = "goto "..index })
              end
          end
      }
      
      
      vim.api.nvim_create_autocmd("VimEnter", {
          group = vim.api.nvim_create_augroup("restore_marlin", { clear = true }),
          callback = function()
              -- If nvim has an argument like file(s) we skip the restore
              if next(vim.fn.argv()) ~= nil then
                  return
              end
              require("marlin").open_all()
          end,
          nested = true,
      })
      
      
      local default = {
          patterns = { ".git", ".svn" }, -- look for root of project
          datafile = vim.fn.stdpath("data") .. "/marlin.json", -- location of data file
          open_callback = callbacks.change_buffer -- default way to open buffer
          sorter = sorter.by_buffer -- sort by bufferid
          save_cursor_location = true
          suppress = {
              missing_root = false -- don't give warning on project root not found
          }
      }
      
      
      return {
          "nvim-lualine/lualine.nvim",
          config = function()
              local marlin = require("marlin")
      
              local marlin_component = function()
                  local indexes = marlin.num_indexes()
                  if indexes == 0 then
                      return ""
                  end
                  local cur_index = marlin.cur_index()
      
                  return " " .. cur_index .. "/" .. indexes
              end
      
              require("lualine").setup({
                  ...
                  sections = {
                      ...
                      lualine_c = { marlin_component },
                      ...
                  },
              })
          end
      
      
          open_callback = function(bufnr, _)
              vim.cmd("vsplit")
              vim.api.nvim_set_current_buf(bufnr)
          end,
      
      
          open_callback = function(bufnr, opts)
              if opts.use_split then
                  local wins = vim.api.nvim_tabpage_list_wins(0)
                  for _, win in ipairs(wins) do
                      local winbufnr = vim.api.nvim_win_get_buf(win)
      
                      if winbufnr == bufnr then
                          vim.api.nvim_set_current_win(win)
                          return
                      end
                  end
              end
      
              vim.api.nvim_set_current_buf(bufnr)
          end,
      
      
          local mindex = 0
          local generate_finder = function()
              mindex = 0
              return require("telescope.finders").new_table({
                  results = require("marlin").get_indexes(),
                  entry_maker = function(entry)
                      mindex = mindex + 1
                      return {
                          value = entry,
                          ordinal = mindex .. ":" .. entry.filename,
                          lnum = entry.row,
                          col = entry.col + 1,
                          filename = entry.filename,
                          display = mindex .. ":" .. entry.filename .. ":" .. entry.row .. ":" .. entry.col,
                      }
                  end,
              })
          end
      
          vim.keymap.set("n", "<Leader>fx", function()
              local conf = require("telescope.config").values
              local action_state = require("telescope.actions.state")
      
              require("telescope.pickers")
                  .new({}, {
                      prompt_title = "Marlin",
                      finder = generate_finder(),
                      previewer = conf.grep_previewer({}),
                      sorter = conf.generic_sorter({}),
                      attach_mappings = function(_, map)
                          map("i", "<c-d>", function(bufnr)
                              local current_picker = action_state.get_current_picker(bufnr)
                              current_picker:delete_selection(function(selection)
                                  require("marlin").remove(selection.filename)
                              end)
                          end)
                          map("i", "+", function(bufnr)
                              local current_picker = action_state.get_current_picker(bufnr)
                              local selection = current_picker:get_selection()
                              require("marlin").move_up(selection.filename)
                              current_picker:refresh(generate_finder(), {})
                          end)
                          map("i", "-", function(bufnr)
                              local current_picker = action_state.get_current_picker(bufnr)
                              local selection = current_picker:get_selection()
                              require("marlin").move_down(selection.filename)
                              current_picker:refresh(generate_finder(), {})
                          end)
                          return true
                      end,
                  })
                  :find()
          end, { desc = "Telescope marlin" })
      
      
          vim.keymap.set("n", "<Leader>fx", function()
              local results = require("marlin").get_indexes()
              local content = {}
      
              local fzf_lua = require("fzf-lua")
              local builtin = require("fzf-lua.previewer.builtin")
              local fzfpreview = builtin.buffer_or_file:extend()
      
              function fzfpreview:new(o, opts, fzf_win)
                  fzfpreview.super.new(self, o, opts, fzf_win)
                  setmetatable(self, fzfpreview)
                  return self
              end
      
              function fzfpreview.parse_entry(_, entry_str)
                  if entry_str == "" then
                      return {}
                  end
      
                  local entry = content[entry_str]
                  return {
                      path = entry.filename,
                      line = entry.row or 1,
                      col = 1,
                  }
              end
      
              fzf_lua.fzf_exec(function(fzf_cb)
                  for i, b in ipairs(results) do
                      local entry = i .. ":" .. b.filename .. ":" .. b.row
      
                      content[entry] = b
                      fzf_cb(entry)
                  end
                  fzf_cb()
              end, {
                  previewer = fzfpreview,
                  prompt = "Marlin> ",
                  actions = {
                      ["ctrl-d"] = {
                          fn = function(selected)
                              require("marlin").remove(content[selected[1]].filename)
                          end,
                          reload = true,
                          silent = true,
                      },
                      ["ctrl-k"] = {
                          fn = function(selected)
                              require("marlin").move_up(content[selected[1]].filename)
                          end,
                          reload = true,
                          silent = false,
                      },
                      ["ctrl-j"] = {
                          fn = function(selected)
                              require("marlin").move_down(content[selected[1]].filename)
                          end,
                          reload = true,
                          silent = false,
                      },
                  },
              })
          end, { desc = "fzf marlin" })
      
      
          vim.keymap.set("n", "<leader>fx", function()
              local snacks = require("snacks")
              local lookup = {}
      
              local function get_choices()
                  local results = require("marlin").get_indexes()
      
                  local items = {}
                  lookup = {}
                  for idx, b in ipairs(results) do
                      local text = b.filename .. ":" .. b.row
      
                      table.insert(items, {
                          formatted = text,
                          file = b.filename,
                          text = text,
                          idx = idx,
                          pos = { tonumber(b.row), 0 },
                      })
      
                      lookup[text] = b
                  end
                  return items
              end
      
              snacks.picker.pick({
                  source = "select",
                  finder = get_choices,
                  title = "Marlin",
                  layout = { preview = true },
                  actions = {
                      marlin_up = function(picker, item)
                          require("marlin").move_up(lookup[item.text].filename)
                          picker:find({ refresh = true })
                      end,
                      marlin_down = function(picker, item)
                          require("marlin").move_down(lookup[item.text].filename)
                          picker:find({ refresh = true })
                      end,
                      marlin_delete = function(picker, item)
                          require("marlin").remove(lookup[item.text].filename)
                          picker:find({ refresh = true })
                      end,
                  },
                  win = {
                      input = {
                          keys = {
                              ["<C-k>"] = { "marlin_up", mode = { "n", "i" }, desc = "Move marlin up" },
                              ["<C-j>"] = { "marlin_down", mode = { "n", "i" }, desc = "Move marlin down" },
                              ["<C-d>"] = { "marlin_delete", mode = { "n", "i" }, desc = "Marlin delete" },
                          },
                      },
                  },
              })
          end, { desc = "marlin" })
      
    end,
  },
  {
    "fnune/recall.nvim",
    config = function()
      
      require("recall").setup({})
      
      
      require("recall").setup({
        sign = "",
        sign_highlight = "@comment.note",
      
        telescope = {
          autoload = true,
          mappings = {
            unmark_selected_entry = {
              normal = "dd",
              insert = "<M-d>",
            },
          },
        },
      
        wshada = vim.fn.has("nvim-0.10") == 0,
      })
      
      
      -- Using commands:
      vim.keymap.set("n", "<leader>mm", ":RecallToggle<CR>", { noremap = true, silent = true })
      vim.keymap.set("n", "<leader>mn", ":RecallNext<CR>", { noremap = true, silent = true })
      vim.keymap.set("n", "<leader>mp", ":RecallPrevious<CR>", { noremap = true, silent = true })
      vim.keymap.set("n", "<leader>mc", ":RecallClear<CR>", { noremap = true, silent = true })
      vim.keymap.set("n", "<leader>ml", ":Telescope recall<CR>", { noremap = true, silent = true })
      
      -- Using the Lua API:
      local recall = require("recall")
      
      vim.keymap.set("n", "<leader>mm", recall.toggle, { noremap = true, silent = true })
      vim.keymap.set("n", "<leader>mn", recall.goto_next, { noremap = true, silent = true })
      vim.keymap.set("n", "<leader>mp", recall.goto_prev, { noremap = true, silent = true })
      vim.keymap.set("n", "<leader>mc", recall.clear, { noremap = true, silent = true })
      vim.keymap.set("n", "<leader>ml", ":Telescope recall<CR>", { noremap = true, silent = true })
      
      
      {
        "fnune/recall.nvim",
        version = "*",
        config = function()
          local recall = require("recall")
      
          recall.setup({})
      
          vim.keymap.set("n", "<leader>mm", recall.toggle, { noremap = true, silent = true })
          vim.keymap.set("n", "<leader>mn", recall.goto_next, { noremap = true, silent = true })
          vim.keymap.set("n", "<leader>mp", recall.goto_prev, { noremap = true, silent = true })
          vim.keymap.set("n", "<leader>mc", recall.clear, { noremap = true, silent = true })
          vim.keymap.set("n", "<leader>ml", ":Telescope recall<CR>", { noremap = true, silent = true })
        end
      }
      
      
      require("recall").setup({
        telescope = {
          mappings = {
            unmark_selected_entry = {
              normal = "d",
              insert = "",
            },
          },
        },
      })
      
      
      require("recall").setup({
        telescope = {
          autoload = false,
        },
      })
      
      require("telescope").load_extension("recall")
      
      
      vim.keymap.set("n", "<leader>ml", require("recall.snacks").pick, { noremap = true, silent = true })
      
      
      require("recall").setup({
        snacks = {
          mappings = {
            unmark_selected_entry = {
              normal = "d",
              insert = "",
            },
          },
        },
      })
      
      
      -- In your Neovim configuration:
      vim.opt.exrc = true
      vim.opt.secure = true
      
      -- /path/to/your/project/.nvim.lua:
      vim.opt.shadafile = ".vim/project.shada"
      
      -- Optionally, in the project's .gitignore or ~/.config/git/ignore:
      .vim
      
    end,
  },
  {
    "niuiic/track.nvim",
    config = function()
      
      vim.api.nvim_create_autocmd("BufWritePost", {
      	callback = function(args)
      		if require("track").is_enabled(args.buf, vim.api.nvim_get_current_win()) then
      			local file_path = vim.api.nvim_buf_get_name(args.buf)
      			require("track").notify_file_change(file_path)
      		end
      	end,
      })
      
      
      local api = require("nvim-tree.api")
      local opts = function(desc)
      	return { desc = "nvim-tree: " .. desc, buffer = bufnr, noremap = true, silent = true, nowait = true }
      end
      local cut_files = {}
      local cut_dirs = {}
      vim.keymap.set("n", "p", function()
      	local node = api.tree.get_node_under_cursor()
      	api.fs.paste()
      	for _, path in ipairs(cut_files) do
      		require("track").notify_file_path_change(
      			path[1],
      			node.type == "file" and node.parent.absolute_path or node.absolute_path .. "/" .. path[2]
      		)
      	end
      	for _, path in ipairs(cut_dirs) do
      		require("track").notify_dir_path_change(
      			path[1],
      			node.type == "file" and node.parent.absolute_path or node.absolute_path .. "/" .. path[2]
      		)
      	end
      	cut_files = {}
      	cut_dirs = {}
      end, opts("paste"))
      vim.keymap.set("n", "r", function()
      	local node = api.tree.get_node_under_cursor()
      	local old = node.absolute_path
      	api.fs.rename()
      	local new = api.tree.get_node_under_cursor().absolute_path
      	if node.type == "file" then
      		require("track").notify_file_path_change(old, new)
      	else
      		require("track").notify_dir_path_change(old, new)
      	end
      end, opts("rename"))
      vim.keymap.set("n", "d", function()
      	local node = api.tree.get_node_under_cursor()
      	local target_buf = vim.iter(vim.api.nvim_list_bufs()):find(function(x)
      		return string.find(vim.api.nvim_buf_get_name(x), node.absolute_path, 1, true) ~= nil
      	end)
      	if target_buf then
      		require("mini.bufremove").delete(target_buf)
      	end
      	api.fs.remove()
      	if node.type == "file" then
      		require("track").notify_file_path_change(node.absolute_path)
      	else
      		require("track").notify_dir_path_change(node.absolute_path)
      	end
      end, opts("remove"))
      vim.keymap.set("n", "x", function()
      	local node = api.tree.get_node_under_cursor()
      	api.fs.cut()
      	if node.type == "file" then
      		table.insert(
      			cut_files,
      			{ node.absolute_path, string.match(node.absolute_path, node.parent.absolute_path .. "/(.*)") }
      		)
      	else
      		table.insert(
      			cut_dirs,
      			{ node.absolute_path, string.match(node.absolute_path, node.parent.absolute_path .. "/(.*)") }
      		)
      	end
      end, opts("cut"))
      
      
      vim.filetype.add({
      	extension = {
      		ts = "typescript",
      	},
      })
      
      
      local screen_w = vim.opt.columns:get()
      local screen_h = vim.opt.lines:get() - vim.opt.cmdheight:get()
      local preview_win_width = math.floor(screen_w * 0.6)
      local preview_win_height = math.floor(screen_h * 0.6)
      
      local default_config = {
      	is_enabled = function()
      		return true
      	end,
      	mark = {
      		mark_hl_group = "WarningMsg",
      		mark_icon = "󰍒",
      		sign_priority = 10,
      		get_root_dir = function()
      			return vim.fs.root(0, ".git") or vim.fn.getcwd()
      		end,
      	},
      	outline = {
      		flow_hl_group = "FloatBorder",
      		mark_hl_group = "WarningMsg",
      		win_pos = "left",
      		win_size = 30,
      		preview_win_width = preview_win_width,
      		preview_win_height = preview_win_height,
      		preview_on_hover = true,
      		cursor_line_hl_group = "CursorLine",
      		set_default_when_update = false,
      		keymap_navigate_to_mark = "<cr>",
      		keymap_move_up = "<A-k>",
      		keymap_move_down = "<A-j>",
      		keymap_delete = "d",
      		keymap_update = "e",
      		keymap_preview_mark = "p",
      		keymap_close_preview_win = "q",
      		get_mark_line_text = function(_, _, text)
      			local space, content = string.match(text, "([%s]*)(.*)")
      			return space .. "- " .. content
      		end,
      		select_window = function() end,
      	},
      }
      
    end,
  },
  {
    "tristone13th/lspmark.nvim",
    config = function()
      
      require("lspmark").setup()
      require("telescope").load_extension("lspmark")
      
      
      -- <new_dir> can be nil, by default it is cwd.
      require("lspmark.bookmarks").load_bookmarks(<new_dir>)
      
      
      vim.api.nvim_create_autocmd({ "DirChanged" }, {
          callback = require("lspmark.bookmarks").load_bookmarks,
          pattern = { "*" },
      })
      
    end,
  },
  {
    "EvWilson/spelunk.nvim",
    config = function()
      
      require('lazy').setup({
      	{
      		'EvWilson/spelunk.nvim',
      		dependencies = {
      			'nvim-lua/plenary.nvim',           -- For window drawing utilities
      			'nvim-telescope/telescope.nvim',   -- Optional: for fuzzy search capabilities
      			'nvim-treesitter/nvim-treesitter', -- Optional: for showing grammar context
      		},
      		config = function()
      			require('spelunk').setup({
      				enable_persist = true
      			})
      		end
      	}
      })
      
      
      {
      	base_mappings = {
      		-- Toggle the UI open/closed
      		toggle = '<leader>bt',
      		-- Add a bookmark to the current stack
      		add = '<leader>ba',
      		-- Move to the next bookmark in the stack
      		next_bookmark = '<leader>bn',
      		-- Move to the previous bookmark in the stack
      		prev_bookmark = '<leader>bp',
      		-- Fuzzy-find all bookmarks
      		search_bookmarks = '<leader>bf',
      		-- Fuzzy-find bookmarks in current stack
      		search_current_bookmarks = '<leader>bc',
      		-- Fuzzy find all stacks
      		search_stacks = '<leader>bs',
      	},
      	window_mappings = {
      		-- Move the UI cursor down
      		cursor_down = 'j',
      		-- Move the UI cursor up
      		cursor_up = 'k',
      		-- Move the current bookmark down in the stack
      		bookmark_down = '<C-j>',
      		-- Move the current bookmark up in the stack
      		bookmark_up = '<C-k>',
      		-- Jump to the selected bookmark
      		goto_bookmark = '<CR>',
      		-- Jump to the selected bookmark in a new vertical split
      		goto_bookmark_hsplit = 'x',
      		-- Jump to the selected bookmark in a new horizontal split
      		goto_bookmark_vsplit = 'v',
      		-- Delete the selected bookmark
      		delete_bookmark = 'd',
      		-- Navigate to the next stack
      		next_stack = '<Tab>',
      		-- Navigate to the previous stack
      		previous_stack = '<S-Tab>',
      		-- Create a new stack
      		new_stack = 'n',
      		-- Delete the current stack
      		delete_stack = 'D',
      		-- Rename the current stack
      		edit_stack = 'E',
      		-- Close the UI
      		close = 'q',
      		-- Open the help menu
      		help = 'h',
      	},
      	-- Flag to enable directory-scoped bookmark persistence
      	enable_persist = false,
      	-- Prefix for the Lualine integration
      	-- (Change this if your terminal emulator lacks emoji support)
      	statusline_prefix = '🔖',
      	-- Set UI orientation
      	-- Type: 'vertical' | 'horizontal' | LayoutProvider
      	-- Advanced customization: you may set your own layout provider for fine-grained control over layout
      	-- See `layout.lua` for guidance on setting this up
      	orientation = 'vertical',
      	-- Enable to show mark index in status column
      	enable_status_col_display = false,
      	-- The character rendered before the currently selected bookmark in the UI
      	cursor_character = '>',
      	-- Set whether or not to persist bookmarks per git branch
      	persist_by_git_branch = false,
      }
      
      
        {
          'nvim-lualine/lualine.nvim',
          config = function()
            require('lualine').setup {
              sections = {
                lualine_b = { 'spelunk' },
      	  -- Or, added to the default lualine_b config from here: https://github.com/nvim-lualine/lualine.nvim?tab=readme-ov-file#default-configuration
                -- lualine_b = { 'branch', 'diff', 'diagnostics', 'spelunk' },
              },
            }
          end
        },
      
      
      
      require('spelunk').setup(opts)
      
      
      	function(abspath)
      		return vim.fn.fnamemodify(abspath, ':~:.')
      	end
      	
      
      	M.display_function = function(mark)
      		return string.format('%s:%d', M.filename_formatter(mark.file), mark.line)
      	end
      	
    end,
  },
  {
    "2KAbhishek/markit.nvim",
    config = function()
      
      {
          '2kabhishek/markit.nvim',
          dependencies = { '2kabhishek/pickme.nvim' },
          config = load_config('tools.marks'),
          event = { 'BufReadPre', 'BufNewFile' },
      },
      
      
      require('markit').setup {
        -- whether to add comprehensive default keybindings. default true
        add_default_keybindings = true,
        -- which builtin marks to show. default {}
        builtin_marks = { ".", "<", ">", "^" },
        -- whether movements cycle back to the beginning/end of buffer. default true
        cyclic = true,
        -- whether the shada file is updated after modifying uppercase marks. default false
        force_write_shada = false,
        -- how often (in ms) to redraw signs/recompute mark positions.
        -- higher value means better performance but may cause visual lag,
        -- while lower value may cause performance penalties. default 150.
        refresh_interval = 150,
        -- sign priorities for each type of mark - builtin marks, uppercase marks, lowercase
        -- marks, and bookmarks.
        -- can be either a table with all/none of the keys, or a single number, in which case
        -- the priority applies to all marks.
        -- default 10.
        sign_priority = { lower=10, upper=15, builtin=8, bookmark=20 },
        -- disables mark tracking for specific filetypes. default {}
        excluded_filetypes = {},
        -- disables mark tracking for specific buftypes. default {}
        excluded_buftypes = {},
        -- bookmark groups configuration
        bookmarks = {
          {
            sign = "⚑",           -- string: sign character to display (empty string to disable)
            virt_text = "hello",  -- string: virtual text to show at end of line
            annotate = false      -- boolean: whether to prompt for annotation when setting bookmark
          },
          { sign = "!", virt_text = "", annotate = false },
          { sign = "@", virt_text = "", annotate = true },
        },
      }
      
    end,
  },
  {
    "you-n-g/navigate-note.nvim",
    config = function()
      
      -- Lazy.nvim
      {
        "you-n-g/navigate-note.nvim",
        config=true,
      }
      
      
      -- Lazy.nvim
      {
        "you-n-g/navigate-note.nvim",
        opts = {
      		filename = "nav.md", -- The filename of the markdown.
      		width = 0.6, -- The width of the popup window when jumping in the file with <tab>.
      		keymaps = {
      			nav_mode = {
      				-- Navigation & Jumping
      				next = "<tab>",
      				prev = "<s-tab>",
      				open = "<m-cr>",
      				switch_back = "<m-h>", -- Switch back to the previous file from `nav.md`.
      				-- Editing
      				append_link = "<m-p>", -- (P)aste will more align with the meaning.
      				-- Mode switching
      				jump_mode = "<m-l>", -- When we jump to a file, jump to the file only or jump to the exact file:line.
      			},
      			add = "<localleader>na",
      			open_nav = "<m-h>", -- Switch to `nav.md`.
      		},
      		link_surround = {  -- sometime you may want to change the link format in case of conflict with other formatting conversion.
      			left = "[[", -- The left delimiter for links.
      			right = "]]" -- The right delimiter for links.
      		},
      		context_line_count = { -- It would be a total of `2 * context_line_count - 1` lines.
      			tab = 8,
      			vline = 2,
      		},
          enable_block = false, -- enable block navigation; block navigation indicates only the block under the cursor will display the peeking window; mark the block with --- or ***
        }
      }
      
    end,
  },
  {
    "zongben/navimark.nvim",
    config = function()
      
      {
        "zongben/navimark.nvim",
        dependencies = {
          "nvim-telescope/telescope.nvim",
          "nvim-lua/plenary.nvim"
        },
        config = function()
          require("navimark").setup()
        end,
      }
      
      
      {
        --set "" to disable keymapping
        keymap = {
          base = {
            mark_toggle = "<leader>mm",
            mark_add = "<leader>ma",
            mark_add_with_title = "<leader>mt",
            mark_remove = "<leader>mr",
      
            -- this only goes to the next/previous mark in the same file
            goto_next_mark = "]m",
            goto_prev_mark = "[m",
      
            open_mark_picker = "<leader>fm",
          },
          telescope = {
            n = {
              delete_mark = "d",
              clear_marks = "c",
              set_mark_title = "t",
              next_stack = "<Tab>",
              prev_stack = "<S-Tab>",
              new_stack = "N",
              rename_stack = "R",
              delete_stack = "D",
              -- open all marked files in current stack
              open_all_marked_files = "<C-o>", 
            },
          },
        },
        sign = {
          text = "",
          color = "#FF0000",
          --options: above || eol || eol_right_align || right_align || none
          -- If set to 'none', you can still assign a title to a mark.
          -- The title will only appear in Telescope but will not be shown as virt_text in the editor.
          title_position = "above"
        },
        --set to true to persist stacks and marks
        persist = true,
      
        --options: manual || auto
        --auto: When the cwd changes, if a stack has the same root_dir as the cwd, that stack will be loaded automatically
        --manual: manage stacks manually
        stack_mode = "auto",
      }
      
      
      local stack = require("navimark.stack")
      stack.mark_toggle()
      stack.mark_add()
      stack.mark_add_with_title()
      stack.mark_remove()
      stack.goto_next_mark()
      stack.goto_prev_mark()
      
      --root_dir is optional. If not provided, stack root_dir will be nil
      stack.new_stack(name, root_dir)
      
      -- dir is optional. If not provided, the cwd will be used as the root_dir.
      -- If stack mode is set to auto, this enables autoloading
      -- when the cwd matches the stack's root_dir.
      -- or you can call :Navimark SaveRootDir to do the same function using cwd as root_dir.
      stack.save_root_dir(dir)
      
      local tele = require("navimark.tele")
      tele.open_mark_picker()
      
      
      return {
        "zongben/navimark.nvim",
        config = function()
          require("navimark").setup({
            persist = true,
            stack_mode = "auto",
          })
        end,
      },
      {
        "zongben/proot.nvim",
        config = function()
          local try_create_stack = function(name, path)
            local stack = require("navimark.stack")
            for _, s in ipairs(stack.stacks) do
              if s.root_dir == path then
                return
              end
            end
      
            stack.new_stack(name, path)
            stack.next_stack()
          end
      
          require("proot").setup({
            events = {
              detected = function(name, path)
                try_create_stack(name, path)
              end,
              entered = function(name, path)
                try_create_stack(name, path)
              end
            },
          })
        end
      }
      
    end,
  },
  {
    "francescarpi/buffon.nvim",
    config = function()
      
      return {
        {
          "francescarpi/buffon.nvim",
          branch = "main",
          ---@type BuffonConfig
          opts = {
            --- Add your config here
          },
          dependencies = {
            "nvim-tree/nvim-web-devicons",
            "nvim-lua/plenary.nvim",
          },
        },
      }
      
      
      return {
        {
          "francescarpi/buffon.nvim",
          branch = "main",
          ---@type BuffonConfig
          opts = {
            cyclic_navigation = true,
          },
          dependencies = {
            "nvim-tree/nvim-web-devicons",
            "nvim-lua/plenary.nvim",
          },
        },
      }
      
      
      {
        cyclic_navigation = true,
        --- possible values:
        ---   "start": buffers are added at the begginning of the buffers list
        ---   "end": buffers are added at the end of the list
        ---   "after": are added after the active buffer
        new_buffer_position = "end",
        num_pages = 2,
        open = {
          by_default = true,
          offset = {
            x = 0,
            y = 0,
          },
          ignore_ft = {
            "gitcommit",
            "gitrebase",
          },
          default_position = "top_right"
        },
        --- Buffers that should be ignored by buffon
        --- It accepts a list of regex patterns
        ignore_buff_names = {
          "diffpanel_",
        },
        sort_buffers_by_loaded_status = false,
        theme = {
          unloaded_buffer = "#404040",
          shortcut = "#CC7832",
          active = "#51afef",
          unsaved_indicator = "#f70067",
        },
        leader_key = ";",
        mapping_chars = "qweryuiop",
        keybindings = {
          goto_next_buffer = "<s-j>",
          goto_previous_buffer = "<s-k>",
          move_buffer_up = "<s-l>",
          move_buffer_down = "<s-h>",
          move_buffer_top = "<s-t>",
          move_buffer_bottom = "<s-b>",
          toggle_buffon_window = "<buffonleader>n",
          --- Toggle window position allows moving the main window position
          --- between top-right and bottom-right positions
          toggle_buffon_window_position = "<buffonleader>nn",
          switch_previous_used_buffer = "<buffonleader><buffonleader>",
          close_buffer = "<buffonleader>d",
          close_buffers_above = "<buffonleader>v",
          close_buffers_below = "<buffonleader>b",
          close_all_buffers = "<buffonleader>cc",
          close_others = "<buffonleader>cd",
          reopen_recent_closed_buffer = "<buffonleader>t",
          show_help = "<buffonleader>h",
          previous_page = "<buffonleader>z",
          next_page = "<buffonleader>x",
          move_to_previous_page = "<buffonleader>a",
          move_to_next_page = "<buffonleader>s",
        },
      }
      
      
      > vim.keymap.set("n", "c-l", vim.lsp.buf.hover)
      > 
      
      {
        goto_next_buffer,
        goto_previous_buffer,
        move_buffer_up,
        move_buffer_down,
        move_buffer_top,
        move_buffer_bottom,
        switch_previous_used_buffer,
        close_buffer,
        close_buffers_above,
        close_buffers_below,
        close_all_buffers,
        close_others,
        reopen_recent_closed_buffer,
      }
      
      
      {
        opts = {
          keybindings = {
            close_buffer = "false"
            close_others = ""
          },
        },
      }
      
      
      vim.api.nvim_set_hl(0, "BuffonUnloadedBuffer", { fg = "#404040" })
      
      
      require("buffon").add(function (maincontroller)
        vim.notify(vim.inspect(maincontroller.config))
      end)
      
      
      return {
        "plugin-author/plugin-repo",
        opts = {},
        ...
      }
      
      
      local M = {}
      local config = {}
      
      ---@type BuffonPluginFunc add this for better completion
      local function initialize_plugin(maincontroller)
        if config.remap["x"] then
          maincontroller.config.mapping_chars["x"] = "z"
        else
          maincontroller.config.mapping_chars = ""
        end
      end
      
      function M.setup(opts)
        config = opts
        require("buffon").add(initialize_plugin)
      end
      
      return M
      
    end,
  },
  {
    "Beargruug/skipper.nvim/",
  },
  {
    "mohseenrm/marko.nvim",
    config = function()
      
      use {
        "mohseenrm/marko.nvim",
        config = function()
          require("marko").setup()
        end
      }
      
      
      {
        "mohseenrm/marko.nvim",
        config = function()
          require("marko").setup()
        end
      }
      
      
      {
        "mohseenrm/marko.nvim",
        opts = {
          debug = false
        }
      }
      
      
      require("marko").setup()
      
      
      require("marko").setup({
        debug = false      -- Set to true for verbose logging
      })
      
      
      use {
        "~/path/to/marko.nvim",
        config = function()
          require("marko").setup({
            debug = true -- Enable debug logging during development
          })
        end
      }
      
      
      {
        dir = "~/path/to/marko.nvim",
        dev = true,
        opts = {
          debug = true -- Enable debug logging during development
        }
      }
      
      
      require("marko").setup({
        debug = true
      })
      
    end,
  },
  {
    "y3owk1n/warp.nvim",
    config = function()
      
      -- warp.lua
      return {
       "y3owk1n/warp.nvim",
       version = "*", -- remove this if you want to use the `main` branch
       opts = {
        -- your configuration comes here
        -- or leave it empty to use the default settings
        -- refer to the configuration section below
       }
      }
      
      
      require("warp").setup({
        -- your configuration
      })
      
      
      ---@type Warp.Config
      {
        -- [auto_prune] automatically prunes by checking if it's a readable file
        -- if `auto_prune` is set to `true`, it will prune all the unreadable files
        -- if `auto_prune` is set to `false`, it will not prune any files but warns you in the list and during navigation
        -- default is `false` by assuming git branch management, and files might be deleted, and you still want to keep it
        -- this gives the flexibility of how you want to keep the files in your fingertips and manage them yourself
        auto_prune = false,
        -- [root_markers] order based markers for root detection, disable root_markers by setting it to {} and it will fallback to only `cwd` as root
        root_markers = { ".git" },
        -- [root_detection_fn] this function must return a path that exists in string
        -- `root_markers` are checked in order, if the function returns a path that doesn't exist, it will fallback to `cwd`
        -- NOTE: this defines a root for the project to be saved and synced to the storage
        -- you can do fancy detection like if condition then a root that you want, else then another root or a global root
        root_detection_fn = require("warp.builtins").root_detection_fn,
        -- [list_item_format_fn] this function must return in Warp.FormattedLineOpts[]
        -- Warp.FormattedLineOpts is a table and some notable fields are `display_text`, optional `hl_group` and `is_virtual`
        -- passing anything other than specified format will be ommited
        list_item_format_fn = require("warp.builtins").list_item_format_fn,
        -- [keymaps] if you don't want certain keymaps, just set it to {}
        keymaps = {
          quit = { "q", "<Esc>" }, -- quit the warp selection window
          select = { "<CR>" }, -- select the file in the warp selection window
          delete = { "dd" }, -- delete the file in the warp selection window
          move_up = { "<C-k>" }, -- move an item up in the warp selection window
          move_down = { "<C-j>" }, -- move an item down in the warp selection window
          split_horizontal = { "<C-w>s" }, -- horizontal split
          split_vertical = { "<C-w>v" }, -- vertical split
          show_help = { "g?" }, -- show the help menu
        },
        -- [window] window configurations
        window = {
          -- [window.list] window configurations for the list window
          -- can be a table of `win_config` or a function that takes a list of lines and returns a `win_config`
          list = {},
          -- [window.help] window configurations for the help window
          -- can be a table of `win_config` or a function that takes a list of lines and returns a `win_config`
          help = {},
        },
        hl_groups = {
          --- list window hl
          list_normal = { link = "Normal" },
          list_border = { link = "FloatBorder" },
          list_title = { link = "FloatTitle" },
          list_footer = { link = "FloatFooter" },
          list_cursor_line = { link = "CursorLine" },
          list_item_active = { link = "Added" },
          list_item_error = { link = "Error" },
          --- help window hl
          help_normal = { link = "Normal" },
          help_border = { link = "FloatBorder" },
          help_title = { link = "FloatTitle" },
          help_footer = { link = "FloatFooter" },
          help_cursor_line = { link = "CursorLine" },
        },
      }
      
      
      ---@class Warp.Config
      ---@field auto_prune? boolean Whether to auto prune the list, defaults to false
      ---@field root_markers? string[] The root markers to check, defaults to { ".git" } and fallback to cwd, set to {} to nil it
      ---@field root_detection_fn? fun(): string The function to detect the root, defaults to `require("warp.storage").find_project_root`
      ---@field list_item_format_fn? fun(warp_item_entry: Warp.ListItem, index: number, is_active: boolean|nil, is_file_exists: boolean|nil): Warp.FormattedLineOpts[] The function to format the list items lines, defaults to `require("warp.ui").default_list_item_format`
      ---@field keymaps? Warp.Config.Keymaps The keymaps for actions
      ---@field window? Warp.Config.Window The windows configurations
      ---@field hl_groups? table<string, vim.api.keyset.highlight> The highlight groups for the list
      
      ---@class Warp.Config.Keymaps
      ---@field quit? string[]
      ---@field select? string[]
      ---@field delete? string[]
      ---@field move_up? string[]
      ---@field move_down? string[]
      ---@field split_horizontal? string[]
      ---@field split_vertical? string[]
      ---@field show_help? string[]
      
      ---@class Warp.ListItem
      ---@field path string The path of the file
      ---@field cursor number[] The cursor position as {row, col}
      
      ---@class Warp.FormattedLineOpts
      ---@field display_text string The display text
      ---@field hl_group? string The highlight group of the text
      ---@field is_virtual? boolean Whether the line is virtual
      
      ---@class Warp.ComputedLineOpts : Warp.FormattedLineOpts
      ---@field col_start? number The start column of the text, NOTE: this is calculated and for type purpose only
      ---@field col_end? number The end column of the text, NOTE: this is calculated and for type purpose only
      
      ---@class Warp.Config.Window
      ---@field list? vim.api.keyset.win_config|fun(lines: string[]):vim.api.keyset.win_config The window configurations for the list window
      ---@field help? vim.api.keyset.win_config|fun(lines:string[]):vim.api.keyset.win_config The window configurations for the help window
      
      
      {
        "y3owk1n/warp.nvim",
        event = "VeryLazy",
        cmd = {
          "WarpAddFile",
          "WarpAddOnScreenFiles",
          "WarpDelFile",
          "WarpMoveTo",
          "WarpShowList",
          "WarpClearCurrentList",
          "WarpClearAllList",
          "WarpGoToIndex",
        },
        ---@module "warp"
        ---@type Warp.Config
        opts = {},
        keys = {
          {
            ---For which key usage
            "<leader>h",
            "",
            desc = "warp",
          },
          {
            ---For which key usage
            "<leader>hm",
            "",
            desc = "move",
          },
          {
            "<leader>ha",
            "<cmd>WarpAddFile<cr>",
            desc = "[Warp] Add",
          },
          {
            "<leader>hA",
            "<cmd>WarpAddOnScreenFiles<cr>",
            desc = "[Warp] Add all on screen files",
          },
          {
            "<leader>hd",
            "<cmd>WarpDelFile<cr>",
            desc = "[Warp] Delete",
          },
          {
            "<leader>he",
            "<cmd>WarpShowList<cr>",
            desc = "[Warp] Show list",
          },
          {
            "<leader>hml",
            "<cmd>WarpMoveTo next<cr>",
            desc = "[Warp] Move to next index",
          },
          {
            "<leader>hmh",
            "<cmd>WarpMoveTo prev<cr>",
            desc = "[Warp] Move to prev index",
          },
          {
            "<leader>hmL",
            "<cmd>WarpMoveTo last<cr>",
            desc = "[Warp] Move to the last index",
          },
          {
            "<leader>hmH",
            "<cmd>WarpMoveTo first<cr>",
            desc = "[Warp] Move to first index",
          },
          {
            "<leader>hx",
            "<cmd>WarpClearCurrentList<cr>",
            desc = "[Warp] Clear current list",
          },
          {
            "<leader>hX",
            "<cmd>WarpClearAllList<cr>",
            desc = "[Warp] Clear all lists",
          },
          {
            "<leader>hl",
            "<cmd>WarpGoToIndex next<cr>",
            desc = "[Warp] Goto next index",
          },
          {
            "<leader>hh",
            "<cmd>WarpGoToIndex prev<cr>",
            desc = "[Warp] Goto prev index",
          },
          {
            "<leader>hH",
            "<cmd>WarpGoToIndex first<cr>",
            desc = "[Warp] Goto first index",
          },
          {
            "<leader>hL",
            "<cmd>WarpGoToIndex last<cr>",
            desc = "[Warp] Goto last index",
          },
          {
            "<leader>1",
            "<cmd>WarpGoToIndex 1<cr>",
            desc = "[Warp] Goto #1",
          },
          {
            "<leader>2",
            "<cmd>WarpGoToIndex 2<cr>",
            desc = "[Warp] Goto #2",
          },
          {
            "<leader>3",
            "<cmd>WarpGoToIndex 3<cr>",
            desc = "[Warp] Goto #3",
          },
          {
            "<leader>4",
            "<cmd>WarpGoToIndex 4<cr>",
            desc = "[Warp] Goto #4",
          },
        },
      },
      
      
      require("warp").show_list()
      
      -- or any of the equivalents
      
      :WarpShowList
      :lua require("warp").show_list()
      
      
      require("warp").add()
      
      -- or any of the equivalents
      
      :WarpAddFile
      :lua require("warp").add()
      
      
      require("warp").add_all_onscreen()
      
      -- or any of the equivalents
      
      :WarpAddOnScreenFiles
      :lua require("warp").add_all_onscreen()
      
      
      require("warp").del()
      
      -- or any of the equivalents
      
      :WarpDelFile
      :lua require("warp").del()
      
      
      ---@alias Warp.Config.MoveDirection
      ---| '"prev"'
      ---| '"next"'
      ---| '"first"'
      ---| '"last"'
      
      ---@param direction_or_index Warp.Config.MoveDirection | number
      require("warp").goto_index(direction_or_index)
      
      -- or any of the equivalents
      
      :WarpGoToIndex {direction_or_index}
      :lua require("warp").goto_index(direction_or_index)
      
      
      ---@alias Warp.Config.MoveDirection
      ---| '"prev"'
      ---| '"next"'
      ---| '"first"'
      ---| '"last"'
      
      ---@param direction_or_index Warp.Config.MoveDirection | number
      require("warp").move_to(direction_or_index)
      
      -- or any of the equivalents
      
      :WarpMoveTo {direction_or_index}
      :lua require("warp").move_to(direction_or_index)
      
      
      require("warp").clear_current_list()
      
      -- or any of the equivalents
      
      :WarpClearCurrentList
      :lua require("warp").clear_current_list()
      
      
      require("warp").clear_all_list()
      
      -- or any of the equivalents
      
      :WarpClearAllList
      :lua require("warp").clear_all_list()
      
      
      ---@param from string
      ---@param to string
      require("warp").on_file_update(from, to)
      
      
      ---@param buf number
      ---@return { entry: Warp.ListItem, index: number }|nil
      require("warp").get_item_by_buf(buf)
      
      
      ---@return number
      require("warp").count()
      
      
      ---Find the root directory based on root markers, or fall back to cwd
      ---@return string root_path The root path
      ---@usage `require('warp.builtins').root_detection_fn()`
      function M.root_detection_fn()
        local cwd = vim.fn.getcwd()
      
        local config = require("warp.config").config
      
        local root_markers = config.root_markers
      
        if not root_markers or #root_markers == 0 then
          return cwd
        end
      
        local path = cwd
      
        while path ~= "/" do
          for _, marker in ipairs(root_markers) do
            local full = path .. "/" .. marker
            if fn.isdirectory(full) == 1 or fn.filereadable(full) == 1 then
              return path
            end
          end
      
          path = fn.fnamemodify(path, ":h")
        end
      
        --- fallback to cwd
        return cwd
      end
      
      
      ---@class Warp.ListItem
      ---@field path string The path of the file
      ---@field cursor number[] The cursor position as {row, col}
      
      ---@class Warp.FormattedLineOpts
      ---@field display_text string The display text
      ---@field hl_group? string The highlight group of the text
      ---@field is_virtual? boolean Whether the line is virtual
      
      ---Default format for the entry lines for warp list
      ---@param warp_item_entry Warp.ListItem The entry item
      ---@param index number The index of the entry
      ---@param is_active boolean|nil Whether the entry is active
      ---@param is_file_exists boolean|nil Whether the file exists in the system and reachable
      ---@return Warp.FormattedLineOpts[] formatted_entry The formatted entry
      ---@see warp.types.Warp.FormattedLineOpts
      ---@usage `require('warp.builtins').list_item_format_fn(warp_item_entry, index, is_active, is_file_exists)`
      function M.list_item_format_fn(warp_item_entry, index, is_active, is_file_exists)
        ---@type Warp.FormattedLineOpts
        local virtual_spacer = {
          display_text = " ",
          is_virtual = true,
        }
      
        ---@type Warp.FormattedLineOpts
        local display_index = {
          display_text = tostring(index),
          is_virtual = true,
        }
      
        if is_active then
          display_index.display_text = "*"
          display_index.hl_group = "Added"
        end
      
        if not is_file_exists then
          display_index.display_text = "x"
          display_index.hl_group = "Error"
        end
      
        local has_devicons, nvim_web_devicons = pcall(require, "nvim-web-devicons")
      
        ---@type Warp.FormattedLineOpts
        ---@diagnostic disable-next-line: missing-fields
        local display_ft_icon = {}
      
        if has_devicons then
          local ft_icon, ft_icon_hl = nvim_web_devicons.get_icon(warp_item_entry.path, nil, { default = true })
      
          ---@type Warp.FormattedLineOpts
          display_ft_icon = {
            display_text = ft_icon,
            hl_group = ft_icon_hl,
            is_virtual = true,
          }
        end
      
        ---@type Warp.FormattedLineOpts
        local display_path = {
          display_text = fn.fnamemodify(warp_item_entry.path, ":~:."),
        }
      
        if not is_file_exists then
          display_path.hl_group = "Error"
        end
      
        return {
          display_index,
          has_devicons and virtual_spacer,
          has_devicons and display_ft_icon,
          virtual_spacer,
          display_path,
        }
      end
      
      
      vim.api.nvim_create_autocmd("User", {
        pattern = "WarpAddedToList",
        callback = function()
          -- do something
        end,
      })
      
      
      vim.api.nvim_create_autocmd("User", {
        group = augroup,
        pattern = { "MiniFilesActionRename", "MiniFilesActionMove" },
        callback = function(ev)
          local from, to = ev.data.from, ev.data.to
      
          local warp_exists, warp = pcall(require, "warp")
          if warp_exists then
            warp.on_file_update(from, to)
          end
        end,
      })
      
      
      {
        "folke/snacks.nvim",
        opts = {},
        keys = {
          {
            "<leader>cr",
            function()
              Snacks.rename.rename_file({
                on_rename = function(to, from)
                  require("warp").on_file_update(from, to)
                end,
              })
            end,
            desc = "Rename File",
          },
        },
      },
      
      
      opts = function(_, opts)
        -- rest of the config
      
        local warp_exists, warp = pcall(require, "warp")
      
        -- rest of the config
      
        local Warp = {}
      
        if warp_exists then
          Warp = {
            condition = function()
              return warp.count() > 0
            end,
            init = function(self)
              local item = warp.get_item_by_buf(0)
              self.current = item and item.index or "-"
              self.total = warp.count()
            end,
            hl = { fg = "teal", bold = true },
            {
              provider = Space.provider,
            },
            {
              provider = function(self)
                local output = {}
      
                if self.total > 0 then
                  table.insert(output, string.format("[%s/%s]", tonumber(self.current) or "-", tonumber(self.total)))
                end
      
                local statusline = table.concat(output, " ")
                return string.format("󱐋 %s", statusline)
              end,
            },
          }
        end
      
        -- rest of the config
      
        local DefaultStatusline = {
          -- rest of default statusline
          Warp, --- add warp the default statusline
          -- rest of default statusline
        }
      
        -- rest of the config
      end,
      
      
      opts = function(_, opts)
        -- rest of the config
        local warp_exists, warp_list = pcall(require, "warp.list")
      
        local new_section = function(name, action, section)
          return { name = name, action = action, section = section }
        end
      
        local items = {
          new_section("e: Explore", "lua require('mini.files').open(vim.uv.cwd(), true)", "Navigate"),
          new_section("f: Find File", "Pick files", "Navigate"),
          new_section("g: Grep Text", "Pick grep_live", "Navigate"),
        }
      
        if warp_exists then
          local warps = warp_list.get.all()
      
          if #warps > 0 then
            for index, warp in ipairs(warps) do
              local display = vim.fn.pathshorten(vim.fn.fnamemodify(warp.path, ":~:."))
      
              table.insert(items, new_section(index .. ": " .. display, "WarpGoToIndex " .. index, "Warp"))
            end
          end
        end
      
        local config = {
          -- rest of the config
          items = items,
          -- rest of the config
        }
      
        return config
      end
      
      
      opts = {
        window = {
          list = function(lines)
            -- get all the line widths
            local line_widths = vim.tbl_map(vim.fn.strdisplaywidth, lines)
            -- set the width te either the max width or at least 20 characters
            local max_width = math.max(math.max(unpack(line_widths)), 30)
            -- set the height to if the number of lines is less than 8 then 8
            -- otherwise the number of lines
            local max_height = #lines < 8 and 8 or math.min(#lines, vim.o.lines - 3)
            -- get the current height of the TUI
            local nvim_tui_height = vim.api.nvim_list_uis()[1]
      
            return {
              width = max_width,
              height = max_height,
              row = nvim_tui_height.height - max_height - 4,
              col = 0,
            }
          end,
        },
      }
      
      
      -- first add it to the hl_groups field in config
      {
        hl_groups = {
          my_hl_group = { link = "Added" }, -- set anything as per `vim.api.vim.api.keyset.highlight`
        },
      }
      
      -- then use it in your formatter fn
      {
        list_item_format_fn = function(...)
          local utils = require("warp.utils")
          -- do some computation or conditional logic
          return {
            {
              display_text = "hello world",
              -- set the defined hl here
              -- notice that you can use the `utils.hlname` to get the hlgroup name with proper formatting
              -- or just do "WarpMyHlGroup"
              -- the `utils.hlname` is just a convenient helper that parses the string and converts it to PascalCase with `Warp` prefix
              hl_group = utils.hlname("my_hl_group"),
            }
          }
        end
      }
      
      
    end,
  },
  {
    "walkersumida/fusen.nvim",
    config = function()
      
      {
        "walkersumida/fusen.nvim",
        event = "VimEnter",
        opts = {},
      }
      
      
      {
        "walkersumida/fusen.nvim",
        event = "VimEnter",
        opts = {
          save_file = vim.fn.expand("$HOME") .. "/my_fusen_marks.json",
        }
      }
      
      
      use {
        "walkersumida/fusen.nvim",
        config = function()
          require("fusen").setup()
        end
      }
      
      
      require("fusen").setup()
      
      
      require("fusen").setup({
        -- Storage location
        save_file = vim.fn.expand("$HOME") .. "/fusen_marks.json",
        
        -- Mark appearance
        mark = {
          icon = "📝",
          hl_group = "FusenMark",
        },
        
        -- Key mappings
        keymaps = {
          add_mark = "me",        -- Add/edit sticky note
          clear_mark = "mc",      -- Clear mark at current line
          clear_buffer = "mC",    -- Clear all marks in buffer
          clear_all = "mD",       -- Clear ALL marks (deletes entire JSON content)
          next_mark = "mn",       -- Jump to next mark
          prev_mark = "mp",       -- Jump to previous mark
          list_marks = "ml",      -- Show marks in quickfix
        },
        
        -- Telescope integration settings
        telescope = {
          keymaps = {
            delete_mark_insert = "<C-d>",  -- Delete mark in insert mode
            delete_mark_normal = "<C-d>",  -- Delete mark in normal mode
          },
        },
        
        -- Sign column priority
        sign_priority = 10,
        
        -- Annotation display settings
        annotation_display = {
          mode = "float", -- "eol", "float", "both", "none"
          
          -- Float window settings
          float = {
            delay = 100,
            border = "rounded",
            max_width = 50,
            max_height = 10,
          },
        },
        
        -- Exclude specific filetypes from keymaps
        exclude_filetypes = {
          -- "neo-tree",     -- Example: neo-tree
          -- "NvimTree",     -- Example: nvim-tree
          -- "nerdtree",     -- Example: NERDTree
        },
      })
      
      
      require("fusen").setup({
        annotation_display = {
          mode = "float",
          float = {
            delay = 300,         -- Show after 300ms (default: 100ms)
            border = "single",   -- Border style: "single", "double", "rounded", etc.
            max_width = 60,      -- Maximum width (default: 50)
            max_height = 15,     -- Maximum height (default: 10)
          }
        }
      })
      
      
      -- Search through all sticky notes
      :Telescope fusen marks
      
      -- Set up a keybinding (example)
      vim.keymap.set("n", "<leader>fm", ":Telescope fusen marks<CR>", { desc = "Find fusen marks" })
      
      -- In Telescope window:
      -- <CR> - Jump to mark
      -- <C-d> - Delete mark (customizable, see configuration)
      
      -- Custom key mappings for Telescope
      require("fusen").setup({
        telescope = {
          keymaps = {
            delete_mark_insert = "<C-x>",  -- Custom key for insert mode
            delete_mark_normal = "dd",     -- Custom key for normal mode
          },
        },
      })
      
      
      require("fusen").setup({
        annotation_display = {
          mode = "float",  -- Use floating windows
          float = {
            delay = 300,         -- Show after 300ms
            border = "single",   -- Border style
            max_width = 60,      -- Maximum width
            max_height = 15,     -- Maximum height
          }
        }
      })
      
      
      require("fusen").setup({
        mark = {
          icon = "📝",
          hl_group = "MyCustomHighlight",  -- Custom highlight group
        },
      })
      
      -- Define your custom highlight group
      vim.api.nvim_set_hl(0, "MyCustomHighlight", {
        fg = "#ff6b6b",      -- Red foreground
        bg = "#1e1e1e",      -- Dark background
        bold = true,         -- Bold text
      })
      
      
      -- Set your own mappings
      vim.keymap.set("n", "<leader>m", require("fusen").add_mark)
      vim.keymap.set("n", "<leader>mc", require("fusen").clear_mark)
      -- etc...
      
    end,
  },
  {
    "wurli/visimatch.nvim",
  },
  {
    "kevinhwang91/nvim-hlslens",
    config = function()
      
      use {'kevinhwang91/nvim-hlslens'}
      
      
      require('hlslens').setup()
      
      local kopts = {noremap = true, silent = true}
      
      vim.api.nvim_set_keymap('n', 'n',
          [[<Cmd>execute('normal! ' . v:count1 . 'n')<CR><Cmd>lua require('hlslens').start()<CR>]],
          kopts)
      vim.api.nvim_set_keymap('n', 'N',
          [[<Cmd>execute('normal! ' . v:count1 . 'N')<CR><Cmd>lua require('hlslens').start()<CR>]],
          kopts)
      vim.api.nvim_set_keymap('n', '*', [[*<Cmd>lua require('hlslens').start()<CR>]], kopts)
      vim.api.nvim_set_keymap('n', '#', [[#<Cmd>lua require('hlslens').start()<CR>]], kopts)
      vim.api.nvim_set_keymap('n', 'g*', [[g*<Cmd>lua require('hlslens').start()<CR>]], kopts)
      vim.api.nvim_set_keymap('n', 'g#', [[g#<Cmd>lua require('hlslens').start()<CR>]], kopts)
      
      vim.api.nvim_set_keymap('n', '<Leader>l', '<Cmd>noh<CR>', kopts)
      
      
      {
          auto_enable = {
              description = [[Enable nvim-hlslens automatically]],
              default = true
          },
          enable_incsearch = {
              description = [[When `incsearch` option is on and enable_incsearch is true, add lens
                  for the current matched instance]],
              default = true
          },
          calm_down = {
              description = [[If calm_down is true, clear all lens and highlighting When the cursor is
                  out of the position range of the matched instance or any texts are changed]],
              default = false,
          },
          nearest_only = {
              description = [[Only add lens for the nearest matched instance and ignore others]],
              default = false
          },
          nearest_float_when = {
              description = [[When to open the floating window for the nearest lens.
                  'auto': floating window will be opened if room isn't enough for virtual text;
                  'always': always use floating window instead of virtual text;
                  'never': never use floating window for the nearest lens]],
              default = 'auto',
          },
          float_shadow_blend = {
              description = [[Winblend of the nearest floating window. `:h winbl` for more details]],
              default = 50,
          },
          virt_priority = {
              description = [[Priority of virtual text, set it lower to overlay others.
              `:h nvim_buf_set_extmark` for more details]],
              default = 100,
          },
          override_lens  = {
              description = [[Hackable function for customizing the lens. If you like hacking, you
                  should search `override_lens` and inspect the corresponding source code.
                  There's no guarantee that this function will not be changed in the future. If it is
                  changed, it will be listed in the CHANGES file.
                  @param render table an inner module for hlslens, use `setVirt` to set virtual text
                  @param splist table (1,1)-indexed position
                  @param nearest boolean whether nearest lens
                  @param idx number nearest index in the plist
                  @param relIdx number relative index, negative means before current position,
                                        positive means after
              ]],
              default = nil
          },
      }
      
      
      require('hlslens').setup({
          calm_down = true,
          nearest_only = true,
          nearest_float_when = 'always'
      })
      
      -- run `:nohlsearch` and export results to quickfix
      -- if Neovim is 0.8.0 before, remap yourself.
      vim.keymap.set({'n', 'x'}, '<Leader>L', function()
          vim.schedule(function()
              if require('hlslens').exportLastSearchToQuickfix() then
                  vim.cmd('cw')
              end
          end)
          return ':noh<CR>'
      end, {expr = true})
      
      
      require('hlslens').setup({
          override_lens = function(render, posList, nearest, idx, relIdx)
              local sfw = vim.v.searchforward == 1
              local indicator, text, chunks
              local absRelIdx = math.abs(relIdx)
              if absRelIdx > 1 then
                  indicator = ('%d%s'):format(absRelIdx, sfw ~= (relIdx > 1) and '▲' or '▼')
              elseif absRelIdx == 1 then
                  indicator = sfw ~= (relIdx == 1) and '▲' or '▼'
              else
                  indicator = ''
              end
      
              local lnum, col = unpack(posList[idx])
              if nearest then
                  local cnt = #posList
                  if indicator ~= '' then
                      text = ('[%s %d/%d]'):format(indicator, idx, cnt)
                  else
                      text = ('[%d/%d]'):format(idx, cnt)
                  end
                  chunks = {{' '}, {text, 'HlSearchLensNear'}}
              else
                  text = ('[%s %d]'):format(indicator, idx)
                  chunks = {{' '}, {text, 'HlSearchLens'}}
              end
              render.setVirt(0, lnum - 1, col - 1, chunks, nearest)
          end
      })
      
      
      -- packer
      use 'haya14busa/vim-asterisk'
      
      vim.api.nvim_set_keymap('n', '*', [[<Plug>(asterisk-z*)<Cmd>lua require('hlslens').start()<CR>]], {})
      vim.api.nvim_set_keymap('n', '#', [[<Plug>(asterisk-z#)<Cmd>lua require('hlslens').start()<CR>]], {})
      vim.api.nvim_set_keymap('n', 'g*', [[<Plug>(asterisk-gz*)<Cmd>lua require('hlslens').start()<CR>]], {})
      vim.api.nvim_set_keymap('n', 'g#', [[<Plug>(asterisk-gz#)<Cmd>lua require('hlslens').start()<CR>]], {})
      
      vim.api.nvim_set_keymap('x', '*', [[<Plug>(asterisk-z*)<Cmd>lua require('hlslens').start()<CR>]], {})
      vim.api.nvim_set_keymap('x', '#', [[<Plug>(asterisk-z#)<Cmd>lua require('hlslens').start()<CR>]], {})
      vim.api.nvim_set_keymap('x', 'g*', [[<Plug>(asterisk-gz*)<Cmd>lua require('hlslens').start()<CR>]], {})
      vim.api.nvim_set_keymap('x', 'g#', [[<Plug>(asterisk-gz#)<Cmd>lua require('hlslens').start()<CR>]], {})
      
      
      -- packer
      use {'kevinhwang91/nvim-ufo', requires = 'kevinhwang91/promise-async'}
      
      -- if Neovim is 0.8.0 before, remap yourself.
      local function nN(char)
          local ok, winid = hlslens.nNPeekWithUFO(char)
          if ok and winid then
              -- Safe to override buffer scope keymaps remapped by ufo,
              -- ufo will restore previous buffer keymaps before closing preview window
              -- Type <CR> will switch to preview window and fire `trace` action
              vim.keymap.set('n', '<CR>', function()
                  return '<Tab><CR>'
              end, {buffer = true, remap = true, expr = true})
          end
      end
      
      vim.keymap.set({'n', 'x'}, 'n', function() nN('n') end)
      vim.keymap.set({'n', 'x'}, 'N', function() nN('N') end)
      
      
      -- packer
      use 'mg979/vim-visual-multi'
      
      local hlslens = require('hlslens')
      if hlslens then
          local overrideLens = function(render, posList, nearest, idx, relIdx)
              local _ = relIdx
              local lnum, col = unpack(posList[idx])
      
              local text, chunks
              if nearest then
                  text = ('[%d/%d]'):format(idx, #posList)
                  chunks = {{' ', 'Ignore'}, {text, 'VM_Extend'}}
              else
                  text = ('[%d]'):format(idx)
                  chunks = {{' ', 'Ignore'}, {text, 'HlSearchLens'}}
              end
              render.setVirt(0, lnum - 1, col - 1, chunks, nearest)
          end
          local lensBak
          local config = require('hlslens.config')
          local gid = vim.api.nvim_create_augroup('VMlens', {})
          vim.api.nvim_create_autocmd('User', {
              pattern = {'visual_multi_start', 'visual_multi_exit'},
              group = gid,
              callback = function(ev)
                  if ev.match == 'visual_multi_start' then
                      lensBak = config.override_lens
                      config.override_lens = overrideLens
                  else
                      config.override_lens = lensBak
                  end
                  hlslens.start()
              end
          })
      end
      
    end,
  },
  {
    "rktjmp/highlight-current-n.nvim",
    config = function()
      
      your_package_manager "rktjmp/highlight-current-n.nvim"
      
      
      require("highlight_current_n").setup({
        highlight_group = "IncSearch" -- highlight group name to use for highlight
      })
      
      
      local function _1_()
        local hcn = require("highlight_current_n")
        local feedkeys = vim.api.nvim_feedkeys
        local _2_ = vim.v.searchforward
        if (_2_ == 0) then
          return hcn.N()
        elseif (_2_ == 1) then
          return hcn.n()
        else
          return nil
        end
      end
      vim.keymap.set("n", "n", _1_)
      
      local function _4_()
        local hcn = require("highlight_current_n")
        local feedkeys = vim.api.nvim_feedkeys
        local _5_ = vim.v.searchforward
        if (_5_ == 0) then
          return hcn.n()
        elseif (_5_ == 1) then
          return hcn.N()
        else
          return nil
        end
      end
      return vim.keymap.set("n", "N", _4_)
      
    end,
  },
  {
    "gaborvecsei/memento.nvim",
    config = function()
      
      Plug 'nvim-lua/plenary.nvim' -- if you already have this you don't need to include it again
      Plug 'gaborvecsei/memento.nvim'
      
      
      -- Open up history popup menu
      :lua require("memento").toggle()
      
      -- Clear history
      :lua require("memento").clear_history()
      
      
      nnoremap <leader>mh <cmd>lua require('memento').toggle()<CR>
      
      
      vim.g.memento_history = 20
      vim.g.memento_shorten_path = true
      vim.g.memento_window_width = 80
      vim.g.memento_window_height = 14
      
    end,
  },
  {
    "ray-x/sad.nvim",
    config = function()
      
        require("packer").startup({
          function(use)
            use({ "wbthomason/packer.nvim" })
            use({
              "ray-x/sad.nvim",
              requires = { "ray-x/guihua.lua", run = "cd lua/fzy && make" },
              config = function()
                require("sad").setup{}
              end,
            })
          end,
        })
      
      
      require'sad'.setup({
        debug = false, -- print debug info
        diff = 'delta', -- you can use `less`, `diff-so-fancy`
        ls_file = 'fd', -- also git ls-files
        exact = false, -- exact match
        vsplit = false, -- split sad window the screen vertically, when set to number
        -- it is a threadhold when window is larger than the threshold sad will split vertically,
        height_ratio = 0.6, -- height ratio of sad window when split horizontally
        width_ratio = 0.6, -- height ratio of sad window when split vertically
      
      })
      
      
      
      -- replace old with new
      lua require'sad'.replace('old', 'new')
      
      -- or replace old with input for 'md' files
      lua require'sad'.replace('old', nil, 'md')
      
      -- or replace expand('<word>') or visual select with 'new' for md files
      lua require'sad'.replace(nil, 'new', 'md')
      
      -- or replace expand('<word>') or visual select with your input for md files
      lua require'sad'.replace(nil, nil, 'md')
      
      
    end,
  },
  {
    "s1n7ax/nvim-search-and-replace",
    config = function()
      
      use {
          's1n7ax/nvim-search-and-replace',
          config = function() require'nvim-search-and-replace'.setup() end,
      }
      
      
      -- search the word "test" in ".js" files and replace them glabally in every file
      /test/g **/*.js
      
      -- search the word "test" in all files and replace them glabally in every file
      test/g
      
      -- search the word "test" in all files and replace one time for single line
      test
      
      -- seach any word starts with "te" and ends with "st" and replace one time for single line
      te.*st
      
      -- seach "print(something)" and add something to match group
      print(\(.*\))
      
      
      require('nvim-search-and-replace').setup{
          -- file patters to ignore
          ignore = {'**/node_modules/**', '**/.git/**',  '**/.gitignore', '**/.gitmodules','build/**'},
      
          -- save the changes after replace
          update_changes = false,
      
          -- keymap for search and replace
          replace_keymap = '<leader>gr',
      
          -- keymap for search and replace ( this does not care about ignored files )
          replace_all_keymap = '<leader>gR',
      
          -- keymap for search and replace
          replace_and_save_keymap = '<leader>gu',
      
          -- keymap for search and replace ( this does not care about ignored files )
          replace_all_and_save_keymap = '<leader>gU',
      }
      
      
      require('nvim-global-replace').setup(config)
      
      -- require('nvim-global-replace').search_and_replace({
      --      ignore = { 'tests/**'} , update_changes = true
      -- })
      require('nvim-global-replace').replace(opts)
      
      -- require('nvim-global-replace').search_and_replace({
      --      update_changes = true
      -- })
      require('nvim-global-replace').replace_all(opts)
      
    end,
  },
  {
    "roobert/search-replace.nvim",
  },
  {
    "AckslD/muren.nvim/",
  },
  {
    "nvim-pack/nvim-spectre",
    config = function()
      
      Plug 'nvim-lua/plenary.nvim'
      Plug 'nvim-pack/nvim-spectre'
      
      
      vim.keymap.set('n', '<leader>S', '<cmd>lua require("spectre").toggle()<CR>', {
          desc = "Toggle Spectre"
      })
      vim.keymap.set('n', '<leader>sw', '<cmd>lua require("spectre").open_visual({select_word=true})<CR>', {
          desc = "Search current word"
      })
      vim.keymap.set('v', '<leader>sw', '<esc><cmd>lua require("spectre").open_visual()<CR>', {
          desc = "Search current word"
      })
      vim.keymap.set('n', '<leader>sp', '<cmd>lua require("spectre").open_file_search({select_word=true})<CR>', {
          desc = "Search on current file"
      })
      
      
      require('spectre').setup()
      
      
      require('spectre').setup({
      
        color_devicons = true,
        open_cmd = 'vnew', -- can also be a lua function
        live_update = false, -- auto execute search again when you write to any file in vim
        lnum_for_results = true, -- show line number for search/replace results
        line_sep_start = '┌-----------------------------------------',
        result_padding = '¦  ',
        line_sep       = '└-----------------------------------------',
        highlight = {
            ui = "String",
            search = "DiffChange",
            replace = "DiffDelete"
        },
        mapping={
          ['tab'] = {
              map = '<Tab>',
              cmd = "<cmd>lua require('spectre').tab()<cr>",
              desc = 'next query'
          },
          ['shift-tab'] = {
              map = '<S-Tab>',
              cmd = "<cmd>lua require('spectre').tab_shift()<cr>",
              desc = 'previous query'
          },
          ['toggle_line'] = {
              map = "dd",
              cmd = "<cmd>lua require('spectre').toggle_line()<CR>",
              desc = "toggle item"
          },
          ['enter_file'] = {
              map = "<cr>",
              cmd = "<cmd>lua require('spectre.actions').select_entry()<CR>",
              desc = "open file"
          },
          ['send_to_qf'] = {
              map = "<leader>q",
              cmd = "<cmd>lua require('spectre.actions').send_to_qf()<CR>",
              desc = "send all items to quickfix"
          },
          ['replace_cmd'] = {
              map = "<leader>c",
              cmd = "<cmd>lua require('spectre.actions').replace_cmd()<CR>",
              desc = "input replace command"
          },
          ['show_option_menu'] = {
              map = "<leader>o",
              cmd = "<cmd>lua require('spectre').show_options()<CR>",
              desc = "show options"
          },
          ['run_current_replace'] = {
            map = "<leader>rc",
            cmd = "<cmd>lua require('spectre.actions').run_current_replace()<CR>",
            desc = "replace current line"
          },
          ['run_replace'] = {
              map = "<leader>R",
              cmd = "<cmd>lua require('spectre.actions').run_replace()<CR>",
              desc = "replace all"
          },
          ['change_view_mode'] = {
              map = "<leader>v",
              cmd = "<cmd>lua require('spectre').change_view()<CR>",
              desc = "change result view mode"
          },
          ['change_replace_sed'] = {
            map = "trs",
            cmd = "<cmd>lua require('spectre').change_engine_replace('sed')<CR>",
            desc = "use sed to replace"
          },
          ['change_replace_oxi'] = {
            map = "tro",
            cmd = "<cmd>lua require('spectre').change_engine_replace('oxi')<CR>",
            desc = "use oxi to replace"
          },
          ['toggle_live_update']={
            map = "tu",
            cmd = "<cmd>lua require('spectre').toggle_live_update()<CR>",
            desc = "update when vim writes to file"
          },
          ['toggle_ignore_case'] = {
            map = "ti",
            cmd = "<cmd>lua require('spectre').change_options('ignore-case')<CR>",
            desc = "toggle ignore case"
          },
          ['toggle_ignore_hidden'] = {
            map = "th",
            cmd = "<cmd>lua require('spectre').change_options('hidden')<CR>",
            desc = "toggle search hidden"
          },
          ['resume_last_search'] = {
            map = "<leader>l",
            cmd = "<cmd>lua require('spectre').resume_last_search()<CR>",
            desc = "repeat last search"
          },
          ['select_template'] = {
              map = '<leader>rp',
              cmd = "<cmd>lua require('spectre.actions').select_template()<CR>",
              desc = 'pick template',
          },
          ['delete_line'] = {
              map = '<leader>rd',
              cmd = "<cmd>lua require('spectre.actions').run_delete_line()<CR>",
              desc = 'delete line',
          }
          -- you can put your mapping here it only use normal mode
        },
        find_engine = {
          -- rg is map with finder_cmd
          ['rg'] = {
            cmd = "rg",
            -- default args
            args = {
              '--color=never',
              '--no-heading',
              '--with-filename',
              '--line-number',
              '--column',
            },
            options = {
              ['ignore-case'] = {
                value= "--ignore-case",
                icon="[I]",
                desc="ignore case"
              },
              ['hidden'] = {
                value="--hidden",
                desc="hidden file",
                icon="[H]"
              },
              -- you can put any rg search option you want here it can toggle with
              -- show_option function
            }
          },
          ['ag'] = {
            cmd = "ag",
            args = {
              '--vimgrep',
              '-s'
            } ,
            options = {
              ['ignore-case'] = {
                value= "-i",
                icon="[I]",
                desc="ignore case"
              },
              ['hidden'] = {
                value="--hidden",
                desc="hidden file",
                icon="[H]"
              },
            },
          },
        },
        replace_engine={
            ['sed']={
                cmd = "sed",
                args = nil,
                options = {
                  ['ignore-case'] = {
                    value= "--ignore-case",
                    icon="[I]",
                    desc="ignore case"
                  },
                }
            },
            -- call rust code by nvim-oxi to replace
            ['oxi'] = {
              cmd = 'oxi',
              args = {},
              options = {
                ['ignore-case'] = {
                  value = "i",
                  icon = "[I]",
                  desc = "ignore case"
                },
              }
            },
            ['sd'] = {
              cmd = "sd",
              options = { },
            },
        },
        default = {
            find = {
                --pick one of item in find_engine
                cmd = "rg",
                options = {"ignore-case"}
            },
            replace={
                --pick one of item in replace_engine
                cmd = "sed"
            }
        },
        replace_vim_cmd = "cdo",
        use_trouble_qf = false, -- use trouble.nvim as quickfix list
        is_open_target_win = true, --open file on opener window
        is_insert_mode = false,  -- start open panel on is_insert_mode
        is_block_ui_break = false -- mapping backspace and enter key to avoid ui break
        open_template      = {
          -- an template to use on open function
          -- see the 'custom function' section below to learn how to configure the template
          -- { search_text = 'text1', replace_text = '', path = "" }
        }
      })
      
      
      
      -- if you want to get items from spectre panel you can use some of the
      -- following functions to get data from spectre.
      require('spectre.actions').get_current_entry()
      require('spectre.actions').get_all_entries()
      require('spectre.actions').get_state()
      
      -- write your custom open function
      require('spectre').open({
        is_insert_mode = true,
        -- the directory where the search tool will be started in
        cwd = "~/.config/nvim",
        search_text="test",
        replace_text="test",
        -- the pattern of files to consider for searching
        path="lua/**/*.lua",
        -- the directories or files to search in
        search_paths = {"lua/", "plugin/"},
        is_close = false, -- close an exists instance of spectre and open new
      })
      -- you can use all variables above on command line
      -- for example: Spectre % is_insert_mode=true cwd=~/.config/nvim
      -- in this example `%` will expand to current file.
      
      
      require('spectre').setup({
          default = {
              replace = {
                  cmd = "oxi"
             }
          }
      })
      
      
          require('windline').add_status(
              require('spectre.state_utils').status_line()
          )
      
      
      require('spectre').setup({ is_block_ui_break = true })
      
    end,
  },
  {
    "nvimdev/hlsearch.nvim",
    config = function()
      
      packer.use {'nvimdev/hlsearch.nvim', event = 'BufRead' config = function()
          require('hlsearch').setup()
      end}
      
    end,
  },
  {
    "mangelozzi/rgflow.nvim",
    config = function()
      
      require('rgflow').setup(
          {
              -- Set the default rip grep flags and options for when running a search via
              -- RgFlow. Once changed via the UI, the previous search flags are used for 
              -- each subsequent search (until Neovim restarts).
              cmd_flags = "--smart-case --fixed-strings --ignore --max-columns 200",
      
              -- Mappings to trigger RgFlow functions
              default_trigger_mappings = true,
              -- These mappings are only active when the RgFlow UI (panel) is open
              default_ui_mappings = true,
              -- QuickFix window only mapping
              default_quickfix_mappings = true,
          }
      )
      
      
          mappings = {
              trigger = {
                  -- Normal mode maps
                  n = {
                      ["<leader>rG"] = "open_blank",      -- Open UI - search pattern = blank
                      ["<leader>rp"] = "open_paste",      -- Open UI - search pattern = First line of unnamed register as the search pattern
                      ["<leader>rg"] = "open_cword",      -- Open UI - search pattern = <cword>
                      ["<leader>rw"] = "open_cword_path", -- Open UI - search pattern = <cword> and path = current file's directory
                      ["<leader>rs"] = "search",          -- Run a search with the current parameters
                      ["<leader>ra"] = "open_again",      -- Open UI - search pattern = Previous search pattern
                      ["<leader>rx"] = "abort",           -- Close UI / abort searching / abortadding results
                      ["<leader>rc"] = "print_cmd",       -- Print a version of last run rip grep that can be pasted into a shell
                      ["<leader>r?"] = "print_status",    -- Print info about the current state of rgflow (mostly useful for deving on rgflow)
                  },
                  -- Visual/select mode maps
                  x = {
                      ["<leader>rg"] = "open_visual", -- Open UI - search pattern = current visual selection
                  },
              },
              -- Mappings that are local only to the RgFlow UI
              ui = {
                  -- Normal mode maps
                  n = {
                      ["<CR>"]  = "start",         -- With the ui open, start a search with the current parameters
                      ["<ESC>"] = "close",         -- With the ui open, discard and close the UI window
                      ["?"]     = "show_rg_help",  -- Show the rg help in a floating window, which can be closed with q or <ESC> or the usual <C-W><C-C>
                      ["<BS>"]  = "parent_path",   -- Change the path to parent directory
                      ["-"]     = "parent_path",   -- Change the path to parent directory
                      ["<C-^>"] = "edit_alt_file", -- Switch to the alternate file
                      ["<C-6>"] = "edit_alt_file", -- Switch to the alternate file
                      ["<C-^>"] = "nop",           -- No operation
                      ["<C-6>"] = "nop",           -- No operation
                  },
                  -- Insert mode maps
                  i = {
                      ["<CR>"]  = "start",         -- With the ui open, start a search with the current parameters (from insert mode)
                      ["<TAB>"] = "auto_complete", -- Start autocomplete if PUM not visible, if visible use own hotkeys to select an option
                      ["<C-N>"] = "auto_complete", -- Start autocomplete if PUM not visible, if visible use own hotkeys to select an option
                      ["<C-P>"] = "auto_complete", -- Start autocomplete if PUM not visible, if visible use own hotkeys to select an option
                  },
              },
              -- Mapping that are local only to the QuickFix window
              quickfix = {
                  -- Normal
                  n = {
                      ["d"] = "qf_delete",        -- QuickFix normal mode delete operator
                      ["dd"] = "qf_delete_line",  -- QuickFix delete a line from quickfix
                      ["<TAB>"] = "qf_mark",      -- QuickFix mark a line in the quickfix
                      ["<S-TAB>"] = "qf_unmark",  -- QuickFix unmark a line in the quickfix window
                      ["<BS>"]  = "nop", -- No operation
                      ["<C-^>"] = "nop", -- No operation - Probably don't want to switch to a buffer in the little quickfix window
                      ["<C-6>"] = "nop", -- No operation
                  },
                  -- Visual/select mode maps
                  x = {
                      ["d"] = "qf_delete_visual",       -- QuickFix visual mode delete operator
                      ["<TAB>"] = "qf_mark_visual",     -- QuickFix visual mode mark operator
                      ["<S-TAB>"] = "qf_unmark_visual", -- QuickFix visual mode unmark operator
                  }
              },
          }
      
      
      require("rgflow").setup(
          {
              default_trigger_mappings = true,
              default_ui_mappings = true,
              default_quickfix_mappings = true,
              quickfix = {
                  open_qf_cmd_or_func = "botright copen", -- Open the quickfix window across the full bottom edge
              },
      
              -- WARNING !!! Glob for '-g *{*}' will not use .gitignore file: https://github.com/BurntSushi/ripgrep/issues/2252
              cmd_flags = ("--smart-case -g *.{*,py} -g !*.{min.js,pyc} --fixed-strings --no-fixed-strings --no-ignore -M 500"
                  -- Exclude globs
                  .. " -g !**/.angular/"
                  .. " -g !**/node_modules/"
                  .. " -g !**/static/*/jsapp/"
                  .. " -g !**/static/*/wcapp/"
              )
          }
      )
      
      
              vim.keymap.set("n", "<leader>RG", function()
                  require('rgflow').open(nil, nil, nil, {
                      callback = function() print('Callback ran... have a nice day!') end
                  })
              end, {noremap = true})
              
      
              vim.keymap.set("n", "<leader>RG", function()
                  -- Here we open UI with the default pattern/flags/path by passing in nil, nil, nil
                  require('rgflow').open(nil, nil, nil, {
                      custom_start = function(pattern, flags, path)
                          print('Pattern:'..pattern..' Flags:'..flags..' Path:'..path)
                      end
                  })
              end, {noremap = true})
              
    end,
  },
  {
    "duane9/nvim-rg",
  },
  {
    "FabianWirth/search.nvim",
    config = function()
      
      --- lazy nvim
      {
          "FabianWirth/search.nvim",
          dependencies = { "nvim-telescope/telescope.nvim" }
      }
      
      
      require('search').open()
      
      
      require('search').open({ tab_id = 2 })
      require('search').open({ tab_name = 'Grep' }) -- if multiple tabs are named the same, the first is selected
      require('search').open({ collection = 'git' }) -- Open the 'git' collection of pickers
      
      
      local builtin = require('telescope.builtin')
      require("search").setup({
        mappings = { -- optional: configure the mappings for switching tabs (will be set in normal and insert mode(!))
          next = "<Tab>",
          prev = "<S-Tab>"
        },
        append_tabs = { -- append_tabs will add the provided tabs to the default ones
          {
            "Commits", -- or name = "Commits"
            builtin.git_commits, -- or tele_func = require('telescope.builtin').git_commits
            available = function() -- optional
              return vim.fn.isdirectory(".git") == 1
            end
          }
        },
        -- its also possible to overwrite the default tabs using the tabs key instead of append_tabs
        tabs = {
          {
            "Files",
            function(opts)
              opts = opts or {}
              if vim.fn.isdirectory(".git") == 1 then
                builtin.git_files(opts)
              else
                builtin.find_files(opts)
              end
            end
          }
        },
      })
      
      
        mappings = {
          next = "<Tab>",
          prev = "<S-Tab>"
        }
      
      
        mappings = {
          next = { { "L", "n" }, { "<Tab>", "n" }, { "<Tab>", "i" } },
          prev = { { "H", "n" }, { "<S-Tab>", "n" }, { "<S-Tab>", "i" } }
        }
      
      
      local builtin = require('telescope.builtin')
      require("search").setup({
        initial_tab = 1,
        tabs = { ... }, -- As shown above
        collections = {
          -- Here the "git" collection is defined. It follows the same configuraton layout as tabs.
          git = {
            initial_tab = 1, -- Git branches
            tabs = {
              { name = "Branches", tele_func = builtin.git_branches },
              { name = "Commits", tele_func = builtin.git_commits },
              { name = "Stashes", tele_func = builtin.git_stash },
            }
          }
        }
      })
      
      
      local builtin = require('telescope.builtin')
      require("search").setup({
        initial_tab = 1,
        tabs = {
          { name = "Files",      tele_func = builtin.find_files },
          { name = "All Files",  tele_func = builtin.find_files, tele_opts = { no_ignore = true, hidden = true }},
        },
      })
      
      
      require('search').open({ tab_name = 'Grep', default_text = get_visual_selection() })
      -- or
      -- NOTE: tele_opts defined here are only sent to the initial tab.
      require('search').open({ tab_name = 'Grep', tele_opts = { default_text = get_visual_selection() } })
      
      
      require("search").setup({
        initial_tab = 1,
        tabs = {
          {
            name = "Files",
            tele_func = function() 
              -- Your custom config logic.
              telescope.find_files({})
            end 
          },
        },
      })
      
    end,
  },
  {
    "backdround/improved-search.nvim",
    config = function()
      
      local search = require("improved-search")
      
      -- Search next / previous.
      vim.keymap.set({"n", "x", "o"}, "n", search.stable_next)
      vim.keymap.set({"n", "x", "o"}, "N", search.stable_previous)
      
      -- Search current word without moving.
      vim.keymap.set("n", "!", search.current_word)
      
      -- Search selected text in visual mode
      vim.keymap.set("x", "!", search.in_place) -- search selection without moving
      vim.keymap.set("x", "*", search.forward)  -- search selection forward
      vim.keymap.set("x", "#", search.backward) -- search selection backward
      
      -- Search by motion in place
      vim.keymap.set("n", "|", search.in_place)
      -- You can also use search.forward / search.backward for motion selection.
      
    end,
  },
  {
    "polirritmico/telescope-lazy-plugins.nvim",
    config = function()
      
      return {
        "nvim-telescope/telescope.nvim",
        dependencies = {
          { "polirritmico/telescope-lazy-plugins.nvim" },
        },
        -- etc.
      }
      
      
      require("telescope").load_extension("lazy_plugins")
      
      
      require("telescope").extensions.lazy_plugins.lazy_plugins()
      
      
      require("telescope").extensions.lazy_plugins.actions
      
      
      ---@class TelescopeLazyPluginsUserConfig
      ---@field lazy_config? string Path to the file containing the lazy opts and setup() call.
      ---@field mappings? table Keymaps attached to the picker. See `:h telescope.mappings`.
      ---@field name_only? boolean Match only the `repo_name`, false to match the full `account/repo_name`.
      ---@field picker_opts? table Layout options passed into Telescope. Check `:h telescope.layout`.
      ---@field show_disabled? boolean Also show disabled plugins from the Lazy spec.
      ---@field auto_rescan? boolean Automatic rescan and rebuild the spec list if Lazy detects a change in the config.
      ---@field custom_entries? (LazyPluginsCustomEntry|LazyPluginsData)[] Table to pass custom entries to the picker.
      ---@field live_grep? table Options to pass into the `live_grep` telescope builtin picker.
      ---@field ignore_imports? string[]|table<string, boolean> Array of imports to ignore.
      ---@field actions? LazyPluginsConfigActions Actions options.
      
      ---@class LazyPluginsConfigActions
      ---@field opts_viewer? LazyPluginsActionOptsViewer
      
      ---@alias LazyPluginsDataField
      --- | "name" Name of the plugin showed in the picker
      --- | "full_name" Full name of the plugin repository (account/repo)
      --- | "filepath" Full file path to the plugin lua configuration
      --- | "line" Line number of the plugin definition in the lua file
      --- | "repo_url" Url to the repo
      --- | "repo_dir" Path to the local repository clone
      --- | "file" Path to the config filename showed in the picker
      
      ---@alias LazyPluginsConfigViewer
      --- | "float" Default. Open the plugin config in a float window.
      --- | "tab" Open the plugin config in a new tab.
      
      
      {
        lazy_config = vim.fn.stdpath("config") .. "/lua/config/lazy.lua", -- This must be a valid path to the file containing the lazy opts and setup() call.
        name_only = true, -- Match only the `repo_name`, false to match the full `account/repo_name`.
        show_disabled = true, -- Also show disabled plugins from the Lazy spec.
        auto_rescan = true, -- Automatic rescan and rebuild the spec list if lazy detects a change in the config.
        custom_entries = {}, -- Table to pass custom entries to the picker.
        live_grep = {}, -- Options to pass into the `live_grep` telescope builtin picker.
        ignore_imports = {}, -- Add imports you want to ignore, e.g., "lazyvim.plugins".
        actions = {
          opts_viewer = "float", -- How to open the generated plugin options.
        },
        mappings = {
          ["i"] = {
            ["<C-g>d"] = lp_actions.open_repo_dir,
            ["<C-g>f"] = lp_actions.open_repo_find_files,
            ["<C-g>l"] = lp_actions.open_repo_live_grep,
            ["<C-g>c"] = lp_actions.open_plugin_opts,
            ["<C-g>r"] = lp_actions.open_plugin_readme,
            ["<C-g>x"] = lp_actions.open_repo_url,
            ["<C-g>R"] = lp_actions.rescan_plugins,
          },
          ["n"] = {
            ["gd"] = lp_actions.open_repo_dir,
            ["gf"] = lp_actions.open_repo_find_files,
            ["gl"] = lp_actions.open_repo_live_grep,
            ["gc"] = lp_actions.open_plugin_opts,
            ["gr"] = lp_actions.open_plugin_readme,
            ["gx"] = lp_actions.open_repo_url,
            ["gR"] = lp_actions.rescan_plugins,
          },
        },
        picker_opts = {
          sorting_strategy = "ascending",
          layout_strategy = "flex",
          layout_config = {
            flex = { flip_columns = 150 },
            horizontal = { preview_width = { 0.55, max = 100, min = 30 } },
            vertical = { preview_cutoff = 20, preview_height = 0.5 },
          },
        },
      }
      
      
      {
        "nvim-telescope/telescope.nvim",
        cmd = "Telescope",
        dependencies = {
          { "nvim-lua/plenary.nvim" },
          {
            "polirritmico/telescope-lazy-plugins.nvim",
            keys = {
              { "<leader>cp", "<Cmd>Telescope lazy_plugins<CR>", desc = "Telescope: Plugins configurations" },
            },
          },
        },
        opts = {
          extensions = {
            ---@module "telescope._extensions.lazy_plugins"
            ---@type TelescopeLazyPluginsUserConfig
            lazy_plugins = {
              lazy_config = vim.fn.stdpath("config") .. "/lua/lazy/init.lua", -- Must be a valid path to the file containing the lazy spec and setup() call.
            },
          },
          -- etc.
        },
      }
      
      
      local load_extension_after_telescope_is_loaded = function(extension_name)
        local lazy_cfg = require("lazy.core.config").plugins
        if lazy_cfg["telescope.nvim"] and lazy_cfg["telescope.nvim"]._.loaded then
          -- Since Telescope is loaded, just load the extension:
          require("telescope").load_extension(extension_name)
        else
          -- If Telescope is not loaded, create an autocmd that will load the
          -- extension after Telescope is loaded.
          vim.api.nvim_create_autocmd("User", {
            pattern = "LazyLoad",
            callback = function(event)
              if event.data == "telescope.nvim" then
                require("telescope").load_extension(extension_name)
                return true
              end
            end,
          })
        end
      end
      
      
      return {
        {
          "nvim-telescope/telescope.nvim",
          cmd = "Telescope",
          dependencies = {
            { "nvim-lua/plenary.nvim" },
            {
              "polirritmico/telescope-lazy-plugins.nvim",
              init = function()
                load_extension_after_telescope_is_loaded("lazy_plugins")
              end,
            },
          },
          keys = {
            {"<leader>cp", "<Cmd>Telescope lazy_plugins<CR>", desc = "Telescope: Plugins configurations"},
          },
          -- Add the plugin configuration through the Telescope extensions options:
          opts = {
            extensions = {
              ---@module "telescope._extensions.lazy_plugins"
              ---@type TelescopeLazyPluginsUserConfig
              lazy_plugins = {
                show_disabled = true,
                lazy_config = vim.fn.stdpath("config") .. "/lua/config/lazy.lua", -- path to the file containing the lazy opts and setup() call.
                -- This is not needed. It is just an example of how you can customize the picker layout. Check `:h telescope.layout`.
                picker_opts = {
                  layout_strategy = "vertical",
                  layout_config = {
                    vertical = { preview_cutoff = 15, preview_height = 0.5 },
                  },
                },
                -- This is not needed. It is just an example of how you can add custom entries.
                custom_entries = {
                  {
                    name = "custom-entry-example",
                    filepath = vim.fn.stdpath("config") .. "/lua/config/mappings.lua",
                    repo_url = "https://www.lua.org/manual/5.2/",
                    line = 23, -- Open the file with the cursor in this line
                  },
                },
              },
            },
          },
        },
        -- etc.
      }
      
      
      -- Content of file: ~/.conf/nvim/init.lua
      local opts = {
        -- Lazy configuration options
      }
      require("lazy").setup({
        -- full list of plugins and configs like this:
        "username/a_plugin",
        opts = {
          configurations = "custom values",
        },
        -- etc.
        {
          "nvim-telescope/telescope.nvim",
          dependencies = {
            { "nvim-lua/plenary.nvim" },
            { "polirritmico/telescope-lazy-plugins.nvim" },
          },
          opts = {
            extensions = {
              ---@module "telescope._extensions.lazy_plugins"
              ---@type TelescopeLazyPluginsUserConfig
              lazy_plugins = {
                -- Set the path of this file (~/.config/nvim/init.lua) into the `lazy_config` field:
                lazy_config = vim.fn.stdpath("config") .. "/init.lua"
              },
            },
          },
        },
      }, opts)
      
      
      --- The example function
      ---@param bufnr integer passed by the telescope mapping execution call
      ---@param entry LazyPluginsData passed inside `custom_action`
      ---@param custom_args {foo: string} If needed custom_args could be added in a table
      local function demo_custom_function(bufnr, entry, custom_args)
        -- (require telescope inside the function call to not trigger a lazy load when
        -- parsing the config)
        local lp_actions = require("telescope").extensions.lazy_plugins.actions
      
        local arguments = custom_args.foo -- access values from the custom_args
        local repository_dir = entry.repo_dir -- access values from the selected picker entry
        local message = string.format("%s%s", arguments, repository_dir)
        vim.notify(message)
      
        -- Use the provided helper builtin functions:
        lp_actions.append_to_telescope_history(bufnr) -- Used by `:Telescope resume` and others.
        lp_actions.close(bufnr)
      end
      -- etc.
      
      
      --- Inside the lazy_plugins config
      lazy_plugins = {
        mappings = {
          ["i"] = {
            ["<C-g>d"] = function(prompt_bufnr)
              local args = { foo = "Plugin path from the selected entry.repo_dir: " }
              require("telescope").extensions.lazy_plugins.actions.custom_action(
                prompt_bufnr,
                "repo_dir", -- This is used to validate the entry. Could be any field of LazyPluginsData (name, full_name, filepath, line, repo_url or repo_dir).
                demo_custom_function,
                args
              )
            end,
          },
        },
      },
      
      
      ---@class LazyPluginsCustomEntry
      ---@field name string Entry name
      ---@field filepath string Full path to the lua target file
      ---@field line? integer Optional: Line number to set the view on the target file. Defaults to 1.
      ---@field repo_url? string Optional: URL to open with the `open_repo_url` action
      ---@field repo_dir? string Optional: Directory path to open with the `open_repo_dir` action
      
      
      --- Custom entry example:
      lazy_plugins = {
        custom_entries = {
          {
            name = "custom-entry",
            filepath = vim.fn.stdpath("config") .. "/lua/extra-options/somefile.lua",
            -- Optional:
            line = 42,
            repo_url = "https://www.lua.org/manual/5.2/",
            repo_dir = vim.fn.stdpath("config") .. "/lua/extra-options/",
          },
          -- etc.
        },
      },
      
    end,
  },
  {
    "MagicDuck/grug-far.nvim",
    config = function()
      
        {
          'MagicDuck/grug-far.nvim',
          -- Note (lazy loading): grug-far.lua defers all it's requires so it's lazy by default
          -- additional lazy config to defer loading is not really needed...
          config = function()
            -- optional setup call to override plugin options
            -- alternatively you can set options with vim.g.grug_far = { ... }
            require('grug-far').setup({
              -- options, see Configuration section below
              -- there are no required options atm
            });
          end
        },
      
      
      :lua require('grug-far').open({ prefills = { search = vim.fn.expand("<cword>") } })
      
      
      :lua require('grug-far').open({ engine = 'astgrep' })
      
      
      :lua require('grug-far').open({ transient = true })
      
      
      :lua require('grug-far').open({ prefills = { paths = vim.fn.expand("%") } })
      
      
      :<C-u>lua require('grug-far').with_visual_selection({ prefills = { paths = vim.fn.expand("%") } })
      
      
      :GrugFarWithin
      
      
      vim.keymap.set({ 'n', 'x' }, '<leader>si', function()
        require('grug-far').open({ visualSelectionUsage = 'operate-within-range' })
      end, { desc = 'grug-far: Search within range' })
      
      
      vim.keymap.set({ 'n', 'x' }, '<leader>ss', function()
        local search = vim.fn.getreg('/')
        -- surround with \b if "word" search (such as when pressing `*`)
        if search and vim.startswith(search, '\\<') and vim.endswith(search, '\\>') then
          search = '\\b' .. search:sub(3, -3) .. '\\b'
        end
        require('grug-far').open({
          prefills = {
            search = search,
          },
        })
      end, { desc = 'grug-far: Search using @/ register value or visual selection' })
      
      
      :lua require('grug-far').toggle_instance({ instanceName="far", staticTitle="Find and Replace" })
      
      
      vim.api.nvim_create_autocmd('FileType', {
        group =  vim.api.nvim_create_augroup('my-grug-far-custom-keybinds', { clear = true }),
        pattern = { 'grug-far' },
        callback = function()
          vim.keymap.set('n', '<localleader>w', function()
            local state = unpack(require('grug-far').get_instance(0):toggle_flags({ '--fixed-strings' }))
            vim.notify('grug-far: toggled --fixed-strings ' .. (state and 'ON' or 'OFF'))
          end, { buffer = true })
        end,
      })
      
      
      vim.api.nvim_create_autocmd('FileType', {
        group = vim.api.nvim_create_augroup('grug-far-keybindings', { clear = true }),
        pattern = { 'grug-far' },
        callback = function()
          vim.keymap.set('n', '<C-enter>', function()
            require('grug-far').get_instance(0):open_location()
            require('grug-far').get_instance(0):close()
          end, { buffer = true })
        end,
      })
      
      
      return {
        "nvim-neo-tree/neo-tree.nvim",
        dependencies = "nvim-tree/nvim-web-devicons",
        config = function()
          local function open_grug_far(prefills)
            local grug_far = require("grug-far")
      
            if not grug_far.has_instance("explorer") then
              grug_far.open({ instanceName = "explorer" })
            else
              grug_far.get_instance('explorer'):open()
            end
            -- doing it seperately because multiple paths doesn't open work when passed with open
            -- updating the prefills without clearing the search and other fields
            grug_far.get_instance('explorer'):update_input_values(prefills, false)
          end
          require("neo-tree").setup {
            commands = {
              -- create a new neo-tree command
              grug_far_replace = function(state)
                local node = state.tree:get_node()
                local prefills = {
                  -- also escape the paths if space is there
                  -- if you want files to be selected, use ':p' only, see filename-modifiers
                  paths = node.type == "directory" and vim.fn.fnameescape(vim.fn.fnamemodify(node:get_id(), ":p"))
              or vim.fn.fnameescape(vim.fn.fnamemodify(node:get_id(), ":h")),
                }
                open_grug_far(prefills)
              end,
              -- https://github.com/nvim-neo-tree/neo-tree.nvim/blob/fbb631e818f48591d0c3a590817003d36d0de691/doc/neo-tree.txt#L535
              grug_far_replace_visual = function(state, selected_nodes, callback)
                local paths = {}
                for _, node in pairs(selected_nodes) do
                  -- also escape the paths if space is there
                  -- if you want files to be selected, use ':p' only, see filename-modifiers
                  local path = node.type == "directory" and vim.fn.fnameescape(vim.fn.fnamemodify(node:get_id(), ":p"))
              or vim.fn.fnameescape(vim.fn.fnamemodify(node:get_id(), ":h"))
                  table.insert(paths, path)
                end
                local prefills = { paths = table.concat(paths, "\n") }
                open_grug_far(prefills)
              end,
            },
            window = {
              mappings = {
                -- map our new command to z
                z = "grug_far_replace",
              },
            },
            -- rest of your config
          }
        end,
      }
      
      
      return {
        "stevearc/oil.nvim",
        config = function()
          local oil = require "oil"
          oil.setup {
            keymaps = {
              -- create a new mapping, gs, to search and replace in the current directory
              gs = {
                callback = function()
                  -- get the current directory
                  local prefills = { paths = oil.get_current_dir() }
      
                  local grug_far = require "grug-far"
                  -- instance check
                  if not grug_far.has_instance "explorer" then
                    grug_far.open {
                      instanceName = "explorer",
                      prefills = prefills,
                      staticTitle = "Find and Replace from Explorer",
                    }
                  else
                    grug_far.get_instance('explorer'):open()
                    -- updating the prefills without clearing the search and other fields
                    grug_far.get_instance('explorer'):update_input_values(prefills, false)
                  end
                end,
                desc = "oil: Search in directory",
              },
            },
            -- rest of your config
          }
        end,
      }
      
      
      return {
        "echasnovski/mini.files",
        config = function()
          local MiniFiles = require "mini.files"
      
          MiniFiles.setup({
            -- your config
          })
      
          
          local files_grug_far_replace = function(path)
            -- works only if cursor is on the valid file system entry
            local cur_entry_path = MiniFiles.get_fs_entry().path
            local prefills = { paths = vim.fs.dirname(cur_entry_path) }
      
            local grug_far = require "grug-far"
      
            -- instance check
            if not grug_far.has_instance "explorer" then
              grug_far.open {
                instanceName = "explorer",
                prefills = prefills,
                staticTitle = "Find and Replace from Explorer",
              }
            else
              grug_far.get_instance('explorer'):open()
              -- updating the prefills without crealing the search and other fields
              grug_far.get_instance('explorer'):update_input_values(prefills, false)
            end
          end
      
          vim.api.nvim_create_autocmd("User", {
            pattern = "MiniFilesBufferCreate",
            callback = function(args)
              vim.keymap.set("n", "gs", files_grug_far_replace, { buffer = args.data.buf_id, desc = "Search in directory" })
            end,
          })
        end,
      }
      
      
      filetypes = {
        ["grug-far"] = false,
        ["grug-far-history"] = false,
        ["grug-far-help"] = false,
      }
      
    end,
  },
  {
    "chrisgrieser/nvim-rip-substitute",
    config = function()
      
      -- lazy.nvim
      {
      	"chrisgrieser/nvim-rip-substitute",
      	cmd = "RipSubstitute",
      	opts = {},
      	keys = {
      		{
      			"<leader>fs",
      			function() require("rip-substitute").sub() end,
      			mode = { "n", "x" },
      			desc = " rip substitute",
      		},
      	},
      },
      
      -- packer
      use {
      	"chrisgrieser/nvim-rip-substitute",
      	config = function() 
      		require("rip-substitute").setup()
      	end,
      }
      
      
      -- default settings
      require("rip-substitute").setup {
      	popupWin = {
      		title = " rip-substitute",
      		border = getBorder(), -- `vim.o.winborder` on nvim 0.11, otherwise "rounded"
      		matchCountHlGroup = "Keyword",
      		noMatchHlGroup = "ErrorMsg",
      		position = "bottom", ---@type "top"|"bottom"
      		hideSearchReplaceLabels = false,
      		hideKeymapHints = false,
      		disableCompletions = true, -- disables all blink.cmp completions
      	},
      	prefill = {
      		normal = "cursorWord", ---@type "cursorWord"|false
      		visual = "selection", ---@type "selection"|false (does not work with ex-command – see README)
      		startInReplaceLineIfPrefill = false,
      		alsoPrefillReplaceLine = false,
      	},
      	keymaps = { -- normal mode (if not stated otherwise)
      		abort = "q",
      		confirm = "<CR>",
      		insertModeConfirm = "<C-CR>",
      		prevSubstitutionInHistory = "<Up>",
      		nextSubstitutionInHistory = "<Down>",
      		toggleFixedStrings = "<C-f>", -- ripgrep's `--fixed-strings`
      		toggleIgnoreCase = "<C-c>", -- ripgrep's `--ignore-case`
      		openAtRegex101 = "R",
      		showHelp = "?",
      	},
      	incrementalPreview = {
      		matchHlGroup = "IncSearch",
      		rangeBackdrop = {
      			enabled = true,
      			blend = 50, -- between 0 and 100
      		},
      	},
      	regexOptions = {
      		startWithFixedStringsOn = false,
      		startWithIgnoreCase = false,
      		pcre2 = true, -- enables lookarounds and backreferences, but slightly slower
      		autoBraceSimpleCaptureGroups = true, -- disable if using named capture groups (see README for details)
      	},
      	editingBehavior = {
      		-- Typing `()` in the `search` line, automatically adds `$n` to the `replace` line.
      		autoCaptureGroups = false,
      	},
      	notification = {
      		onSuccess = true,
      		icon = "",
      	},
      	debug = false, -- extra notifications for debugging
      }
      
      
      vim.keymap.set(
      	{ "n", "x" },
      	"<leader>fs",
      	function() require("rip-substitute").sub() end,
      	{ desc = " rip substitute" }
      )
      
    end,
  },
  {
    "wsdjeg/flygrep.nvim",
    config = function()
      
      require('plug').add({
          {
              'wsdjeg/flygrep.nvim',
              config = function()
                  require('flygrep').setup()
              end,
      
              depends = { { 'wsdjeg/job.nvim' } },
          },
      })
      
      
      require('flygrep').open({
        cwd = vim.fn.fnamemodify(vim.fn.bufname(), ':p:h'),
      })
      
      
      require('flygrep').open({
        input = vim.fn.expand('<cword>')
      })
      
      
      require('flygrep').setup({
          color_templete = {
              a = {
                  fg = '#2c323c',
                  bg = '#98c379',
                  ctermfg = 16,
                  ctermbg = 114,
                  bold = true,
              },
              b = {
                  fg = '#abb2bf',
                  bg = '#3b4048',
                  ctermfg = 145,
                  ctermbg = 16,
                  bold = false,
              },
          },
          timeout = 200,
          mappings = {
              next_item = '<Tab>',
              previous_item = '<S-Tab>',
              toggle_fix_string = '<C-e>',
              toggle_hidden_file = '<C-h>',
              toggle_preview_win = '<C-p>',
              open_item_edit = '<Enter>',
              open_item_split = '<C-s>',
              open_item_vsplit = '<C-v>',
              open_item_tabedit = '<C-t>',
          },
          command = {
              execute = 'rg',
              default_opts = {
                  '--no-heading',
                  '--color=never',
                  '--with-filename',
                  '--line-number',
                  '--column',
                  '-g',
                  '!.git',
              },
              recursive_opt = {},
              expr_opt = { '-e' },
              fixed_string_opt = { '-F' },
              default_fopts = { '-N' },
              smart_case = { '-S' },
              ignore_case = { '-i' },
              hidden_opt = { '--hidden' },
          },
          matched_higroup = 'IncSearch',
          enable_preview = false,
          window = {
              width = 0.8,   -- flygrep screen width, default is vim.o.columns * 0.8
              height = 0.8,  -- flygrep screen height, default is vim.o.lines * 0.8
              col = 0.1,     -- flygrep screen start col, default is vim.o.columns * 0.1
              row = 0.1,     -- flygrep screen start row, default is vim.o.lines * 0.1
          },
      })
      
    end,
  },
  {
    "prochri/telescope-all-recent.nvim",
    config = function()
      
      {
        'prochri/telescope-all-recent.nvim',
        dependencies = {
          "nvim-telescope/telescope.nvim",
          "kkharji/sqlite.lua",
          -- optional, if using telescope for vim.ui.select
          "stevearc/dressing.nvim"
        },
        opts =
          {
            -- your config goes here
          }
      }
      
      
      -- This may bind to old telescope function depending on your load order:
      -- vim.keymap.set('n', '<leader>f', require'telescope'.builtins.find_files)
      -- So: better wrap it in a function:
      vim.keymap.set('n', '<leader>f', function() require'telescope'.builtins.find_files() end)
      
      
      require'telescope-all-recent'.setup{
        database = {
          folder = vim.fn.stdpath("data"),
          file = "telescope-all-recent.sqlite3",
          max_timestamps = 10,
        },
        debug = false,
        scoring = {
          recency_modifier = { -- also see telescope-frecency for these settings
            [1] = { age = 240, value = 100 }, -- past 4 hours
            [2] = { age = 1440, value = 80 }, -- past day
            [3] = { age = 4320, value = 60 }, -- past 3 days
            [4] = { age = 10080, value = 40 }, -- past week
            [5] = { age = 43200, value = 20 }, -- past month
            [6] = { age = 129600, value = 10 } -- past 90 days
          },
          -- how much the score of a recent item will be improved.
          boost_factor = 0.0001
        },
        default = {
          disable = true, -- disable any unkown pickers (recommended)
          use_cwd = true, -- differentiate scoring for each picker based on cwd
          sorting = 'recent' -- sorting: options: 'recent' and 'frecency'
        },
        pickers = { -- allows you to overwrite the default settings for each picker
          man_pages = { -- enable man_pages picker. Disable cwd and use frecency sorting.
            disable = false,
            use_cwd = false,
            sorting = 'frecency',
          },
      
          -- change settings for a telescope extension.
          -- To find out about extensions, you can use `print(vim.inspect(require'telescope'.extensions))`
          ['extension_name#extension_method'] = {
            -- [...]
          }
        }
      }
      
      
      {
        pickers = {
          // ...
          ['extension_name#extension_method'] = {
            disable = false,
            use_cwd = false,
            sorting = 'recent',
          }
        }
      }
      
      
      {
        -- [..]
        vim_ui_select = {
          kinds = {
            overseer_template = {
              use_cwd = true,
              prompt = "Task template",
              -- include the prompt in the picker name
              -- helps differentiate between same picker kinds with different prompts
              name_include_prompt = true,
            },
          }
          -- used as fallback if no kind configuration is available
          prompts = {
            ["Load session"] = {
            use_cwd = false,
          }
      }
      
    end,
  },
  {
    "mahyarmirrashed/search-and-replace.nvim",
    config = function()
      
      use "mahyarmirrashed/search-and-replace.nvim"
      
      
      {
        "mahyarmirrashed/search-and-replace.nvim",
        config = function()
          require("search-and-replace").setup()
        end,
      }
      
      
      require("search-and-replace").setup()
      
    end,
  },
  {
    "nvim-telescope/telescope.nvim",
    config = function()
      
      use {
        'nvim-telescope/telescope.nvim', tag = '0.1.8',
      -- or                            , branch = '0.1.x',
        requires = { {'nvim-lua/plenary.nvim'} }
      }
      
      
      -- init.lua:
          {
          'nvim-telescope/telescope.nvim', tag = '0.1.8',
      -- or                              , branch = '0.1.x',
            dependencies = { 'nvim-lua/plenary.nvim' }
          }
      
      -- plugins/telescope.lua:
      return {
          'nvim-telescope/telescope.nvim', tag = '0.1.8',
      -- or                              , branch = '0.1.x',
            dependencies = { 'nvim-lua/plenary.nvim' }
          }
      
      
      local builtin = require('telescope.builtin')
      vim.keymap.set('n', '<leader>ff', builtin.find_files, { desc = 'Telescope find files' })
      vim.keymap.set('n', '<leader>fg', builtin.live_grep, { desc = 'Telescope live grep' })
      vim.keymap.set('n', '<leader>fb', builtin.buffers, { desc = 'Telescope buffers' })
      vim.keymap.set('n', '<leader>fh', builtin.help_tags, { desc = 'Telescope help tags' })
      
      
      require('telescope').setup{
        defaults = {
          -- Default configuration for telescope goes here:
          -- config_key = value,
          mappings = {
            i = {
              -- map actions.which_key to <C-h> (default: <C-/>)
              -- actions.which_key shows the mappings for your picker,
              -- e.g. git_{create, delete, ...}_branch for the git_branches picker
              ["<C-h>"] = "which_key"
            }
          }
        },
        pickers = {
          -- Default configuration for builtin pickers goes here:
          -- picker_name = {
          --   picker_config_key = value,
          --   ...
          -- }
          -- Now the picker_config_key will be applied every time you call this
          -- builtin picker
        },
        extensions = {
          -- Your extension configuration goes here:
          -- extension_name = {
          --   extension_config_key = value,
          -- }
          -- please take a look at the readme of the extension you want to configure
        }
      }
      
      
      lua << EOF
      require('telescope').setup{
        -- ...
      }
      EOF
      
      
      -- Built-in actions
      local transform_mod = require('telescope.actions.mt').transform_mod
      
      -- or create your custom action
      local my_cool_custom_action = transform_mod({
        x = function(prompt_bufnr)
          print("This function ran after another action. Prompt_bufnr: " .. prompt_bufnr)
          -- Enter your function logic here. You can take inspiration from lua/telescope/actions.lua
        end,
      })
      
      
      vim.api.nvim_create_autocmd("User", {
        pattern = "TelescopePreviewerLoaded",
        callback = function(args)
          if args.data.filetype ~= "help" then
            vim.wo.number = true
          elseif args.data.bufname:match("*.csv") then
            vim.wo.wrap = false
          end
        end,
      })
      
      
      {
        title: string, # preview window title
        filetype: string,
        bufname: string,
      }
      
      
      require('telescope').setup({
        defaults = {
          layout_config = {
            vertical = { width = 0.5 }
            -- other layout configuration here
          },
          -- other defaults configuration here
        },
        -- other configuration values here
      })
      
      
      require('telescope').setup{
        defaults = {
          -- ...
        },
        pickers = {
          find_files = {
            theme = "dropdown",
          }
        },
        extensions = {
          -- ...
        }
      }
      
      
      -- This will load fzy_native and have it override the default file sorter
      require('telescope').load_extension('fzy_native')
      
      
      -- Run the `configurations` picker from nvim-dap
      require('telescope').extensions.dap.configurations()
      
    end,
  },
  {
    "vijaymarupudi/nvim-fzf",
    config = function()
      
      local fzf = require("fzf")
      
      coroutine.wrap(function()
        local result = fzf.fzf({"choice 1", "choice 2"}, "--ansi")
        -- result is a list of lines that fzf returns, if the user has chosen
        if result then
          print(result[1])
        end
      end)()
      
      
      local fzf = require("fzf")
      
      coroutine.wrap(function()
        local result = fzf.fzf({"choice 1", "choice 2"})
        if result then
          print(result[1])
        end
      end)()
      
      
        local results = fzf.fzf({"Option 1", "Option 2"}, "--nth 1")
        if results then
          -- do something
        end
        
      
        local results = fzf.fzf({"Option 1", "Option 2"},
          "--nth 1",
          { width = 30, height = 10, border = false })
        if results then
          -- do something
        end
        
      
        local results = fzf.fzf_relative({"Option 1", "Option 2"}, "--nth 1")
        if results then
          -- do something
        end
        
      
        -- for a vertical fzf
        vim.cmd [[ vertical new ]]
        fzf.provided_win_fzf(contents, fzf_cli_args)
        
      
          local result = fzf("fd")
          
      
          local result = fzf({1, 2, "item"})
          
      
          local result = fzf(function(cb)
            cb("value_1", function(err)
              -- this error can happen if the user has already chosen a value
              -- before the information was sent to fzf
              if err then
                return
              end
              cb("value_2", function(err)
                if err then
                  return
                end
                cb(nil) -- to close the pipe to fzf, this removes the loading
                        -- indicator in fzf
              end)
            end)
          end)
          
      
          local result = fzf("fd")
          if result then
            -- do something with result[1]
          end
          
      
          local result = fzf("fd", "--multi")
          if result then
            -- do something with result[1] to result[#result]
          end
          
      
          local result = fzf("fd", "--expect=ctrl-t")
          if result then
            if result[1] == "ctrl-t" then
              -- do something with result[2]
            else
              -- do something with result[2]
            end
          end
          
      
      local fzf = require "fzf".fzf
      local action = require "fzf.actions".action
      
      coroutine.wrap(function()
        -- items is a table of selected or hovered fzf items
        local shell = action(function(items, fzf_lines, fzf_cols)
          -- only one item will be hovered at any time, so get the selection
          -- out and convert it to a number
          local buf = tonumber(items[1])
      
          -- you can return either a string or a table to show in the preview
          -- window
          return vim.api.nvim_buf_get_lines(buf, 0, -1, false)
        end)
      
        fzf(vim.api.nvim_list_bufs(), "--preview " .. shell)
      end)()
      
      
        local fzf = require("fzf").fzf
        local raw_action = require("fzf.actions").raw_action
      
        local raw_act_string = raw_action(function(args)
          -- do something with the args
        end)
      
        local bind_string =
        vim.fn.shellescape(string.format("--bind=ctrl-r:reload(%s)",
        raw_act_string))
      
        coroutine.wrap(function()
          fzf({1, 2, 3, 4}, "--multi " .. bind_string)
        end)()
        
      
      local fzf = require("fzf")
      local fzf_helpers = require("fzf.helpers")
      
      coroutine.wrap(function()
      
        -- the transformation function runs for each line in the command
        local fzf_fn = fzf_helpers.cmd_line_transformer("seq 1000", function(x)
          local n = tonumber(x)
          return tostring(n * n)
        end)
      
        local choices = fzf.fzf(fzf_fn)
      
      end)()
      
      
        local fzf = require("fzf")
        local helpers = require("fzf.helpers")
      
      
        coroutine.wrap(function ()
          local action = helpers.choices_to_shell_cmd_previewer(function(items)
            return "seq " .. vim.fn.shellescape(tostring(items[1])) 
          end)
          fzf.fzf("seq 1 1000", "--preview=" .. action)
        end)()
        
      
      local fts = {
        "typescript",
        "javascript",
        "lua",
        "python",
        "vim",
        "markdown",
        "sh"
      }
      
      
      coroutine.wrap(function()
        local choice = require "fzf".fzf(fts)
        if choice then
          vim.cmd(string.format("set ft=%s", choice[1]))
        end
      end)()
      
      
      local action = require("fzf.actions").action
      
      local function get_colorschemes()
        local colorscheme_vim_files = vim.fn.globpath(vim.o.rtp, "colors/*.vim", true, true)
        local colorschemes = {}
        for _, colorscheme_file in ipairs(colorscheme_vim_files) do
          local colorscheme = vim.fn.fnamemodify(colorscheme_file, ":t:r")
          table.insert(colorschemes, colorscheme)
        end
        return colorschemes
      end
      
      local function get_current_colorscheme()
        if vim.g.colors_name then
          return vim.g.colors_name
        else
          return 'default'
        end
      end
      
      
      coroutine.wrap(function ()
        local preview_function = action(function (args)
          if args then
            local colorscheme = args[1]
            vim.cmd("colorscheme " .. colorscheme)
          end
        end)
      
        local current_colorscheme = get_current_colorscheme()
        local choices = fzf(get_colorschemes(), "--preview=" .. preview_function .. " --preview-window right:0") 
        if not choices then
          vim.cmd("colorscheme " .. current_colorscheme)
        else
          vim.cmd("colorscheme " .. choices[1])
        end
      end)()
      
      
      
      local runtimepaths = vim.api.nvim_list_runtime_paths()
      local uv = vim.loop
      local fzf = require('fzf').fzf
      
      local function readfilecb(path, callback)
        uv.fs_open(path, "r", 438, function(err, fd)
          if err then
            callback(err)
            return
          end
          uv.fs_fstat(fd, function(err, stat)
            if err then
              callback(err)
              return
            end
            uv.fs_read(fd, stat.size, 0, function(err, data)
              if err then
                callback(err)
                return
              end
              uv.fs_close(fd, function(err)
                if err then
                  callback(err)
                  return
                end
                return callback(nil, data)
              end)
            end)
          end)
        end)
      end
      
      local function readfile(name)
        local co = coroutine.running()
        readfilecb(name, function (err, data)
          coroutine.resume(co, err, data)
        end)
        local err, data = coroutine.yield()
        if err then error(err) end
        return data
      end
      
      local function deal_with_tags(tagfile, cb)
        local co = coroutine.running()
        coroutine.wrap(function ()
          local success, data = pcall(readfile, tagfile)
          if success then
            for i, line in ipairs(vim.split(data, "\n")) do
              local items = vim.split(line, "\t")
              -- escape codes for grey
              local tag = string.format("%s\t\27[0;37m%s\27[0m", items[1], items[2])
              local co = coroutine.running()
              cb(tag, function ()
                coroutine.resume(co)
              end)
              coroutine.yield()
            end
          end
          coroutine.resume(co)
        end)()
        coroutine.yield()
      end
      
      local fzf_function = function (cb)
        local total_done = 0
        for i, rtp in ipairs(runtimepaths) do
          local tagfile = table.concat({rtp, "doc", "tags"}, "/")
          -- wrapping to make all the file reading concurrent
          coroutine.wrap(function ()
            deal_with_tags(tagfile, cb)
            total_done = total_done + 1
            if total_done == #runtimepaths then
              cb(nil)
            end
          end)()
        end
      end
      
      coroutine.wrap(function ()
        local result = fzf(fzf_function, "--nth 1 --ansi --expect=ctrl-t,ctrl-s,ctrl-v")
        if not result then
          return
        end
        local choice = vim.split(result[2], "\t")[1]
        local key = result[1]
        local windowcmd
        if key == "" or key == "ctrl-s" then
          windowcmd = ""
        elseif key == "ctrl-v" then
          windowcmd = "vertical"
        elseif key == "ctrl-t" then
          windowcmd = "tab"
        else
          print("Not implemented!")
          error("Not implemented!")
        end
      
        vim.cmd(string.format("%s h %s", windowcmd, choice))
      end)()
      
      
        require("fzf").default_options = {
          window_on_create = function()
            vim.cmd("set winhl=Normal:Normal")
          end
        }
        
    end,
  },
  {
    "camspiers/snap",
    config = function()
      
      require("lazy").setup({
        "camspiers/snap",
        config = function ()
          -- Basic example config
          local snap = require"snap"
          snap.maps{
            { "<Leader><Leader>", snap.config.file { producer = "ripgrep.file" } },
          }
        end
      })
      
      
      require("lazy").setup({
        {
          "camspiers/luarocks",
          opts = { rocks = { "fzy" } },
        },
        {
          "camspiers/snap",
          dependencies = { "camspiers/luarocks" },
        }
      })
      
      
      use { 'camspiers/snap' }
      
      
      use { 'camspiers/snap', rocks = {'fzy'}}
      
      
      local snap = require'snap'
      snap.maps {
        {"<Leader><Leader>", snap.config.file {producer = "ripgrep.file"}},
        {"<Leader>fb", snap.config.file {producer = "vim.buffer"}},
        {"<Leader>fo", snap.config.file {producer = "vim.oldfile"}},
        {"<Leader>ff", snap.config.vimgrep {}},
      }
      
      
      local snap = require'snap'
      local file = snap.config.file:with {reverse = true, suffix = ">>", consumer = "fzy"}
      local vimgrep = snap.config.vimgrep:with {reverse = true, suffix = ">>", limit = 50000}
      snap.maps {
        {"<Leader><Leader>", file {producer = "ripgrep.file"}},
        {"<Leader>ff", vimgrep {}},
      }
      
      
      local snap = require'snap'
      snap.maps {
        {"<Leader><Leader>", snap.config.file {producer = "ripgrep.file"}, {command = "mycommandname"}}
      }
      
      
      -- Basic ripgrep file producer
      file {producer = "ripgrep.file"}
      
      -- Ripgrep file producer with args
      file {producer = "ripgrep.file", args = {'--hidden', '--iglob', '!.git/*'}}
      
      -- Git file producer with ripgrep fallback
      file {try = {"git.file", "ripgrep.file"}}
      
      -- Basic file producer with previews off
      file {producer = "ripgrep.file", preview = false}
      
      -- Basic buffer producer
      file {producer = "vim.buffer"}
      
      -- Basic oldfile producer
      file {producer = "vim.oldfile"}
      
      -- A customized prompt
      file {producer = "ripgrep.file", prompt = "MyFiles"}
      
      -- A customized prompt suffix
      file {producer = "ripgrep.file", suffix = ">>"}
      
      -- Display input at top
      file {producer = "ripgrep.file", reverse = true}
      
      -- Custom layout function
      file {producer = "ripgrep.file", layout = myCustomLayoutFunction}
      
      
      snap.run {
        producer = snap.get'consumer.fzy'(snap.get'producer.ripgrep.file'),
        select = snap.get'select.file'.select,
        multiselect = snap.get'select.file'.multiselect,
        views = {snap.get'preview.file'}
      }
      
      
      snap.run {
        producer = snap.get'consumer.fzf'(snap.get'producer.ripgrep.file'),
        select = snap.get'select.file'.select,
        multiselect = snap.get'select.file'.multiselect,
        views = {snap.get'preview.file'}
      }
      
      
      snap.run {
        producer = snap.get'producer.ripgrep.vimgrep',
        select = snap.get'select.vimgrep'.select,
        multiselect = snap.get'select.vimgrep'.multiselect,
        views = {snap.get'preview.vimgrep'}
      }
      
      
      snap.run {
        producer = snap.get'consumer.limit'(10000, snap.get'producer.ripgrep.vimgrep'),
        select = snap.get'select.vimgrep'.select,
        multiselect = snap.get'select.vimgrep'.multiselect,
        views = {snap.get'preview.vimgrep'}
      }
      
      
      snap.run {
        producer = snap.get'consumer.fzy'(snap.get'producer.vim.buffer'),
        select = snap.get'select.file'.select,
        multiselect = snap.get'select.file'.multiselect,
        views = {snap.get'preview.file'}
      }
      
      
      snap.run {
        producer = snap.get'consumer.fzy'(snap.get'producer.vim.oldfile'),
        select = snap.get'select.file'.select,
        multiselect = snap.get'select.file'.multiselect,
        views = {snap.get'preview.file'}
      }
      
      
      snap.run {
        producer = snap.get'consumer.fzy'(snap.get'producer.git.file'),
        select = snap.get'select.file'.select,
        multiselect = snap.get'select.file'.multiselect,
        views = {snap.get'preview.file'}
      }
      
      
      snap.run {
        producer = snap.get'consumer.fzf'(
          snap.get'consumer.try'(
            snap.get'producer.git.file',
            snap.get'producer.ripgrep.file'
          ),
        ),
        select = snap.get'select.file'.select,
        multiselect = snap.get'select.file'.multiselect,
        views = {snap.get'preview.file'}
      }
      
      
      snap.run {
        prompt = "Help>",
        producer = snap.get'consumer.fzy'(snap.get'producer.vim.help'),
        select = snap.get'select.help'.select,
        views = {snap.get'preview.help'}
      }
      
      
      snap.run {
        prompt = "Marks>",
        producer = snap.get'consumer.fzy'(snap.get'producer.vim.marks'),
        select = snap.get'select.vim.mark'.select,
        views = {snap.get'preview.vim.mark'}
      }
      
      
      snap.run {
        prompt = "Global Marks>",
        producer = snap.get'consumer.fzy'(snap.get'producer.vim.globalmarks'),
        select = snap.get'select.vim.mark'.select,
        views = {snap.get'preview.vim.mark'}
      }
      
      
      snap.run {
        producer = snap.get'producer.ripgrep.vimgrep',
        steps = {{
          consumer = snap.get'consumer.fzf',
          config = {prompt = "FZF>"}
        }},
        select = snap.get'select.file'.select,
        multiselect = snap.get'select.file'.multiselect,
        views = {snap.get'preview.file'}
      }
      
      
      snap.run {
        producer = snap.get'consumer.fzf'(
          snap.get'consumer.combine'(
            snap.get'producer.ripgrep.file'.args({}, "/directory1"),
            snap.get'producer.ripgrep.file'.args({}, "/directory2"),
            snap.get'producer.ripgrep.file'.args({}, "/directory3"),
          ),
        ),
        select = snap.get'select.file'.select,
        multiselect = snap.get'select.file'.multiselect,
        views = {snap.get'preview.file'}
      }
      
      
      {
        ["enter-split"] = {"<C-x>"},
        ["enter-tab"] = {"<C-t>"},
        ["enter-vsplit"] = {"<C-v>"},
        ["next-item"] = {"<C-n>"},
        ["next-page"] = {"<C-f>"},
        ["prev-item"] = {"<C-p>"},
        ["prev-page"] = {"<C-b>"},
        ["select-all"] = {"<C-a>"},
        ["view-page-down"] = {"<C-d>"},
        ["view-page-up"] = {"<C-u>"},
        ["view-toggle-hide"] = {"<C-h>"},
        enter = {"<CR>"},
        exit = {"<Esc>", "<C-c>"},
        next = {"<C-q>"},
        select = {"<Tab>"},
        unselect = {"<S-Tab>"}
      }
      
      
      snap.run {
        producer = snap.get'consumer.fzy'(snap.get'producer.ripgrep.file'),
        select = snap.get'select.file'.select,
        multiselect = snap.get'select.file'.multiselect,
        views = {snap.get'preview.file'},
        mappings = {
          enter = {"<CR>", "<C-o>"}, -- my custom mapping
        }
      }
      
      
      local snap = require'snap'
      local io = snap.get'common.io'
      
      -- Runs ls and yields lua tables containing each line
      local function producer (request)
        -- Runs the slow-mode getcwd function
        local cwd = snap.sync(vim.fn.getcwd)
        -- Iterates ls commands output using snap.io.spawn
        for data, err, kill in io.spawn("ls", {}, cwd) do
          -- If the filter updates while the command is still running
          -- then we kill the process and yield nil
          if request.canceled() then
            kill()
            coroutine.yield(nil)
          -- If there is an error we yield nil
          elseif (err ~= "") then
            coroutine.yield(nil)
          -- If the data is empty we yield an empty table
          elseif (data == "") then
            coroutine.yield({})
          -- If there is data we split it by newline
          else
            coroutine.yield(vim.split(data, "\n", true))
          end
        end
      end
      
      
      -- Takes in a producer and returns a producer
      local function consumer (producer)
        -- Return producer
        return function (request)
          -- Iterates over the producers results
          for results in snap.consume(producer, request) do
            -- If we have a table then we want to filter it
            if type(results) == "table" then
              -- Yield the filtered table
              coroutine.yield(vim.tbl_filter(
                function (value)
                  return string.find(value, request.filter, 0, true)
                end,
                results
              ))
            -- If we don't have a table we finish by yielding nil
            else
              coroutine.yield(nil)
            end
          end
        end
      end
      
      
      snap.run {
        producer = consumer(producer),
        select = print
      }
      
      
      local function producer(message)
        coroutine.yield({"Result 1", "Result 1"})
        -- the nvim UI can respond to input between these yields
        coroutine.yield({"Result 3", "Result 4"})
      end
      
      
      local function producer(message)
        coroutine.yield({
          snap.with_meta("Higher rank", "score", 10),
          snap.with_meta("Lower rank", "score", 1),
          snap.with_meta("Mid rank", "score", 5)
        })
      end
      
      
      local function producer(message)
        -- Yield a function to get its result
        local cwd = snap.sync(vim.fn.getcwd)
        -- Now we have the cwd we can do something with it
      end
      
      
      local function producer(message)
        coroutine.yield({"Result 1", "Result 1"})
        coroutine.yield(nil)
        -- Doesn't proces this, as coroutine is dead
        coroutine.yield({"Result 3", "Result 4"})
      end
      
      
      snap.get'consumer.try'(
        snap.get'producer.git.file',
        snap.get'producer.ripgrep.file'
      )
      
      
      snap.get'consumer.combine'(
        snap.get'producer.ripgrep.file'.args({}, "/directory1"),
        snap.get'producer.ripgrep.file'.args({}, "/directory2"),
      )
      
    end,
  },
  {
    "ibhagwan/fzf-lua",
    config = function()
      
      {
        "ibhagwan/fzf-lua",
        -- optional for icon support
        dependencies = { "nvim-tree/nvim-web-devicons" },
        -- or if using mini.icons/mini.nvim
        -- dependencies = { "nvim-mini/mini.icons" },
        opts = {}
      }
      
      
      :lua require("fzf-lua").files()
      -- once loaded we can use the global object
      :lua FzfLua.files()
      -- or the vim command:
      :FzfLua files
      
      
      :lua FzfLua.files({ cwd = '~/.config' })
      -- or using the `FzfLua` vim command:
      :FzfLua files cwd=~/.config
      
      
      :lua FzfLua.resume()
      -- or
      :FzfLua resume
      
      
      :lua FzfLua.files({ resume = true })
      -- or
      :FzfLua files resume=true
      
      
      :lua FzfLua.combine({ pickers = "oldfiles;git_files" })
      -- or using the `FzfLua` vim command:
      :FzfLua combine pickers=oldfiles;git_files
      
      
      :lua FzfLua.global()
      -- or using the `FzfLua` vim command:
      :FzfLua global
      
      
      require("fzf-lua").setup {
        -- MISC GLOBAL SETUP OPTIONS, SEE BELOW
        -- fzf_bin = ...,
        -- each of these options can also be passed as function that return options table
        -- e.g. winopts = function() return { ... } end
        winopts = { ...  },     -- UI Options
        keymap = { ...  },      -- Neovim keymaps / fzf binds
        actions = { ...  },     -- Fzf "accept" binds
        fzf_opts = { ...  },    -- Fzf CLI flags
        fzf_colors = { ...  },  -- Fzf `--color` specification
        hls = { ...  },         -- Highlights
        previewers = { ...  },  -- Previewers options
        -- SPECIFIC COMMAND/PICKER OPTIONS, SEE BELOW
        -- files = { ... },
      }
      
      
        -- Use skim (or a speccific fzf binary/version) instead of fzf?
        -- fzf_bin = 'sk',
        -- Padding can help kitty term users with double-width icon rendering
        file_icon_padding = '',
        -- Uncomment if your terminal/font does not support unicode character
        -- 'EN SPACE' (U+2002), the below sets it to 'NBSP' (U+00A0) instead
        -- nbsp = '\xc2\xa0',
        -- Function override for opening the help window (default bound to `<F1>`)
        -- Override this function if you want to customize window config of the
        -- help window (location, width, border, etc.)
        help_open_win = vim.api.nvim_open_win,
      
      
      winopts = {
          -- split = "belowright new",-- open in a split instead?
                  -- "belowright new"  : split below
                  -- "aboveleft new"   : split above
                  -- "belowright vnew" : split right
                  -- "aboveleft vnew   : split left
          -- Only valid when using a float window
          -- (i.e. when 'split' is not defined, default)
          height           = 0.85,            -- window height
          width            = 0.80,            -- window width
          row              = 0.35,            -- window row position (0=top, 1=bottom)
          col              = 0.50,            -- window col position (0=left, 1=right)
          -- border argument passthrough to nvim_open_win()
          border           = "rounded",
          -- Backdrop opacity, 0 is fully opaque, 100 is fully transparent (i.e. disabled)
          backdrop         = 60,
          -- title         = "Title",
          -- title_pos     = "center",        -- 'left', 'center' or 'right'
          -- title_flags   = false,           -- uncomment to disable title flags
          fullscreen       = false,           -- start fullscreen?
          -- enable treesitter highlighting for the main fzf window will only have
          -- effect where grep like results are present, i.e. "file:line:col:text"
          -- due to highlight color collisions will also override `fzf_colors`
          -- set `fzf_colors=false` or `fzf_colors.hl=...` to override
          treesitter       = {
            enabled    = true,
            fzf_colors = { ["hl"] = "-1:reverse", ["hl+"] = "-1:reverse" }
          },
          preview = {
            -- default     = 'bat',           -- override the default previewer?
                                              -- default uses the 'builtin' previewer
            border         = "rounded",       -- preview border: accepts both `nvim_open_win`
                                              -- and fzf values (e.g. "border-top", "none")
                                              -- native fzf previewers (bat/cat/git/etc)
                                              -- can also be set to `fun(winopts, metadata)`
            wrap           = false,           -- preview line wrap (fzf's 'wrap|nowrap')
            hidden         = false,           -- start preview hidden
            vertical       = "down:45%",      -- up|down:size
            horizontal     = "right:60%",     -- right|left:size
            layout         = "flex",          -- horizontal|vertical|flex
            flip_columns   = 100,             -- #cols to switch to horizontal on flex
            -- Only used with the builtin previewer:
            title          = true,            -- preview border title (file/buf)?
            title_pos      = "center",        -- left|center|right, title alignment
            scrollbar      = "float",         -- `false` or string:'float|border'
                                              -- float:  in-window floating border
                                              -- border: in-border "block" marker
            scrolloff      = -1,              -- float scrollbar offset from right
                                              -- applies only when scrollbar = 'float'
            delay          = 20,              -- delay(ms) displaying the preview
                                              -- prevents lag on fast scrolling
            winopts = {                       -- builtin previewer window options
              number            = true,
              relativenumber    = false,
              cursorline        = true,
              cursorlineopt     = "both",
              cursorcolumn      = false,
              signcolumn        = "no",
              list              = false,
              foldenable        = false,
              foldmethod        = "manual",
            },
          },
          on_create = function()
            -- called once upon creation of the fzf main window
            -- can be used to add custom fzf-lua mappings, e.g:
            --   vim.keymap.set("t", "<C-j>", "<Down>", { silent = true, buffer = true })
          end,
          -- called once _after_ the fzf interface is closed
          -- on_close = function() ... end
      }
      
      
      keymap = {
          -- Below are the default binds, setting any value in these tables will override
          -- the defaults, to inherit from the defaults change [1] from `false` to `true`
          builtin = {
            -- neovim `:tmap` mappings for the fzf win
            -- true,        -- uncomment to inherit all the below in your custom config
            ["<M-Esc>"]     = "hide",     -- hide fzf-lua, `:FzfLua resume` to continue
            ["<F1>"]        = "toggle-help",
            ["<F2>"]        = "toggle-fullscreen",
            -- Only valid with the 'builtin' previewer
            ["<F3>"]        = "toggle-preview-wrap",
            ["<F4>"]        = "toggle-preview",
            -- Rotate preview clockwise/counter-clockwise
            ["<F5>"]        = "toggle-preview-cw",
            -- Preview toggle behavior default/extend
            ["<F6>"]        = "toggle-preview-behavior",
            -- `ts-ctx` binds require `nvim-treesitter-context`
            ["<F7>"]        = "toggle-preview-ts-ctx",
            ["<F8>"]        = "preview-ts-ctx-dec",
            ["<F9>"]        = "preview-ts-ctx-inc",
            ["<S-Left>"]    = "preview-reset",
            ["<S-down>"]    = "preview-page-down",
            ["<S-up>"]      = "preview-page-up",
            ["<M-S-down>"]  = "preview-down",
            ["<M-S-up>"]    = "preview-up",
          },
          fzf = {
            -- fzf '--bind=' options
            -- true,        -- uncomment to inherit all the below in your custom config
            ["ctrl-z"]      = "abort",
            ["ctrl-u"]      = "unix-line-discard",
            ["ctrl-f"]      = "half-page-down",
            ["ctrl-b"]      = "half-page-up",
            ["ctrl-a"]      = "beginning-of-line",
            ["ctrl-e"]      = "end-of-line",
            ["alt-a"]       = "toggle-all",
            ["alt-g"]       = "first",
            ["alt-G"]       = "last",
            -- Only valid with fzf previewers (bat/cat/git/etc)
            ["f3"]          = "toggle-preview-wrap",
            ["f4"]          = "toggle-preview",
            ["shift-down"]  = "preview-page-down",
            ["shift-up"]    = "preview-page-up",
          },
      },
      
      
      actions = {
          -- Below are the default actions, setting any value in these tables will override
          -- the defaults, to inherit from the defaults change [1] from `false` to `true`
          files = {
            -- true,        -- uncomment to inherit all the below in your custom config
            -- Pickers inheriting these actions:
            --   files, git_files, git_status, grep, lsp, oldfiles, quickfix, loclist,
            --   tags, btags, args, buffers, tabs, lines, blines
            -- `file_edit_or_qf` opens a single selection or sends multiple selection to quickfix
            -- replace `enter` with `file_edit` to open all files/bufs whether single or multiple
            -- replace `enter` with `file_switch_or_edit` to attempt a switch in current tab first
            ["enter"]       = FzfLua.actions.file_edit_or_qf,
            ["ctrl-s"]      = FzfLua.actions.file_split,
            ["ctrl-v"]      = FzfLua.actions.file_vsplit,
            ["ctrl-t"]      = FzfLua.actions.file_tabedit,
            ["alt-q"]       = FzfLua.actions.file_sel_to_qf,
            ["alt-Q"]       = FzfLua.actions.file_sel_to_ll,
            ["alt-i"]       = FzfLua.actions.toggle_ignore,
            ["alt-h"]       = FzfLua.actions.toggle_hidden,
            ["alt-f"]       = FzfLua.actions.toggle_follow,
          },
        }
      
      
      fzf_opts = {
          -- options are sent as `<left>=<right>`
          -- set to `false` to remove a flag
          -- set to `true` for a no-value flag
          -- for raw args use `fzf_args` instead
          ["--ansi"]           = true,
          ["--info"]           = "inline-right", -- fzf < v0.42 = "inline"
          ["--height"]         = "100%",
          ["--layout"]         = "reverse",
          ["--border"]         = "none",
          ["--highlight-line"] = true,           -- fzf >= v0.53
        }
      
      -- Only used when fzf_bin = "fzf-tmux", by default opens as a
      -- popup 80% width, 80% height (note `-p` requires tmux > 3.2)
      -- and removes the sides margin added by `fzf-tmux` (fzf#3162)
      -- for more options run `fzf-tmux --help`
      -- NOTE: since fzf v0.53 / sk v0.15 it is recommended to use
      -- native tmux integration by adding the below to `fzf_opts`
      -- fzf_opts = { ["--tmux"] = "center,80%,60%" }
      fzf_tmux_opts = { ["-p"] = "80%,80%", ["--margin"] = "0,0" },
      
      
        -- 
        -- Set fzf's terminal colorscheme (optional)
        --
        -- Set to `true` to automatically generate an fzf's colorscheme from
        -- Neovim's current colorscheme:
        -- fzf_colors       = true,
        -- 
        -- Building a custom colorscheme, has the below specifications:
        -- If rhs is of type "string" rhs will be passed raw, e.g.:
        --   `["fg"] = "underline"` will be translated to `--color fg:underline`
        -- If rhs is of type "table", the following convention is used:
        --   [1] "what" field to extract from the hlgroup, i.e "fg", "bg", etc.
        --   [2] Neovim highlight group(s), can be either "string" or "table"
        --       when type is "table" the first existing highlight group is used
        --   [3+] any additional fields are passed raw to fzf's command line args
        -- Example of a "fully loaded" color option:
        --   `["fg"] = { "fg", { "NonExistentHl", "Comment" }, "underline", "bold" }`
        -- Assuming `Comment.fg=#010101` the resulting fzf command line will be:
        --   `--color fg:#010101:underline:bold`
        -- NOTE: to pass raw arguments `fzf_opts["--color"]` or `fzf_args`
        -- NOTE: below is an example, not the defaults:
        fzf_colors = {
            true,   -- inherit fzf colors that aren't specified below from
                    -- the auto-generated theme similar to `fzf_colors=true`
            ["fg"]          = { "fg", "CursorLine" },
            ["bg"]          = { "bg", "Normal" },
            ["hl"]          = { "fg", "Comment" },
            ["fg+"]         = { "fg", "Normal", "underline" },
            ["bg+"]         = { "bg", { "CursorLine", "Normal" } },
            ["hl+"]         = { "fg", "Statement" },
            ["info"]        = { "fg", "PreProc" },
            ["prompt"]      = { "fg", "Conditional" },
            ["pointer"]     = { "fg", "Exception" },
            ["marker"]      = { "fg", "Keyword" },
            ["spinner"]     = { "fg", "Label" },
            ["header"]      = { "fg", "Comment" },
            ["gutter"]      = "-1",
        },
      
      
      hls = {
          normal = "Normal"          -- highlight group for normal fg/bg
          preview_normal = "Normal"  -- highlight group for preview fg/bg
          ...
      }
      
      
      previewers = {
          cat = {
            cmd             = "cat",
            args            = "-n",
          },
          bat = {
            cmd             = "bat",
            args            = "--color=always --style=numbers,changes",
          },
          head = {
            cmd             = "head",
            args            = nil,
          },
          git_diff = {
            -- if required, use `{file}` for argument positioning
            -- e.g. `cmd_modified = "git diff --color HEAD {file} | cut -c -30"`
            cmd_deleted     = "git diff --color HEAD --",
            cmd_modified    = "git diff --color HEAD",
            cmd_untracked   = "git diff --color --no-index /dev/null",
            -- git-delta is automatically detected as pager, set `pager=false`
            -- to disable, can also be set under 'git.status.preview_pager'
          },
          man = {
            -- NOTE: remove the `-c` flag when using man-db
            -- replace with `man -P cat %s | col -bx` on OSX
            cmd             = "man -c %s | col -bx",
          },
          builtin = {
            syntax          = true,         -- preview syntax highlight?
            syntax_limit_l  = 0,            -- syntax limit (lines), 0=nolimit
            syntax_limit_b  = 1024*1024,    -- syntax limit (bytes), 0=nolimit
            limit_b         = 1024*1024*10, -- preview limit (bytes), 0=nolimit
            -- previewer treesitter options:
            -- enable specific filetypes with: `{ enabled = { "lua" } }
            -- exclude specific filetypes with: `{ disabled = { "lua" } }
            -- disable `nvim-treesitter-context` with `context = false`
            -- disable fully with: `treesitter = false` or `{ enabled = false }`
            treesitter      = {
              enabled = true,
              disabled = {},
              -- nvim-treesitter-context config options
              context = { max_lines = 1, trim_scope = "inner" }
            },
            -- By default, the main window dimensions are calculated as if the
            -- preview is visible, when hidden the main window will extend to
            -- full size. Set the below to "extend" to prevent the main window
            -- from being modified when toggling the preview.
            toggle_behavior = "default",
            -- Title transform function, by default only displays the tail
            -- title_fnamemodify = function(s) return vim.fn.fnamemodify(s, ":t") end,
            -- preview extensions using a custom shell command:
            -- for example, use `viu` for image previews
            -- will do nothing if `viu` isn't executable
            extensions      = {
              -- neovim terminal only supports `viu` block output
              ["png"]       = { "viu", "-b" },
              -- by default the filename is added as last argument
              -- if required, use `{file}` for argument positioning
              ["svg"]       = { "chafa", "{file}" },
              ["jpg"]       = { "ueberzug" },
            },
            -- if using `ueberzug` in the above extensions map
            -- set the default image scaler, possible scalers:
            --   false (none), "crop", "distort", "fit_contain",
            --   "contain", "forced_cover", "cover"
            -- https://github.com/seebye/ueberzug
            ueberzug_scaler = "cover",
            -- render_markdown.nvim integration, enabled by default for markdown
            render_markdown = { enabled = true, filetypes = { ["markdown"] = true } },
            -- snacks.images integration, enabled by default
            snacks_image = { enabled = true, render_inline = true },
          },
          -- Code Action previewers, default is "codeaction" (set via `lsp.code_actions.previewer`)
          -- "codeaction_native" uses fzf's native previewer, recommended when combined with git-delta
          codeaction = {
            -- options for vim.diff(): https://neovim.io/doc/user/lua.html#vim.diff()
            diff_opts = { ctxlen = 3 },
          },
          codeaction_native = {
            diff_opts = { ctxlen = 3 },
            -- git-delta is automatically detected as pager, set `pager=false`
            -- to disable, can also be set under 'lsp.code_actions.preview_pager'
            -- recommended styling for delta
            --pager = [[delta --width=$COLUMNS --hunk-header-style="omit" --file-style="omit"]],
          },
      }
      
      
        -- use `defaults` (table or function) if you wish to set "global-picker" defaults
        -- for example, using "mini.icons" globally and open the quickfix list at the top
        --   defaults = {
        --     file_icons   = "mini",
        --     copen        = "topleft copen",
        --   },
        files = {
          -- previewer      = "bat",          -- uncomment to override previewer
                                              -- (name from 'previewers' table)
                                              -- set to 'false' to disable
          prompt            = 'Files❯ ',
          multiprocess      = true,           -- run command in a separate process
          git_icons         = false,          -- show git icons?
          file_icons        = true,           -- show file icons (true|"devicons"|"mini")?
          color_icons       = true,           -- colorize file|git icons
          -- path_shorten   = 1,              -- 'true' or number, shorten path?
          -- Uncomment for custom vscode-like formatter where the filename is first:
          -- e.g. "fzf-lua/previewer/fzf.lua" => "fzf.lua previewer/fzf-lua"
          -- formatter      = "path.filename_first",
          -- executed command priority is 'cmd' (if exists)
          -- otherwise auto-detect prioritizes `fd`:`rg`:`find`
          -- default options are controlled by 'fd|rg|find|_opts'
          -- cmd            = "rg --files",
          find_opts         = [[-type f \! -path '*/.git/*']],
          rg_opts           = [[--color=never --hidden --files -g "!.git"]],
          fd_opts           = [[--color=never --hidden --type f --type l --exclude .git]],
          dir_opts          = [[/s/b/a:-d]],
          -- by default, cwd appears in the header only if {opts} contain a cwd
          -- parameter to a different folder than the current working directory
          -- uncomment if you wish to force display of the cwd as part of the
          -- query prompt string (fzf.vim style), header line or both
          -- cwd_header = true,
          cwd_prompt             = true,
          cwd_prompt_shorten_len = 32,        -- shorten prompt beyond this length
          cwd_prompt_shorten_val = 1,         -- shortened path parts length
          toggle_ignore_flag = "--no-ignore", -- flag toggled in `actions.toggle_ignore`
          toggle_hidden_flag = "--hidden",    -- flag toggled in `actions.toggle_hidden`
          toggle_follow_flag = "-L",          -- flag toggled in `actions.toggle_follow`
          hidden             = true,          -- enable hidden files by default
          follow             = false,         -- do not follow symlinks by default
          no_ignore          = false,         -- respect ".gitignore"  by default
          actions = {
            -- inherits from 'actions.files', here we can override
            -- or set bind to 'false' to disable a default action
            -- uncomment to override `actions.file_edit_or_qf`
            --   ["enter"]     = actions.file_edit,
            -- custom actions are available too
            --   ["ctrl-y"]    = function(selected) print(selected[1]) end,
          }
        },
        git = {
          files = {
            prompt        = 'GitFiles❯ ',
            cmd           = 'git ls-files --exclude-standard',
            multiprocess  = true,           -- run command in a separate process
            git_icons     = true,           -- show git icons?
            file_icons    = true,           -- show file icons (true|"devicons"|"mini")?
            color_icons   = true,           -- colorize file|git icons
            -- force display the cwd header line regardless of your current working
            -- directory can also be used to hide the header when not wanted
            -- cwd_header = true
          },
          status = {
            prompt        = 'GitStatus❯ ',
            cmd           = "git -c color.status=false --no-optional-locks status --porcelain=v1 -u",
            multiprocess  = true,           -- run command in a separate process
            file_icons    = true,
            color_icons   = true,
            previewer     = "git_diff",
            -- git-delta is automatically detected as pager, uncomment to disable
            -- preview_pager = false,
            actions = {
              -- actions inherit from 'actions.files' and merge
              ["right"]  = { fn = actions.git_unstage, reload = true },
              ["left"]   = { fn = actions.git_stage, reload = true },
              ["ctrl-x"] = { fn = actions.git_reset, reload = true },
            },
            -- If you wish to use a single stage|unstage toggle instead
            -- using 'ctrl-s' modify the 'actions' table as shown below
            -- actions = {
            --   ["right"]   = false,
            --   ["left"]    = false,
            --   ["ctrl-x"]  = { fn = actions.git_reset, reload = true },
            --   ["ctrl-s"]  = { fn = actions.git_stage_unstage, reload = true },
            -- },
          },
          diff = {
            cmd               = "git --no-pager diff --name-only {ref}",
            ref               = "HEAD",
            preview           = "git diff {ref} {file}",
            -- git-delta is automatically detected as pager, uncomment to disable
            -- preview_pager = false,
            file_icons        = true,
            color_icons       = true,
            fzf_opts          = { ["--multi"] = true },
          },
          hunks = {
            cmd               = "git --no-pager diff --color=always {ref}",
            ref               = "HEAD",
            file_icons        = true,
            color_icons       = true,
            fzf_opts          = {
            ["--multi"] = true,
            ["--delimiter"] = ":",
            ["--nth"] = "3..",
            },
          },
          commits = {
            prompt        = 'Commits❯ ',
            cmd           = [[git log --color --pretty=format:"%C(yellow)%h%Creset ]]
                .. [[%Cgreen(%><(12)%cr%><|(12))%Creset %s %C(blue)<%an>%Creset"]],
            preview       = "git show --color {1}",
            -- git-delta is automatically detected as pager, uncomment to disable
            -- preview_pager = false,
            actions = {
              ["enter"]   = actions.git_checkout,
              -- remove `exec_silent` or set to `false` to exit after yank
              ["ctrl-y"]  = { fn = actions.git_yank_commit, exec_silent = true },
            },
          },
          bcommits = {
            prompt        = 'BCommits❯ ',
            -- default preview shows a git diff vs the previous commit
            -- if you prefer to see the entire commit you can use:
            --   git show --color {1} --rotate-to={file}
            --   {1}    : commit SHA (fzf field index expression)
            --   {file} : filepath placement within the commands
            cmd           = [[git log --color --pretty=format:"%C(yellow)%h%Creset ]]
                .. [[%Cgreen(%><(12)%cr%><|(12))%Creset %s %C(blue)<%an>%Creset" {file}]],
            preview       = "git show --color {1} -- {file}",
            -- git-delta is automatically detected as pager, uncomment to disable
            -- preview_pager = false,
            actions = {
              ["enter"]   = actions.git_buf_edit,
              ["ctrl-s"]  = actions.git_buf_split,
              ["ctrl-v"]  = actions.git_buf_vsplit,
              ["ctrl-t"]  = actions.git_buf_tabedit,
              ["ctrl-y"]  = { fn = actions.git_yank_commit, exec_silent = true },
            },
          },
          blame = {
            prompt        = "Blame> ",
            cmd           = [[git blame --color-lines {file}]],
            preview       = "git show --color {1} -- {file}",
            -- git-delta is automatically detected as pager, uncomment to disable
            -- preview_pager = false,
            actions = {
              ["enter"]  = actions.git_goto_line,
              ["ctrl-s"] = actions.git_buf_split,
              ["ctrl-v"] = actions.git_buf_vsplit,
              ["ctrl-t"] = actions.git_buf_tabedit,
              ["ctrl-y"] = { fn = actions.git_yank_commit, exec_silent = true },
            },
          },
          branches = {
            prompt   = 'Branches❯ ',
            cmd      = "git branch --all --color",
            preview  = "git log --graph --pretty=oneline --abbrev-commit --color {1}",
            remotes  = "local", -- "detach|local", switch behavior for remotes
            actions  = {
              ["enter"]   = actions.git_switch,
              ["ctrl-x"]  = { fn = actions.git_branch_del, reload = true },
              ["ctrl-a"]  = { fn = actions.git_branch_add, field_index = "{q}", reload = true },
            },
            -- If you wish to add branch and switch immediately
            -- cmd_add  = { "git", "checkout", "-b" },
            cmd_add  = { "git", "branch" },
            -- If you wish to delete unmerged branches add "--force"
            -- cmd_del  = { "git", "branch", "--delete", "--force" },
            cmd_del  = { "git", "branch", "--delete" },
          },
          tags = {
            prompt   = "Tags> ",
            cmd      = [[git for-each-ref --color --sort="-taggerdate" --format ]]
                .. [["%(color:yellow)%(refname:short)%(color:reset) ]]
                .. [[%(color:green)(%(taggerdate:relative))%(color:reset)]]
                .. [[ %(subject) %(color:blue)%(taggername)%(color:reset)" refs/tags]],
            preview  = [[git log --graph --color --pretty=format:"%C(yellow)%h%Creset ]]
                .. [[%Cgreen(%><(12)%cr%><|(12))%Creset %s %C(blue)<%an>%Creset" {1}]],
            actions  = { ["enter"] = actions.git_checkout },
          },
          stash = {
            prompt          = 'Stash> ',
            cmd             = "git --no-pager stash list",
            preview         = "git --no-pager stash show --patch --color {1}",
            actions = {
              ["enter"]     = actions.git_stash_apply,
              ["ctrl-x"]    = { fn = actions.git_stash_drop, reload = true },
            },
          },
          icons = {
            ["M"]           = { icon = "M", color = "yellow" },
            ["D"]           = { icon = "D", color = "red" },
            ["A"]           = { icon = "A", color = "green" },
            ["R"]           = { icon = "R", color = "yellow" },
            ["C"]           = { icon = "C", color = "yellow" },
            ["T"]           = { icon = "T", color = "magenta" },
            ["?"]           = { icon = "?", color = "magenta" },
            -- override git icons?
            -- ["M"]        = { icon = "★", color = "red" },
            -- ["D"]        = { icon = "✗", color = "red" },
            -- ["A"]        = { icon = "+", color = "green" },
          },
        },
        grep = {
          prompt            = 'Rg❯ ',
          input_prompt      = 'Grep For❯ ',
          multiprocess      = true,           -- run command in a separate process
          git_icons         = false,          -- show git icons?
          file_icons        = true,           -- show file icons (true|"devicons"|"mini")?
          color_icons       = true,           -- colorize file|git icons
          -- executed command priority is 'cmd' (if exists)
          -- otherwise auto-detect prioritizes `rg` over `grep`
          -- default options are controlled by 'rg|grep_opts'
          -- cmd            = "rg --vimgrep",
          grep_opts         = "--binary-files=without-match --line-number --recursive --color=auto --perl-regexp -e",
          rg_opts           = "--column --line-number --no-heading --color=always --smart-case --max-columns=4096 -e",
          hidden             = false,       -- disable hidden files by default
          follow             = false,       -- do not follow symlinks by default
          no_ignore          = false,       -- respect ".gitignore"  by default
          -- Uncomment to use the rg config file `$RIPGREP_CONFIG_PATH`
          -- RIPGREP_CONFIG_PATH = vim.env.RIPGREP_CONFIG_PATH
          --
          -- Set to 'true' to always parse globs in both 'grep' and 'live_grep'
          -- search strings will be split using the 'glob_separator' and translated
          -- to '--iglob=' arguments, requires 'rg'
          -- can still be used when 'false' by calling 'live_grep_glob' directly
          rg_glob           = true,         -- default to glob parsing with `rg`
          glob_flag         = "--iglob",    -- for case sensitive globs use '--glob'
          glob_separator    = "%s%-%-",     -- query separator pattern (lua): ' --'
          -- advanced usage: for custom argument parsing define
          -- 'rg_glob_fn' to return a pair:
          --   first returned argument is the new search query
          --   second returned argument are additional rg flags
          -- rg_glob_fn = function(query, opts)
          --   ...
          --   return new_query, flags
          -- end,
          --
          -- Enable with narrow term width, split results to multiple lines
          -- NOTE: multiline requires fzf >= v0.53 and is ignored otherwise
          -- multiline      = 1,      -- Display as: PATH:LINE:COL\nTEXT
          -- multiline      = 2,      -- Display as: PATH:LINE:COL\nTEXT\n
          actions = {
            -- actions inherit from 'actions.files' and merge
            -- this action toggles between 'grep' and 'live_grep'
            ["ctrl-g"]      = { actions.grep_lgrep }
            -- uncomment to enable '.gitignore' toggle for grep
            -- ["ctrl-r"]   = { actions.toggle_ignore }
          },
          no_header             = false,    -- hide grep|cwd header?
          no_header_i           = false,    -- hide interactive header?
        },
        args = {
          prompt            = 'Args❯ ',
          files_only        = true,
          -- actions inherit from 'actions.files' and merge
          actions           = { ["ctrl-x"] = { fn = actions.arg_del, reload = true } },
        },
        oldfiles = {
          prompt            = 'History❯ ',
          cwd_only          = false,
          stat_file         = true,         -- verify files exist on disk
          -- can also be a lua function, for example:
          -- stat_file = FzfLua.utils.file_is_readable,
          -- stat_file = function() return true end,
          include_current_session = false,  -- include bufs from current session
        },
        buffers = {
          prompt            = 'Buffers❯ ',
          file_icons        = true,         -- show file icons (true|"devicons"|"mini")?
          color_icons       = true,         -- colorize file|git icons
          sort_lastused     = true,         -- sort buffers() by last used
          show_unloaded     = true,         -- show unloaded buffers
          cwd_only          = false,        -- buffers for the cwd only
          cwd               = nil,          -- buffers list for a given dir
          actions = {
            -- actions inherit from 'actions.files' and merge
            -- by supplying a table of functions we're telling
            -- fzf-lua to not close the fzf window, this way we
            -- can resume the buffers picker on the same window
            -- eliminating an otherwise unaesthetic win "flash"
            ["ctrl-x"]      = { fn = actions.buf_del, reload = true },
          }
        },
        tabs = {
          prompt            = 'Tabs❯ ',
          tab_title         = "Tab",
          tab_marker        = "<<",
          locate            = true,         -- position cursor at current window
          file_icons        = true,         -- show file icons (true|"devicons"|"mini")?
          color_icons       = true,         -- colorize file|git icons
          actions = {
            -- actions inherit from 'actions.files' and merge
            ["enter"]       = actions.buf_switch,
            ["ctrl-x"]      = { fn = actions.buf_del, reload = true },
          },
          fzf_opts = {
            -- hide tabnr
            ["--delimiter"] = "[\\):]",
            ["--with-nth"]  = '2..',
          },
        },
        -- `blines` has the same defaults as `lines` aside from prompt and `show_bufname`
        lines = {
          prompt            = 'Lines❯ ',
          file_icons        = true,
          show_bufname      = true,         -- display buffer name
          show_unloaded     = true,         -- show unloaded buffers
          show_unlisted     = false,        -- exclude 'help' buffers
          no_term_buffers   = true,         -- exclude 'term' buffers
          sort_lastused     = true,         -- sort by most recent
          winopts  = { treesitter = true }, -- enable TS highlights
          fzf_opts = {
            -- do not include bufnr in fuzzy matching
            -- tiebreak by line no.
            ["--multi"]     = true,
            ["--delimiter"] = "[\t]",
            ["--tabstop"]   = "1",
            ["--tiebreak"]  = "index",
            ["--with-nth"]  = "2..",
            ["--nth"]       = "4..",
          },
        },
        tags = {
          prompt                = 'Tags❯ ',
          ctags_file            = nil,      -- auto-detect from tags-option
          multiprocess          = true,
          file_icons            = true,
          color_icons           = true,
          -- 'tags_live_grep' options, `rg` prioritizes over `grep`
          rg_opts               = "--no-heading --color=always --smart-case",
          grep_opts             = "--color=auto --perl-regexp",
          fzf_opts              = { ["--tiebreak"] = "begin" },
          actions = {
            -- actions inherit from 'actions.files' and merge
            -- this action toggles between 'grep' and 'live_grep'
            ["ctrl-g"]          = { actions.grep_lgrep }
          },
          no_header             = false,    -- hide grep|cwd header?
          no_header_i           = false,    -- hide interactive header?
        },
        btags = {
          prompt                = 'BTags❯ ',
          ctags_file            = nil,      -- auto-detect from tags-option
          ctags_autogen         = true,     -- dynamically generate ctags each call
          multiprocess          = true,
          file_icons            = false,
          rg_opts               = "--color=never --no-heading",
          grep_opts             = "--color=never --perl-regexp",
          fzf_opts              = { ["--tiebreak"] = "begin" },
          -- actions inherit from 'actions.files'
        },
        colorschemes = {
          prompt            = 'Colorschemes❯ ',
          live_preview      = true,       -- apply the colorscheme on preview?
          actions           = { ["enter"] = actions.colorscheme },
          winopts           = { height = 0.55, width = 0.30, },
          -- uncomment to ignore colorschemes names (lua patterns)
          -- ignore_patterns   = { "^delek$", "^blue$" },
        },
        awesome_colorschemes = {
          prompt            = 'Colorschemes❯ ',
          live_preview      = true,       -- apply the colorscheme on preview?
          max_threads       = 5,          -- max download/update threads
          winopts           = { row = 0, col = 0.99, width = 0.50 },
          fzf_opts          = {
            ["--multi"]     = true,
            ["--delimiter"] = "[:]",
            ["--with-nth"]  = "3..",
            ["--tiebreak"]  = "index",
          },
          actions           = {
            ["enter"]   = actions.colorscheme,
            ["ctrl-g"]  = { fn = actions.toggle_bg, exec_silent = true },
            ["ctrl-r"]  = { fn = actions.cs_update, reload = true },
            ["ctrl-x"]  = { fn = actions.cs_delete, reload = true },
          },
        },
        keymaps = {
          prompt            = "Keymaps> ",
          winopts           = { preview = { layout = "vertical" } },
          fzf_opts          = { ["--tiebreak"] = "index", },
          -- by default, we ignore <Plug> and <SNR> mappings
          -- set `ignore_patterns = false` to disable filtering
          ignore_patterns   = { "^<SNR>", "^<Plug>" },
          show_desc         = true,
          show_details      = true,
          actions           = {
            ["enter"]       = actions.keymap_apply,
            ["ctrl-s"]      = actions.keymap_split,
            ["ctrl-v"]      = actions.keymap_vsplit,
            ["ctrl-t"]      = actions.keymap_tabedit,
          },
        },
        nvim_options = {
          prompt            = "Nvim Options> ",
          separator         = "│",  -- separator between option name and value
          color_values      = true, -- colorize boolean values
          actions           = {
            ["enter"]     = { fn = actions.nvim_opt_edit_local, reload = true },
            ["alt-enter"] = { fn = actions.nvim_opt_edit_global, reload = true },
          },
        },
        quickfix = {
          file_icons        = true,
          valid_only        = false, -- select among only the valid quickfix entries
        },
        quickfix_stack = {
          prompt = "Quickfix Stack> ",
          marker = ">",                   -- current list marker
        },
        lsp = {
          prompt_postfix    = '❯ ',       -- will be appended to the LSP label
                                          -- to override use 'prompt' instead
          cwd_only          = false,      -- LSP/diagnostics for cwd only?
          async_or_timeout  = 5000,       -- timeout(ms) or 'true' for async calls
          file_icons        = true,
          git_icons         = false,
          jump1             = true,       -- skip the UI when result is a single entry
          jump1_action      = FzfLua.actions.file_edit
          -- The equivalent of using `includeDeclaration` in lsp buf calls, e.g:
          -- :lua vim.lsp.buf.references({includeDeclaration = false})
          includeDeclaration = true,      -- include current declaration in LSP context
          -- settings for 'lsp_{document|workspace|lsp_live_workspace}_symbols'
          symbols = {
              -- lsp_query      = "foo"       -- query passed to the LSP directly
              -- query          = "bar"       -- query passed to fzf prompt for fuzzy matching
              locate            = false,      -- attempt to position cursor at current symbol
              async_or_timeout  = true,       -- symbols are async by default
              symbol_style      = 1,          -- style for document/workspace symbols
                                              -- false: disable,    1: icon+kind
                                              --     2: icon only,  3: kind only
                                              -- NOTE: icons are extracted from
                                              -- vim.lsp.protocol.CompletionItemKind
              -- icons for symbol kind
              -- see https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#symbolKind
              -- see https://github.com/neovim/neovim/blob/829d92eca3d72a701adc6e6aa17ccd9fe2082479/runtime/lua/vim/lsp/protocol.lua#L117
              symbol_icons     = {
                File          = "󰈙",
                Module        = "",
                Namespace     = "󰦮",
                Package       = "",
                Class         = "󰆧",
                Method        = "󰊕",
                Property      = "",
                Field         = "",
                Constructor   = "",
                Enum          = "",
                Interface     = "",
                Function      = "󰊕",
                Variable      = "󰀫",
                Constant      = "󰏿",
                String        = "",
                Number        = "󰎠",
                Boolean       = "󰨙",
                Array         = "󱡠",
                Object        = "",
                Key           = "󰌋",
                Null          = "󰟢",
                EnumMember    = "",
                Struct        = "󰆼",
                Event         = "",
                Operator      = "󰆕",
                TypeParameter = "󰗴",
              },
              -- colorize using Treesitter '@' highlight groups ("@function", etc).
              -- or 'false' to disable highlighting
              symbol_hl         = function(s) return "@" .. s:lower() end,
              -- additional symbol formatting, works with or without style
              symbol_fmt        = function(s, opts) return "[" .. s .. "]" end,
              -- prefix child symbols. set to any string or `false` to disable
              child_prefix      = true,
              fzf_opts          = { ["--tiebreak"] = "begin" },
          },
          code_actions = {
              prompt            = 'Code Actions> ',
              async_or_timeout  = 5000,
              -- when git-delta is installed use "codeaction_native" for beautiful diffs
              -- try it out with `:FzfLua lsp_code_actions previewer=codeaction_native`
              -- scroll up to `previewers.codeaction{_native}` for more previewer options
              previewer        = "codeaction",
          },
          finder = {
              prompt      = "LSP Finder> ",
              file_icons  = true,
              color_icons = true,
              async       = true,         -- async by default
              silent      = true,         -- suppress "not found"
              separator   = "| ",         -- separator after provider prefix, `false` to disable
              includeDeclaration = true,  -- include current declaration in LSP context
              -- by default display all LSP locations
              -- to customize, duplicate table and delete unwanted providers
              providers   = {
                  { "references",      prefix = FzfLua.utils.ansi_codes.blue("ref ") },
                  { "definitions",     prefix = FzfLua.utils.ansi_codes.green("def ") },
                  { "declarations",    prefix = FzfLua.utils.ansi_codes.magenta("decl") },
                  { "typedefs",        prefix = FzfLua.utils.ansi_codes.red("tdef") },
                  { "implementations", prefix = FzfLua.utils.ansi_codes.green("impl") },
                  { "incoming_calls",  prefix = FzfLua.utils.ansi_codes.cyan("in  ") },
                  { "outgoing_calls",  prefix = FzfLua.utils.ansi_codes.yellow("out ") },
              },
          }
        },
        diagnostics ={
          prompt            = 'Diagnostics❯ ',
          cwd_only          = false,
          file_icons        = false,
          git_icons         = false,
          color_headings    = true,   -- use diag highlights to color source & filepath
          diag_icons        = true,   -- display icons from diag sign definitions
          diag_source       = true,   -- display diag source (e.g. [pycodestyle])
          diag_code         = true,   -- display diag code (e.g. [undefined])
          icon_padding      = '',     -- add padding for wide diagnostics signs
          multiline         = 2,      -- split heading and diag to separate lines
          -- severity_only:   keep any matching exact severity
          -- severity_limit:  keep any equal or more severe (lower)
          -- severity_bound:  keep any equal or less severe (higher)
        },
        marks = {
          marks = "", -- filter vim marks with a lua pattern
          -- for example if you want to only show user defined marks
          -- you would set this option as %a this would match characters from [A-Za-z]
          -- or if you want to show only numbers you would set the pattern to %d (0-9).
        },
        complete_path = {
          cmd          = nil, -- default: auto detect fd|rg|find
          complete     = { ["enter"] = actions.complete },
          word_pattern = nil, -- default: "[^%s\"']*"
        },
        complete_file = {
          cmd          = nil, -- default: auto detect rg|fd|find
          file_icons   = true,
          color_icons  = true,
          word_pattern = nil,
          -- actions inherit from 'actions.files' and merge
          actions      = { ["enter"] = actions.complete },
          -- previewer hidden by default
          winopts      = { preview = { hidden = true } },
        },
        zoxide = {
          cmd          = "zoxide query --list --score",
          scope        = "global", -- cd action scope "local|win|tab"
          git_root     = false,    -- auto-detect git root
          formatter    = "path.dirname_first",
          fzf_opts     = {
            ["--no-multi"]  = true,
            ["--delimiter"] = "[\t]",
            ["--tabstop"]   = "4",
            ["--tiebreak"]  = "end,index", -- prefer dirs ending with search term
            ["--nth"]       = "2..",       -- exclude score from fuzzy matching
          },
          actions      = { enter = actions.cd }
        },
        -- uncomment to use fzf native previewers
        -- (instead of using a neovim floating window)
        -- manpages = { previewer = "man_native" },
        -- helptags = { previewer = "help_native" },
      
      
      :lua FzfLua.files({ fzf_opts = {['--layout'] = 'reverse-list'} })
      -- Or via the vimL command
      :FzfLua files fzf_opts.--layout=reverse-list
      
      
      :lua FzfLua.files({ prompt="LS> ", cmd = "ls", cwd="~/.config" })
      -- Or via the vimL command
      :FzfLua files prompt="LS>\ " cmd=ls cwd=~/.config
      
      
      :lua FzfLua.live_grep({ cmd = "git grep --line-number --column --color=always" })
      
      
      :lua FzfLua.spell_suggest({ winopts = { height=0.33, width=0.33, relative="cursor" } })
      -- Or via the vimL command
      :FzfLua spell_suggest winopts={height=0.33,width=0.33,relative=cursor}
      :FzfLua spell_suggest winopts={height=0.33,width=0.33} winopts.relative=cursor
      
      
      require('fzf-lua').setup({'fzf-native'})
      
      
      :lua require"fzf-lua".setup({"telescope",winopts={preview={default="bat"}}})
      
      
      :lua require"fzf-lua".setup({{"telescope","fzf-native"},winopts={fullscreen=true}})
      
      
      > require("fzf-lua").setup({
      >   { "fzf-native", "hide" },
      >   -- your other settings here
      > })
      > 
      
      require('fzf-lua').setup({'fzf-vim'})
      
      
      vim.keymap.set({ "n", "v", "i" }, "<C-x><C-f>",
        function() FzfLua.complete_path() end,
        { silent = true, desc = "Fuzzy complete path" })
      
      
      vim.keymap.set({ "i" }, "<C-x><C-f>",
        function()
          FzfLua.complete_file({
            cmd = "rg --files",
            winopts = { preview = { hidden = true } }
          })
        end, { silent = true, desc = "Fuzzy complete file" })
      
      
      FzfLua.fzf_exec({"foo", "bar"}, {complete = true})
      
      
      FzfLua.fzf_exec({"foo", "bar"}, {
        -- @param selected: the selected entry or entries
        -- @param opts: fzf-lua caller/provider options
        -- @param line: originating buffer completed line
        -- @param col: originating cursor column location
        -- @return newline: will replace the current buffer line
        -- @return newcol?: optional, sets the new cursor column
        complete = function(selected, opts, line, col)
          local newline = line:sub(1, col) .. selected[1]
          -- set cursor to EOL, since `nvim_win_set_cursor`
          -- is 0-based we have to lower the col value by 1
          return newline, #newline - 1
        end
      })
      
      
      :lua vim.api.nvim_set_hl(0, "FzfLuaBorder", { link = "FloatBorder" })
      
      
      require('fzf-lua').setup {
        hls = { border = "FloatBorder" }
      }
      
      
      :lua FzfLua.files({ hls={preview_title="IncSearch"} })
      -- vimL equivalent
      :FzfLua files hls.preview_title=IncSearch
      
      
      require("fzf-lua").setup({ fzf_colors = true })
      -- Or in the direct call options
      :lua FzfLua.files({ fzf_colors = true })
      :FzfLua files fzf_colors=true
      
      
      require('fzf-lua').setup {
        fzf_colors = {
          -- First existing highlight group will be used
          -- values in 3rd+ index will be passed raw
          -- i.e:  `--color fg+:#010101:bold:underline`
          ["fg+"] = { "fg" , { "Comment", "Normal" }, "bold", "underline" },
          -- It is also possible to pass raw values directly
          ["gutter"] = "-1"
        }
      }
      
      
      -- Similarly, first existing highlight group will be used
      :lua vim.g.fzf_colors = { ["gutter"] = { "bg", "DoesNotExist", "IncSearch" } }
      
      
      :lua vim.g.fzf_colors = { ["fg+"] = { "fg", { "ErrorMsg" }, "bold", "underline" } }
      
    end,
  },
  {
    "jvgrootveld/telescope-zoxide",
    config = function()
      
      -- Useful for easily creating commands
      local z_utils = require("telescope._extensions.zoxide.utils")
      
      require('telescope').setup{
        -- (other Telescope configuration...)
        extensions = {
          zoxide = {
            prompt_title = "[ Walking on the shoulders of TJ ]",
            mappings = {
              default = {
                after_action = function(selection)
                  print("Update to (" .. selection.z_score .. ") " .. selection.path)
                end
              },
              ["<C-s>"] = {
                before_action = function(selection) print("before C-s") end,
                action = function(selection)
                  vim.cmd.edit(selection.path)
                end
              },
              -- Opens the selected entry in a new split
              ["<C-q>"] = { action = z_utils.create_basic_command("split") },
            },
          }
        }
      }
      
      
      require("telescope").load_extension('zoxide')
      
      
      require("telescope").extensions.zoxide.list({picker_opts})
      
      
      vim.keymap.set("n", "<leader>cd", require("telescope").extensions.zoxide.list)
      
      
      local t = require("telescope")
      local z_utils = require("telescope._extensions.zoxide.utils")
      
      -- Configure the extension
      t.setup({
        extensions = {
          zoxide = {
            prompt_title = "[ Walking on the shoulders of TJ ]",
            mappings = {
              default = {
                after_action = function(selection)
                  print("Update to (" .. selection.z_score .. ") " .. selection.path)
                end
              },
              ["<C-s>"] = {
                before_action = function(selection) print("before C-s") end,
                action = function(selection)
                  vim.cmd.edit(selection.path)
                end
              },
              ["<C-q>"] = { action = z_utils.create_basic_command("split") },
            },
          },
        },
      })
      
      -- Load the extension
      t.load_extension('zoxide')
      
      -- Add a mapping
      vim.keymap.set("n", "<leader>cd", t.extensions.zoxide.list)
      
      
      {
        prompt_title = "[ Zoxide List ]",
      
        -- Zoxide list command with score
        list_command = "zoxide query -ls",
        mappings = {
          default = {
            action = function(selection)
              vim.cmd.cd(selection.path)
            end,
            after_action = function(selection)
              vim.notify("Directory changed to " .. selection.path)
            end,
          },
          ["<C-s>"] = { action = z_utils.create_basic_command("split") },
          ["<C-v>"] = { action = z_utils.create_basic_command("vsplit") },
          ["<C-e>"] = { action = z_utils.create_basic_command("edit") },
          ["<C-f>"] = {
            keepinsert = true,
            action = function(selection)
              builtin.find_files({ cwd = selection.path })
            end,
          },
          ["<C-t>"] = {
            action = function(selection)
              vim.cmd.tcd(selection.path)
            end,
          },
        }
      }
      
      
      {
        mappings = {
          ["<C-b>"] = {
            keepinsert = true,
            action = function(selection)
              require("telescope").extensions.file_browser.file_browser({ cwd = selection.path })
            end
          },
        }
      }
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-fuzzy.md",
  },
  {
    "axkirillov/easypick.nvim",
    config = function()
      
      use {'axkirillov/easypick.nvim', requires = 'nvim-telescope/telescope.nvim'}
      
      
      local easypick = require("easypick")
      
      -- only required for the example to work
      local get_default_branch = "git remote show origin | grep 'HEAD branch' | cut -d' ' -f5"
      local base_branch = vim.fn.system(get_default_branch) or "main"
      
      easypick.setup({
      	pickers = {
      		-- add your custom pickers here
      		-- below you can find some examples of what those can look like
      
      		-- list files inside current folder with default previewer
      		{
      			-- name for your custom picker, that can be invoked using :Easypick <name> (supports tab completion)
      			name = "ls",
      			-- the command to execute, output has to be a list of plain text entries
      			command = "ls",
      			-- specify your custom previwer, or use one of the easypick.previewers
      			previewer = easypick.previewers.default()
      		},
      
      		-- diff current branch with base_branch and show files that changed with respective diffs in preview
      		{
      			name = "changed_files",
      			command = "git diff --name-only $(git merge-base HEAD " .. base_branch .. " )",
      			previewer = easypick.previewers.branch_diff({base_branch = base_branch})
      		},
      
      		-- list files that have conflicts with diffs in preview
      		{
      			name = "conflicts",
      			command = "git diff --name-only --diff-filter=U --relative",
      			previewer = easypick.previewers.file_diff()
      		},
      	}
      })
      
      
      local pickers = { ... }
      require("easypick").setup(pickers = pickers)
      require("easypick").one("ls", pickers)
      require("easypick").ls()
      
    end,
  },
  {
    "linrongbin16/fzfx.nvim",
    config = function()
      
      require("lazy").setup({
        -- Optional for icons.
        { "nvim-tree/nvim-web-devicons" },
      
        -- Optional for 'fzf' command.
        {
          "junegunn/fzf",
          build = function()
            vim.fn["fzf#install"]()
          end,
        },
      
        {
          "linrongbin16/fzfx.nvim",
          -- Optional to avoid break changes between major versions.
          version = "v8.*",
          dependencies = { "nvim-tree/nvim-web-devicons", 'junegunn/fzf' },
          config = function()
            require("fzfx").setup()
          end,
        },
      })
      
      
      return require("packer").startup(function(use)
        -- Optional for icons.
        use({ "nvim-tree/nvim-web-devicons" })
      
        -- Optional for 'fzf' command.
        use({
          "junegunn/fzf",
          run = function()
            vim.fn["fzf#install"]()
          end,
        })
      
        use({
          "linrongbin16/fzfx.nvim",
          -- Optional to avoid break changes between major versions.
          tag = "v8.0.0",
          config = function()
            require("fzfx").setup()
          end,
        })
      end)
      
      
      -- ======== files ========
      
      -- by args
      vim.keymap.set(
        "n",
        "<space>f",
        "<cmd>FzfxFiles<cr>",
        { silent = true, noremap = true, desc = "Find files" }
      )
      -- by visual select
      vim.keymap.set(
        "x",
        "<space>f",
        "<cmd>FzfxFiles visual<CR>",
        { silent = true, noremap = true, desc = "Find files" }
      )
      -- by cursor word
      vim.keymap.set(
        "n",
        "<space>wf",
        "<cmd>FzfxFiles cword<cr>",
        { silent = true, noremap = true, desc = "Find files by cursor word" }
      )
      -- by yank text
      vim.keymap.set(
        "n",
        "<space>pf",
        "<cmd>FzfxFiles put<cr>",
        { silent = true, noremap = true, desc = "Find files by yank text" }
      )
      -- by resume
      vim.keymap.set(
        "n",
        "<space>rf",
        "<cmd>FzfxFiles resume<cr>",
        { silent = true, noremap = true, desc = "Find files by resume last" }
      )
      
      -- ======== live grep ========
      
      -- live grep
      vim.keymap.set(
        "n",
        "<space>l",
        "<cmd>FzfxLiveGrep<cr>",
        { silent = true, noremap = true, desc = "Live grep" }
      )
      -- by visual select
      vim.keymap.set(
        "x",
        "<space>l",
        "<cmd>FzfxLiveGrep visual<cr>",
        { silent = true, noremap = true, desc = "Live grep" }
      )
      -- by cursor word
      vim.keymap.set(
        "n",
        "<space>wl",
        "<cmd>FzfxLiveGrep cword<cr>",
        { silent = true, noremap = true, desc = "Live grep by cursor word" }
      )
      -- by yank text
      vim.keymap.set(
        "n",
        "<space>pl",
        "<cmd>FzfxLiveGrep put<cr>",
        { silent = true, noremap = true, desc = "Live grep by yank text" }
      )
      -- by resume
      vim.keymap.set(
        "n",
        "<space>rl",
        "<cmd>FzfxLiveGrep resume<cr>",
        { silent = true, noremap = true, desc = "Live grep by resume last" }
      )
      
      -- ======== buffers ========
      
      -- by args
      vim.keymap.set(
        "n",
        "<space>bf",
        "<cmd>FzfxBuffers<cr>",
        { silent = true, noremap = true, desc = "Find buffers" }
      )
      
      -- ======== git files ========
      
      -- by args
      vim.keymap.set(
        "n",
        "<space>gf",
        "<cmd>FzfxGFiles<cr>",
        { silent = true, noremap = true, desc = "Find git files" }
      )
      
      -- ======== git live grep ========
      
      -- by args
      vim.keymap.set(
        "n",
        "<space>gl",
        "<cmd>FzfxGLiveGrep<cr>",
        { silent = true, noremap = true, desc = "Git live grep" }
      )
      -- by visual select
      vim.keymap.set(
        "x",
        "<space>gl",
        "<cmd>FzfxGLiveGrep visual<cr>",
        { silent = true, noremap = true, desc = "Git live grep" }
      )
      -- by cursor word
      vim.keymap.set(
        "n",
        "<space>wgl",
        "<cmd>FzfxGLiveGrep cword<cr>",
        { silent = true, noremap = true, desc = "Git live grep by cursor word" }
      )
      -- by yank text
      vim.keymap.set(
        "n",
        "<space>pgl",
        "<cmd>FzfxGLiveGrep put<cr>",
        { silent = true, noremap = true, desc = "Git live grep by yank text" }
      )
      -- by resume
      vim.keymap.set(
        "n",
        "<space>rgl",
        "<cmd>FzfxGLiveGrep resume<cr>",
        { silent = true, noremap = true, desc = "Git live grep by resume last" }
      )
      
      -- ======== git changed files (status) ========
      
      -- by args
      vim.keymap.set(
        "n",
        "<space>gs",
        "<cmd>FzfxGStatus<cr>",
        { silent = true, noremap = true, desc = "Find git changed files (status)" }
      )
      
      -- ======== git branches ========
      
      -- by args
      vim.keymap.set(
        "n",
        "<space>br",
        "<cmd>FzfxGBranches<cr>",
        { silent = true, noremap = true, desc = "Search git branches" }
      )
      
      -- ======== git commits ========
      
      -- by args
      vim.keymap.set(
        "n",
        "<space>gc",
        "<cmd>FzfxGCommits<cr>",
        { silent = true, noremap = true, desc = "Search git commits" }
      )
      
      -- ======== git blame ========
      
      -- by args
      vim.keymap.set(
        "n",
        "<space>gb",
        "<cmd>FzfxGBlame<cr>",
        { silent = true, noremap = true, desc = "Search git blame" }
      )
      
      -- ======== lsp diagnostics ========
      
      -- by args
      vim.keymap.set(
        "n",
        "<space>dg",
        "<cmd>FzfxLspDiagnostics<cr>",
        { silent = true, noremap = true, desc = "Search lsp diagnostics" }
      )
      
      -- ======== lsp symbols ========
      
      -- lsp definitions
      vim.keymap.set(
        "n",
        "gd",
        "<cmd>FzfxLspDefinitions<cr>",
        { silent = true, noremap = true, desc = "Goto lsp definitions" }
      )
      
      -- lsp type definitions
      vim.keymap.set(
        "n",
        "gt",
        "<cmd>FzfxLspTypeDefinitions<cr>",
        { silent = true, noremap = true, desc = "Goto lsp type definitions" }
      )
      
      -- lsp references
      vim.keymap.set(
        "n",
        "gr",
        "<cmd>FzfxLspReferences<cr>",
        { silent = true, noremap = true, desc = "Goto lsp references" }
      )
      
      -- lsp implementations
      vim.keymap.set(
        "n",
        "gi",
        "<cmd>FzfxLspImplementations<cr>",
        { silent = true, noremap = true, desc = "Goto lsp implementations" }
      )
      
      -- lsp incoming calls
      vim.keymap.set(
        "n",
        "gI",
        "<cmd>FzfxLspIncomingCalls<cr>",
        { silent = true, noremap = true, desc = "Goto lsp incoming calls" }
      )
      
      -- lsp outgoing calls
      vim.keymap.set(
        "n",
        "gO",
        "<cmd>FzfxLspOutgoingCalls<cr>",
        { silent = true, noremap = true, desc = "Goto lsp outgoing calls" }
      )
      
      -- ======== vim commands ========
      
      -- by args
      vim.keymap.set(
        "n",
        "<space>cm",
        "<cmd>FzfxCommands<cr>",
        { silent = true, noremap = true, desc = "Search vim commands" }
      )
      
      -- ======== vim key maps ========
      
      -- by args
      vim.keymap.set(
        "n",
        "<space>km",
        "<cmd>FzfxKeyMaps<cr>",
        { silent = true, noremap = true, desc = "Search vim keymaps" }
      )
      
      -- ======== vim marks ========
      
      -- by args
      vim.keymap.set(
        "n",
        "<space>mk",
        "<cmd>FzfxMarks<cr>",
        { silent = true, noremap = true, desc = "Search vim marks" }
      )
      
      -- ======== file explorer ========
      
      -- by args
      vim.keymap.set(
        "n",
        "<space>xp",
        "<cmd>FzfxFileExplorer<cr>",
        { silent = true, noremap = true, desc = "File explorer" }
      )
      
      
      require('fzfx').setup(opts)
      
      
      require("fzfx").setup()
      
      require("fzfx").register("ls", {
        --- @type fzfx.CommandConfig
        command = {
          name = "FzfxLs",
          desc = "File Explorer (ls -1)",
        },
        variants = {
          {
            name = "args",
            feed = "args",
            default_provider = "filter_hiddens",
          },
          {
            name = "hidden_args",
            feed = "args",
            default_provider = "include_hiddens",
          },
        },
        --- @type table<string, fzfx.ProviderConfig>
        providers = {
          filter_hiddens = {
            key = "ctrl-h",
            provider = { "ls", "--color=always", "-1" },
            provider_type = "COMMAND_ARRAY",
          },
          include_hiddens = {
            key = "ctrl-u",
            provider = { "ls", "--color=always", "-1a" },
            provider_type = "COMMAND_ARRAY",
          },
        },
        --- @type table<string, fzfx.PreviewerConfig>
        previewers = {
          filter_hiddens = {
            previewer = function(line)
              -- each line is either a folder or a file
              return vim.fn.isdirectory(line) > 0 and { "ls", "--color=always", "-lha", line }
                or { "cat", line }
            end,
            previewer_type = "COMMAND_ARRAY",
          },
          include_hiddens = {
            previewer = function(line)
              return vim.fn.isdirectory(line) > 0 and { "ls", "--color=always", "-lha", line }
                or { "cat", line }
            end,
            previewer_type = "COMMAND_ARRAY",
          },
        },
        actions = {
          ["esc"] = function(lines)
            -- do nothing
          end,
          ["enter"] = function(lines)
            for _, line in ipairs(lines) do
              vim.cmd(string.format([[edit %s]], line))
            end
          end,
        },
        fzf_opts = {
          "--multi",
          { "--prompt", "Ls > " },
        },
      })
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-pick.md",
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-extra.md",
  },
  {
    "fdschmidt93/telescope-egrepify.nvim",
    config = function()
      
      -- DEFAULTS
      -- filter for file suffixes
      -- example prompt: #lua,md $MY_PROMPT
      -- searches with ripgrep prompt $MY_PROMPT in files with extensions lua and md
      -- i.e. rg --glob="*.{lua,md}" -- $MY_PROMPT
      { ["#"] = {
            -- #$REMAINDER
            -- # is caught prefix
            -- `input` becomes $REMAINDER
            -- in the above example #lua,md -> input: lua,md
            flag = "glob",
            cb = function(input)
                return string.format([[*.{%s}]], input)
            end,
        },
        -- filter for (partial) folder names
        -- example prompt: >conf $MY_PROMPT
        -- searches with ripgrep prompt $MY_PROMPT in paths that have "conf" in folder
        -- i.e. rg --glob="**/conf*/**" -- $MY_PROMPT
        [">"] = {
            flag = "glob",
            cb = function(input)
                return string.format([[**/{%s}*/**]], input)
            end,
        },
        -- filter for (partial) file names
        -- example prompt: &egrep $MY_PROMPT
        -- searches with ripgrep prompt $MY_PROMPT in paths that have "egrep" in file name
        -- i.e. rg --glob="*egrep*" -- $MY_PROMPT
        ["&"] = {
            flag = "glob",
            cb = function(input)
                return string.format([[*{%s}*]], input)
            end,
        }
      }
      
      
      {
          "fdschmidt93/telescope-egrepify.nvim",
          dependencies = { "nvim-telescope/telescope.nvim", "nvim-lua/plenary.nvim" }
      }
      
      
      require "telescope".setup({ "$YOUR_TELESCOPE_OPTS" })
      require "telescope".load_extension "egrepify"
      
      
      require "telescope".extensions.egrepify.egrepify {}
      
      
      local egrep_actions = require "telescope._extensions.egrepify.actions"
      
      require("telescope").setup {
        extensions = {
          egrepify = {
            -- intersect tokens in prompt ala "str1.*str2" that ONLY matches
            -- if str1 and str2 are consecutively in line with anything in between (wildcard)
            AND = true,                     -- default
            permutations = false,           -- opt-in to imply AND & match all permutations of prompt tokens
            lnum = true,                    -- default, not required
            lnum_hl = "EgrepifyLnum",       -- default, not required, links to `Constant`
            col = false,                    -- default, not required
            col_hl = "EgrepifyCol",         -- default, not required, links to `Constant`
            title = true,                   -- default, not required, show filename as title rather than inline
            filename_hl = "EgrepifyFile",   -- default, not required, links to `Title`
            results_ts_hl = true,           -- set to false if you experience latency issues!
            -- suffix = long line, see screenshot
            -- EXAMPLE ON HOW TO ADD PREFIX!
            prefixes = {
              -- ADDED ! to invert matches
              -- example prompt: ! sorter
              -- matches all lines that do not comprise sorter
              -- rg --invert-match -- sorter
              ["!"] = {
                flag = "invert-match",
              },
              -- HOW TO OPT OUT OF PREFIX
              -- ^ is not a default prefix and safe example
              ["^"] = false
            },
            -- default mappings
            mappings = {
              i = {
                -- toggle prefixes, prefixes is default
                ["<C-z>"] = egrep_actions.toggle_prefixes,
                -- toggle AND, AND is default, AND matches tokens and any chars in between
                ["<C-a>"] = egrep_actions.toggle_and,
                -- toggle permutations, permutations of tokens is opt-in
                ["<C-r>"] = egrep_actions.toggle_permutations,
              },
            },
          },
        },
      }
      require("telescope").load_extension "egrepify"
      
    end,
  },
  {
    "crispgm/telescope-heading.nvim",
    config = function()
      
      use('nvim-telescope/telescope.nvim')
      use('crispgm/telescope-heading.nvim')
      
      
      require('telescope').load_extension('heading')
      
      
      -- add nvim-treesitter
      use('nvim-treesitter/nvim-treesitter')
      
      -- make sure you have already installed treesitter modules
      require('nvim-treesitter.configs').setup({
          ensure_installed = {
              -- ..
              'markdown',
              'rst',
              -- ..
          },
      })
      
      -- enable treesitter parsing
      local telescope = require('telescope')
      telescope.setup({
          -- ...
          extensions = {
              heading = {
                  treesitter = true,
              },
          },
      })
      
      -- `load_extension` must be after `telescope.setup`
      telescope.load_extension('heading')
      
      
      local telescope = require('telescope')
      telescope.setup({
          -- ...
          extensions = {
              heading = {
                picker_opts = {
                    layout_config = { width = 0.8, preview_width = 0.5 },
                    layout_strategy = 'horizontal',
                },
              },
              -- ...
          },
      })
      
    end,
  },
  {
    "bassamsdata/namu.nvim",
    config = function()
      
      {
          "bassamsdata/namu.nvim",
          opts = {
              global = { },
              namu_symbols = { -- Specific Module options
                  options = {},
              },
          },
          -- === Suggested Keymaps: ===
          vim.keymap.set("n", "<leader>ss", ":Namu symbols<cr>", {
              desc = "Jump to LSP symbol",
              silent = true,
          })
          vim.keymap.set("n", "<leader>sw", ":Namu workspace<cr>", {
              desc = "LSP Symbols - Workspace",
              silent = true,
          })
      }
      
      
        require "paq" {
          "bassamsdata/namu.nvim"
        }
        
      
        require("mini.deps").add("bassamsdata/namu.nvim")
        
      
      -- in namu_symbols.options
        movement = {
          next = { "<C-n>", "<DOWN>" }, -- Support multiple keys
          previous = { "<C-p>", "<UP>" }, -- Support multiple keys
          close = { "<ESC>" }, -- close mapping
          select = { "<CR>" }, -- select mapping
          delete_word = {}, -- delete word mapping
          clear_line = {}, -- clear line mapping
        },
        multiselect = {
          enabled = false,
          indicator = "●", -- or "✓"◉
          keymaps = {
            toggle = "<Tab>",
            select_all = "<C-a>",
            clear_all = "<C-l>",
            untoggle = "<S-Tab>",
          },
          max_items = nil, -- No limit by default
        },
        custom_keymaps = {
          yank = {
            keys = { "<C-y>" }, -- yank symbol text
          },
          delete = {
            keys = { "<C-d>" }, -- delete symbol text
          },
          vertical_split = {
            keys = { "<C-v>" }, -- open in vertical split
          },
          horizontal_split = {
            keys = { "<C-h>" }, -- open in horizontal split
          },
          codecompanion = {
            keys = "<C-o>", -- Add symbols to CodeCompanion
          },
          avante = {
            keys = "<C-t>", -- Add symbol to Avante
          },
        },
      
      
      { -- Those are the default options
        "bassamsdata/namu.nvim",
          opts = {
            -- Enable symbols navigator which is the default
            namu_symbols = {
              enable = true,
              ---@type NamuConfig
              options = {
                AllowKinds = {
                  default = {
                    "Function",
                    "Method",
                    "Class",
                    "Module",
                    "Property",
                    "Variable",
                    -- "Constant",
                    -- "Enum",
                    -- "Interface",
                    -- "Field",
                    -- "Struct",
                  },
                  go = {
                    "Function",
                    "Method",
                    "Struct", -- For struct definitions
                    "Field", -- For struct fields
                    "Interface",
                    "Constant",
                    -- "Variable",
                    "Property",
                    -- "TypeParameter", -- For type parameters if using generics
                  },
                  lua = { "Function", "Method", "Table", "Module" },
                  python = { "Function", "Class", "Method" },
                  -- Filetype specific
                  yaml = { "Object", "Array" },
                  json = { "Module" },
                  toml = { "Object" },
                  markdown = { "String" },
                },
                BlockList = {
                  default = {},
                  -- Filetype-specific
                  lua = {
                    "^vim%.", -- anonymous functions passed to nvim api
                    "%.%.%. :", -- vim.iter functions
                    ":gsub", -- lua string.gsub
                    "^callback$", -- nvim autocmds
                    "^filter$",
                    "^map$", -- nvim keymaps
                  },
                  -- another example:
                  -- python = { "^__" }, -- ignore __init__ functions
                },
                display = {
                  mode = "icon", -- "icon" or "raw"
                  padding = 2,
                },
                -- This is a preset that let's set window without really get into the hassle of tuning window options
                -- top10 meaning top 10% of the window
                row_position = "top10", -- options: "center"|"top10"|"top10_right"|"center_right"|"bottom",
                preview = {
                  highlight_on_move = true, -- Whether to highlight symbols as you move through them
                  -- still needs implmenting, keep it always now
                  highlight_mode = "always", -- "always" | "select" (only highlight when selecting)
                },
                window = {
                  auto_size = true,
                  min_height = 1,
                  min_width = 20,
                  max_width = 120,
                  max_height = 30,
                  padding = 2,
                  border = "rounded",
                  title_pos = "left",
                  show_footer = true,
                  footer_pos = "right",
                  relative = "editor",
                  style = "minimal",
                  width_ratio = 0.6,
                  height_ratio = 0.6,
                  title_prefix = "󱠦 ",
                },
                debug = false,
                focus_current_symbol = true,
                auto_select = false,
                initially_hidden = false,
                multiselect = {
                  enabled = true,
                  indicator = "✓", -- or "✓"●
                  keymaps = {
                    toggle = "<Tab>",
                    untoggle = "<S-Tab>",
                    select_all = "<C-a>",
                    clear_all = "<C-l>",
                  },
                  max_items = nil, -- No limit by default
                },
                actions = {
                  close_on_yank = false, -- Whether to close picker after yanking
                  close_on_delete = true, -- Whether to close picker after deleting
                },
                movement = {-- Support multiple keys
                  next = { "<C-n>", "<DOWN>" },
                  previous = { "<C-p>", "<UP>" },
                  close = { "<ESC>" }, -- "<C-c>" can be added as well
                  select = { "<CR>" },
                  delete_word = {}, -- it can assign "<C-w>"
                  clear_line = {}, -- it can be "<C-u>"
                },
                custom_keymaps = {
                  yank = {
                    keys = { "<C-y>" },
                    desc = "Yank symbol text",
                  },
                  delete = {
                    keys = { "<C-d>" },
                    desc = "Delete symbol text",
                  },
                  vertical_split = {
                    keys = { "<C-v>" },
                    desc = "Open in vertical split",
                  },
                  horizontal_split = {
                    keys = { "<C-h>" },
                    desc = "Open in horizontal split",
                  },
                  codecompanion = {
                    keys = "<C-o>",
                    desc = "Add symbol to CodeCompanion",
                  },
                  avante = {
                    keys = "<C-t>",
                    desc = "Add symbol to Avante",
                  },
                },
                icon = "󱠦", -- 󱠦 -  -  -- 󰚟
                kindText = {
                  Function = "function",
                  Class = "class",
                  Module = "module",
                  Constructor = "constructor",
                  Interface = "interface",
                  Property = "property",
                  Field = "field",
                  Enum = "enum",
                  Constant = "constant",
                  Variable = "variable",
                },
                kindIcons = {
                  File = "󰈙",
                  Module = "󰏗",
                  Namespace = "󰌗",
                  Package = "󰏖",
                  Class = "󰌗",
                  Method = "󰆧",
                  Property = "󰜢",
                  Field = "󰜢",
                  Constructor = "󰆧",
                  Enum = "󰒻",
                  Interface = "󰕘",
                  Function = "󰊕",
                  Variable = "󰀫",
                  Constant = "󰏿",
                  String = "󰀬",
                  Number = "󰎠",
                  Boolean = "󰨙",
                  Array = "󰅪",
                  Object = "󰅩",
                  Key = "󰌋",
                  Null = "󰟢",
                  EnumMember = "󰒻",
                  Struct = "󰌗",
                  Event = "󰉁",
                  Operator = "󰆕",
                  TypeParameter = "󰊄",
                },
                highlight = "NamuPreview",
                highlights = {
                  parent = "NamuParent",
                  nested = "NamuNested",
                  style = "NamuStyle",
                },
                kinds = {
                  prefix_kind_colors = true,
                  enable_highlights = true,
                  highlights = {
                    PrefixSymbol = "NamuPrefixSymbol",
                    Function = "NamuSymbolFunction",
                    Method = "NamuSymbolMethod",
                    Class = "NamuSymbolClass",
                    Interface = "NamuSymbolInterface",
                    Variable = "NamuSymbolVariable",
                    Constant = "NamuSymbolConstant",
                    Property = "NamuSymbolProperty",
                    Field = "NamuSymbolField",
                    Enum = "NamuSymbolEnum",
                    Module = "NamuSymbolModule",
                  },
                },
              }
            }
            ui_select = { enable = false }, -- vim.ui.select() wrapper
          }
        end,
      }
      
    end,
  },
  {
    "folke/snacks.nvim/blob/main/docs/picker.md",
  },
  {
    "dmtrKovalenko/fff.nvim",
    config = function()
      
      {
        'dmtrKovalenko/fff.nvim',
        build = function()
          -- this will download prebuild binary or try to use existing rustup toolchain to build from source
          -- (if you are using lazy you can use gb for rebuilding a plugin if needed)
          require("fff.download").download_or_build_binary()
        end,
        -- if you are using nixos
        -- build = "nix run .#release",
        opts = { -- (optional)
          debug = {
            enabled = true,     -- we expect your collaboration at least during the beta
            show_scores = true, -- to help us optimize the scoring system, feel free to share your scores!
          },
        },
        -- No need to lazy-load with lazy.nvim.
        -- This plugin initializes itself lazily.
        lazy = false,
        keys = {
          {
            "ff", -- try it if you didn't it is a banger keybinding for a picker
            function() require('fff').find_files() end,
            desc = 'FFFind files',
          }
        }
      }
      
      
      vim.pack.add({ 'https://github.com/dmtrKovalenko/fff.nvim' })
      
      nvim.create_autocmd('PackChanged', {
        callback = function(event)
          if event.data.updated then 
            require('fff.download').download_or_build_binary() 
          end
        end,
      })
      
      -- the plugin will automatically lazy load
      vim.g.fff = {
        lazy_sync = true, -- start syncing only when the picker is open
        debug = {
          enabled = true,
          show_scores = true,
        },
      }
      
      vim.keymap.set(
        'n',
        'ff',
        function() require('fff').find_files() end,
        { desc = 'FFFind files' }
      )
      
      
      require('fff').setup({
          base_path = vim.fn.getcwd(),
          prompt = '🪿 ',
          title = 'FFFiles',
          max_results = 100,
          max_threads = 4,
          lazy_sync = true, -- set to false if you want file indexing to start on open
          layout = {
            height = 0.8,
            width = 0.8,
            prompt_position = 'bottom', -- or 'top'
            preview_position = 'right', -- or 'left', 'right', 'top', 'bottom'
            preview_size = 0.5,
          },
          preview = {
            enabled = true,
            max_size = 10 * 1024 * 1024, -- Do not try to read files larger than 10MB
            chunk_size = 8192, -- Bytes per chunk for dynamic loading (8kb - fits ~100-200 lines)
            binary_file_threshold = 1024, -- amount of bytes to scan for binary content (set 0 to disable)
            imagemagick_info_format_str = '%m: %wx%h, %[colorspace], %q-bit',
            line_numbers = false,
            wrap_lines = false,
            show_file_info = true,
            filetypes = {
              svg = { wrap_lines = true },
              markdown = { wrap_lines = true },
              text = { wrap_lines = true },
            },
          },
          keymaps = {
            close = '<Esc>',
            select = '<CR>',
            select_split = '<C-s>',
            select_vsplit = '<C-v>',
            select_tab = '<C-t>',
            move_up = { '<Up>', '<C-p>' },
            move_down = { '<Down>', '<C-n>' },
            preview_scroll_up = '<C-u>',
            preview_scroll_down = '<C-d>',
            toggle_debug = '<F2>',
          },
          hl = {
            border = 'FloatBorder',
            normal = 'Normal',
            cursor = 'CursorLine',
            matched = 'IncSearch',
            title = 'Title',
            prompt = 'Question',
            active_file = 'Visual',
            frecency = 'Number',
            debug = 'Comment',
          },
          frecency = {
            enabled = true,
            db_path = vim.fn.stdpath('cache') .. '/fff_nvim',
          },
          debug = {
            enabled = false, -- Set to true to show scores in the UI
            show_scores = false,
          },
          logging = {
            enabled = true,
            log_file = vim.fn.stdpath('log') .. '/fff.log',
            log_level = 'info',
          }
      })
      
      
      require('fff').find_files()                         -- Find files in current directory
      require('fff').find_in_git_root()                   -- Find files in the current git repository
      require('fff').scan_files()                         -- Trigger rescan of files in the current directory
      require('fff').refresh_git_status()                 -- Refresh git status for the active file lock
      require('fff').find_files_in_dir(path)              -- Find files in a specific directory
      require('fff').change_indexing_directory(new_path)  -- Change the base directory for the file picker
      
      
      keymaps = {
        move_up = { '<Up>', '<C-p>', '<C-k>' },  -- Three ways to move up
        close = { '<Esc>', '<C-c>' },            -- Two ways to close
        select = '<CR>',                         -- Single binding still works
      }
      
    end,
  },
  {
    "nvim-tree/nvim-tree.lua",
    config = function()
      
      -- disable netrw at the very start of your init.lua
      vim.g.loaded_netrw = 1
      vim.g.loaded_netrwPlugin = 1
      
      -- optionally enable 24-bit colour
      vim.opt.termguicolors = true
      
      -- empty setup using defaults
      require("nvim-tree").setup()
      
      -- OR setup with some options
      require("nvim-tree").setup({
        sort = {
          sorter = "case_sensitive",
        },
        view = {
          width = 30,
        },
        renderer = {
          group_empty = true,
        },
        filters = {
          dotfiles = true,
        },
      })
      
      
      local function my_on_attach(bufnr)
        local api = require "nvim-tree.api"
      
        local function opts(desc)
          return { desc = "nvim-tree: " .. desc, buffer = bufnr, noremap = true, silent = true, nowait = true }
        end
      
        -- default mappings
        api.config.mappings.default_on_attach(bufnr)
      
        -- custom mappings
        vim.keymap.set('n', '<C-t>', api.tree.change_root_to_parent,        opts('Up'))
        vim.keymap.set('n', '?',     api.tree.toggle_help,                  opts('Help'))
      end
      
      -- pass to setup along with your other options
      require("nvim-tree").setup {
        ---
        on_attach = my_on_attach,
        ---
      }
      
      
      vim.cmd([[
          :hi      NvimTreeExecFile    guifg=#ffa0a0
          :hi      NvimTreeSpecialFile guifg=#ff80ff gui=underline
          :hi      NvimTreeSymlink     guifg=Yellow  gui=italic
          :hi link NvimTreeImageFile   Title
      ]])
      
    end,
  },
  {
    "luukvbaal/nnn.nvim",
    config = function()
      
      use {
        "luukvbaal/nnn.nvim",
        config = function() require("nnn").setup() end
      }
      
      
      local cfg = {
        explorer = {
          cmd = "nnn",       -- command override (-F1 flag is implied, -a flag is invalid!)
          width = 24,        -- width of the vertical split
          side = "topleft",  -- or "botright", location of the explorer window
          session = "",      -- or "global" / "local" / "shared"
          tabs = true,       -- separate nnn instance per tab
          fullscreen = true, -- whether to fullscreen explorer window when current tab is empty
        },
        picker = {
          cmd = "nnn",       -- command override (-p flag is implied)
          style = {
            width = 0.9,     -- percentage relative to terminal size when < 1, absolute otherwise
            height = 0.8,    -- ^
            xoffset = 0.5,   -- ^
            yoffset = 0.5,   -- ^
            border = "single"-- border decoration for example "rounded"(:h nvim_open_win)
          },
          session = "",      -- or "global" / "local" / "shared"
          tabs = true,       -- separate nnn instance per tab
          fullscreen = true, -- whether to fullscreen picker window when current tab is empty
        },
        auto_open = {
          setup = nil,       -- or "explorer" / "picker", auto open on setup function
          tabpage = nil,     -- or "explorer" / "picker", auto open when opening new tabpage
          empty = false,     -- only auto open on empty buffer
          ft_ignore = {      -- dont auto open for these filetypes
            "gitcommit",
          }
        },
        auto_close = false,  -- close tabpage/nvim when nnn is last window
        replace_netrw = nil, -- or "explorer" / "picker"
        mappings = {},       -- table containing mappings, see below
        windownav = {        -- window movement mappings to navigate out of nnn
          left = "<C-w>h",
          right = "<C-w>l",
          next = "<C-w>w",
          prev = "<C-w>W",
        },
        buflisted = false,   -- whether or not nnn buffers show up in the bufferlist
        quitcd = nil,        -- or "cd" / tcd" / "lcd", command to run on quitcd file if found
        offset = false,      -- whether or not to write position offset to tmpfile(for use in preview-tui)
      }
      
      
      require("nnn").setup({
        picker = {
          cmd = "tmux new-session nnn -Pp",
          style = { border = "rounded" },
          session = "shared",
        },
        replace_netrw = "picker",
        windownav = "<C-l>"
      })
      
      
        local builtin = require("nnn").builtin
        mappings = {
          { "<C-t>", builtin.open_in_tab },       -- open file(s) in tab
          { "<C-s>", builtin.open_in_split },     -- open file(s) in split
          { "<C-v>", builtin.open_in_vsplit },    -- open file(s) in vertical split
          { "<C-p>", builtin.open_in_preview },   -- open file in preview split keeping nnn focused
          { "<C-y>", builtin.copy_to_clipboard }, -- copy file(s) to clipboard
          { "<C-w>", builtin.cd_to_path },        -- cd to file directory
          { "<C-e>", builtin.populate_cmdline },  -- populate cmdline (:) with file(s)
        }
      
    end,
  },
  {
    "tamago324/lir.nvim",
    config = function()
      
      local actions = require'lir.actions'
      local mark_actions = require 'lir.mark.actions'
      local clipboard_actions = require'lir.clipboard.actions'
      
      require'lir'.setup {
        show_hidden_files = false,
        ignore = {}, -- { ".DS_Store", "node_modules" } etc.
        devicons = {
          enable = false,
          highlight_dirname = false
        },
        mappings = {
          ['l']     = actions.edit,
          ['<C-s>'] = actions.split,
          ['<C-v>'] = actions.vsplit,
          ['<C-t>'] = actions.tabedit,
      
          ['h']     = actions.up,
          ['q']     = actions.quit,
      
          ['K']     = actions.mkdir,
          ['N']     = actions.newfile,
          ['R']     = actions.rename,
          ['@']     = actions.cd,
          ['Y']     = actions.yank_path,
          ['.']     = actions.toggle_show_hidden,
          ['D']     = actions.delete,
      
          ['J'] = function()
            mark_actions.toggle_mark()
            vim.cmd('normal! j')
          end,
          ['C'] = clipboard_actions.copy,
          ['X'] = clipboard_actions.cut,
          ['P'] = clipboard_actions.paste,
        },
        float = {
          winblend = 0,
          curdir_window = {
            enable = false,
            highlight_dirname = false
          },
      
          -- -- You can define a function that returns a table to be passed as the third
          -- -- argument of nvim_open_win().
          -- win_opts = function()
          --   local width = math.floor(vim.o.columns * 0.8)
          --   local height = math.floor(vim.o.lines * 0.8)
          --   return {
          --     border = {
          --       "+", "─", "+", "│", "+", "─", "+", "│",
          --     },
          --     width = width,
          --     height = height,
          --     row = 1,
          --     col = math.floor((vim.o.columns - width) / 2),
          --   }
          -- end,
        },
        hide_cursor = true
      }
      
      vim.api.nvim_create_autocmd({'FileType'}, {
        pattern = {"lir"},
        callback = function()
          -- use visual mode
          vim.api.nvim_buf_set_keymap(
            0,
            "x",
            "J",
            ':<C-u>lua require"lir.mark.actions".toggle_mark("v")<CR>',
            { noremap = true, silent = true }
          )
        
          -- echo cwd
          vim.api.nvim_echo({ { vim.fn.expand("%:p"), "Normal" } }, false, {})
        end
      })
      
      -- custom folder icon
      require'nvim-web-devicons'.set_icon({
        lir_folder_icon = {
          icon = "",
          color = "#7ebae4",
          name = "LirFolderNode"
        }
      })
      
    end,
  },
  {
    "TimUntersberger/neofs",
    config = function()
      
      local neofs = require('neofs')
      
      neofs.setup {
        mappings = {
          ["<c-e>w"] = function(fm)
            fm.path = vim.fn.expand("~/Desktop/workspace")
            fm.refresh()
          end
        }
      }
      
      
      local neofs = require('neofs')
      
      neofs.setup {
        devicons = true
      }
      
      
      vim.keymap.set("n", "<leader>fs", function()
        require("neofs").open()
      end, {noremap = true})
      
    end,
  },
  {
    "kevinhwang91/rnvimr",
  },
  {
    "Xuyuanp/yanil",
  },
  {
    "ms-jpq/chadtree",
  },
  {
    "is0n/fm-nvim",
    config = function()
      
        use {'is0n/fm-nvim'}
        
      
      require('fm-nvim').setup{
      	-- (Vim) Command used to open files
      	edit_cmd = "edit",
      
      	-- See `Q&A` for more info
      	on_close = {},
      	on_open = {},
      
      	-- UI Options
      	ui = {
      		-- Default UI (can be "split" or "float")
      		default = "float",
      
      		float = {
      			-- Floating window border (see ':h nvim_open_win')
      			border    = "none",
      
      			-- Highlight group for floating window/border (see ':h winhl')
      			float_hl  = "Normal",
      			border_hl = "FloatBorder",
      
      			-- Floating Window Transparency (see ':h winblend')
      			blend     = 0,
      
      			-- Num from 0 - 1 for measurements
      			height    = 0.8,
      			width     = 0.8,
      
      			-- X and Y Axis of Window
      			x         = 0.5,
      			y         = 0.5
      		},
      
      		split = {
      			-- Direction of split
      			direction = "topleft",
      
      			-- Size of split
      			size      = 24
      		}
      	},
      
      	-- Terminal commands used w/ file manager (have to be in your $PATH)
      	cmds = {
      		lf_cmd      = "lf", -- eg: lf_cmd = "lf -command 'set hidden'"
      		fm_cmd      = "fm",
      		nnn_cmd     = "nnn",
      		fff_cmd     = "fff",
      		twf_cmd     = "twf",
      		fzf_cmd     = "fzf", -- eg: fzf_cmd = "fzf --preview 'bat --style=numbers --color=always --line-range :500 {}'"
      		fzy_cmd     = "find . | fzy",
      		xplr_cmd    = "xplr",
      		vifm_cmd    = "vifm",
      		skim_cmd    = "sk",
      		broot_cmd   = "broot",
      		gitui_cmd   = "gitui",
      		ranger_cmd  = "ranger",
      		joshuto_cmd = "joshuto",
      		lazygit_cmd = "lazygit",
      		neomutt_cmd = "neomutt",
              taskwarrior_cmd = "taskwarrior-tui"
      	},
      
      	-- Mappings used with the plugin
      	mappings = {
      		vert_split = "<C-v>",
      		horz_split = "<C-h>",
      		tabedit    = "<C-t>",
      		edit       = "<C-e>",
      		ESC        = "<ESC>"
      	},
      
      	-- Path to broot config
      	broot_conf = vim.fn.stdpath("data") .. "/site/pack/packer/start/fm-nvim/assets/broot_conf.hjson"
      }
      
      
      local function yourFunction()
      	-- Your code goes here
      end
      
      require('fm-nvim').setup{
      	-- Runs yourFunction() upon exiting the floating window (can only be a function)
      	on_close = { yourFunction },
      
      	-- Runs yourFunction() upon opening the floating window (can only be a function)
      	on_open = { yourFunction }
      }
      
      
      require('fm-nvim').setup{
      	mappings = {
      		-- Example for Vifm
      		ESC        = ":q<CR>"
      	}
      }
      
    end,
  },
  {
    "Rolv-Apneseth/tfm.nvim",
    config = function()
      
      {
          "rolv-apneseth/tfm.nvim",
          config = function()
              -- Set keymap so you can open the default terminal file manager (yazi)
              vim.api.nvim_set_keymap("n", "<leader>e", "", {
                  noremap = true,
                  callback = require("tfm").open,
              })
          end,
      }
      
      
      {
          "rolv-apneseth/tfm.nvim",
          lazy = false,
          opts = {
              -- TFM to use
              -- Possible choices: "ranger" | "nnn" | "lf" | "vifm" | "yazi" (default)
              file_manager = "yazi",
              -- Replace netrw entirely
              -- Default: false
              replace_netrw = true,
              -- Enable creation of commands
              -- Default: false
              -- Commands:
              --   Tfm: selected file(s) will be opened in the current window
              --   TfmSplit: selected file(s) will be opened in a horizontal split
              --   TfmVsplit: selected file(s) will be opened in a vertical split
              --   TfmTabedit: selected file(s) will be opened in a new tab page
              enable_cmds = false, 
              -- Custom keybindings only applied within the TFM buffer
              -- Default: {}
              keybindings = {
                  ["<ESC>"] = "q",
                  -- Override the open mode (i.e. vertical/horizontal split, new tab)
                  -- Tip: you can add an extra `<CR>` to the end of these to immediately open the selected file(s) (assuming the TFM uses `enter` to finalise selection)
                  ["<C-v>"] = "<C-\\><C-O>:lua require('tfm').set_next_open_mode(require('tfm').OPEN_MODE.vsplit)<CR>",
                  ["<C-x>"] = "<C-\\><C-O>:lua require('tfm').set_next_open_mode(require('tfm').OPEN_MODE.split)<CR>",
                  ["<C-t>"] = "<C-\\><C-O>:lua require('tfm').set_next_open_mode(require('tfm').OPEN_MODE.tabedit)<CR>",
              },
              -- Customise UI. The below options are the default
              ui = {
                  border = "rounded",
                  height = 1,
                  width = 1,
                  x = 0.5,
                  y = 0.5,
              },
          },
          keys = {
              -- Make sure to change these keybindings to your preference,
              -- and remove the ones you won't use
              {
                  "<leader>e",
                  ":Tfm<CR>",
                  desc = "TFM",
              },
              {
                  "<leader>mh",
                  ":TfmSplit<CR>",
                  desc = "TFM - horizontal split",
              },
              {
                  "<leader>mv",
                  ":TfmVsplit<CR>",
                  desc = "TFM - vertical split",
              },
              {
                  "<leader>mt",
                  ":TfmTabedit<CR>",
                  desc = "TFM - new tab",
              },
          },
      }
      
      
          keys = {
              {
                  "<leader>e",
                  function()
                      require("tfm").open()
                  end,
                  desc = "TFM",
              },
              {
                  "<leader>mh",
                  function()
                      local tfm = require("tfm")
                      tfm.open(nil, tfm.OPEN_MODE.split)
                  end,
                  desc = "TFM - horizontal split",
              },
              {
                  "<leader>mv",
                  function()
                      local tfm = require("tfm")
                      tfm.open(nil, tfm.OPEN_MODE.vsplit)
                  end,
                  desc = "TFM - vertical split",
              },
              {
                  "<leader>mt",
                  function()
                      local tfm = require("tfm")
                      tfm.open(nil, tfm.OPEN_MODE.tabedit)
                  end,
                  desc = "TFM - new tab",
              },
          },
      
      
      {
          "<leader>mc",
          function()
              require("tfm").select_file_manager(vim.fn.input("Change file manager: "))
          end,
          desc = "TFM - change selected file manager",
      },
      
    end,
  },
  {
    "nvim-neo-tree/neo-tree.nvim",
    config = function()
      
      local add = MiniDeps.add
      
      add({
        source = 'nvim-neo-tree/neo-tree.nvim',
        checkout = 'v3.x',
        depends = {
          "nvim-lua/plenary.nvim",
          "MunifTanjim/nui.nvim",
          "nvim-tree/nvim-web-devicons", -- optional, but recommended
        }
      })
      
      
      return {
        {
          "nvim-neo-tree/neo-tree.nvim",
          branch = "v3.x",
          dependencies = {
            "nvim-lua/plenary.nvim",
            "MunifTanjim/nui.nvim",
            "nvim-tree/nvim-web-devicons", -- optional, but recommended
          },
          lazy = false, -- neo-tree will lazily load itself
        }
      }
      
      
      return {
        {
          "nvim-neo-tree/neo-tree.nvim",
          branch = "v3.x",
          dependencies = {
            "nvim-lua/plenary.nvim",
            "MunifTanjim/nui.nvim",
            "nvim-tree/nvim-web-devicons",
          },
        },
        {
          "antosha417/nvim-lsp-file-operations",
          dependencies = {
            "nvim-lua/plenary.nvim",
            "nvim-neo-tree/neo-tree.nvim", -- makes sure that this loads after Neo-tree.
          },
          config = function()
            require("lsp-file-operations").setup()
          end,
        },
        {
          "s1n7ax/nvim-window-picker",
          version = "2.*",
          config = function()
            require("window-picker").setup({
              filter_rules = {
                include_current_win = false,
                autoselect_one = true,
                -- filter using buffer options
                bo = {
                  -- if the file type is one of following, the window will be ignored
                  filetype = { "neo-tree", "neo-tree-popup", "notify" },
                  -- if the buffer type is one of following, the window will be ignored
                  buftype = { "terminal", "quickfix" },
                },
              },
            })
          end,
        },
      }
      
      
      use({
        "nvim-neo-tree/neo-tree.nvim",
        branch = "v3.x",
        requires = {
          "nvim-lua/plenary.nvim",
          "MunifTanjim/nui.nvim",
          "nvim-tree/nvim-web-devicons", -- optional, but recommended
        }
      })
      
      
      vim.pack.add({
        {
          src = 'https://github.com/nvim-neo-tree/neo-tree.nvim',
          version = vim.version.range('3')
        },
        -- dependencies
        "nvim-lua/plenary.nvim",
        "MunifTanjim/nui.nvim",
        -- optional, but recommended
        "nvim-tree/nvim-web-devicons",
      })
      
      
      require('neo-tree').setup({
        -- options go here
      })
      
      
      return {
        "nvim-neo-tree/neo-tree.nvim",
        branch = "v3.x",
        dependencies = {
          "nvim-lua/plenary.nvim",
          "MunifTanjim/nui.nvim",
          "nvim-tree/nvim-web-devicons", -- optional, but recommended
        },
        lazy = false, -- neo-tree will lazily load itself
        ---@module 'neo-tree'
        ---@type neotree.Config
        opts = {
          -- options go here
        }
      }
      
      
      vim.keymap.set("n", "<leader>e", "<Cmd>Neotree<CR>")
      require("neo-tree").setup({
        close_if_last_window = false, -- Close Neo-tree if it is the last window left in the tab
        popup_border_style = "NC", -- or "" to use 'winborder' on Neovim v0.11+
        enable_git_status = true,
        enable_diagnostics = true,
        open_files_do_not_replace_types = { "terminal", "trouble", "qf" }, -- when opening files, do not use windows containing these filetypes or buftypes
        open_files_using_relative_paths = false,
        sort_case_insensitive = false, -- used when sorting files and directories in the tree
        sort_function = nil, -- use a custom function for sorting files and directories in the tree
        -- sort_function = function (a,b)
        --       if a.type == b.type then
        --           return a.path > b.path
        --       else
        --           return a.type > b.type
        --       end
        --   end , -- this sorts files and directories descendantly
        default_component_configs = {
          container = {
            enable_character_fade = true,
          },
          indent = {
            indent_size = 2,
            padding = 1, -- extra padding on left hand side
            -- indent guides
            with_markers = true,
            indent_marker = "│",
            last_indent_marker = "└",
            highlight = "NeoTreeIndentMarker",
            -- expander config, needed for nesting files
            with_expanders = nil, -- if nil and file nesting is enabled, will enable expanders
            expander_collapsed = "",
            expander_expanded = "",
            expander_highlight = "NeoTreeExpander",
          },
          icon = {
            folder_closed = "",
            folder_open = "",
            folder_empty = "󰜌",
            provider = function(icon, node, state) -- default icon provider utilizes nvim-web-devicons if available
              if node.type == "file" or node.type == "terminal" then
                local success, web_devicons = pcall(require, "nvim-web-devicons")
                local name = node.type == "terminal" and "terminal" or node.name
                if success then
                  local devicon, hl = web_devicons.get_icon(name)
                  icon.text = devicon or icon.text
                  icon.highlight = hl or icon.highlight
                end
              end
            end,
            -- The next two settings are only a fallback, if you use nvim-web-devicons and configure default icons there
            -- then these will never be used.
            default = "*",
            highlight = "NeoTreeFileIcon",
          },
          modified = {
            symbol = "[+]",
            highlight = "NeoTreeModified",
          },
          name = {
            trailing_slash = false,
            use_git_status_colors = true,
            highlight = "NeoTreeFileName",
          },
          git_status = {
            symbols = {
              -- Change type
              added = "", -- or "✚"
              modified = "", -- or ""
              deleted = "✖", -- this can only be used in the git_status source
              renamed = "󰁕", -- this can only be used in the git_status source
              -- Status type
              untracked = "",
              ignored = "",
              unstaged = "󰄱",
              staged = "",
              conflict = "",
            },
          },
          -- If you don't want to use these columns, you can set `enabled = false` for each of them individually
          file_size = {
            enabled = true,
            width = 12, -- width of the column
            required_width = 64, -- min width of window required to show this column
          },
          type = {
            enabled = true,
            width = 10, -- width of the column
            required_width = 122, -- min width of window required to show this column
          },
          last_modified = {
            enabled = true,
            width = 20, -- width of the column
            required_width = 88, -- min width of window required to show this column
          },
          created = {
            enabled = true,
            width = 20, -- width of the column
            required_width = 110, -- min width of window required to show this column
          },
          symlink_target = {
            enabled = false,
          },
        },
        -- A list of functions, each representing a global custom command
        -- that will be available in all sources (if not overridden in `opts[source_name].commands`)
        -- see `:h neo-tree-custom-commands-global`
        commands = {},
        window = {
          position = "left",
          width = 40,
          mapping_options = {
            noremap = true,
            nowait = true,
          },
          mappings = {
            ["<space>"] = {
              "toggle_node",
              nowait = false, -- disable `nowait` if you have existing combos starting with this char that you want to use
            },
            ["<2-LeftMouse>"] = "open",
            ["<cr>"] = "open",
            ["<esc>"] = "cancel", -- close preview or floating neo-tree window
            ["P"] = {
              "toggle_preview",
              config = {
                use_float = true,
                use_snacks_image = true,
                use_image_nvim = true,
              },
            },
            -- Read `# Preview Mode` for more information
            ["l"] = "focus_preview",
            ["S"] = "open_split",
            ["s"] = "open_vsplit",
            -- ["S"] = "split_with_window_picker",
            -- ["s"] = "vsplit_with_window_picker",
            ["t"] = "open_tabnew",
            -- ["<cr>"] = "open_drop",
            -- ["t"] = "open_tab_drop",
            ["w"] = "open_with_window_picker",
            --["P"] = "toggle_preview", -- enter preview mode, which shows the current node without focusing
            ["C"] = "close_node",
            -- ['C'] = 'close_all_subnodes',
            ["z"] = "close_all_nodes",
            --["Z"] = "expand_all_nodes",
            --["Z"] = "expand_all_subnodes",
            ["a"] = {
              "add",
              -- this command supports BASH style brace expansion ("x{a,b,c}" -> xa,xb,xc). see `:h neo-tree-file-actions` for details
              -- some commands may take optional config options, see `:h neo-tree-mappings` for details
              config = {
                show_path = "none", -- "none", "relative", "absolute"
              },
            },
            ["A"] = "add_directory", -- also accepts the optional config.show_path option like "add". this also supports BASH style brace expansion.
            ["d"] = "delete",
            ["r"] = "rename",
            ["b"] = "rename_basename",
            ["y"] = "copy_to_clipboard",
            ["x"] = "cut_to_clipboard",
            ["p"] = "paste_from_clipboard",
            ["c"] = "copy", -- takes text input for destination, also accepts the optional config.show_path option like "add":
            -- ["c"] = {
            --  "copy",
            --  config = {
            --    show_path = "none" -- "none", "relative", "absolute"
            --  }
            --}
            ["m"] = "move", -- takes text input for destination, also accepts the optional config.show_path option like "add".
            ["q"] = "close_window",
            ["R"] = "refresh",
            ["?"] = "show_help",
            ["<"] = "prev_source",
            [">"] = "next_source",
            ["i"] = "show_file_details",
            -- ["i"] = {
            --   "show_file_details",
            --   -- format strings of the timestamps shown for date created and last modified (see `:h os.date()`)
            --   -- both options accept a string or a function that takes in the date in seconds and returns a string to display
            --   -- config = {
            --   --   created_format = "%Y-%m-%d %I:%M %p",
            --   --   modified_format = "relative", -- equivalent to the line below
            --   --   modified_format = function(seconds) return require('neo-tree.utils').relative_date(seconds) end
            --   -- }
            -- },
          },
        },
        nesting_rules = {},
        filesystem = {
          filtered_items = {
            visible = false, -- when true, they will just be displayed differently than normal items
            hide_dotfiles = true,
            hide_gitignored = true,
            hide_ignored = true, -- hide files that are ignored by other gitignore-like files
            -- other gitignore-like files, in descending order of precedence.
            ignore_files = {
              ".neotreeignore",
              ".ignore",
              -- ".rgignore"
            },
            hide_hidden = true, -- only works on Windows for hidden files/directories
            hide_by_name = {
              --"node_modules"
            },
            hide_by_pattern = { -- uses glob style patterns
              --"*.meta",
              --"*/src/*/tsconfig.json",
            },
            always_show = { -- remains visible even if other settings would normally hide it
              --".gitignored",
            },
            always_show_by_pattern = { -- uses glob style patterns
              --".env*",
            },
            never_show = { -- remains hidden even if visible is toggled to true, this overrides always_show
              --".DS_Store",
              --"thumbs.db"
            },
            never_show_by_pattern = { -- uses glob style patterns
              --".null-ls_*",
            },
          },
          follow_current_file = {
            enabled = false, -- This will find and focus the file in the active buffer every time
            --               -- the current file is changed while the tree is open.
            leave_dirs_open = false, -- `false` closes auto expanded dirs, such as with `:Neotree reveal`
          },
          group_empty_dirs = false, -- when true, empty folders will be grouped together
          hijack_netrw_behavior = "open_default", -- netrw disabled, opening a directory opens neo-tree
          -- in whatever position is specified in window.position
          -- "open_current",  -- netrw disabled, opening a directory opens within the
          -- window like netrw would, regardless of window.position
          -- "disabled",    -- netrw left alone, neo-tree does not handle opening dirs
          use_libuv_file_watcher = false, -- This will use the OS level file watchers to detect changes
          -- instead of relying on nvim autocmd events.
          window = {
            mappings = {
              ["<bs>"] = "navigate_up",
              ["."] = "set_root",
              ["H"] = "toggle_hidden",
              ["/"] = "fuzzy_finder",
              ["D"] = "fuzzy_finder_directory",
              ["#"] = "fuzzy_sorter", -- fuzzy sorting using the fzy algorithm
              -- ["D"] = "fuzzy_sorter_directory",
              ["f"] = "filter_on_submit",
              ["<c-x>"] = "clear_filter",
              ["[g"] = "prev_git_modified",
              ["]g"] = "next_git_modified",
              ["o"] = {
                "show_help",
                nowait = false,
                config = { title = "Order by", prefix_key = "o" },
              },
              ["oc"] = { "order_by_created", nowait = false },
              ["od"] = { "order_by_diagnostics", nowait = false },
              ["og"] = { "order_by_git_status", nowait = false },
              ["om"] = { "order_by_modified", nowait = false },
              ["on"] = { "order_by_name", nowait = false },
              ["os"] = { "order_by_size", nowait = false },
              ["ot"] = { "order_by_type", nowait = false },
              -- ['<key>'] = function(state) ... end,
            },
            fuzzy_finder_mappings = { -- define keymaps for filter popup window in fuzzy_finder_mode
              ["<down>"] = "move_cursor_down",
              ["<C-n>"] = "move_cursor_down",
              ["<up>"] = "move_cursor_up",
              ["<C-p>"] = "move_cursor_up",
              ["<esc>"] = "close",
              ["<S-CR>"] = "close_keep_filter",
              ["<C-CR>"] = "close_clear_filter",
              ["<C-w>"] = { "<C-S-w>", raw = true },
              {
                -- normal mode mappings
                n = {
                  ["j"] = "move_cursor_down",
                  ["k"] = "move_cursor_up",
                  ["<S-CR>"] = "close_keep_filter",
                  ["<C-CR>"] = "close_clear_filter",
                  ["<esc>"] = "close",
                }
              }
              -- ["<esc>"] = "noop", -- if you want to use normal mode
              -- ["key"] = function(state, scroll_padding) ... end,
            },
          },
      
          commands = {}, -- Add a custom command or override a global one using the same function name
        },
        buffers = {
          follow_current_file = {
            enabled = true, -- This will find and focus the file in the active buffer every time
            --              -- the current file is changed while the tree is open.
            leave_dirs_open = false, -- `false` closes auto expanded dirs, such as with `:Neotree reveal`
          },
          group_empty_dirs = true, -- when true, empty folders will be grouped together
          show_unloaded = true,
          window = {
            mappings = {
              ["d"] = "buffer_delete",
              ["bd"] = "buffer_delete",
              ["<bs>"] = "navigate_up",
              ["."] = "set_root",
              ["o"] = {
                "show_help",
                nowait = false,
                config = { title = "Order by", prefix_key = "o" },
              },
              ["oc"] = { "order_by_created", nowait = false },
              ["od"] = { "order_by_diagnostics", nowait = false },
              ["om"] = { "order_by_modified", nowait = false },
              ["on"] = { "order_by_name", nowait = false },
              ["os"] = { "order_by_size", nowait = false },
              ["ot"] = { "order_by_type", nowait = false },
            },
          },
        },
        git_status = {
          window = {
            position = "float",
            mappings = {
              ["A"] = "git_add_all",
              ["gu"] = "git_unstage_file",
              ["gU"] = "git_undo_last_commit",
              ["ga"] = "git_add_file",
              ["gr"] = "git_revert_file",
              ["gc"] = "git_commit",
              ["gp"] = "git_push",
              ["gg"] = "git_commit_and_push",
              ["o"] = {
                "show_help",
                nowait = false,
                config = { title = "Order by", prefix_key = "o" },
              },
              ["oc"] = { "order_by_created", nowait = false },
              ["od"] = { "order_by_diagnostics", nowait = false },
              ["om"] = { "order_by_modified", nowait = false },
              ["on"] = { "order_by_name", nowait = false },
              ["os"] = { "order_by_size", nowait = false },
              ["ot"] = { "order_by_type", nowait = false },
            },
          },
        },
      })
      
      
      vim.diagnostic.config({
        signs = {
          text = {
            [vim.diagnostic.severity.ERROR] = '',
            [vim.diagnostic.severity.WARN] = '',
            [vim.diagnostic.severity.INFO] = '',
            [vim.diagnostic.severity.HINT] = '󰌵',
          },
        }
      })
      
      
      vim.fn.sign_define("DiagnosticSignError", { text = " ", texthl = "DiagnosticSignError" })
      vim.fn.sign_define("DiagnosticSignWarn", { text = " ", texthl = "DiagnosticSignWarn" })
      vim.fn.sign_define("DiagnosticSignInfo", { text = " ", texthl = "DiagnosticSignInfo" })
      vim.fn.sign_define("DiagnosticSignHint", { text = "󰌵", texthl = "DiagnosticSignHint" })
      
      
          require("neo-tree").setup({
              source_selector = {
                  winbar = false,
                  statusline = false
              }
          })
      
      
      require("neo-tree").setup({
        window = {
          mappings = {
            ["P"] = {
              "toggle_preview",
              config = {
                use_float = false,
                -- use_image_nvim = true,
                -- use_snacks_image = true,
                -- title = 'Neo-tree Preview',
              },
            },
          }
        }
      })
      
    end,
  },
  {
    "elihunter173/dirbuf.nvim",
    config = function()
      
      require("nvim-tree").setup {
          update_to_buf_dir = { enable = false }
      }
      
      
      require("dirbuf").setup {
          hash_padding = 2,
          show_hidden = true,
          sort_order = "default",
          write_cmd = "DirbufSync",
      }
      
    end,
  },
  {
    "TheBlob42/drex.nvim",
    config = function()
      
      use {
        'theblob42/drex.nvim',
        requires = 'kyazdani42/nvim-web-devicons', -- optional
      }
      
      
      require('drex.config').configure {
          icons = {
              file_default = "",
              dir_open = "",
              dir_closed = "",
              link = "",
              others = "",
          },
          colored_icons = true,
          hide_cursor = true,
          hijack_netrw = false,
          keepalt = false,
          sorting = function(a, b)
              local aname, atype = a[1], a[2]
              local bname, btype = b[1], b[2]
      
              local aisdir = atype == 'directory'
              local bisdir = btype == 'directory'
      
              if aisdir ~= bisdir then
                  return aisdir
              end
      
              return aname < bname
          end,
          drawer = {
              side = 'left',
              default_width = 30,
              window_picker = {
                  enabled = true,
                  labels = 'abcdefghijklmnopqrstuvwxyz',
              },
          },
          actions = {
            files = {
              delete_cmd = nil,
            },
          },
          disable_default_keybindings = false,
          keybindings = {
              ['n'] = {
                  ['v'] = 'V',
                  ['l'] = { '<cmd>lua require("drex.elements").expand_element()<CR>', { desc = 'expand element' }},
                  ['h'] = { '<cmd>lua require("drex.elements").collapse_directory()<CR>', { desc = 'collapse directory' }},
                  ['<right>'] = { '<cmd>lua require("drex.elements").expand_element()<CR>', { desc = 'expand element' }},
                  ['<left>']  = { '<cmd>lua require("drex.elements").collapse_directory()<CR>', { desc = 'collapse directory'}},
                  ['<2-LeftMouse>'] = { '<LeftMouse><cmd>lua require("drex.elements").expand_element()<CR>', { desc = 'expand element' }},
                  ['<RightMouse>']  = { '<LeftMouse><cmd>lua require("drex.elements").collapse_directory()<CR>', { desc = 'collapse directory' }},
                  ['<C-v>'] = { '<cmd>lua require("drex.elements").open_file("vs")<CR>', { desc = 'open file in vsplit' }},
                  ['<C-x>'] = { '<cmd>lua require("drex.elements").open_file("sp")<CR>', { desc = 'open file in split' }},
                  ['<C-t>'] = { '<cmd>lua require("drex.elements").open_file("tabnew", true)<CR>', { desc = 'open file in new tab' }},
                  ['<C-l>'] = { '<cmd>lua require("drex.elements").open_directory()<CR>', { desc = 'open directory in new buffer' }},
                  ['<C-h>'] = { '<cmd>lua require("drex.elements").open_parent_directory()<CR>', { desc = 'open parent directory in new buffer' }},
                  ['<F5>'] = { '<cmd>lua require("drex").reload_directory()<CR>', { desc = 'reload' }},
                  ['gj'] = { '<cmd>lua require("drex.actions.jump").jump_to_next_sibling()<CR>', { desc = 'jump to next sibling' }},
                  ['gk'] = { '<cmd>lua require("drex.actions.jump").jump_to_prev_sibling()<CR>', { desc = 'jump to prev sibling' }},
                  ['gh'] = { '<cmd>lua require("drex.actions.jump").jump_to_parent()<CR>', { desc = 'jump to parent element' }},
                  ['s'] = { '<cmd>lua require("drex.actions.stats").stats()<CR>', { desc = 'show element stats' }},
                  ['a'] = { '<cmd>lua require("drex.actions.files").create()<CR>', { desc = 'create element' }},
                  ['d'] = { '<cmd>lua require("drex.actions.files").delete("line")<CR>', { desc = 'delete element' }},
                  ['D'] = { '<cmd>lua require("drex.actions.files").delete("clipboard")<CR>', { desc = 'delete (clipboard)' }},
                  ['p'] = { '<cmd>lua require("drex.actions.files").copy_and_paste()<CR>', { desc = 'copy & paste (clipboard)' }},
                  ['P'] = { '<cmd>lua require("drex.actions.files").cut_and_move()<CR>', { desc = 'cut & move (clipboard)' }},
                  ['r'] = { '<cmd>lua require("drex.actions.files").rename()<CR>', { desc = 'rename element' }},
                  ['R'] = { '<cmd>lua require("drex.actions.files").multi_rename("clipboard")<CR>', { desc = 'rename (clipboard)' }},
                  ['/'] = { '<cmd>keepalt lua require("drex.actions.search").search()<CR>', { desc = 'search' }},
                  ['M'] = { '<cmd>DrexMark<CR>', { desc = 'mark element' }},
                  ['u'] = { '<cmd>DrexUnmark<CR>', { desc = 'unmark element' }},
                  ['m'] = { '<cmd>DrexToggle<CR>', { desc = 'toggle element' }},
                  ['cc'] = { '<cmd>lua require("drex.clipboard").clear_clipboard()<CR>', { desc = 'clear clipboard' }},
                  ['cs'] = { '<cmd>lua require("drex.clipboard").open_clipboard_window()<CR>', { desc = 'edit clipboard' }},
                  ['y'] = { '<cmd>lua require("drex.actions.text").copy_name()<CR>', { desc = 'copy element name' }},
                  ['Y'] = { '<cmd>lua require("drex.actions.text").copy_relative_path()<CR>', { desc = 'copy element relative path' }},
                  ['<C-y>'] = { '<cmd>lua require("drex.actions.text").copy_absolute_path()<CR>', { desc = 'copy element absolute path' }},
              },
              ['v'] = {
                  ['d'] = { ':lua require("drex.actions.files").delete("visual")<CR>', { desc = 'delete elements' }},
                  ['r'] = { ':lua require("drex.actions.files").multi_rename("visual")<CR>', { desc = 'rename elements' }},
                  ['M'] = { ':DrexMark<CR>', { desc = 'mark elements' }},
                  ['u'] = { ':DrexUnmark<CR>', { desc = 'unmark elements' }},
                  ['m'] = { ':DrexToggle<CR>', { desc = 'toggle elements' }},
                  ['y'] = { ':lua require("drex.actions.text").copy_name(true)<CR>', { desc = 'copy element names' }},
                  ['Y'] = { ':lua require("drex.actions.text").copy_relative_path(true)<CR>', { desc = 'copy element relative paths' }},
                  ['<C-y>'] = { ':lua require("drex.actions.text").copy_absolute_path(true)<CR>', { desc = 'copy element absolute paths' }},
              }
          },
          on_enter = nil,
          on_leave = nil,
      }
      
    end,
  },
  {
    "SidOfc/carbon.nvim",
    config = function()
      
      require('carbon').setup()
      
      
      require('carbon').setup({ setting = 'value' })
      
      
      require('carbon').setup(function(settings)
        settings.setting = 'value'
      end)
      
    end,
  },
  {
    "dinhhuy258/sfm.nvim",
    config = function()
      
      use {
        'dinhhuy258/sfm.nvim',
        config = function()
          require("sfm").setup()
        end
      }
      
      
      local default_config = {
        view = {
          side = "left", -- side of the tree, can be `left`, `right`. this setting will be ignored if view.float.enable is set to true,
          width = 30, -- this setting will be ignored if view.float.enable is set to true,
          float = {
            enable = false,
            config = {
              relative = "editor",
              border = "rounded",
              width = 30, -- int or function
              height = 30, -- int or function
              row = 1, -- int or function
              col = 1 -- int or function
            }
          },
          selection_render_method = "icon" -- render method of selected entries, can be `icon`, `sign`, `highlight`.
        },
        mappings = {
          custom_only = false,
          list = {
            -- user mappings go here
          }
        },
        renderer = {
          icons = {
            file = {
              default = "",
              symlink = "",
            },
            folder = {
              default = "",
              open = "",
              symlink = "",
              symlink_open = "",
            },
            indicator = {
              folder_closed = "",
              folder_open = "",
              file = " ",
            },
            selection = "",
          }
        },
        file_nesting = {
          enabled = false,
          expand = false,
          patterns = {},
        },
        misc = {
          trash_cmd = nil,
          system_open_cmd = nil,
        }
      }
      
      
      require("sfm").setup {
      --- your customization configuration
      }
      
      
      require("sfm").setup({
        file_nesting = {
          enabled = true, -- controls whether file nesting is enabled
          expand = true, -- controls whether nested files are expanded by default
          patterns = {
            { "*.cs", { "$(capture).*.cs" } },
            { "*.ts", { "$(capture).js", "$(capture).d.ts.map", "$(capture).*.ts", "$(capture)_*.js", "$(capture)_*.ts" } },
            { "go.mod", { "go.sum" } },
          }, -- controls how files get nested
        }
      })
      
      
      local sfm_explorer = require("sfm").setup {
        mappings = {
          list = {
            {
              key = "c",
              action = function()
                print("Custom function executed")
              end,
            },
            {
              key = "x",
              action = "close",
            },
          },
        },
      }
      
      
      -- define a custom renderer that displays the entry size
      local function size_renderer(entry)
        local stat = vim.loop.fs_stat(entry.path)
        local size = stat.size
        local size_text = string.format("[%d bytes]", size)
      
        return {
          text = size_text,
          highlight = "SFMSize",
        }
      end
      
      local sfm_explorer = require("sfm").setup {}
      -- register the custom renderer
      sfm_explorer:register_renderer("custom", 100, size_renderer)
      
      
      local sfm_explorer = require("sfm").setup {}
      sfm_explorer:register_entry_filter("big_files", function(entry)
        local stat = vim.loop.fs_stat(entry.path)
        local size = stat.size
        if size > 1000000 then
          return false
        else
          return true
        end
      end)
      
      
      local sfm_explorer = require("sfm").setup {}
      sfm_explorer:set_entry_sort_method(function(entry1, entry2)
        return entry1.name < entry2.name
      end)
      
      
      local sfm_explorer = require("sfm").setup {}
      sfm_explorer:subscribe(event.ExplorerOpened, function(payload)
        local bufnr = payload["bufnr"]
        local options = {
          noremap = true,
          expr = false,
        }
      
        vim.api.nvim_buf_set_keymap(
          bufnr,
          "n",
          "m",
          "<CMD>lua require('sfm.extensions.sfm-bookmark').set_mark()<CR>",
          options
        )
        vim.api.nvim_buf_set_keymap(
          bufnr,
          "n",
          "`",
          "<CMD>lua require('sfm.extensions.sfm-bookmark').load_mark()<CR>",
          options
        )
      end)
      
      
      local api = require('sfm.api')
      -- use the `path.remove_trailing` function to remove trailing slashes from a file path
      local cleaned_path = api.path.remove_trailing('/path/to/file/')
      -- use the `debounce` function to debounce a function call
      api.debounce("debounce-context", 1000, function()
        -- your code
      end)
      
    end,
  },
  {
    "kiran94/s3edit.nvim",
    config = function()
      
      { 'kiran94/s3edit.nvim', config = true, cmd = "S3Edit"},
      
      
      require('s3edit').setup()
      
      
      require('s3edit').setup({
          exclude = { ".git", ".hoodie", ".parquet", ".zip" },
          autocommand_events = { "BufWritePost" },
      }
      
      
      require('s3edit').edit() -- or :S3Edit
      
    end,
  },
  {
    "stevearc/oil.nvim",
    config = function()
      
      {
        'stevearc/oil.nvim',
        ---@module 'oil'
        ---@type oil.SetupOpts
        opts = {},
        -- Optional dependencies
        dependencies = { { "nvim-mini/mini.icons", opts = {} } },
        -- dependencies = { "nvim-tree/nvim-web-devicons" }, -- use if you prefer nvim-web-devicons
        -- Lazy loading is not recommended because it is very tricky to make it work correctly in all situations.
        lazy = false,
      }
      
      
      require("packer").startup(function()
        use({
          "stevearc/oil.nvim",
          config = function()
            require("oil").setup()
          end,
        })
      end)
      
      
      require("paq")({
        { "stevearc/oil.nvim" },
      })
      
      
      require("oil").setup()
      
      
      vim.keymap.set("n", "-", "<CMD>Oil<CR>", { desc = "Open parent directory" })
      
      
      require("oil").setup({
        -- Oil will take over directory buffers (e.g. `vim .` or `:e src/`)
        -- Set to false if you want some other plugin (e.g. netrw) to open when you edit directories.
        default_file_explorer = true,
        -- Id is automatically added at the beginning, and name at the end
        -- See :help oil-columns
        columns = {
          "icon",
          -- "permissions",
          -- "size",
          -- "mtime",
        },
        -- Buffer-local options to use for oil buffers
        buf_options = {
          buflisted = false,
          bufhidden = "hide",
        },
        -- Window-local options to use for oil buffers
        win_options = {
          wrap = false,
          signcolumn = "no",
          cursorcolumn = false,
          foldcolumn = "0",
          spell = false,
          list = false,
          conceallevel = 3,
          concealcursor = "nvic",
        },
        -- Send deleted files to the trash instead of permanently deleting them (:help oil-trash)
        delete_to_trash = false,
        -- Skip the confirmation popup for simple operations (:help oil.skip_confirm_for_simple_edits)
        skip_confirm_for_simple_edits = false,
        -- Selecting a new/moved/renamed file or directory will prompt you to save changes first
        -- (:help prompt_save_on_select_new_entry)
        prompt_save_on_select_new_entry = true,
        -- Oil will automatically delete hidden buffers after this delay
        -- You can set the delay to false to disable cleanup entirely
        -- Note that the cleanup process only starts when none of the oil buffers are currently displayed
        cleanup_delay_ms = 2000,
        lsp_file_methods = {
          -- Enable or disable LSP file operations
          enabled = true,
          -- Time to wait for LSP file operations to complete before skipping
          timeout_ms = 1000,
          -- Set to true to autosave buffers that are updated with LSP willRenameFiles
          -- Set to "unmodified" to only save unmodified buffers
          autosave_changes = false,
        },
        -- Constrain the cursor to the editable parts of the oil buffer
        -- Set to `false` to disable, or "name" to keep it on the file names
        constrain_cursor = "editable",
        -- Set to true to watch the filesystem for changes and reload oil
        watch_for_changes = false,
        -- Keymaps in oil buffer. Can be any value that `vim.keymap.set` accepts OR a table of keymap
        -- options with a `callback` (e.g. { callback = function() ... end, desc = "", mode = "n" })
        -- Additionally, if it is a string that matches "actions.<name>",
        -- it will use the mapping at require("oil.actions").<name>
        -- Set to `false` to remove a keymap
        -- See :help oil-actions for a list of all available actions
        keymaps = {
          ["g?"] = { "actions.show_help", mode = "n" },
          ["<CR>"] = "actions.select",
          ["<C-s>"] = { "actions.select", opts = { vertical = true } },
          ["<C-h>"] = { "actions.select", opts = { horizontal = true } },
          ["<C-t>"] = { "actions.select", opts = { tab = true } },
          ["<C-p>"] = "actions.preview",
          ["<C-c>"] = { "actions.close", mode = "n" },
          ["<C-l>"] = "actions.refresh",
          ["-"] = { "actions.parent", mode = "n" },
          ["_"] = { "actions.open_cwd", mode = "n" },
          ["`"] = { "actions.cd", mode = "n" },
          ["~"] = { "actions.cd", opts = { scope = "tab" }, mode = "n" },
          ["gs"] = { "actions.change_sort", mode = "n" },
          ["gx"] = "actions.open_external",
          ["g."] = { "actions.toggle_hidden", mode = "n" },
          ["g\\"] = { "actions.toggle_trash", mode = "n" },
        },
        -- Set to false to disable all of the above keymaps
        use_default_keymaps = true,
        view_options = {
          -- Show files and directories that start with "."
          show_hidden = false,
          -- This function defines what is considered a "hidden" file
          is_hidden_file = function(name, bufnr)
            local m = name:match("^%.")
            return m ~= nil
          end,
          -- This function defines what will never be shown, even when `show_hidden` is set
          is_always_hidden = function(name, bufnr)
            return false
          end,
          -- Sort file names with numbers in a more intuitive order for humans.
          -- Can be "fast", true, or false. "fast" will turn it off for large directories.
          natural_order = "fast",
          -- Sort file and directory names case insensitive
          case_insensitive = false,
          sort = {
            -- sort order can be "asc" or "desc"
            -- see :help oil-columns to see which columns are sortable
            { "type", "asc" },
            { "name", "asc" },
          },
          -- Customize the highlight group for the file name
          highlight_filename = function(entry, is_hidden, is_link_target, is_link_orphan)
            return nil
          end,
        },
        -- Extra arguments to pass to SCP when moving/copying files over SSH
        extra_scp_args = {},
        -- EXPERIMENTAL support for performing file operations with git
        git = {
          -- Return true to automatically git add/mv/rm files
          add = function(path)
            return false
          end,
          mv = function(src_path, dest_path)
            return false
          end,
          rm = function(path)
            return false
          end,
        },
        -- Configuration for the floating window in oil.open_float
        float = {
          -- Padding around the floating window
          padding = 2,
          -- max_width and max_height can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
          max_width = 0,
          max_height = 0,
          border = "rounded",
          win_options = {
            winblend = 0,
          },
          -- optionally override the oil buffers window title with custom function: fun(winid: integer): string
          get_win_title = nil,
          -- preview_split: Split direction: "auto", "left", "right", "above", "below".
          preview_split = "auto",
          -- This is the config that will be passed to nvim_open_win.
          -- Change values here to customize the layout
          override = function(conf)
            return conf
          end,
        },
        -- Configuration for the file preview window
        preview_win = {
          -- Whether the preview window is automatically updated when the cursor is moved
          update_on_cursor_moved = true,
          -- How to open the preview window "load"|"scratch"|"fast_scratch"
          preview_method = "fast_scratch",
          -- A function that returns true to disable preview on a file e.g. to avoid lag
          disable_preview = function(filename)
            return false
          end,
          -- Window-local options to use for preview window buffers
          win_options = {},
        },
        -- Configuration for the floating action confirmation window
        confirmation = {
          -- Width dimensions can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
          -- min_width and max_width can be a single value or a list of mixed integer/float types.
          -- max_width = {100, 0.8} means "the lesser of 100 columns or 80% of total"
          max_width = 0.9,
          -- min_width = {40, 0.4} means "the greater of 40 columns or 40% of total"
          min_width = { 40, 0.4 },
          -- optionally define an integer/float for the exact width of the preview window
          width = nil,
          -- Height dimensions can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
          -- min_height and max_height can be a single value or a list of mixed integer/float types.
          -- max_height = {80, 0.9} means "the lesser of 80 columns or 90% of total"
          max_height = 0.9,
          -- min_height = {5, 0.1} means "the greater of 5 columns or 10% of total"
          min_height = { 5, 0.1 },
          -- optionally define an integer/float for the exact height of the preview window
          height = nil,
          border = "rounded",
          win_options = {
            winblend = 0,
          },
        },
        -- Configuration for the floating progress window
        progress = {
          max_width = 0.9,
          min_width = { 40, 0.4 },
          width = nil,
          max_height = { 10, 0.9 },
          min_height = { 5, 0.1 },
          height = nil,
          border = "rounded",
          minimized_border = "none",
          win_options = {
            winblend = 0,
          },
        },
        -- Configuration for the floating SSH window
        ssh = {
          border = "rounded",
        },
        -- Configuration for the floating keymaps help window
        keymaps_help = {
          border = "rounded",
        },
      })
      
    end,
  },
  {
    "kelly-lin/ranger.nvim",
    config = function()
      
      {
        "kelly-lin/ranger.nvim",
        config = function()
          require("ranger-nvim").setup({ replace_netrw = true })
          vim.api.nvim_set_keymap("n", "<leader>ef", "", {
            noremap = true,
            callback = function()
              require("ranger-nvim").open(true)
            end,
          })
        end,
      }
      
      
      local ranger_nvim = require("ranger-nvim")
      ranger_nvim.setup({
        enable_cmds = false,
        replace_netrw = false,
        keybinds = {
          ["ov"] = ranger_nvim.OPEN_MODE.vsplit,
          ["oh"] = ranger_nvim.OPEN_MODE.split,
          ["ot"] = ranger_nvim.OPEN_MODE.tabedit,
          ["or"] = ranger_nvim.OPEN_MODE.rifle,
        },
        ui = {
          border = "none",
          height = 1,
          width = 1,
          x = 0.5,
          y = 0.5,
        }
      })
      
      
      local ranger_nvim = require("ranger-nvim")
      ranger_nvim.setup({
        keybinds = {
          ["ov"] = ranger_nvim.OPEN_MODE.vsplit,
          ["oh"] = ranger_nvim.OPEN_MODE.split,
          ["ot"] = ranger_nvim.OPEN_MODE.tabedit,
          ["or"] = ranger_nvim.OPEN_MODE.rifle,
        },
      })
      
    end,
  },
  {
    "mikavilpas/yazi.nvim",
    config = function()
      
      ---@type LazySpec
      {
        "mikavilpas/yazi.nvim",
        version = "*", -- use the latest stable version
        event = "VeryLazy",
        dependencies = {
          { "nvim-lua/plenary.nvim", lazy = true },
        },
        keys = {
          -- 👇 in this section, choose your own keymappings!
          {
            "<leader>-",
            mode = { "n", "v" },
            "<cmd>Yazi<cr>",
            desc = "Open yazi at the current file",
          },
          {
            -- Open in the current working directory
            "<leader>cw",
            "<cmd>Yazi cwd<cr>",
            desc = "Open the file manager in nvim's working directory",
          },
          {
            "<c-up>",
            "<cmd>Yazi toggle<cr>",
            desc = "Resume the last yazi session",
          },
        },
        ---@type YaziConfig | {}
        opts = {
          -- if you want to open yazi instead of netrw, see below for more info
          open_for_directories = false,
          keymaps = {
            show_help = "<f1>",
          },
        },
        -- 👇 if you use `open_for_directories=true`, this is recommended
        init = function()
          -- mark netrw as loaded so it's not loaded at all.
          --
          -- More details: https://github.com/mikavilpas/yazi.nvim/issues/802
          vim.g.loaded_netrwPlugin = 1
        end,
      }
      
      
      -- (Obtain yazi.nvim and its dependencies using your preferred method first)
      --
      -- Next, map a key to open yazi.nvim
      vim.keymap.set("n", "<leader>-", function()
        require("yazi").yazi()
      end)
      
      
      return {
        -- ... other lazy.nvim configuration from above
      
        ---@type YaziConfig | {}
        opts = {
          -- Below is the default configuration. It is optional to set these values.
          -- You can customize the configuration for each yazi call by passing it to
          -- yazi() explicitly
      
          -- enable this if you want to open yazi instead of netrw.
          -- Note that if you enable this, you need to call yazi.setup() to
          -- initialize the plugin. lazy.nvim does this for you in certain cases.
          --
          -- If you are also using neotree, you may prefer not to bring it up when
          -- opening a directory:
          -- {
          --   "nvim-neo-tree/neo-tree.nvim",
          --   opts = {
          --     filesystem = {
          --       hijack_netrw_behavior = "disabled",
          --     },
          --   },
          -- }
          open_for_directories = false,
      
          -- open visible splits and quickfix items as yazi tabs for easy navigation
          -- https://github.com/mikavilpas/yazi.nvim/pull/359
          open_multiple_tabs = false,
      
          -- when yazi is closed with no file chosen, change the Neovim working
          -- directory to the directory that yazi was in before it was closed. Defaults
          -- to being off (`false`)
          change_neovim_cwd_on_close = false,
      
          highlight_groups = {
            -- See https://github.com/mikavilpas/yazi.nvim/pull/180
            hovered_buffer = nil,
            -- See https://github.com/mikavilpas/yazi.nvim/pull/351
            hovered_buffer_in_same_directory = nil,
          },
      
          -- the floating window scaling factor. 1 means 100%, 0.9 means 90%, etc.
          floating_window_scaling_factor = 0.9,
      
          -- the transparency of the yazi floating window (0-100). See :h winblend
          yazi_floating_window_winblend = 0,
      
          -- the type of border to use for the floating window. Can be many values,
          -- including 'none', 'rounded', 'single', 'double', 'shadow', etc. For
          -- more information, see :h nvim_open_win
          yazi_floating_window_border = "rounded",
      
          -- the zindex of the yazi floating window. Can be used to make the yazi
          -- window fullscreen. See `:h nvim_open_win()` for more information.
          yazi_floating_window_zindex = nil,
      
          -- the log level to use. Off by default, but can be used to diagnose
          -- issues. You can find the location of the log file by running
          -- `:checkhealth yazi` in Neovim. Also check out the "reproducing issues"
          -- section below
          log_level = vim.log.levels.OFF,
      
          -- what Neovim should do a when a file was opened (selected) in yazi.
          -- Defaults to simply opening the file.
          open_file_function = function(chosen_file, config, state) end,
      
          -- customize the keymaps that are active when yazi is open and focused. The
          -- defaults are listed below. Note that the keymaps simply hijack input and
          -- they are never sent to yazi, so only try to map keys that are never
          -- needed by yazi.
          --
          -- Also:
          -- - use e.g. `open_file_in_tab = false` to disable a keymap
          -- - you can customize only some of the keymaps (not all of them)
          -- - you can opt out of all keymaps by setting `keymaps = false`
          keymaps = {
            show_help = "<f1>",
            open_file_in_vertical_split = "<c-v>",
            open_file_in_horizontal_split = "<c-x>",
            open_file_in_tab = "<c-t>",
            grep_in_directory = "<c-s>",
            replace_in_directory = "<c-g>",
            cycle_open_buffers = "<tab>",
            copy_relative_path_to_selected_files = "<c-y>",
            send_to_quickfix_list = "<c-q>",
            change_working_directory = "<c-\\>",
            open_and_pick_window = "<c-o>",
          },
      
          -- completely override the keymappings for yazi. This function will be
          -- called in the context of the yazi terminal buffer.
          set_keymappings_function = function(yazi_buffer_id, config, context) end,
      
          -- some yazi.nvim commands copy text to the clipboard. This is the register
          -- yazi.nvim should use for copying. Defaults to "*", the system clipboard
          clipboard_register = "*",
      
          hooks = {
            -- if you want to execute a custom action when yazi has been opened,
            -- you can define it here.
            yazi_opened = function(preselected_path, yazi_buffer_id, config)
              -- you can optionally modify the config for this specific yazi
              -- invocation if you want to customize the behaviour
            end,
      
            -- when yazi was successfully closed
            yazi_closed_successfully = function(chosen_file, config, state) end,
      
            -- when yazi opened multiple files. The default is to send them to the
            -- quickfix list, but if you want to change that, you can define it here
            yazi_opened_multiple_files = function(chosen_files, config, state) end,
      
            -- This function is called when yazi is ready to process events.
            on_yazi_ready = function(buffer, config, process_api) end,
          },
      
          -- highlight buffers in the same directory as the hovered buffer
          highlight_hovered_buffers_in_same_directory = true,
      
          integrations = {
            --- What should be done when the user wants to grep in a directory
            grep_in_directory = function(directory)
              -- the default implementation uses telescope if available, otherwise nothing
            end,
      
            grep_in_selected_files = function(selected_files)
              -- similar to grep_in_directory, but for selected files
            end,
      
            --- Similarly, search and replace in the files in the directory
            replace_in_directory = function(directory)
              -- default: grug-far.nvim
            end,
      
            replace_in_selected_files = function(selected_files)
              -- default: grug-far.nvim
            end,
      
            -- `grealpath` on OSX, (GNU) `realpath` otherwise
            resolve_relative_path_application = "",
      
            -- the way to resolve relative paths. The default_implementation can be
            -- customized with a function. See
            -- documentation/copy-relative-path-to-files.md for more information.
            resolve_relative_path_implementation = function(args, get_relative_path)
            end,
      
            -- how to delete (close) a buffer. Defaults to a bundled version of
            -- `snacks.bufdelete`, copied from https://github.com/folke/snacks.nvim,
            -- which maintains the window layout. See the `types.lua` file for more
            -- information for the available options.
            bufdelete_implementation = "bundled-snacks",
      
            -- add an action to a file picker to copy the relative path to the
            -- selected file(s). The implementation is the same as for the
            -- `copy_relative_path_to_selected_files` yazi.nvim keymap. Currently
            -- only snacks.nvim is supported. Documentation can be found in the
            -- keybindings section of the readme.
            --
            -- available options:
            -- - nil (default, no action added)
            -- - "snacks.picker" (snacks.nvim)
            picker_add_copy_relative_path_action = nil,
          },
      
          future_features = {
            -- use a file to store the last directory that yazi was in before it was
            -- closed. Defaults to `true`.
            use_cwd_file = true,
      
            -- use a new shell escaping implementation that is more robust and works
            -- on more platforms. Defaults to `true`. If set to `false`, the old
            -- shell escaping implementation will be used, which is less robust and
            -- may not work on all platforms.
            new_shell_escaping = true,
          },
        },
      }
      
    end,
  },
  {
    "simonmclean/triptych.nvim",
    config = function()
      
      {
        'simonmclean/triptych.nvim',
        dependencies = {
          'nvim-lua/plenary.nvim', -- required
          'nvim-tree/nvim-web-devicons', -- optional for icons
          'antosha417/nvim-lsp-file-operations' -- optional LSP integration
        },
        opts = {}, -- config options here
        keys = {
          { '<leader>-', ':Triptych<CR>' },
        },
      }
      
      
      -- Manual setup
      require('triptych').setup()
      vim.keymap.set('n', '<leader>-', ':Triptych<CR>', { silent = true, desc = 'Toggle Triptych' })
      
      
      {
        mappings = {
          -- Everything below is buffer-local, meaning it will only apply to Triptych windows
          show_help = 'g?',
          jump_to_cwd = '.',  -- Pressing again will toggle back
          nav_left = 'h',
          nav_right = { 'l', '<CR>' }, -- If target is a file, opens the file in-place
          open_hsplit = { '-' },
          open_vsplit = { '|' },
          open_tab = { '<C-t>' },
          cd = '<leader>cd',
          delete = 'd',
          add = 'a',
          copy = 'c',
          rename = 'r',
          rename_from_scratch = 'R',
          cut = 'x',
          paste = 'p',
          quit = 'q',
          toggle_hidden = '<leader>.',
          toggle_collapse_dirs = 'z',
        },
        extension_mappings = {},
        options = {
          dirs_first = true,
          show_hidden = false,
          collapse_dirs = true,
          line_numbers = {
            enabled = true,
            relative = false,
          },
          file_icons = {
            enabled = true,
            directory_icon = '',
            fallback_file_icon = ''
          },
          responsive_column_widths = {
            -- Keys are breakpoints, values are column widths
            -- A breakpoint means "when vim.o.columns >= x, use these column widths"
            -- Columns widths must add up to 1 after rounding to 2 decimal places
            -- Parent or child windows can be hidden by setting a width of 0
            ['0'] = { 0, 0.5, 0.5 },
            ['120'] = { 0.2, 0.3, 0.5 },
            ['200'] = { 0.25, 0.25, 0.5 },
          },
          highlights = { -- Highlight groups to use. See `:highlight` or `:h highlight`
            file_names = 'NONE',
            directory_names = 'NONE',
          },
          syntax_highlighting = { -- Applies to file previews
            enabled = true,
            debounce_ms = 100,
          },
          backdrop = 60 -- Backdrop opacity. 0 is fully opaque, 100 is fully transparent (disables the feature)
          transparency = 0, -- 0 is fully opaque, 100 is fully transparent
          border = 'single' -- See :h nvim_open_win for border options
          max_height = 45,
          max_width = 220,
          margin_x = 4 -- Space left and right
          margin_y = 4 -- Space above and below
        },
        git_signs = {
          enabled = true,
          signs = {
            -- The value can be either a string or a table.
            -- If a string, will be basic text. If a table, will be passed as the {dict} argument to vim.fn.sign_define
            -- If you want to add color, you can specify a highlight group in the table.
            add = '+',
            modify = '~',
            rename = 'r',
            untracked = '?',
          },
        },
        diagnostic_signs = {
          enabled = true,
        }
      }
      
      
      {
        dirname, -- e.g. /User/Name/foo
        display_name -- e.g. 'bar.js'
        filetype, -- e.g. 'javascript'
        is_dir, -- boolean indicating whether this is a directory
        path, -- e.g. /User/Name/foo/bar.js
      }
      
      
      {
        opts = {
          extension_mappings = {
            ['<c-f>'] = {
              mode = 'n',
              fn = function(target, _)
                require 'telescope.builtin'.live_grep {
                  search_dirs = { target.path }
                }
              end
            }
          }
        }
      }
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-files.md",
  },
  {
    "prichrd/netrw.nvim",
    config = function()
      
      require("netrw").setup({})
      
      
      require("netrw").setup({
        -- File icons to use when `use_devicons` is false or if
        -- no icon is found for the given file type.
        icons = {
          symlink = '',
          directory = '',
          file = '',
        },
        -- Uses mini.icon or nvim-web-devicons if true, otherwise use the file icon specified above
        use_devicons = true,
        mappings = {
          -- Function mappings receive an object describing the node under the cursor
          ['p'] = function(payload) print(vim.inspect(payload)) end,
          -- String mappings are executed as vim commands
          ['<Leader>p'] = ":echo 'hello world'<CR>",
        },
      })
      
    end,
  },
  {
    "X3eRo0/dired.nvim",
    config = function()
      
      use {
          "X3eRo0/dired.nvim",
          requires = "MunifTanjim/nui.nvim",
          config = function()
              require("dired").setup {
                  path_separator = "/",
                  show_banner = false,
                  show_icons = false,
                  show_hidden = true,
                  show_dot_dirs = true,
                  show_colors = true,
              }
          end
      }
      
      
      -- Neovim configuration for the 'dired' plugin
      
      -- Set up the 'dired' plugin with custom options
      require("dired").setup({
          path_separator = "/",                -- Use '/' as the path separator
          show_hidden = true,                  -- Show hidden files
          show_icons = false,                  -- Show icons (patched font required)
          show_banner = false,                 -- Do not show the banner
          hide_details = false,                -- Show file details by default
          sort_order = "name",                 -- Sort files by name by default
      
          -- Define keybindings for various 'dired' actions
          keybinds = {
              dired_enter = "<CR>",
              dired_back = "-",
              dired_up = "_",
              dired_rename = "R",
              -- ... (add more keybindings as needed)
              dired_quit = "q",
          },
      
          -- Define colors for different file types and attributes
          colors = {
              DiredDimText = { link = {}, bg = "NONE", fg = "505050", gui = "NONE" },
              DiredDirectoryName = { link = {}, bg = "NONE", fg = "9370DB", gui = "NONE" },
              -- ... (define more colors as needed)
              DiredMoveFile = { link = {}, bg = "NONE", fg = "ff3399", gui = "bold" },
          },
      })
      
      
      {
          dired_enter = "<CR>",
          dired_back = "-",
          dired_up = "_",
          dired_rename = "R",
          dired_create = "d",
          dired_delete = "D",
          dired_delete_range = "D",
          dired_copy = "C",
          dired_copy_range = "C",
          dired_copy_marked = "MC",
          dired_move = "X",
          dired_move_range = "X",
          dired_move_marked = "MX",
          dired_paste = "P",
          dired_mark = "M",
          dired_mark_range = "M",
          dired_delete_marked = "MD",
          dired_shell_cmd = "!",
          dired_shell_cmd_marked = "&",
          dired_toggle_hidden = ".",
          dired_toggle_sort_order = ",",
          dired_toggle_icons = "*",
          dired_toggle_colors = "c",
          dired_toggle_hide_details = "(",
          dired_quit = "q",
      }
      
      
      local DiredDimText = {
          link = {},
          bg = "232323",
          fg = "f3f3f3"
          gui = "bold",
      }
      
      
      {
          DiredDimText = { link = {}, bg = "NONE", fg = "505050", gui = "NONE" },
          DiredDirectoryName = { link = {}, bg = "NONE", fg = "9370DB", gui = "NONE" },
          DiredDotfile = { link = {}, bg = "NONE", fg = "626262" },
          DiredFadeText1 = { link = {}, bg = "NONE", fg = "626262", gui = "NONE" },
          DiredFadeText2 = { link = {}, bg = "NONE", fg = "444444", gui = "NONE" },
          DiredSize = { link = { "Normal" }, bg = "NONE", fg = "None", gui = "NONE" },
          DiredUsername = { link = {}, bg = "NONE", fg = "87CEFA", gui = "bold" },
          DiredMonth = { link = { "Normal" }, bg = "NONE", fg = "None", gui = "bold" },
          DiredDay = { link = { "Normal" }, bg = "NONE", fg = "None", gui = "bold" },
          DiredFileName = { link = {}, bg = "NONE", fg = "NONE", gui = "NONE" },
          DiredFileSuid = { link = {}, bg = "ff6666", fg = "000000", gui = "bold" },
          DiredNormal = { link = { "Normal" }, bg = "NONE", fg = "NONE", gui = "NONE" },
          DiredNormalBold = { link = {}, bg = "NONE", fg = "ffffff", gui = "bold" },
          DiredSymbolicLink = { link = {}, bg = "NONE", fg = "33ccff", gui = "bold" },
          DiredBrokenLink = { link = {}, bg = "2e2e1f", fg = "ff1a1a", gui = "bold" },
          DiredSymbolicLinkTarget = { link = {}, bg = "5bd75b", fg = "000000", gui = "bold" },
          DiredBrokenLinkTarget = { link = {}, bg = "2e2e1f", fg = "ff1a1a", gui = "bold" },
          DiredFileExecutable = { link = {}, bg = "NONE", fg = "5bd75b", gui = "bold" },
          DiredMarkedFile = { link = {}, bg = "NONE", fg = "a8b103", gui = "bold" },
          DiredCopyFile = { link = {}, bg = "NONE", fg = "ff8533", gui = "bold" },
          DiredMoveFile = { link = {}, bg = "NONE", fg = "ff3399", gui = "bold" },
      }
      
    end,
  },
  {
    "saifulapm/neotree-file-nesting-config",
    config = function()
      
      -- lazy.nvim
      {
          'nvim-neo-tree/neo-tree.nvim',
          branch = 'v3.x',
          dependencies = {
            -- Others dependencies
            'saifulapm/neotree-file-nesting-config', -- add plugin as dependency. no need any other config or setup call
          },
          opts = {
            -- recommanded config for better UI
            hide_root_node = true,
            retain_hidden_root_indent = true,
            filesystem = {
              filtered_items = {
                show_hidden_count = false,
                never_show = {
                  '.DS_Store',
                },
              },
            },
            default_component_configs = {
              indent = {
                with_expanders = true,
                expander_collapsed = '',
                expander_expanded = '',
              },
            },
            -- others config
          },
          config = function(_, opts)
            -- Adding rules from plugin
            opts.nesting_rules = require('neotree-file-nesting-config').nesting_rules
            require('neo-tree').setup(opts)
          end,
      }
      
      
      -- updated 2025-03-06 12:53
      {
        ['*.asax'] = {
          files = { '%1%.*%.cs', '%1%.*%.vb' },
          pattern = '(.*)%.asax$'
        },
        ['*.ascx'] = {
          files = { '%1%.*%.cs', '%1%.*%.vb' },
          pattern = '(.*)%.ascx$'
        },
        ['*.ashx'] = {
          files = { '%1%.*%.cs', '%1%.*%.vb' },
          pattern = '(.*)%.ashx$'
        },
        ['*.aspx'] = {
          files = { '%1%.*%.cs', '%1%.*%.vb' },
          pattern = '(.*)%.aspx$'
        },
        ['*.axaml'] = {
          files = { '%1%.axaml%.cs' },
          pattern = '(.*)%.axaml$'
        },
        ['*.bloc.dart'] = {
          files = { '%1%.event%.dart', '%1%.state%.dart' },
          pattern = '(.*)%.bloc%.dart$'
        },
        ['*.c'] = {
          files = { '%1%.h' },
          pattern = '(.*)%.c$'
        },
        ['*.cc'] = {
          files = { '%1%.hpp', '%1%.h', '%1%.hxx', '%1%.hh' },
          pattern = '(.*)%.cc$'
        },
        ['*.cjs'] = {
          files = { '%1%.cjs%.map', '%1%.*%.cjs', '%1_*%.cjs' },
          pattern = '(.*)%.cjs$'
        },
        ['*.component.ts'] = {
          files = { '%1%.component%.html', '%1%.component%.spec%.ts', '%1%.component%.css', '%1%.component%.scss', '%1%.component%.sass', '%1%.component%.less' },
          pattern = '(.*)%.component%.ts$'
        },
        ['*.cpp'] = {
          files = { '%1%.hpp', '%1%.h', '%1%.hxx', '%1%.hh' },
          pattern = '(.*)%.cpp$'
        },
        ['*.cs'] = {
          files = { '%1%.*%.cs' },
          pattern = '(.*)%.cs$'
        },
        ['*.cshtml'] = {
          files = { '%1%.cshtml%.cs' },
          pattern = '(.*)%.cshtml$'
        },
        ['*.csproj'] = {
          files = { '*proj%.user', '*%.config', 'appsettings%.*', 'bundleconfig%.json' },
          pattern = '(.*)%.csproj$'
        },
        ['*.css'] = {
          files = { '%1%.css%.map', '%1%.*%.css' },
          pattern = '(.*)%.css$'
        },
        ['*.cxx'] = {
          files = { '%1%.hpp', '%1%.h', '%1%.hxx', '%1%.hh' },
          pattern = '(.*)%.cxx$'
        },
        ['*.dart'] = {
          files = { '%1%.freezed%.dart', '%1%.g%.dart' },
          pattern = '(.*)%.dart$'
        },
        ['*.db'] = {
          files = { '*%.db-shm', '*%.db-wal' },
          pattern = '(.*)%.db$'
        },
        ['*.ex'] = {
          files = { '%1%.html%.eex', '%1%.html%.leex', '%1%.html%.heex' },
          pattern = '(.*)%.ex$'
        },
        ['*.fs'] = {
          files = { '%1%.fs%.js', '%1%.fs%.js%.map', '%1%.fs%.jsx', '%1%.fs%.ts', '%1%.fs%.tsx', '%1%.fs%.rs', '%1%.fs%.php', '%1%.fs%.dart' },
          pattern = '(.*)%.fs$'
        },
        ['*.go'] = {
          files = { '%1_test%.go' },
          pattern = '(.*)%.go$'
        },
        ['*.java'] = {
          files = { '%1%.class' },
          pattern = '(.*)%.java$'
        },
        ['*.js'] = {
          files = { '%1%.js%.map', '%1%.*%.js', '%1_*%.js', '%1%.d%.ts', '%1%.js%.flow' },
          pattern = '(.*)%.js$'
        },
        ['*.jsx'] = {
          files = { '%1%.js', '%1%.*%.jsx', '%1_*%.js', '%1_*%.jsx', '%1%.css', '%1%.module%.css', '%1%.less', '%1%.module%.less', '%1%.module%.less%.d%.ts', '%1%.scss', '%1%.module%.scss', '%1%.module%.scss%.d%.ts' },
          pattern = '(.*)%.jsx$'
        },
        ['*.master'] = {
          files = { '%1%.*%.cs', '%1%.*%.vb' },
          pattern = '(.*)%.master$'
        },
        ['*.md'] = {
          files = { '%1%.*' },
          pattern = '(.*)%.md$'
        },
        ['*.mjs'] = {
          files = { '%1%.mjs%.map', '%1%.*%.mjs', '%1_*%.mjs' },
          pattern = '(.*)%.mjs$'
        },
        ['*.module.ts'] = {
          files = { '%1%.resolver%.ts', '%1%.controller%.ts', '%1%.service%.ts' },
          pattern = '(.*)%.module%.ts$'
        },
        ['*.mts'] = {
          files = { '%1%.mts%.map', '%1%.*%.mts', '%1_*%.mts' },
          pattern = '(.*)%.mts$'
        },
        ['*.pubxml'] = {
          files = { '%1%.pubxml%.user' },
          pattern = '(.*)%.pubxml$'
        },
        ['*.py'] = {
          files = { '%1%.pyi' },
          pattern = '(.*)%.py$'
        },
        ['*.razor'] = {
          files = { '%1%.razor%.css', '%1%.razor%.scss', '%1%.razor%.cs' },
          pattern = '(.*)%.razor$'
        },
        ['*.resx'] = {
          files = { '%1%.*%.resx', '%1%.designer%.cs', '%1%.designer%.vb' },
          pattern = '(.*)%.resx$'
        },
        ['*.tex'] = {
          files = { '%1%.acn', '%1%.acr', '%1%.alg', '%1%.aux', '%1%.bbl-SAVE-ERROR', '%1%.bbl', '%1%.bcf', '%1%.blg', '%1%.fdb_latexmk', '%1%.fls', '%1%.glg', '%1%.glo', '%1%.gls', '%1%.idx', '%1%.ind', '%1%.ist', '%1%.lof', '%1%.log', '%1%.lot', '%1%.nav', '%1%.out', '%1%.run%.xml', '%1%.snm', '%1%.synctex%.gz', '%1%.toc', '%1%.xdv' },
          pattern = '(.*)%.tex$'
        },
        ['*.ts'] = {
          files = { '%1%.js', '%1%.d%.ts%.map', '%1%.*%.ts', '%1_*%.js', '%1_*%.ts' },
          pattern = '(.*)%.ts$'
        },
        ['*.tsx'] = {
          files = { '%1%.ts', '%1%.*%.tsx', '%1_*%.ts', '%1_*%.tsx', '%1%.css', '%1%.module%.css', '%1%.less', '%1%.module%.less', '%1%.module%.less%.d%.ts', '%1%.scss', '%1%.module%.scss', '%1%.module%.scss%.d%.ts', '%1%.css%.ts' },
          pattern = '(.*)%.tsx$'
        },
        ['*.vbproj'] = {
          files = { '*proj%.user', '*%.config', 'appsettings%.*', 'bundleconfig%.json' },
          pattern = '(.*)%.vbproj$'
        },
        ['*.vue'] = {
          files = { '%1%.*%.ts', '%1%.*%.js', '%1%.story%.vue' },
          pattern = '(.*)%.vue$'
        },
        ['*.w'] = {
          files = { '%1%.*%.w', 'I%1%.w' },
          pattern = '(.*)%.w$'
        },
        ['*.xaml'] = {
          files = { '%1%.xaml%.cs' },
          pattern = '(.*)%.xaml$'
        },
        ['+layout.svelte'] = {
          files = { '+layout%.ts', '+layout%.ts', '+layout%.js', '+layout%.server%.ts', '+layout%.server%.js', '+layout%.gql' },
          pattern = '+layout%.svelte$'
        },
        ['+page.svelte'] = {
          files = { '+page%.server%.ts', '+page%.server%.js', '+page%.ts', '+page%.js', '+page%.gql' },
          pattern = '+page%.svelte$'
        },
        ['.clang-tidy'] = {
          files = { '%.clang-format', '%.clangd', 'compile_commands%.json' },
          pattern = '%.clang-tidy$'
        },
        ['.env'] = {
          files = { '%.env%.*', '%.envrc', '*%.env', 'env%.d%.ts' },
          pattern = '%.env$'
        },
        ['.gitignore'] = {
          files = { '%.gitattributes', '%.gitmodules', '%.gitmessage', '%.lfsconfig', '%.mailmap', '%.git-blame*' },
          pattern = '%.gitignore$'
        },
        ['.project'] = {
          files = { '%.classpath' },
          pattern = '%.project$'
        },
        ['BUILD.bazel'] = {
          files = { '*%.bzl', '*%.bazel', '*%.bazelrc', 'bazel%.rc', '%.bazelignore', '%.bazelproject', '%.bazelversion', 'MODULE%.bazel%.lock', 'WORKSPACE' },
          pattern = 'BUILD%.bazel$'
        },
        ['CMakeLists.txt'] = {
          files = { '*%.cmake', '*%.cmake%.in', '%.cmake-format%.yaml', 'CMakePresets%.json', 'CMakeCache%.txt' },
          pattern = 'CMakeLists%.txt$'
        },
        ['Cargo.toml'] = {
          files = { '%.clippy%.toml', '%.rustfmt%.toml', 'Cargo%.Bazel%.lock', 'Cargo%.lock', 'clippy%.toml', 'cross%.toml', 'insta%.yaml', 'rust-toolchain%.toml', 'rustfmt%.toml' },
          pattern = 'Cargo%.toml$'
        },
        Dockerfile = {
          files = { 'dockerfile*', '*%.dockerfile', '%.dockerignore', 'docker-compose%.*', 'compose%.*', '%.devcontainer%.*', 'captain-definition' },
          pattern = 'Dockerfile$'
        },
        ['I*.cs'] = {
          files = { '%1%.cs' },
          pattern = 'I(.*)%.cs$'
        },
        Makefile = {
          files = { '*%.mk' },
          pattern = 'Makefile$'
        },
        Pipfile = {
          files = { 'Pipfile', 'Pipfile%.lock', 'requirements*%.txt', 'requirements*%.in', 'requirements*%.pip', 'tox%.ini', '%.flake8', '%.isort%.cfg', '%.python-version' },
          pattern = 'Pipfile$'
        },
        ['README.*'] = {
          files = { 'AUTHORS', 'BACKERS*', 'CHANGELOG*', 'CITATION*', 'CODE_OF_CONDUCT*', 'CODEOWNERS', 'CONTRIBUTING*', 'CONTRIBUTORS', 'COPYING*', 'CREDITS', 'GOVERNANCE%.MD', 'HISTORY%.MD', 'LICENSE*', 'MAINTAINERS', 'README_*', 'RELEASE_NOTES*', 'ROADMAP%.MD', 'SECURITY%.MD', 'SPONSORS*', 'README-*' },
          ignore_case = true,
          pattern = 'README%.(.*)$'
        },
        ['ansible.cfg'] = {
          files = { 'ansible%.cfg', '%.ansible-lint', 'requirements%.yml' },
          pattern = 'ansible%.cfg$'
        },
        ['app.config.*'] = {
          files = { '%.babelrc*', '%.cssnanorc*', '%.htmlnanorc*', '%.postcssrc*', '%.terserrc*', 'babel%.config%.*', 'capacitor%.config%.*', 'content%.config%.*', 'contentlayer%.config%.*', 'cssnano%.config%.*', 'drizzle%.config%.*', 'formkit%.config%.*', 'formulate%.config%.*', 'htmlnanorc%.*', 'i18n%.config%.*', 'ionic%.config%.*', 'panda%.config%.*', 'postcss%.config%.*', 'react-router%.config%.*', 'rspack%.config%.*', 'sst%.config%.*', 'svgo%.config%.*', 'tailwind%.config%.*', 'uno%.config%.*', 'unocss%.config%.*', 'vuetify%.config%.*', 'webpack%.config%.*', 'windi%.config%.*', '%.env%.*', '%.envrc', '*%.env', 'env%.d%.ts', '%.codecov', '%.lighthouserc%.*', '%.mocha*', 'ava%.config%.*', 'cypress%.*', 'histoire%.config%.*', 'jasmine%.*', 'jest%.config%.*', 'karma*', 'lighthouserc%.*', 'playwright%.config%.*', 'puppeteer%.config%.*', 'vitest%.config%.*', 'api-extractor%.json', 'jsconfig%.*', 'tsconfig%.*', 'tsdoc%.*' },
          pattern = 'app%.config%.(.*)$'
        },
        artisan = {
          files = { '%.babelrc*', '%.cssnanorc*', '%.htmlnanorc*', '%.postcssrc*', '%.terserrc*', 'babel%.config%.*', 'capacitor%.config%.*', 'content%.config%.*', 'contentlayer%.config%.*', 'cssnano%.config%.*', 'drizzle%.config%.*', 'formkit%.config%.*', 'formulate%.config%.*', 'htmlnanorc%.*', 'i18n%.config%.*', 'ionic%.config%.*', 'panda%.config%.*', 'postcss%.config%.*', 'react-router%.config%.*', 'rspack%.config%.*', 'sst%.config%.*', 'svgo%.config%.*', 'tailwind%.config%.*', 'uno%.config%.*', 'unocss%.config%.*', 'vuetify%.config%.*', 'webpack%.config%.*', 'windi%.config%.*', '%.env%.*', '%.envrc', '*%.env', 'env%.d%.ts', '%.codecov', '%.lighthouserc%.*', '%.mocha*', 'ava%.config%.*', 'cypress%.*', 'histoire%.config%.*', 'jasmine%.*', 'jest%.config%.*', 'karma*', 'lighthouserc%.*', 'playwright%.config%.*', 'puppeteer%.config%.*', 'vitest%.config%.*', 'api-extractor%.json', 'jsconfig%.*', 'tsconfig%.*', 'tsdoc%.*' },
          pattern = 'artisan$'
        },
        ['astro.config.*'] = {
          files = { '%.babelrc*', '%.cssnanorc*', '%.htmlnanorc*', '%.postcssrc*', '%.terserrc*', 'babel%.config%.*', 'capacitor%.config%.*', 'content%.config%.*', 'contentlayer%.config%.*', 'cssnano%.config%.*', 'drizzle%.config%.*', 'formkit%.config%.*', 'formulate%.config%.*', 'htmlnanorc%.*', 'i18n%.config%.*', 'ionic%.config%.*', 'panda%.config%.*', 'postcss%.config%.*', 'react-router%.config%.*', 'rspack%.config%.*', 'sst%.config%.*', 'svgo%.config%.*', 'tailwind%.config%.*', 'uno%.config%.*', 'unocss%.config%.*', 'vuetify%.config%.*', 'webpack%.config%.*', 'windi%.config%.*', '%.env%.*', '%.envrc', '*%.env', 'env%.d%.ts', '%.codecov', '%.lighthouserc%.*', '%.mocha*', 'ava%.config%.*', 'cypress%.*', 'histoire%.config%.*', 'jasmine%.*', 'jest%.config%.*', 'karma*', 'lighthouserc%.*', 'playwright%.config%.*', 'puppeteer%.config%.*', 'vitest%.config%.*', 'api-extractor%.json', 'jsconfig%.*', 'tsconfig%.*', 'tsdoc%.*' },
          pattern = 'astro%.config%.(.*)$'
        },
        ['build-wrapper.log'] = {
          files = { 'build-wrapper*%.log', 'build-wrapper-dump*%.json', 'build-wrapper-win*%.exe', 'build-wrapper-linux*', 'build-wrapper-macosx*' },
          pattern = 'build-wrapper%.log$'
        },
        ['composer.json'] = {
          files = { 'composer%.lock', 'phpunit%.xml*', 'psalm*%.xml', '%.php*%.cache' },
          pattern = 'composer%.json$'
        },
        ['default.nix'] = {
          files = { 'shell%.nix' },
          pattern = 'default%.nix$'
        },
        ['deno.json*'] = {
          files = { 'import_map%.json', 'import-map%.json', 'deno%.lock', 'api-extractor%.json', 'jsconfig%.*', 'tsconfig%.*', 'tsdoc%.*', '%.env%.*', '%.envrc', '*%.env', 'env%.d%.ts' },
          pattern = 'deno%.json(.*)$'
        },
        ['flake.nix'] = {
          files = { 'flake%.lock' },
          pattern = 'flake%.nix$'
        },
        ['gatsby-config.*'] = {
          files = { '%.babelrc*', '%.cssnanorc*', '%.htmlnanorc*', '%.postcssrc*', '%.terserrc*', 'babel%.config%.*', 'capacitor%.config%.*', 'content%.config%.*', 'contentlayer%.config%.*', 'cssnano%.config%.*', 'drizzle%.config%.*', 'formkit%.config%.*', 'formulate%.config%.*', 'htmlnanorc%.*', 'i18n%.config%.*', 'ionic%.config%.*', 'panda%.config%.*', 'postcss%.config%.*', 'react-router%.config%.*', 'rspack%.config%.*', 'sst%.config%.*', 'svgo%.config%.*', 'tailwind%.config%.*', 'uno%.config%.*', 'unocss%.config%.*', 'vuetify%.config%.*', 'webpack%.config%.*', 'windi%.config%.*', '%.env%.*', '%.envrc', '*%.env', 'env%.d%.ts', '%.codecov', '%.lighthouserc%.*', '%.mocha*', 'ava%.config%.*', 'cypress%.*', 'histoire%.config%.*', 'jasmine%.*', 'jest%.config%.*', 'karma*', 'lighthouserc%.*', 'playwright%.config%.*', 'puppeteer%.config%.*', 'vitest%.config%.*', 'api-extractor%.json', 'jsconfig%.*', 'tsconfig%.*', 'tsdoc%.*' },
          pattern = 'gatsby-config%.(.*)$'
        },
        gemfile = {
          files = { 'gemfile%.lock', '%.ruby-version' },
          pattern = 'gemfile$'
        },
        ['go.mod'] = {
          files = { 'go%.sum', '%.air*' },
          pattern = 'go%.mod$'
        },
        ['go.work'] = {
          files = { 'go%.work%.sum' },
          pattern = 'go%.work$'
        },
        ['hatch.toml'] = {
          files = { 'hatch%.toml', 'requirements*%.txt', 'requirements*%.in', 'requirements*%.pip', 'tox%.ini', '%.flake8', '%.isort%.cfg', '%.python-version' },
          pattern = 'hatch%.toml$'
        },
        ['mix.exs'] = {
          files = { 'mix%.lock', '%.formatter%.exs', '%.credo%.exs', '%.dialyzer_ignore%.exs', '%.iex%.exs', '%.tool-versions' },
          pattern = 'mix%.exs$'
        },
        ['next.config.*'] = {
          files = { '%.babelrc*', '%.cssnanorc*', '%.htmlnanorc*', '%.postcssrc*', '%.terserrc*', 'babel%.config%.*', 'capacitor%.config%.*', 'content%.config%.*', 'contentlayer%.config%.*', 'cssnano%.config%.*', 'drizzle%.config%.*', 'formkit%.config%.*', 'formulate%.config%.*', 'htmlnanorc%.*', 'i18n%.config%.*', 'ionic%.config%.*', 'panda%.config%.*', 'postcss%.config%.*', 'react-router%.config%.*', 'rspack%.config%.*', 'sst%.config%.*', 'svgo%.config%.*', 'tailwind%.config%.*', 'uno%.config%.*', 'unocss%.config%.*', 'vuetify%.config%.*', 'webpack%.config%.*', 'windi%.config%.*', '%.env%.*', '%.envrc', '*%.env', 'env%.d%.ts', '%.codecov', '%.lighthouserc%.*', '%.mocha*', 'ava%.config%.*', 'cypress%.*', 'histoire%.config%.*', 'jasmine%.*', 'jest%.config%.*', 'karma*', 'lighthouserc%.*', 'playwright%.config%.*', 'puppeteer%.config%.*', 'vitest%.config%.*', 'api-extractor%.json', 'jsconfig%.*', 'tsconfig%.*', 'tsdoc%.*' },
          pattern = 'next%.config%.(.*)$'
        },
        ['nuxt.config.*'] = {
          files = { '%.babelrc*', '%.cssnanorc*', '%.htmlnanorc*', '%.postcssrc*', '%.terserrc*', 'babel%.config%.*', 'capacitor%.config%.*', 'content%.config%.*', 'contentlayer%.config%.*', 'cssnano%.config%.*', 'drizzle%.config%.*', 'formkit%.config%.*', 'formulate%.config%.*', 'htmlnanorc%.*', 'i18n%.config%.*', 'ionic%.config%.*', 'panda%.config%.*', 'postcss%.config%.*', 'react-router%.config%.*', 'rspack%.config%.*', 'sst%.config%.*', 'svgo%.config%.*', 'tailwind%.config%.*', 'uno%.config%.*', 'unocss%.config%.*', 'vuetify%.config%.*', 'webpack%.config%.*', 'windi%.config%.*', '%.env%.*', '%.envrc', '*%.env', 'env%.d%.ts', '%.codecov', '%.lighthouserc%.*', '%.mocha*', 'ava%.config%.*', 'cypress%.*', 'histoire%.config%.*', 'jasmine%.*', 'jest%.config%.*', 'karma*', 'lighthouserc%.*', 'playwright%.config%.*', 'puppeteer%.config%.*', 'vitest%.config%.*', 'api-extractor%.json', 'jsconfig%.*', 'tsconfig%.*', 'tsdoc%.*' },
          pattern = 'nuxt%.config%.(.*)$'
        },
        ['package.json'] = {
          files = { '%.browserslist*', '%.cz-config%.js', '%.czrc', 'components%.*', '%.nodemon*', '%.pm2*', '%.versionrc*', '%.vscode*', '%.watchman*', 'apollo%.config%.*', 'nest-cli%.*', 'nodemon*', 'pm2%.*', 'typedoc*', 'vetur%.config%.*', '%.gitmojirc%.json', '%.huskyrc*', '%.node-version', '%.npm*', '%.nvmrc', '%.pnp%.*', '%.pnpm*', '%.release-please*%.json', '%.releaserc*', '%.simple-git-hooks*', '%.tazerc*', '%.tool-versions', '%.yarnrc*', '*%.code-workspace', 'bower%.json', 'bun%.lock', 'bun%.lockb', 'bunfig%.toml', 'firebase%.json', 'lerna*', 'npm-shrinkwrap%.json', 'nx%.*', 'package-lock%.json', 'package%.nls*%.json', 'pnpm*', 'release-please*%.json', 'release%.config%.*', 'simple-git-hooks*', 'turbo*', 'workspace%.json', 'yarn*', 'build%.config%.*', 'electron-builder%.*', 'grunt*', 'gulp*', 'rolldown%.config%.*', 'rollup%.config%.*', 'tsup%.config%.*', 'tsdown%.config%.*', 'webpack*', 'rspack*', '%.circleci*', '%.cursorrules', '%.firebase*', '%.github*', '%.gitlab*', '%.gitpod*', '%.sentry*', '%.stackblitz*', '%.styleci*', '%.travis*', 'appveyor*', 'azure-pipelines*', 'colada%.options%.ts', 'crowdin*', 'jenkins*', 'netlify*', 'nixpacks*', 'Procfile', 'pullapprove*', 'release-tasks%.sh', 'renovate*', 'sentry%.*%.config%.ts', 'sonar-project%.properties', 'unlighthouse*', 'vercel*', 'wrangler%.*', '%.commitlint*', '%.cspell*', '%.dlint%.json', '%.dprint%.json*', '%.editorconfig', '%.eslint*', '%.flowconfig', '%.jslint*', '%.lintstagedrc*', '%.ls-lint%.yml', '%.markdownlint*', '%.prettier*', '%.pylintrc', '%.ruff%.toml', '%.shellcheckrc', '%.stylelint*', '%.textlint*', '%.xo-config*', '%.yamllint*', 'biome%.json*', 'commitlint*', 'cspell*', 'dangerfile*', 'dlint%.json', 'dprint%.json*', 'eslint*', 'lint-staged*', 'phpcs%.xml', 'prettier*', 'pyrightconfig%.json', 'ruff%.toml', 'stylelint*', 'tslint*', 'xo%.config%.*', 'knip%.*', '%.knip%.*', 'ec%.config%.*' },
          pattern = 'package%.json$'
        },
        ['pubspec.yaml'] = {
          files = { '%.metadata', '%.packages', 'all_lint_rules%.yaml', 'analysis_options%.yaml', 'build%.yaml', 'pubspec%.lock', 'pubspec_overrides%.yaml' },
          pattern = 'pubspec%.yaml$'
        },
        ['pyproject.toml'] = {
          files = { 'pyproject%.toml', 'pdm%.lock', '%.pdm%.toml', '%.pdm-python', 'poetry%.lock', 'poetry%.toml', 'uv%.lock', 'uv%.toml', 'setup%.py', 'setup%.cfg', 'MANIFEST%.in', 'requirements*%.txt', 'requirements*%.in', 'requirements*%.pip', 'tox%.ini', '%.flake8', '%.isort%.cfg', '%.python-version', 'Pipfile', 'Pipfile%.lock', 'requirements*%.txt', 'requirements*%.in', 'requirements*%.pip', 'tox%.ini', '%.flake8', '%.isort%.cfg', '%.python-version', 'hatch%.toml', 'requirements*%.txt', 'requirements*%.in', 'requirements*%.pip', 'tox%.ini', '%.flake8', '%.isort%.cfg', '%.python-version', '%.commitlint*', '%.cspell*', '%.dlint%.json', '%.dprint%.json*', '%.editorconfig', '%.eslint*', '%.flowconfig', '%.jslint*', '%.lintstagedrc*', '%.ls-lint%.yml', '%.markdownlint*', '%.prettier*', '%.pylintrc', '%.ruff%.toml', '%.shellcheckrc', '%.stylelint*', '%.textlint*', '%.xo-config*', '%.yamllint*', 'biome%.json*', 'commitlint*', 'cspell*', 'dangerfile*', 'dlint%.json', 'dprint%.json*', 'eslint*', 'lint-staged*', 'phpcs%.xml', 'prettier*', 'pyrightconfig%.json', 'ruff%.toml', 'stylelint*', 'tslint*', 'xo%.config%.*' },
          pattern = 'pyproject%.toml$'
        },
        ['quasar.conf.js'] = {
          files = { '%.babelrc*', '%.cssnanorc*', '%.htmlnanorc*', '%.postcssrc*', '%.terserrc*', 'babel%.config%.*', 'capacitor%.config%.*', 'content%.config%.*', 'contentlayer%.config%.*', 'cssnano%.config%.*', 'drizzle%.config%.*', 'formkit%.config%.*', 'formulate%.config%.*', 'htmlnanorc%.*', 'i18n%.config%.*', 'ionic%.config%.*', 'panda%.config%.*', 'postcss%.config%.*', 'react-router%.config%.*', 'rspack%.config%.*', 'sst%.config%.*', 'svgo%.config%.*', 'tailwind%.config%.*', 'uno%.config%.*', 'unocss%.config%.*', 'vuetify%.config%.*', 'webpack%.config%.*', 'windi%.config%.*', '%.env%.*', '%.envrc', '*%.env', 'env%.d%.ts', '%.codecov', '%.lighthouserc%.*', '%.mocha*', 'ava%.config%.*', 'cypress%.*', 'histoire%.config%.*', 'jasmine%.*', 'jest%.config%.*', 'karma*', 'lighthouserc%.*', 'playwright%.config%.*', 'puppeteer%.config%.*', 'vitest%.config%.*', 'api-extractor%.json', 'jsconfig%.*', 'tsconfig%.*', 'tsdoc%.*' },
          pattern = 'quasar%.conf%.js$'
        },
        ['remix.config.*'] = {
          files = { '%.babelrc*', '%.cssnanorc*', '%.htmlnanorc*', '%.postcssrc*', '%.terserrc*', 'babel%.config%.*', 'capacitor%.config%.*', 'content%.config%.*', 'contentlayer%.config%.*', 'cssnano%.config%.*', 'drizzle%.config%.*', 'formkit%.config%.*', 'formulate%.config%.*', 'htmlnanorc%.*', 'i18n%.config%.*', 'ionic%.config%.*', 'panda%.config%.*', 'postcss%.config%.*', 'react-router%.config%.*', 'rspack%.config%.*', 'sst%.config%.*', 'svgo%.config%.*', 'tailwind%.config%.*', 'uno%.config%.*', 'unocss%.config%.*', 'vuetify%.config%.*', 'webpack%.config%.*', 'windi%.config%.*', '%.env%.*', '%.envrc', '*%.env', 'env%.d%.ts', '%.codecov', '%.lighthouserc%.*', '%.mocha*', 'ava%.config%.*', 'cypress%.*', 'histoire%.config%.*', 'jasmine%.*', 'jest%.config%.*', 'karma*', 'lighthouserc%.*', 'playwright%.config%.*', 'puppeteer%.config%.*', 'vitest%.config%.*', 'api-extractor%.json', 'jsconfig%.*', 'tsconfig%.*', 'tsdoc%.*' },
          pattern = 'remix%.config%.(.*)$'
        },
        ['requirements.txt'] = {
          files = { 'requirements*%.txt', 'requirements*%.in', 'requirements*%.pip', 'tox%.ini', '%.flake8', '%.isort%.cfg', '%.python-version' },
          pattern = 'requirements%.txt$'
        },
        ['rush.json'] = {
          files = { '%.browserslist*', '%.cz-config%.js', '%.czrc', 'components%.*', '%.nodemon*', '%.pm2*', '%.versionrc*', '%.vscode*', '%.watchman*', 'apollo%.config%.*', 'nest-cli%.*', 'nodemon*', 'pm2%.*', 'typedoc*', 'vetur%.config%.*', '%.gitmojirc%.json', '%.huskyrc*', '%.node-version', '%.npm*', '%.nvmrc', '%.pnp%.*', '%.pnpm*', '%.release-please*%.json', '%.releaserc*', '%.simple-git-hooks*', '%.tazerc*', '%.tool-versions', '%.yarnrc*', '*%.code-workspace', 'bower%.json', 'bun%.lock', 'bun%.lockb', 'bunfig%.toml', 'firebase%.json', 'lerna*', 'npm-shrinkwrap%.json', 'nx%.*', 'package-lock%.json', 'package%.nls*%.json', 'pnpm*', 'release-please*%.json', 'release%.config%.*', 'simple-git-hooks*', 'turbo*', 'workspace%.json', 'yarn*', 'build%.config%.*', 'electron-builder%.*', 'grunt*', 'gulp*', 'rolldown%.config%.*', 'rollup%.config%.*', 'tsup%.config%.*', 'tsdown%.config%.*', 'webpack*', 'rspack*', '%.circleci*', '%.cursorrules', '%.firebase*', '%.github*', '%.gitlab*', '%.gitpod*', '%.sentry*', '%.stackblitz*', '%.styleci*', '%.travis*', 'appveyor*', 'azure-pipelines*', 'colada%.options%.ts', 'crowdin*', 'jenkins*', 'netlify*', 'nixpacks*', 'Procfile', 'pullapprove*', 'release-tasks%.sh', 'renovate*', 'sentry%.*%.config%.ts', 'sonar-project%.properties', 'unlighthouse*', 'vercel*', 'wrangler%.*', '%.commitlint*', '%.cspell*', '%.dlint%.json', '%.dprint%.json*', '%.editorconfig', '%.eslint*', '%.flowconfig', '%.jslint*', '%.lintstagedrc*', '%.ls-lint%.yml', '%.markdownlint*', '%.prettier*', '%.pylintrc', '%.ruff%.toml', '%.shellcheckrc', '%.stylelint*', '%.textlint*', '%.xo-config*', '%.yamllint*', 'biome%.json*', 'commitlint*', 'cspell*', 'dangerfile*', 'dlint%.json', 'dprint%.json*', 'eslint*', 'lint-staged*', 'phpcs%.xml', 'prettier*', 'pyrightconfig%.json', 'ruff%.toml', 'stylelint*', 'tslint*', 'xo%.config%.*', 'knip%.*', '%.knip%.*', 'ec%.config%.*' },
          pattern = 'rush%.json$'
        },
        ['sanity.config.*'] = {
          files = { 'sanity%.cli%.*', 'sanity%.types%.ts', 'schema%.json' },
          pattern = 'sanity%.config%.(.*)$'
        },
        ['setup.cfg'] = {
          files = { 'setup%.cfg', 'MANIFEST%.in', 'requirements*%.txt', 'requirements*%.in', 'requirements*%.pip', 'tox%.ini', '%.flake8', '%.isort%.cfg', '%.python-version' },
          pattern = 'setup%.cfg$'
        },
        ['setup.py'] = {
          files = { 'setup%.py', 'setup%.cfg', 'MANIFEST%.in', 'requirements*%.txt', 'requirements*%.in', 'requirements*%.pip', 'tox%.ini', '%.flake8', '%.isort%.cfg', '%.python-version' },
          pattern = 'setup%.py$'
        },
        ['shims.d.ts'] = {
          files = { '*%.d%.ts' },
          pattern = 'shims%.d%.ts$'
        },
        ['svelte.config.*'] = {
          files = { '%.babelrc*', '%.cssnanorc*', '%.htmlnanorc*', '%.postcssrc*', '%.terserrc*', 'babel%.config%.*', 'capacitor%.config%.*', 'content%.config%.*', 'contentlayer%.config%.*', 'cssnano%.config%.*', 'drizzle%.config%.*', 'formkit%.config%.*', 'formulate%.config%.*', 'htmlnanorc%.*', 'i18n%.config%.*', 'ionic%.config%.*', 'panda%.config%.*', 'postcss%.config%.*', 'react-router%.config%.*', 'rspack%.config%.*', 'sst%.config%.*', 'svgo%.config%.*', 'tailwind%.config%.*', 'uno%.config%.*', 'unocss%.config%.*', 'vuetify%.config%.*', 'webpack%.config%.*', 'windi%.config%.*', '%.env%.*', '%.envrc', '*%.env', 'env%.d%.ts', '%.codecov', '%.lighthouserc%.*', '%.mocha*', 'ava%.config%.*', 'cypress%.*', 'histoire%.config%.*', 'jasmine%.*', 'jest%.config%.*', 'karma*', 'lighthouserc%.*', 'playwright%.config%.*', 'puppeteer%.config%.*', 'vitest%.config%.*', 'api-extractor%.json', 'jsconfig%.*', 'tsconfig%.*', 'tsdoc%.*' },
          pattern = 'svelte%.config%.(.*)$'
        },
        ['vite.config.*'] = {
          files = { '%.babelrc*', '%.cssnanorc*', '%.htmlnanorc*', '%.postcssrc*', '%.terserrc*', 'babel%.config%.*', 'capacitor%.config%.*', 'content%.config%.*', 'contentlayer%.config%.*', 'cssnano%.config%.*', 'drizzle%.config%.*', 'formkit%.config%.*', 'formulate%.config%.*', 'htmlnanorc%.*', 'i18n%.config%.*', 'ionic%.config%.*', 'panda%.config%.*', 'postcss%.config%.*', 'react-router%.config%.*', 'rspack%.config%.*', 'sst%.config%.*', 'svgo%.config%.*', 'tailwind%.config%.*', 'uno%.config%.*', 'unocss%.config%.*', 'vuetify%.config%.*', 'webpack%.config%.*', 'windi%.config%.*', '%.env%.*', '%.envrc', '*%.env', 'env%.d%.ts', '%.codecov', '%.lighthouserc%.*', '%.mocha*', 'ava%.config%.*', 'cypress%.*', 'histoire%.config%.*', 'jasmine%.*', 'jest%.config%.*', 'karma*', 'lighthouserc%.*', 'playwright%.config%.*', 'puppeteer%.config%.*', 'vitest%.config%.*', 'api-extractor%.json', 'jsconfig%.*', 'tsconfig%.*', 'tsdoc%.*' },
          pattern = 'vite%.config%.(.*)$'
        },
        ['vue.config.*'] = {
          files = { '%.babelrc*', '%.cssnanorc*', '%.htmlnanorc*', '%.postcssrc*', '%.terserrc*', 'babel%.config%.*', 'capacitor%.config%.*', 'content%.config%.*', 'contentlayer%.config%.*', 'cssnano%.config%.*', 'drizzle%.config%.*', 'formkit%.config%.*', 'formulate%.config%.*', 'htmlnanorc%.*', 'i18n%.config%.*', 'ionic%.config%.*', 'panda%.config%.*', 'postcss%.config%.*', 'react-router%.config%.*', 'rspack%.config%.*', 'sst%.config%.*', 'svgo%.config%.*', 'tailwind%.config%.*', 'uno%.config%.*', 'unocss%.config%.*', 'vuetify%.config%.*', 'webpack%.config%.*', 'windi%.config%.*', '%.env%.*', '%.envrc', '*%.env', 'env%.d%.ts', '%.codecov', '%.lighthouserc%.*', '%.mocha*', 'ava%.config%.*', 'cypress%.*', 'histoire%.config%.*', 'jasmine%.*', 'jest%.config%.*', 'karma*', 'lighthouserc%.*', 'playwright%.config%.*', 'puppeteer%.config%.*', 'vitest%.config%.*', 'api-extractor%.json', 'jsconfig%.*', 'tsconfig%.*', 'tsdoc%.*' },
          pattern = 'vue%.config%.(.*)$'
        }
      }
      
    end,
  },
  {
    "Enigama/miss.nvim",
    config = function()
      
      use 'Enigama/miss.nvim'
      
      
      require('miss').setup()
      
    end,
  },
  {
    "vodchella/hodur.nvim",
  },
  {
    "sukineco/neoproj",
  },
  {
    "Abstract-IDE/penvim",
    config = function()
      
      Plug 'Abstract-IDE/penvim'
      
      
      use {'Abstract-IDE/penvim'}
      
      
      require("penvim").setup() -- use defaults
      
      
      require("penvim").setup({
      	rooter = {
      		enable = true, -- enable/disable rooter
      		patterns = {'.__nvim__.lua', '.git', 'node_modules'}
      	},
      	indentor = {
      		enable = true, -- enable/disable indentor
      		indent_length = 4, -- tab indent width
      		accuracy = 5, -- positive integer. higher the number, the more accurate result (but affects the startup time)
      		disable_types = {
      			'help','dashboard','dashpreview','NvimTree','vista','sagahover', 'terminal',
      		},
      	},
      	project_env = {
      		enable = true, -- enable/disable project_env
      		config_name = '.__nvim__.lua' -- config file name
      	},
      })
      
      
      -- .__nvim__.lua
      return {
      	-- for all file types
      	all = {
      		tabstop = 4, -- spaces per tab
      		cursorline = true, -- highlight current line
      		relativenumber = true, -- show relative line number
      		number = true, -- show line numbers
      	},
      
      	-- for filetype lua
      	lua = {	
      		smarttab = true, -- <tab>/<BS> indent/dedent in leading whitespace
      		softtabstop = 4,
      		shiftwidth = 4, -- spaces per tab (when shifting), when using the >> or << commands, shift lines by 4 spaces
      	},
      	
      	-- for filetype python and javascript
      	py_js = {
      		tabstop = 4, -- spaces per tab
      		wrap = false, -- don't automatically wrap on load
      	}
      }
      
    end,
  },
  {
    "windwp/nvim-projectconfig",
    config = function()
      
      require('nvim-projectconfig').setup()
      
      
      require('nvim-projectconfig').load_json()
      require('nvim-projectconfig').save_json(data)
      
    end,
  },
  {
    "ahmedkhalf/project.nvim",
    config = function()
      
          -- lua
          require("nvim-tree").setup({
            sync_root_with_cwd = true,
            respect_buf_cwd = true,
            update_focused_file = {
              enable = true,
              update_root = true
            },
          })
          
      
      -- Lua
      use {
        "ahmedkhalf/project.nvim",
        config = function()
          require("project_nvim").setup {
            -- your configuration comes here
            -- or leave it empty to use the default settings
            -- refer to the configuration section below
          }
        end
      }
      
      
      {
        -- Manual mode doesn't automatically change your root directory, so you have
        -- the option to manually do so using `:ProjectRoot` command.
        manual_mode = false,
      
        -- Methods of detecting the root directory. **"lsp"** uses the native neovim
        -- lsp, while **"pattern"** uses vim-rooter like glob pattern matching. Here
        -- order matters: if one is not detected, the other is used as fallback. You
        -- can also delete or rearangne the detection methods.
        detection_methods = { "lsp", "pattern" },
      
        -- All the patterns used to detect root dir, when **"pattern"** is in
        -- detection_methods
        patterns = { ".git", "_darcs", ".hg", ".bzr", ".svn", "Makefile", "package.json" },
      
        -- Table of lsp clients to ignore by name
        -- eg: { "efm", ... }
        ignore_lsp = {},
      
        -- Don't calculate root dir on specific directories
        -- Ex: { "~/.cargo/*", ... }
        exclude_dirs = {},
      
        -- Show hidden files in telescope
        show_hidden = false,
      
        -- When set to false, you will get a message when project.nvim changes your
        -- directory.
        silent_chdir = true,
      
        -- What scope to change the directory, valid options are
        -- * global (default)
        -- * tab
        -- * win
        scope_chdir = 'global',
      
        -- Path where project.nvim will store the project history for use in
        -- telescope
        datapath = vim.fn.stdpath("data"),
      }
      
      
      patterns = { "=src" }
      
      
      patterns = { ".git", "Makefile", "*.sln", "build/env.sh" }
      
      
      patterns = { "^fixtures" }
      
      
      patterns = { ">Latex" }
      
      
      patterns = { "!.git/worktrees", "!=extras", "!^fixtures", "!build/env.sh" }
      
      
      require('telescope').load_extension('projects')
      
      
      require'telescope'.extensions.projects.projects{}
      
      
      local project_nvim = require("project_nvim")
      local recent_projects = project_nvim.get_recent_projects()
      
      print(vim.inspect(recent_projects))
      
    end,
  },
  {
    "DrKJeff16/project.nvim",
    config = function()
      
      require('lazy').setup({
        spec = {
          -- Other plugins
          {
            'DrKJeff16/project.nvim',
            dependencies = { -- OPTIONAL
              'nvim-lua/plenary.nvim',
              'nvim-telescope/telescope.nvim',
              'ibhagwan/fzf-lua',
            },
            ---@module 'project'
      
            ---@type Project.Config.Options
            opts = {
              -- your configuration comes here
              -- or leave it empty to use the default settings
              -- refer to the configuration section below
            },
            cond = vim.fn.has('nvim-0.11') == 1, -- RECOMMENDED
          },
        },
      })
      
      
      if vim.fn.has('nvim-0.11') == 1 then
        require('pckr').add({
          {
            'DrKJeff16/project.nvim',
            requires = { -- OPTIONAL
              'nvim-lua/plenary.nvim',
              'nvim-telescope/telescope.nvim',
              'ibhagwan/fzf-lua',
            },
            config = function()
              require('project').setup({
                -- your configuration comes here
                -- or leave it empty to use the default settings
                -- refer to the configuration section below
              })
            end,
          };
        })
      end
      
      
      local paq = require('paq')
      
      paq({
        'savq/paq-nvim',
      
        'DrKJeff16/project.nvim',
        'nvim-lua/plenary.nvim', -- OPTIONAL
        'nvim-telescope/telescope.nvim', -- OPTIONAL
        'ibhagwan/fzf-lua', -- OPTIONAL
      })
      
      
      require('project').setup()
      
      
      > ---@alias Project.Telescope.ActionNames
      > ---|'browse_project_files'
      > ---|'change_working_directory'
      > ---|'delete_project'
      > ---|'find_project_files'
      > ---|'help_mappings'
      > ---|'recent_project_files'
      > ---|'search_in_project_files'
      > 
      
      {
          ---Options for logging utility.
          --- ---
          ---@type Project.Config.Logging
          log = {
              ---If `true`, it enables logging in the same directory in which your
              ---history file is stored.
              --- ---
              ---Default: `false`
              --- ---
              ---@type boolean
              enabled = false,
      
              ---The maximum logfile size (in megabytes).
              --- ---
              ---Default: `1.0`
              --- ---
              ---@type number
              max_size = 1.0,
      
              ---Path in which the log file will be saved.
              --- ---
              ---Default: `vim.fn.stdpath('state')`
              --- ---
              ---@type string
              logpath = vim.fn.stdpath('state'),
          },
      
          ---Table of options used for `fzf-lua` integration
          --- ---
          ---@type Project.Config.FzfLua
          fzf_lua = {
              ---Determines whether the `fzf-lua` integration is enabled.
              ---
              ---If `fzf-lua` is not installed, this won't make a difference.
              --- ---
              ---Default: `false`
              --- ---
              ---@type boolean
              enabled = false,
          },
      
          ---Determines in what filetypes/buftypes the plugin won't execute.
          ---It's a table with two fields:
          ---
          --- - `ft`: A string array of filetypes to exclude
          --- - `bt`: A string array of buftypes to exclude
          ---
          ---CREDITS TO [@Zeioth](https://github.com/Zeioth)!:
          ---[`Zeioth/project.nvim`](https://github.com/Zeioth/project.nvim/commit/95f56b8454f3285b819340d7d769e67242d59b53)
          --- ---
          ---The default value for this one can be found in the project's `README.md`.
          --- ---
          ---@type { ft: string[], bt: string[] }
          disable_on = {
              ft = {
                  '',
                  'TelescopePrompt',
                  'TelescopeResults',
                  'alpha',
                  'checkhealth',
                  'lazy',
                  'minimap', -- from `mini.map`
                  'notify',
                  'packer',
                  'qf',
              }, ---`filetype`
      
              bt = {
                  'help',
                  'nofile',
                  'terminal',
              }, ---`buftype`
          },
      
          ---If `true` your root directory won't be changed automatically,
          ---so you have the option to manually do so
          ---using the `:ProjectRoot` command.
          --- ---
          ---Default: `false`
          --- ---
          ---@type boolean
          manual_mode = false,
      
          ---Methods of detecting the root directory. `'lsp'` uses the native Neovim
          ---LSP, while `'pattern'` uses vim-rooter like glob pattern matching. Here
          ---order matters: if one is not detected, the other is used as fallback. You
          ---can also delete or rearrange the detection methods.
          ---
          ---The detection methods get filtered and rid of duplicates during runtime.
          --- ---
          ---Default: `{ 'lsp' , 'pattern' }`
          --- ---
          ---@type ("lsp"|"pattern")[]
          detection_methods = { 'lsp', 'pattern' },
      
          ---All the patterns used to detect root dir, when **'pattern'** is in
          ---detection_methods.
          ---
          ---See `:h project-nvim.pattern-matching`
          --- ---
          ---Default: `{ '.git', '.github', '_darcs', '.hg', '.bzr', '.svn', 'Pipfile' }`
          --- ---
          ---@type string[]
          patterns = {
              '.git',
              '.github',
              '_darcs',
              '.hg',
              '.bzr',
              '.svn',
              'Pipfile',
          },
      
          ---Sets whether to use Pattern Matching rules on the LSP.
          ---
          ---If `false`, the Pattern Matching will only apply to the `pattern` detection method.
          --- ---
          ---Default: `true`
          --- ---
          ---@type boolean
          allow_patterns_for_lsp = true,
      
          ---Determines whether a project will be added if its project root is owned by a different user.
          ---
          ---If `false`, it won't add a project if its root is not owned by the
          ---current nvim `UID` **(UNIX only)**.
          --- ---
          ---Default: `true`
          --- ---
          ---@type boolean
          allow_different_owners = true,
      
          ---If enabled, set `vim.opt.autochdir` to `true`.
          ---
          ---This is disabled by default because the plugin implicitly disables `autochdir`.
          --- ---
          ---Default: `false`
          --- ---
          ---@type boolean
          enable_autochdir = false,
      
          ---The history size. (by @acristoffers)
          ---
          ---This will indicate how many entries will be written to the history file.
          ---Set to `0` for no limit.
          --- ---
          ---Default: `100`
          --- ---
          ---@type integer
          historysize = 100
      
          ---Table of options used for the telescope picker.
          --- ---
          ---@type Project.Config.Telescope
          telescope = {
              ---Determines whether the `telescope` picker should be called
              ---from the `setup()` function.
              ---
              ---If telescope is not installed, this doesn't make a difference.
              ---
              ---Note that even if set to `false`, you can still load the extension manually.
              --- ---
              ---Default: `false`
              --- ---
              ---@type boolean
              enabled = false,
      
              ---Determines whether the newest projects come first in the
              ---telescope picker (`'newest'`), or the oldest (`'oldest'`).
              --- ---
              ---Default: `'newest'`
              --- ---
              ---@type 'oldest'|'newest'
              sort = 'newest',
      
              ---If you have `telescope-file-browser.nvim` installed, you can enable this
              ---so that the Telescope picker uses it instead of the `find_files` builtin.
              ---
              ---If `true`, use `telescope-file-browser.nvim` instead of builtins.
              ---In case it is not available, it'll fall back to `find_files`.
              --- ---
              ---Default: `false`
              --- ---
              ---@type boolean
              prefer_file_browser = false,
      
              ---Set this to `true` if you don't want the file picker to appear
              ---after you've selected a project.
              ---
              ---CREDITS: [UNKNOWN](https://github.com/ahmedkhalf/project.nvim/issues/157#issuecomment-2226419783)
              --- ---
              ---Default: `false`
              --- ---
              ---@type boolean
              disable_file_picker = false,
      
              ---Table of mappings for the Telescope picker.
              ---
              ---Only supports Normal and Insert modes.
              --- ---
              ---Default: check the README
              --- ---
              ---@type table<'n'|'i', table<string, Project.Telescope.ActionNames>>
              mappings = {
                  n = {
                      b = 'browse_project_files',
                      d = 'delete_project',
                      f = 'find_project_files',
                      r = 'recent_project_files',
                      s = 'search_in_project_files',
                      w = 'change_working_directory',
                  },
      
                  i = {
                      ['<C-b>'] = 'browse_project_files',
                      ['<C-d>'] = 'delete_project',
                      ['<C-f>'] = 'find_project_files',
                      ['<C-r>'] = 'recent_project_files',
                      ['<C-s>'] = 'search_in_project_files',
                      ['<C-w>'] = 'change_working_directory',
                  },
              },
          },
      
          ---Make hidden files visible when using any picker.
          --- ---
          ---Default: `false`
          --- ---
          ---@type boolean
          show_hidden = false,
      
          ---Table of lsp clients to ignore by name,
          ---e.g. `{ 'efm', ... }`.
          ---
          ---If you have `nvim-lspconfig` installed **see** `:h lspconfig-all`
          ---for a list of servers.
          --- ---
          ---Default: `{}`
          --- ---
          ---@type string[]
          ignore_lsp = {},
      
          ---Don't calculate root dir on specific directories,
          ---e.g. `{ '~/.cargo/*', ... }`.
          ---
          ---See the `Pattern Matching` section in the `README.md` for more info.
          --- ---
          ---Default: `{}`
          --- ---
          ---@type string[]
          exclude_dirs = {},
      
          ---If `false`, you'll get a _notification_ every time
          ---`project.nvim` changes directory.
          ---
          ---This is useful for debugging, or for players that
          ---enjoy verbose operations.
          --- ---
          ---Default: `true`
          --- ---
          ---@type boolean
          silent_chdir = true,
      
          ---Determines the scope for changing the directory.
          ---
          ---Valid options are:
          --- - `'global'`: All your nvim `cwd` will sync to your current buffer's project
          --- - `'tab'`: _Per-tab_ `cwd` sync to the current buffer's project
          --- - `'win'`: _Per-window_ `cwd` sync to the current buffer's project
          --- ---
          ---Default: `'global'`
          --- ---
          ---@type 'global'|'tab'|'win'
          scope_chdir = 'global',
      
          ---Hook to run before attaching to a new project.
          ---
          ---It recieves `target_dir` and, optionally,
          ---the `method` used to change directory.
          ---
          ---CREDITS: @danilevy1212
          --- ---
          ---Default: `function(target_dir, method) end`
          --- ---
          ---@param target_dir? string
          ---@param method? string
          before_attach = function(target_dir, method) end,
      
          ---Hook to run after attaching to a new project.
          ---**_This only runs if the directory changes successfully._**
          ---
          ---It recieves `dir` and, optionally,
          ---the `method` used to change directory.
          ---
          ---CREDITS: @danilevy1212
          --- ---
          ---Default: `function(dir, method) end`
          --- ---
          ---@param dir? string
          ---@param method? string
          on_attach = function(dir, method) end,
      
          ---The path where `project.nvim` will store the project history directory,
          ---containing the project history in it.
          ---
          ---For more info, run `:lua vim.print(require('project').get_history_paths())`
          --- ---
          ---Default: `vim.fn.stdpath('data')`
          --- ---
          ---@type string
          datapath = vim.fn.stdpath('data'),
      }
      
      
        patterns = { '=src' }
        
      
        patterns = { '.git', '.github', '*.sln', 'build/env.sh' }
        
      
        patterns = { '^fixtures' }
        
      
        patterns = { '>Latex' }
        
      
        patterns = { '!.git/worktrees', '!=extras', '!^fixtures', '!build/env.sh' }
        
      
      require('nvim-tree').setup({
        sync_root_with_cwd = true,
        respect_buf_cwd = true,
        update_focused_file = {
          enable = true,
          update_root = true,
        },
      })
      
      
      vim.keymap.set('n', '<YOUR-TOGGLE-MAP>', ':Neotree filesystem toggle reveal_force_cwd<CR>', opts)
      vim.keymap.set('n', '<YOUR-SHOW-MAP>', ':Neotree filesystem show reveal_force_cwd<CR>', opts)
      vim.keymap.set('n', '<YOUR-FLOAT-MAP>', ':Neotree filesystem float reveal_force_cwd<CR>', opts)
      -- ... and so on
      
      
      require('telescope').setup(...)
      -- Other stuff may come here...
      require('telescope').load_extension('projects')
      
      
      > require('telescope').setup({
      >   --- ...
      >   extensions = {
      >     projects = {
      >       layout_strategy = "horizontal",
      >       layout_config = {
      >         anchor = "N",
      >         height = 0.25,
      >         width = 0.6,
      >         prompt_position = "bottom",
      >       },
      >
      >       prompt_prefix = "󱎸  ",
      >     },
      >   },
      > })
      > 
      
      ---@type string?, string?
      local root, lsp_or_method = require('project').get_project_root()
      
      
      ---@type string[]
      local recent_projects = require('project').get_recent_projects()
      
      -- Using `vim.notify()`
      vim.notify(vim.inspect(recent_projects))
      
      -- Using `vim.print()`
      vim.print(recent_projects)
      
      
      local config = require('project').get_config()
      
      -- Using `vim.notify()`
      vim.notify(vim.inspect(config))
      
      -- Using `vim.print()`
      vim.print(config)
      
      
      ---@type fun(path: ('datapath'|'projectpath'|'historyfile')?): string|{ datapath: string, projectpath: string, historyfile: string }
      local get_history_paths = require('project').get_history_paths
      
      -- A dictionary table containing all return values below
      vim.print(get_history_paths())
      --- { datapath = <datapath>, projectpath = <projectpath>, historyfile = <historyfile> }
      
      
      -- The directory where `project` sets its `datapath`
      vim.print(get_history_paths('datapath'))
      
      -- The directory where `project` saves the project history
      vim.print(get_history_paths('projectpath'))
      
      -- The path to where `project` saves its recent projects history
      vim.print(get_history_paths('historyfile'))
      
      
      local ProjUtil = require('project.utils.util')
      
    end,
  },
  {
    "klen/nvim-config-local",
    config = function()
      
      
      use {
        "klen/nvim-config-local",
        config = function()
          require('config-local').setup {
            -- Default options (optional)
      
            -- Config file patterns to load (lua supported)
            config_files = { ".nvim.lua", ".nvimrc", ".exrc" },
      
            -- Where the plugin keeps files data
            hashfile = vim.fn.stdpath("data") .. "/config-local",
      
            autocommands_create = true, -- Create autocommands (VimEnter, DirectoryChanged)
            commands_create = true,     -- Create commands (ConfigLocalSource, ConfigLocalEdit, ConfigLocalTrust, ConfigLocalDeny)
            silent = false,             -- Disable plugin messages (Config loaded/denied)
            lookup_parents = false,     -- Lookup config files in parent directories
          }
        end
      }
      
    end,
  },
  {
    "otavioschwanck/telescope-alternate.nvim",
    config = function()
      
      use { "otavioschwanck/telescope-alternate" }
      
      
      {
        "otavioschwanck/telescope-alternate",
        dependencies = { "nvim-telescope/telescope.nvim" }, -- or { "ibhagwan/fzf-lua" }
      }
      
      
      -- Configuration using vim.g (recommended approach)
      vim.g.telescope_alternate = {
        mappings = {
          { 'app/services/(.*)_services/(.*).rb', { -- alternate from services to contracts / models
            { 'app/contracts/[1]_contracts/[2].rb', 'Contract' }, -- Adding label to switch
            { 'app/models/**/*[1].rb', 'Model', true }, -- Ignore create entry (with true)
          } },
          { 'app/contracts/(.*)_contracts/(.*).rb', { { 'app/services/[1]_services/[2].rb', 'Service' } } }, -- from contracts to services
          -- Search anything on helper folder that contains pluralize version of model.
          --Example: app/models/user.rb -> app/helpers/foo/bar/my_users_helper.rb
          { 'app/models/(.*).rb', { { 'db/helpers/**/*[1:pluralize]*.rb', 'Helper' } } },
          { 'app/**/*.rb', { { 'spec/[1].rb', 'Test' } } }, -- Alternate between file and test
        },
        presets = { 'rails', 'rspec', 'nestjs', 'angular' }, -- Pre-defined mapping presets
        picker = 'telescope', -- or 'fzf-lua'
        open_only_one_with = 'current_pane', -- when just have only possible file, open it with.  Can also be horizontal_split and vertical_split
        transformers = { -- custom transformers
          change_to_uppercase = function(w) return my_uppercase_method(w) end
        },
        telescope_mappings = { -- Change the telescope mappings
          i = {
            open_current = '<CR>',
            open_horizontal = '<C-s>',
            open_vertical = '<C-v>',
            open_tab = '<C-t>',
          },
          n = {
            open_current = '<CR>',
            open_horizontal = '<C-s>',
            open_vertical = '<C-v>',
            open_tab = '<C-t>',
          }
        }
      }
      
      -- Alternative setup method (legacy, still supported)
      require('telescope-alternate').setup({
          mappings = {
            { 'app/services/(.*)_services/(.*).rb', { -- alternate from services to contracts / models
              { 'app/contracts/[1]_contracts/[2].rb', 'Contract' }, -- Adding label to switch
              { 'app/models/**/*[1].rb', 'Model', true }, -- Ignore create entry (with true)
            } },
            { 'app/contracts/(.*)_contracts/(.*).rb', { { 'app/services/[1]_services/[2].rb', 'Service' } } }, -- from contracts to services
            -- Search anything on helper folder that contains pluralize version of model.
            --Example: app/models/user.rb -> app/helpers/foo/bar/my_users_helper.rb
            { 'app/models/(.*).rb', { { 'db/helpers/**/*[1:pluralize]*.rb', 'Helper' } } },
            { 'app/**/*.rb', { { 'spec/[1].rb', 'Test' } } }, -- Alternate between file and test
          },
          presets = { 'rails', 'rspec', 'nestjs', 'angular' }, -- Pre-defined mapping presets
          picker = 'telescope', -- or 'fzf-lua'
          open_only_one_with = 'current_pane', -- when just have only possible file, open it with.  Can also be horizontal_split and vertical_split
          transformers = { -- custom transformers
            change_to_uppercase = function(w) return my_uppercase_method(w) end
          },
          telescope_mappings = { -- Change the telescope mappings
            i = {
              open_current = '<CR>',
              open_horizontal = '<C-s>',
              open_vertical = '<C-v>',
              open_tab = '<C-t>',
            },
            n = {
              open_current = '<CR>',
              open_horizontal = '<C-s>',
              open_vertical = '<C-v>',
              open_tab = '<C-t>',
            }
          }
        })
      
      ## Alternative Configuration Methods
      
      ### Using Telescope Setup (Legacy)
      
      
      mappings = {
        { pattern = 'app/services/(.*)_services/(.*).rb', targets = {
            { template =  'app/contracts/[1]_contracts/[2].rb', label = 'Contract', enable_new = true } -- enable_new can be a function too.
          }
        },
        { pattern = 'app/contracts/(.*)_contracts/(.*).rb', targets = {
            { template =  'app/services/[1]_services/[2].rb', label = 'Service', enable_new = true }
          }
        },
      }
      
      
      vim.g.telescope_alternate = {
        picker = 'fzf-lua',
        mappings = {
          -- your mappings here
        }
      }
      
      
      :lua require('telescope-alternate').alternate_file()
      
      
      -- Using the provided command (recommended)
      vim.keymap.set('n', '<leader>ta', ':TelescopeAlternate<CR>', { desc = 'Alternate file' })
      
      -- Or using telescope directly
      vim.keymap.set('n', '<leader>ta', ':Telescope telescope-alternate alternate_file<CR>', { desc = 'Alternate file' })
      
      -- Or using lua function directly
      vim.keymap.set('n', '<leader>ta', function() require('telescope-alternate').alternate_file() end, { desc = 'Alternate file' })
      
      
      { 'current-file-pattern', { { 'destination-pattern', 'label', ignoreCreate (true or false) } } }
      
      
      require('telescope-alternate').setup({
        transformers = {
          my_custom_transformer = function(text)
            return text:upper()
          end
        }
      })
      
      
      {
        'app/models/(.*).rb', {
          { 'db/helpers/**/*[1]*.rb', 'Helper' },
          { 'app/controllers/**/*[1:pluralize]_controller.rb', 'Controller' },
          { 'spec/models/[1]_spec.rb', 'Test' }
        }
      }
      
      
      require('telescope-alternate').setup({
        presets = { 'rails', 'rspec' }
      })
      
    end,
  },
  {
    "natecraddock/workspaces.nvim",
    config = function()
      
      require("workspaces").setup()
      
      
      {
          -- path to a file to store workspaces data in
          -- on a unix system this would be ~/.local/share/nvim/workspaces
          path = vim.fn.stdpath("data") .. "/workspaces",
      
          -- to change directory for nvim (:cd), or only for window (:lcd)
          -- deprecated, use cd_type instead
          -- global_cd = true,
      
          -- controls how the directory is changed. valid options are "global", "local", and "tab"
          --   "global" changes directory for the neovim process. same as the :cd command
          --   "local" changes directory for the current window. same as the :lcd command
          --   "tab" changes directory for the current tab. same as the :tcd command
          --
          -- if set, overrides the value of global_cd
          cd_type = "global",
      
          -- sort the list of workspaces by name after loading from the workspaces path.
          sort = true,
      
          -- sort by recent use rather than by name. requires sort to be true
          mru_sort = true,
      
          -- option to automatically activate workspace when opening neovim in a workspace directory
          auto_open = false,
      
          -- option to automatically activate workspace when changing directory not via this plugin
          -- set to "autochdir" to enable auto_dir when using :e and vim.opt.autochdir
          -- valid options are false, true, and "autochdir"
          auto_dir = false,
      
          -- enable info-level notifications after adding or removing a workspace
          notify_info = true,
      
          -- lists of hooks to run after specific actions
          -- hooks can be a lua function or a vim command (string)
          -- lua hooks take a name, a path, and an optional state table
          -- if only one hook is needed, the list may be omitted
          hooks = {
              add = {},
              remove = {},
              rename = {},
              open_pre = {},
              open = {},
          },
      }
      
      
      require("workspaces").setup({
          hooks = {
              open = { "Telescope find_files" },
          }
      })
      
      
      local workspaces = require("workspaces")
      
      workspaces.add(path: string, name: string)
      
      workspaces.add_dir(path: string)
      
      workspaces.remove(name: string)
      
      workspaces.remove_dir(name: string)
      
      workspaces.rename(name: string, new_name: string)
      
      workspaces.list()
      
      workspaces.list_dirs()
      
      workspaces.open(name: string)
      
      workspaces.get(): table
      
      workspaces.name(): string|nil
      
      workspaces.path(): string|nil
      
      workspaces.sync_dirs()
      
      workspaces.get_custom(name: string): string|nil
      
      workspaces.set_custom(name: string, data: string)
      
      
      
      telescope.load_extension("workspaces")
      
      
      require("telescope").setup({
        extensions = {
          workspaces = {
            -- keep insert mode after selection in the picker, default is false
            keep_insert = true,
            -- Highlight group used for the path in the picker, default is "String"
            path_hl = "String"
          }
        }
      })
      
      
      require("workspaces").setup({
          hooks = {
              open = "FZF",
          }
      })
      
      
      require("workspaces").setup({
          hooks = {
              open = "NvimTreeOpen",
          }
      })
      
      
      require("workspaces").setup({
          hooks = {
              open_pre = {
                -- If recording, save current session state and stop recording
                "SessionsStop",
      
                -- delete all buffers (does not save changes)
                "silent %bdelete!",
              },
              open = function()
                require("sessions").load(nil, { silent = true })
              end,
          }
      })
      
      
      require("workspaces").setup({
          hooks = {
              open = { "NvimTreeOpen", "Telescope find_files" },
          }
      })
      
    end,
  },
  {
    "GnikDroy/projections.nvim",
    config = function()
      
      use({ 
          'gnikdroy/projections.nvim',
          config = function()
              require("projections").setup({
                  workspaces = {                                -- Default workspaces to search for 
                      -- { "~/Documents/dev", { ".git" } },        Documents/dev is a workspace. patterns = { ".git" }
                      -- { "~/repos", {} },                        An empty pattern list indicates that all subdirectories are considered projects
                      -- "~/dev",                                  dev is a workspace. default patterns is used (specified below)
                  },
                  -- patterns = { ".git", ".svn", ".hg" },      -- Default patterns to use if none were specified. These are NOT regexps.
                  -- store_hooks = { pre = nil, post = nil },   -- pre and post hooks for store_session, callable | nil
                  -- restore_hooks = { pre = nil, post = nil }, -- pre and post hooks for restore_session, callable | nil
                  -- workspaces_file = "path/to/file",          -- Path to workspaces json file
                  -- sessions_directory = "path/to/dir",        -- Directory where sessions are stored
              })
          end
      })
      
      
      use({
          "gnikdroy/projections.nvim",
          config = function()
              require("projections").setup({})
      
              -- Bind <leader>fp to Telescope projections
              require('telescope').load_extension('projections')
              vim.keymap.set("n", "<leader>fp", function() vim.cmd("Telescope projections") end)
      
              -- Autostore session on VimExit
              local Session = require("projections.session")
              vim.api.nvim_create_autocmd({ 'VimLeavePre' }, {
                  callback = function() Session.store(vim.loop.cwd()) end,
              })
      
              -- Switch to project if vim was started in a project dir
              local switcher = require("projections.switcher")
              vim.api.nvim_create_autocmd({ "VimEnter" }, {
                  callback = function()
                      if vim.fn.argc() == 0 then switcher.switch(vim.loop.cwd()) end
                  end,
              })
          end
      })
      
      
      vim.opt.sessionoptions:append("localoptions")       -- Save localoptions to session file
      
      
      -- If vim was started with arguments, do nothing
      -- If in some project's root, attempt to restore that project's session
      -- If not, restore last session
      -- If no sessions, do nothing
      local Session = require("projections.session")
      vim.api.nvim_create_autocmd({ "VimEnter" }, {
          callback = function()
              if vim.fn.argc() ~= 0 then return end
              local session_info = Session.info(vim.loop.cwd())
              if session_info == nil then
                  Session.restore_latest()
              else
                  Session.restore(vim.loop.cwd())
              end
          end,
          desc = "Restore last session automatically"
      })
      
      
      local Session = require("projections.session")
      vim.api.nvim_create_user_command("StoreProjectSession", function()
          Session.store(vim.loop.cwd())
      end, {})
      
      vim.api.nvim_create_user_command("RestoreProjectSession", function()
          Session.restore(vim.loop.cwd())
      end, {})
      
      
      local Workspace = require("projections.workspace")
      -- Add workspace command
      vim.api.nvim_create_user_command("AddWorkspace", function() 
          Workspace.add(vim.loop.cwd()) 
      end, {})
      
      
      workspaces = stdpath('data') .. 'projections_workspaces.json'
      sessions   = stdpath('cache') .. 'projections_sessions/'
      
      
      require("projections").setup({
          store_hooks = {
              pre = function()
                  -- nvim-tree 
                  local nvim_tree_present, api = pcall(require, "nvim-tree.api")
                  if nvim_tree_present then api.tree.close() end
      
                  -- neo-tree
                  if pcall(require, "neo-tree") then vim.cmd [[Neotree action=close]] end
              end
          }
      })
      
    end,
  },
  {
    "nyngwang/suave.lua",
    config = function()
      
      use {
        'nyngwang/suave.lua',
        config = function ()
          require('suave').setup {
            -- menu_height = 6,
            auto_save = {
              enabled = true,
              -- exclude_filetypes = {},
            },
            store_hooks = {
              -- WARN: DON'T call `vim.cmd('wa')` here. Use `setup.auto_save` instead. (See #4)
              before_mksession = {
                -- function ()
                --   -- `rcarriga/nvim-dap-ui`.
                --   require('dapui').close()
                -- end,
                -- function ()
                --   -- `nvim-neo-tree/neo-tree.nvim`.
                --   for _, w in ipairs(vim.api.nvim_list_wins()) do
                --     if vim.api.nvim_buf_get_option(vim.api.nvim_win_get_buf(w), 'ft') == 'neo-tree' then
                --       vim.api.nvim_win_close(w, false)
                --     end
                --   end
                -- end,
              },
              after_mksession = {
                -- NOTE: the `data` param is Lua table, which will be stored in json format under `.suave/` folder.
                function (data)
                  -- store current colorscheme.
                  data.colorscheme = vim.g.colors_name
                end,
              },
            },
            restore_hooks = {
              after_source = {
                function (data)
                  if not data then return end
                  -- restore colorscheme.
                  vim.cmd(string.format([[
                    color %s
                    doau ColorScheme %s
                  ]], data.colorscheme, data.colorscheme))
                end,
              },
            }
          }
        end
      }
      
    end,
  },
  {
    "desdic/telescope-rooter.nvim",
    config = function()
      
      
      dependencies = {
      	...
      	{"desdic/telescope-rooter.nvim"}
      	...
      }
      
      
      require "telescope".load_extension("rooter")
      
      
      require("telescope").extensions = {
          rooter = {
             enable = true,
             patterns = { ".git" }
          }
      }
      
    end,
  },
  {
    "SalOrak/whaler.nvim",
    config = function()
      
      return {
          "SalOrak/whaler"
      }
      
      
      -- Telescope setup()
      local telescope = require('telescope')
      
      telescope.setup({
          -- Your telescope setup here...
          extensions = {
              whaler = {
                  -- Whaler configuration
                  directories = { "path/to/dir", "path/to/another/dir", { path = "path/to/yet/another/dir", alias = "yet" } },
                  -- You may also add directories that will not be searched for subdirectories
                  oneoff_directories = { "path/to/project/folder",  { path = "path/to/another/project", alias = "Project Z" } },
              }
          }
      })
      -- More config here
      telescope.load_extension("whaler")
      --
      
      -- Open whaler using <leader>fw
      vim.keymap.set("n", "<leader>fw", function()
          local w = telescope.extensions.whaler.whaler
          w({
              -- Settings can also be called here.
              -- These would use but not change the setup configuration.
          })
       end,)
      
      -- Or directly
      vim.keymap.set("n", "<leader>fw", telescope.extensions.whaler.whaler)
      
      
      whaler = {
          directories = { "/home/user/projects", { path = "/home/user/work", alias = "work" } }, -- Path directories to search. By default the list is empty.
          oneoff_directories = { "/home/user/.config/nvim" }, -- Path directories to append directly to list of projects. By default is empty. 
          auto_file_explorer = true, -- Whether to automatically open file explorer. By default is `true`
          auto_cwd = true, -- Whether to automatically change current working directory. By default is `true`
          file_explorer = "netrw", -- Automagically creates a configuration for the file explorer of your choice. 
                                   -- Options are "netrw"(default), "nvimtree", "neotree", "oil", "telescope_file_browser", "rnvimr"
          file_explorer_config = { -- (OPTIONAL) Map to configure what command is triggered by which plugin. 
              hidden = false, -- Show hidden directories or not (default false)
                                   -- For basic configuration this is done automatically setting up the file_explorer config.
              plugin_name = "netrw", -- Plugin. Should be installed.
              command = "Explorer", -- The plugin command to open.
                                    -- Command must accept a path as parameter
              prefix_dir = " ",     -- Prefix string to be appended after the command and before the directory path. 
                                    -- Example: In the `telescope_file_browser` the value is ` path=`.
                                    --          The final command is `Telescope file_browser path=/path/to/dir`.
                                    -- By default is " " (space)
          },
          theme = {                -- Telescope theme default Whaler options.
              results_title = false, -- Either `false` or a string. 
              layout_strategy = "center",
              previewer = false,
              layout_config = {
                  height =  0.3,
                  width = 0.4
              },
              sorting_strategy = "ascending",
              border = true,
          } 
      }
      
      
      whaler = {
          -- Some config here
          file_explorer_config = {
              plugin_name = "netrw", -- Plugin name.
              command = "Vexplore", -- Vertical file explorer command
              prefix_dir = " ", -- (Optional) By default is space.  
          },
      }
      
      
      whaler = {
          directories = { "~/work" }, 
          auto_file_explorer = false, -- Do not open file explorer
          auto_cwd = true, -- But change working directory
      }
      
      
      -- Setup whaler
      whaler = {
          directories = { "/home/user/projects", { path = "/home/user/work", alias = "work" } },
          oneoff_directories = { "/home/user/.config/nvim" }, 
          auto_file_explorer = true, 
          auto_cwd = true, 
          file_explorer = "netrw",
          theme = {                -- Telescope theme default Whaler options.
              results_title = false,
              layout_strategy = "center",
              previewer = false,
              layout_config = {
                  height =  0.3,
                  width = 0.4
              },
              sorting_strategy = "ascending",
              border = true,
          } 
      }
      
      
      local keymap = vim.keymap
      keymap.set("n", "<leader>ww", telescope.extensions.whaler.whaler)
      keymap.set("n", "<leader>wn", function()
              local w = telescope.extensions.whaler.whaler
              w({
                  auto_file_explorer = true,
                  auto_cwd = false,
                  file_explorer_config = {
                  plugin_name = "telescope",
                  command = "Telescope find_files",
                  prefix_dir = " cwd=",
                  },
                  theme = {
                      previewer = false,
                  },
              })
          end)
              
      
      
      -- Setup rnvimr
      vim.api.nvim_create_user_command("RnvimrOpen", function(args)
          if #args.fargs == 1 then
             local arg = vim.fn.expand(args.fargs[1])
             vim.api.nvim_call_function("rnvimr#open", { arg })
          else
             vim.api.nvim_command("RnvimrToggle")
          end
      end, { nargs = "?" })
      
      vim.api.nvim_set_keymap( "n", "<leader>e", ":RnvimrOpen<CR>", { noremap = true, desc = "Ranger File Explorer" })
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-visits.md",
  },
  {
    "LintaoAmons/cd-project.nvim",
    config = function()
      
      -- using lazy.nvim
      return {
        "LintaoAmons/cd-project.nvim",
        tag = "v0.11.0", -- Optional, You can use pin to a tag for stability
      }
      
      
      ---@type CdProject.Config
      local opts = {
        -- this json file is acting like a database to update and read the projects in real time.
        -- So because it's just a json file, you can edit directly to add more paths you want manually
        projects_config_filepath = vim.fs.normalize(vim.fn.stdpath("config") .. "/cd-project.nvim.json"),
        -- this controls the behaviour of `CdProjectAdd` command about how to get the project directory
        project_dir_pattern = { ".git", ".gitignore", "Cargo.toml", "package.json", "go.mod" },
        choice_format = "both",        -- optional, you can switch to "name" or "path"
        projects_picker = "telescope", -- optional, you can switch to `vim-ui`
        auto_register_project = false, -- optional, toggle on/off the auto add project behaviour
        -- do whatever you like by hooks
        hooks = {
          {
            callback = function(dir)
              vim.notify("switched to dir: " .. dir)
            end,
          },
          {
            callback = function(dir)
              vim.notify("switched to dir: " .. dir)
            end,                         -- required, action when trigger the hook
            name = "cd hint",            -- optional
            order = 1,                   -- optional, the exection order if there're multiple hooks to be trigger at one point
            pattern = "cd-project.nvim", -- optional, trigger hook if contains pattern
            trigger_point = "DISABLE",   -- optional, enum of trigger_points, default to `AFTER_CD`
            match_rule = function(dir)   -- optional, a function return bool. if have this fields, then pattern will be ignored
              return true
            end,
          },
        }
      }
      
      return {
          "LintaoAmons/cd-project.nvim",
          tag = "v0.10.0", -- Optional, You can also use tag to pin the plugin version for stability
          init = function() -- use init if you want enable auto_register_project, otherwise config is good
            require("cd-project").setup(opts)
          end,
        }
      
    end,
  },
  {
    "LucasTavaresA/headers.nvim",
    config = function()
      
      use {
      	"lucastavaresa/headers.nvim",
      	config = function()
      		require("headers").setup()
      	end,
      }
      
      
      {
      	"lucastavaresa/headers.nvim",
      	config = function ()
      		require("headers").setup()
      	end,
      }
      
      
      -- Prepends/Appends the hovered header/footer
      vim.keymap.set("n", "<space>H", require("headers").fix_hovered)
      -- Ignore warnings for the current buffer root
      vim.keymap.set("n", "<space>I", require("headers").ignore)
      
      
      {
      	code_paths = {}, -- {} will warn everywhere, set one or more folders to warn only in those folders
      	paths_file = vim.fn.stdpath("data") .. "/headers.nvim/paths.lua",
      	non_code = { "sh", "zsh", "bash", "fish", "vim", "markdown", "txt", "json", "yaml", "toml", "ini", "html", "css", "sql", "xml", "cmake", "make", "diff", "patch", "git", "gitcommit", "gitconfig", "gitignore", "gitattributes", },
      }
      
    end,
  },
  {
    "zongben/proot.nvim",
    config = function()
      
      {
        "zongben/proot.nvim",
        dependencies = {
          "nvim-telescope/telescope.nvim",
          "nvim-lua/plenary.nvim"
        },
        opts = {}
      }
      
      
      {
        detector = {
          enable_file_detect = true,
          enable_lsp_detect = true,
        },
        files = { ".git" },
        ignore = {
          subpath = true, --If you are using monorepo, set to true to ignore subrepos
          lsp = nil, -- ignore lsp clients by name e.g. { "pyright", "tsserver" }
        },
        events = {
          -- called when new project is found
          detected = function(name, path)
          end
          -- called when you change the directory
          entered = function(name, path)
          end
        },
      }
      
      
      events = {
        entered = function ()
          vim.cmd("bufdo bd")
      
          for _, client in pairs(vim.lsp.get_clients()) do
            vim.lsp.stop_client(client)
          end
        end
      }
      
      
      local Terminal = require("toggleterm.terminal").Terminal
      local lazygit = Terminal:new({
        cmd = "lazygit",
        hidden = true,
        direction = "float",
        float_opts = {
          border = "curved",
        },
      })
      function Lazygit_toggle()
        lazygit.dir = vim.fn.getcwd()
        lazygit:toggle()
      end
      
    end,
  },
  {
    "wsdjeg/rooter.nvim",
    config = function()
      
      require('plug').add({
        {
          'wsdjeg/rooter.nvim',
          config = function()
            require('rooter').setup({
              root_pattern = { '.git/' },
            })
          end,
        }
      })
      
      
      require('rooter').setup({
        root_patterns = { '.git/' },
        outermost = true,
        enable_cache = true,
        project_non_root = '',  -- this can be '', 'home' or 'current'
        enable_logger = true,   -- enable runtime log via logger.nvim
        command = 'lcd',        -- cd, tcd or lcd
      })
      
      
      local c_runner = {
          exe = 'gcc',
          targetopt = '-o',
          usestdin = true,
          opt = { '-std=c11', '-xc', '-' },
      }
      require('code-runner').setup({
          runners = {
              c = { c_runner, '#TEMP#' },
          },
      })
      vim.keymap.set(
          'n',
          '<leader>lr',
          '<cmd>lua require("code-runner").open()<cr>',
          { silent = true }
      )
      
      -- make sure rooter.nvim plugin is loaded before code-runner
      
      local function update_clang_flag()
          if vim.fn.filereadable('.clang') == 1 then
              local flags = vim.fn.readfile('.clang')
              local opt = { '-std=c11' }
              for _, v in ipairs(flags) do
                  table.insert(opt, v)
              end
              table.insert(opt, '-xc')
              table.insert(opt, '-')
              c_runner.opt = opt
          end
      end
      
      require('rooter').reg_callback(update_clang_flag)
      
      
      require('plug').add({
        {
          'wsdjeg/rooter.nvim',
          config = function()
            require('rooter').setup({
              root_pattern = { '.git/' },
              enable_logger = true,
            })
          end,
          depends = {
            {
              'wsdjeg/logger.nvim',
              config = function()
                vim.keymap.set(
                  'n',
                  '<leader>hL',
                  '<cmd>lua require("logger").viewRuntimeLog()<cr>',
                  { silent = true }
                )
              end,
            },
          },
        },
      })
      
    end,
  },
  {
    "catgoose/nvim-colorizer.lua",
    config = function()
      
      {
          "catgoose/nvim-colorizer.lua",
          event = "BufReadPre",
          opts = { -- set to setup table
          },
      }
      
      
      use("catgoose/nvim-colorizer.lua")
      
      
      require("colorizer").setup()
      
      
      -- All options that can be passed to `user_default_options` in setup() can be
      -- passed to `attach_to_buffer`
      -- Similar for other functions
      
      -- Attach to buffer
      require("colorizer").attach_to_buffer(0, { mode = "background", css = true })
      
      -- Detach from buffer
      require("colorizer").detach_from_buffer(0, { mode = "virtualtext", css = true })
      
      
        require("colorizer").setup({
          filetypes = { "*" }, -- Filetype options.  Accepts table like `user_default_options`
          buftypes = {}, -- Buftype options.  Accepts table like `user_default_options`
          -- Boolean | List of usercommands to enable.  See User commands section.
          user_commands = true, -- Enable all or some usercommands
          lazy_load = false, -- Lazily schedule buffer highlighting setup function
          user_default_options = {
            names = true, -- "Name" codes like Blue or red.  Added from `vim.api.nvim_get_color_map()`
            names_opts = { -- options for mutating/filtering names.
              lowercase = true, -- name:lower(), highlight `blue` and `red`
              camelcase = true, -- name, highlight `Blue` and `Red`
              uppercase = false, -- name:upper(), highlight `BLUE` and `RED`
              strip_digits = false, -- ignore names with digits,
              -- highlight `blue` and `red`, but not `blue3` and `red4`
            },
            -- Expects a table of color name to #RRGGBB value pairs.  # is optional
            -- Example: { cool = "#107dac", ["notcool"] = "ee9240" }
            -- Set to false to disable, for example when setting filetype options
            names_custom = false, -- Custom names to be highlighted: table|function|false
            RGB = true, -- #RGB hex codes
            RGBA = true, -- #RGBA hex codes
            RRGGBB = true, -- #RRGGBB hex codes
            RRGGBBAA = false, -- #RRGGBBAA hex codes
            AARRGGBB = false, -- 0xAARRGGBB hex codes
            rgb_fn = false, -- CSS rgb() and rgba() functions
            hsl_fn = false, -- CSS hsl() and hsla() functions
            css = false, -- Enable all CSS *features*:
            -- names, RGB, RGBA, RRGGBB, RRGGBBAA, AARRGGBB, rgb_fn, hsl_fn
            css_fn = false, -- Enable all CSS *functions*: rgb_fn, hsl_fn
            -- Tailwind colors.  boolean|'normal'|'lsp'|'both'.  True sets to 'normal'
            tailwind = false, -- Enable tailwind colors
            tailwind_opts = { -- Options for highlighting tailwind names
              update_names = false, -- When using tailwind = 'both', update tailwind names from LSP results.  See tailwind section
            },
            -- parsers can contain values used in `user_default_options`
            sass = { enable = false, parsers = { "css" } }, -- Enable sass colors
            xterm = false, -- Enable xterm 256-color codes (#xNN, \e[38;5;NNNm)
            -- Highlighting mode.  'background'|'foreground'|'virtualtext'
            mode = "background", -- Set the display mode
            -- Virtualtext character to use
            virtualtext = "■",
            -- Display virtualtext inline with color.  boolean|'before'|'after'.  True sets to 'after'
            virtualtext_inline = false,
            -- Virtualtext highlight mode: 'background'|'foreground'
            virtualtext_mode = "foreground",
            -- update color values even if buffer is not focused
            -- example use: cmp_menu, cmp_docs
            always_update = false,
            -- hooks to invert control of colorizer
            hooks = {
              -- called before line parsing.  Accepts boolean or function that returns boolean
              -- see hooks section below
              disable_line_highlight = false,
            },
          },
        })
      
      
      ---@param line string: Line's contents
      ---@param bufnr number: Buffer number
      ---@line_num number: Line number (0-indexed).  Add 1 to get the line number in buffer
      ---@return boolean: Return true if current line should be parsed for highlighting.
      function(line, bufnr, line_num)
        -- Treesitter could also be used, but be warned it will be quite laggy unless you are caching results somehow
        return string.sub(line, 1, 2) ~= "--"
      end
      
      
      -- Attaches to every FileType with default options
      require("colorizer").setup()
      
      -- Attach to certain Filetypes, add special `mode` configuration for `html`
      -- Use `background` for everything else.
      require("colorizer").setup({
        filetypes = {
          "css",
          "javascript",
          html = { mode = "foreground" },
        },
      })
      
      -- Use `user_default_options` as the second parameter, which uses
      -- `background` for every mode. This is the inverse of the previous
      -- setup configuration.
      require("colorizer").setup({
        filetypes = {
          "css",
          "javascript",
          html = { mode = "foreground" },
        },
        user_default_options = { mode = "background" },
      })
      
      -- Use default for all filetypes with overrides for css and html
      require("colorizer").setup({
        filetypes = {
          "*", -- Highlight all files, but customize some others.
          css = { rgb_fn = true }, -- Enable parsing rgb(...) functions in css.
          html = { names = false }, -- Disable parsing "names" like Blue or Gray
        },
      })
      
      -- Exclude some filetypes from highlighting by using `!`
      require("colorizer").setup({
        filetypes = {
          "*", -- Highlight all files, but customize some others.
          "!vim", -- Exclude vim from highlighting.
          -- Exclusion Only makes sense if '*' is specified first!
        },
      })
      
      -- Always update the color values in cmp_docs even if it not focused
      require("colorizer").setup({
        filetypes = {
          "*", -- Highlight all files, but customize some others.
          cmp_docs = { always_update = true },
        },
      })
      
      -- Only enable ColorizerToggle and ColorizerReloadAllBuffers user_command
      require("colorizer").setup({
        user_commands = { "ColorizerToggle", "ColorizerReloadAllBuffers" },
      })
      
      -- Apply names_custom from theme
      -- names_custom are stored by hashed key to allow filetype to override `user_default_options`
      require("colorizer").setup({
        names = true,
        names_custom = function()
          local colors = require("kanagawa.colors").setup({ theme = "dragon" })
          return colors.palette
        end,
        filetypes = {
          "*",
          lua = { -- use different theme for lua filetype
            names_custom = function()
              local colors = require("kanagawa.colors").setup({ theme = "wave" })
              return colors.palette
            end,
          },
        },
      })
      
      -- Enable support for xterm 256-color codes (`#xNN`, `\e[38;5;NNNm`) by setting the `xterm` option:
      require("colorizer").setup({
        user_default_options = {
          xterm = true,
        },
      })
      
      
      require("colorizer").setup({
        user_default_options = {
          names = false,
          css = true,
        },
      })
      
      
      require("colorizer").setup({
        user_default_options = {
          css_fn = false,
          css = true,
        },
      })
      
      
      -- Alwyas update the color values in cmp_docs even if it not focused
      require("colorizer").setup({
        filetypes = {
          "*", -- Highlight all files, but customize some others.
          cmp_docs = { always_update = true },
        },
      })
      
      
      -- need to specify buftypes
      require("colorizer").setup(
        buftypes = {
            "*",
            -- exclude prompt and popup buftypes from highlight
            "!prompt",
            "!popup",
          }
      )
      
      
      return {
        "catgoose/nvim-colorizer.lua",
        event = "VeryLazy",
        opts = {
          lazy_load = true,
          -- other setup options
        },
      }
      
    end,
  },
  {
    "winston0410/range-highlight.nvim",
    config = function()
      
      require("lazy").setup({
          {
              "winston0410/range-highlight.nvim",
              event = { "CmdlineEnter" },
              opts = {},
          }
      })
      ,
      
      
      require("range-highlight").setup({ 
      	highlight = {
      		group = "Visual",
      		priority = 10,
      		-- if you want to highlight empty line, set it to true
      		to_eol = false,
      	},
      	-- disable range highlight, if the cmd is matched here. Value here does not accept shorthand
      	excluded = { cmd = {} },
      	debounce = {
      		-- how long to debounce, set to 0 to disable
      		wait = 100,
      	},
      })
      
      
      require("range-highlight").setup({ 
      	excluded = { cmd = { "substitute" } },
      })
      
    end,
  },
  {
    "xiyaowong/transparent.nvim",
    config = function()
      
       -- Optional, you don't have to run setup.
      require("transparent").setup({
        -- table: default groups
        groups = {
          'Normal', 'NormalNC', 'Comment', 'Constant', 'Special', 'Identifier',
          'Statement', 'PreProc', 'Type', 'Underlined', 'Todo', 'String', 'Function',
          'Conditional', 'Repeat', 'Operator', 'Structure', 'LineNr', 'NonText',
          'SignColumn', 'CursorLine', 'CursorLineNr', 'StatusLine', 'StatusLineNC',
          'EndOfBuffer',
        },
        -- table: additional groups that should be cleared
        extra_groups = {},
        -- table: groups you don't want to clear
        exclude_groups = {},
        -- function: code to be executed after highlight groups are cleared
        -- Also the user event "TransparentClear" will be triggered
        on_clear = function() end,
      })
      
      
      vim.g.transparent_groups = vim.list_extend(vim.g.transparent_groups or {}, { "ExtraGroup" })
      -- vimscript: let g:transparent_groups = extend(get(g:, 'transparent_groups', []), ["ExtraGroup"])
      
      
      vim.g.transparent_groups = vim.list_extend(
        vim.g.transparent_groups or {},
        vim.tbl_map(function(v)
          return v.hl_group
        end, vim.tbl_values(require('bufferline.config').highlights))
      )
      
      
      require('transparent').clear_prefix('BufferLine')
      
      
      require('transparent').clear_prefix('NeoTree')
      
      
      require('transparent').clear_prefix('lualine')
      
      
      {
        extra_groups = {
          "NormalFloat", -- plugins which have float panel such as Lazy, Mason, LspInfo
          "NvimTreeNormal" -- NvimTree
        },
      }
      
    end,
  },
  {
    "folke/twilight.nvim",
    config = function()
      
      -- Lua
      {
        "folke/twilight.nvim",
        opts = {
          -- your configuration comes here
          -- or leave it empty to use the default settings
          -- refer to the configuration section below
        }
      }
      
      
      {
        dimming = {
          alpha = 0.25, -- amount of dimming
          -- we try to get the foreground from the highlight groups or fallback color
          color = { "Normal", "#ffffff" },
          term_bg = "#000000", -- if guibg=NONE, this will be used to calculate text color
          inactive = false, -- when true, other windows will be fully dimmed (unless they contain the same buffer)
        },
        context = 10, -- amount of lines we will try to show around the current line
        treesitter = true, -- use treesitter when available for the filetype
        -- treesitter is used to automatically expand the visible text,
        -- but you can further control the types of nodes that should always be fully expanded
        expand = { -- for treesitter, we we always try to expand to the top-most ancestor with these types
          "function",
          "method",
          "table",
          "if_statement",
        },
        exclude = {}, -- exclude these filetypes
      }
      
    end,
  },
  {
    "koenverburg/peepsight.nvim",
  },
  {
    "uga-rosa/ccc.nvim",
  },
  {
    "ziontee113/color-picker.nvim",
    config = function()
      
      use ({"ziontee113/color-picker.nvim",
          config = function()
              require("color-picker")
          end,
      })
      
      
      Plug 'ziontee113/color-picker.nvim'
      -- Initialize the plugin
      require('color-picker').setup()
      
      
      local opts = { noremap = true, silent = true }
      
      vim.keymap.set("n", "<C-c>", "<cmd>PickColor<cr>", opts)
      vim.keymap.set("i", "<C-c>", "<cmd>PickColorInsert<cr>", opts)
      
      -- vim.keymap.set("n", "your_keymap", "<cmd>ConvertHEXandRGB<cr>", opts)
      -- vim.keymap.set("n", "your_keymap", "<cmd>ConvertHEXandHSL<cr>", opts)
      
      require("color-picker").setup({ -- for changing icons & mappings
      	-- ["icons"] = { "ﱢ", "" },
      	-- ["icons"] = { "ﮊ", "" },
      	-- ["icons"] = { "", "ﰕ" },
      	-- ["icons"] = { "", "" },
      	-- ["icons"] = { "", "" },
      	["icons"] = { "ﱢ", "" },
      	["border"] = "rounded", -- none | single | double | rounded | solid | shadow
      	["keymap"] = { -- mapping example:
      		["U"] = "<Plug>ColorPickerSlider5Decrease",
      		["O"] = "<Plug>ColorPickerSlider5Increase",
      	},
      	["background_highlight_group"] = "Normal", -- default
      	["border_highlight_group"] = "FloatBorder", -- default
        ["text_highlight_group"] = "Normal", --default
      })
      
      vim.cmd([[hi FloatBorder guibg=NONE]]) -- if you don't want weird border background colors around the popup.
      
    end,
  },
  {
    "lcheylus/overlength.nvim",
    config = function()
      
      use 'lcheylus/overlength.nvim'
      
      
      { 'lcheylus/overlength.nvim' }
      
      
      require('overlength').setup()
      
      
      require('overlength').setup({
         -- Overlength highlighting enabled by default
        enabled = true,
      
        -- Colors for OverLength highlight group
        colors = {
          ctermfg = nil,
          ctermbg = 'darkgrey',
          fg = nil,
          bg = '#8B0000',
        }
      
        -- Mode to use textwidth local options
        -- 0: Don't use textwidth at all, always use config.default_overlength.
        -- 1: Use `textwidth, unless it's 0, then use config.default_overlength.
        -- 2: Always use textwidth. There will be no highlighting where
        --    textwidth == 0, unless added explicitly
        textwidth_mode = 2,
        -- Default overlength with no filetype
        default_overlength = 80,
        -- How many spaces past your overlength to start highlighting
        grace_length = 1,
        -- Highlight only the column or until the end of the line
        highlight_to_eol = true,
      
        -- List of filetypes to disable overlength highlighting
        disable_ft = { 'qf', 'help', 'man', 'checkhealth', 'lazy', 'packer', 'NvimTree', 'Telescope', 'TelescopePrompt', 'TelescopeResults', 'WhichKey' },
      })
      
      
      require('overlength').setup({ colors = { bg='#592929' } })
      
      
      :lua require('overlength').set_overlength(python, 100)
      
      
      :lua require('overlength').set_overlength(markdown, 0)
      
    end,
  },
  {
    "brenoprata10/nvim-highlight-colors",
    config = function()
      
      'brenoprata10/nvim-highlight-colors'
      
      
      -- Ensure termguicolors is enabled if not already
      vim.opt.termguicolors = true
      
      require('nvim-highlight-colors').setup({})
      
      
      require("cmp").setup({
              ... other configs
              formatting = {
                      format = require("nvim-highlight-colors").format
              }
      })
      
      
      require("cmp").setup({
              ... other configs
              formatting = {
                      format = function(entry, item)
                              item = -- YOUR other configs come first
                              return require("nvim-highlight-colors").format(entry, item)
                      end
              }
      })
      
      
      require("cmp").setup({
              ... other configs
              formatting = {
                      format = function(entry, item)
                              local color_item = require("nvim-highlight-colors").format(entry, { kind = item.kind })
                              item = require("lspkind").cmp_format({
                                      -- any lspkind format settings here
                              })(entry, item)
                              if color_item.abbr_hl_group then
                                      item.kind_hl_group = color_item.abbr_hl_group
                                      item.kind = color_item.abbr
                              end
                              return item
                      end
              }
      })
      
      
      require("blink.cmp").setup {
      	completion = {
      		menu = {
      			draw = {
      				components = {
      					-- customize the drawing of kind icons
      					kind_icon = {
      						text = function(ctx)
      						  -- default kind icon
      						  local icon = ctx.kind_icon
      							-- if LSP source, check for color derived from documentation
      							if ctx.item.source_name == "LSP" then
      								local color_item = require("nvim-highlight-colors").format(ctx.item.documentation, { kind = ctx.kind })
      								if color_item and color_item.abbr ~= "" then
      								  icon = color_item.abbr
      								end
      							end
      							return icon .. ctx.icon_gap
      						end,
      						highlight = function(ctx)
      							-- default highlight group
      							local highlight = "BlinkCmpKind" .. ctx.kind
      							-- if LSP source, check for color derived from documentation
      							if ctx.item.source_name == "LSP" then
      								local color_item = require("nvim-highlight-colors").format(ctx.item.documentation, { kind = ctx.kind })
      								if color_item and color_item.abbr_hl_group then
      								  highlight = color_item.abbr_hl_group
      								end
      							end
      							return highlight
      						end,
      					},
      				},
      			},
      		},
      	},
      }
      
      
      require("nvim-highlight-colors").setup {
      	---Render style
      	---@usage 'background'|'foreground'|'virtual'
      	render = 'background',
      
      	---Set virtual symbol (requires render to be set to 'virtual')
      	virtual_symbol = '■',
      
      	---Set virtual symbol suffix (defaults to '')
      	virtual_symbol_prefix = '',
      
      	---Set virtual symbol suffix (defaults to ' ')
      	virtual_symbol_suffix = ' ',
      
      	---Set virtual symbol position()
       	---@usage 'inline'|'eol'|'eow'
       	---inline mimics VS Code style
       	---eol stands for `end of column` - Recommended to set `virtual_symbol_suffix = ''` when used.
       	---eow stands for `end of word` - Recommended to set `virtual_symbol_prefix = ' ' and virtual_symbol_suffix = ''` when used.
      	virtual_symbol_position = 'inline',
      
      	---Highlight hex colors, e.g. '#FFFFFF'
      	enable_hex = true,
      
          	---Highlight short hex colors e.g. '#fff'
      	enable_short_hex = true,
      
      	---Highlight rgb colors, e.g. 'rgb(0 0 0)'
      	enable_rgb = true,
      
      	---Highlight hsl colors, e.g. 'hsl(150deg 30% 40%)'
      	enable_hsl = true,
      	
      	---Highlight ansi colors, e.g '\033[0;34m'
      	enable_ansi = true,
      
        -- Highlight hsl colors without function, e.g. '--foreground: 0 69% 69%;'
        enable_hsl_without_function = true,
      
      	---Highlight CSS variables, e.g. 'var(--testing-color)'
      	enable_var_usage = true,
      
      	---Highlight named colors, e.g. 'green'
      	enable_named_colors = true,
      
      	---Highlight tailwind colors, e.g. 'bg-blue-500'
      	enable_tailwind = false,
      
      	---Set custom colors
      	---Label must be properly escaped with '%' to adhere to `string.gmatch`
      	--- :help string.gmatch
      	custom_colors = {
      		{ label = '%-%-theme%-primary%-color', color = '#0f1219' },
      		{ label = '%-%-theme%-secondary%-color', color = '#5a5d64' },
      	},
      
       	-- Exclude filetypes or buftypes from highlighting e.g. 'exclude_buftypes = {'text'}'
          	exclude_filetypes = {},
          	exclude_buftypes = {},
       	-- Exclude buffer from highlighting e.g. 'exclude_buffer = function(bufnr) return vim.fn.getfsize(vim.api.nvim_buf_get_name(bufnr)) > 1000000 end'
          	exclude_buffer = function(bufnr) end
      }
      
      
      require("nvim-highlight-colors").turnOn()
      require("nvim-highlight-colors").turnOff()
      require("nvim-highlight-colors").toggle()
      require("nvim-highlight-colors").is_active()
      
    end,
  },
  {
    "max397574/colortils.nvim",
  },
  {
    "Mr-LLLLL/interestingwords.nvim",
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-hipatterns.md",
  },
  {
    "miversen33/sunglasses.nvim",
    config = function()
      
      require("lazy").setup({"miversen33/sunglasses.nvim", config = true})
      
      
      require("lazy").setup({"miversen33/sunglasses.nvim", config = true, event = "UIEnter"})
      
      
      -- Config: https://github.com/miversen33
      {
          filter_type = "SHADE",
          filter_percent = .65
      }
      
      
      -- Config: https://github.com/miversen33
      {
          filter_type = "TINT",
          filter_percent = .65
      }
      
      
      -- Config: https://github.com/miversen33
      {
          filter_type = "NOSYNTAX",
          filter_percent = .65
      }
      
      
      -- Config: https://github.com/miversen33
      {
          filter_type = "NOSYNTAX",
          filter_percent = .65
      }
      
      
      -- Config: https://github.com/miversen33
      {
          filter_type = "TINT",
          filter_percent = .65
      }
      
      
      -- Config: https://github.com/miversen33
      {
          filter_type = "NOSYNTAX",
          filter_percent = .65
      }
      
      
      -- Config: https://github.com/miversen33
      {
          filter_type = "SHADE",
          filter_percent = .65
      }
      
      
      -- Config: https://github.com/miversen33
      {
          filter_type = "TINT",
          filter_percent = .65
      }
      
      
      -- Config: https://github.com/miversen33
      {
          filter_type = "NOSYNTAX",
          filter_percent = .65
      }
      
      
      -- lua
      local sunglasses_defaults = {
          filter_percent = 0.65,
          filter_type = "SHADE",
          log_level = "ERROR",
          refresh_timer = 5,
          excluded_filetypes = {
              "dashboard",
              "lspsagafinder",
              "packer",
              "checkhealth",
              "mason",
              "NvimTree",
              "neo-tree",
              "plugin",
              "lazy",
              "TelescopePrompt",
              "alpha",
              "toggleterm",
              "sagafinder",
              "better_term",
              "fugitiveblame",
              "starter",
              "NeogitPopup",
              "NeogitStatus",
              "DiffviewFiles",
              "DiffviewFileHistory",
              "DressingInput",
              "spectre_panel",
              "zsh",
              "registers",
              "startuptime",
              "OverseerList",
              "Outline",
              "Navbuddy",
              "noice",
              "notify",
              "saga_codeaction",
              "sagarename"
          },
          excluded_highlights = {
              "WinSeparator",
              {"lualine_.*", glob = true},
          },
          can_shade_callback = function(opts)
              local conditions = {
                  function()
                      return vim.api.nvim_get_option_value("diff", { win = opts.window })
                  end,
              }
      
              for _, condition in ipairs(conditions) do
                  if condition() then
                      return false
                  end
              end
      
              return true
          end,
      }
      
      -- The above table will is the default configuration.
      -- If you do not wish to set any configuration options, you can simply
      -- pass nil into your setup
      require("sunglasses").setup()
      -- Or you can provide your own values. Please configure your
      -- options by looking at each option available and setting it
      require("sunglasses").setup({
          filter_percent = 0.65,
          filter_type = "SHADE",
          log_level = "ERROR",
          refresh_timer = 5,
          excluded_filetypes = {
              "dashboard",
              "lspsagafinder",
              "packer",
              "checkhealth",
              "mason",
              "NvimTree",
              "neo-tree",
              "plugin",
              "lazy",
              "TelescopePrompt",
              "alpha",
              "toggleterm",
              "sagafinder",
              "better_term",
              "fugitiveblame",
              "starter",
              "NeogitPopup",
              "NeogitStatus",
              "DiffviewFiles",
              "DiffviewFileHistory",
              "DressingInput",
              "spectre_panel",
              "zsh",
              "registers",
              "startuptime",
              "OverseerList",
              "Outline",
              "Navbuddy",
              "noice",
              "notify",
              "saga_codeaction",
              "sagarename"
          },
          excluded_highlights = {
              "WinSeparator",
              {"lualine_.*", glob = true},
          },
          can_shade_callback = function(opts)
              local conditions = {
                  function()
                      return vim.api.nvim_get_option_value("diff", { win = opts.window })
                  end,
              }
      
              for _, condition in ipairs(conditions) do
                  if condition() then
                      return false
                  end
              end
      
              return true
          end,
      })
      
      
      -- lua
      local sunglasses_options = {
          filter_percent = 0.65
      }
      
      require("sunglasses").setup(sunglasses_options)
      
      
      -- lua
      local sunglasses_options = {
          filter_type = "SHADE"
      }
      
      require("sunglasses").setup(sunglasses_options)
      
      
      -- lua
      print(vim.fn.stdpath('log') .. '/sunglasses.log')
      
      
      -- lua
      local sunglasses_options = {
          filter_level = "ERROR"
      }
      require("sunglasses").setup(sunglasses_options)
      
      
      -- lua
      local sunglasses_options = {
          refresh_timer = 5
      }
      require("sunglasses").setup(refresh_timer)
      
      
      -- lua
      {
          "dashboard",
          "lspsagafinder",
          "packer",
          "checkhealth",
          "mason",
          "NvimTree",
          "neo-tree",
          "plugin",
          "lazy",
          "TelescopePrompt",
          "alpha",
          "toggleterm",
          "sagafinder",
          "better_term",
          "fugitiveblame",
          "starter",
          "NeogitPopup",
          "NeogitStatus",
          "DiffviewFiles",
          "DiffviewFileHistory",
          "DressingInput",
          "spectre_panel",
          "zsh",
          "registers",
          "startuptime",
          "OverseerList",
          "Outline",
          "Navbuddy",
          "noice",
          "notify",
          "saga_codeaction",
          "sagarename"
      }
      
      
      -- lua
      local sunglasses_options = {
          excluded_filetypes = {
              "lazy"
          }
      }
      require("sunglasses").setup(sunglasses_options)
      
      
      -- lua
      {
          "WinSeparator",
          {"lualine_.*", glob = true},
      }
      
      
      -- lua
      local sunglasses_options = {
          excluded_highlights = {
              "WinSeparator"
          }
      }
      require("sunglasses").setup(sunglasses_options)
      
      
          -- lua
          can_shade_callback = function(opts)
              -- opts: { window_id = number, buffer = number, filetype = string, filename = string }
              local conditions = {
                  function()
                      return vim.api.nvim_get_option_value("diff", { win = opts.window })
                  end,
              }
      
              for _, condition in ipairs(conditions) do
                  if condition() then
                      return false
                  end
              end
      
              return true
          end,
      
    end,
  },
  {
    "rasulomaroff/reactive.nvim",
    config = function()
      
      { 'rasulomaroff/reactive.nvim' }
      
      
      use { 'rasulomaroff/reactive.nvim' }
      
      
      require('reactive').setup {
        builtin = {
          cursorline = true,
          cursor = true,
          modemsg = true
        }
      }
      
      
      require('reactive').add_preset {
        -- your preset configuration here
      }
      
      
      require('reactive').setup {
        configs = {
          -- a key here is a preset name, a value can be a boolean (if false, presets will be disabled)
          -- or a table that overwrites preset's values
          presetone = {
            modes = {
              i = {
                winhl = {
                  -- overwrites StatusLine highlight group in insert mode
                  StatusLine = { bg = '', fg = '' }
                }
              }
            }
          },
          -- disables `presettwo`
          presettwo = false
        }
      }
      
      
      require('reactive').setup {
        load = { 'yourpresetname' } -- you can also use a string
      }
      
      
      local my_preset = {
        name = 'my-preset',
        skip = function()
          return vim.api.nvim_buf_get_option(0, 'buftype') == ''
        end,
        modes = {
          n = {
            -- normal mode configuration
          },
          i = {
            -- insert mode configuration
          }
        }
      }
      
      
      winhl = {
        StatusLine = { fg = '#000000', bg = '#ffffff' }
      }
      
      
      hl = {
        Cursor = { fg = '#00ff00', bg = '#ff00ff' }
      }
      
      
      operators = {
        d = {
          winhl = {
            -- if the `no` mode has StatusLine highlight, it will be overwritten by this one below
            StatusLine = { fg = 'yourcolor', bg = 'yourcolor' }
          }
        }
      }
      
      
      modes = {
        i = {
          from = function(modes)
            -- callback that will be executed every time you leave an insert mode
          end
        }
      }
      
      
      modes = {
        n = {
          to = function(modes)
            -- callback that will be executed every time you enter a normal mode
          end
        }
      }
      
      
      local my_preset = {
        name = 'my-preset',
        init = function()
          -- making our cursor to use `MyCursor` highlight group
          vim.opt.guicursor:append 'MyCursor'
        end,
        modes = {
          n = {
            winhl = {
              -- we use `winhl` because we want to highlight CursorLine only in a current window, not in all of them
              -- if you want to change global highlights, use the `hl` field instead.
              CursorLine = { bg = '#21202e' }
            },
            hl = {
              MyCursor = { bg = '#FFFFFF' }
            },
          },
          no = {
            -- You can also specify winhl and hl that will be applied with every operator
            winhl = {},
            hl = {},
            operators = {
              d = {
                winhl = {
                  CursorLine = { bg = '#450a0a' }
                },
                hl = {
                  MyCursor = { bg = '#fca5a5' }
                }
              },
              y = {
                winhl = {
                  CursorLine = { bg = '#422006' },
                },
                hl = {
                  MyCursor = { bg = '#fdba74' }
                }
              }
            }
          },
          i = {
            winhl = {
              CursorLine = { bg = '#042f2e' }
            },
            hl = {
              MyCursor = { bg = '#5eead4' }
            }
          }
        }
      }
      
      
      {
        modes = {
          -- here is your modes config
        },
        static = {
          hl = {
            -- put your `fallback` highlights here
          },
          winhl = {
            active = {
              -- put your highlights for a current window here
            },
            inactive = {
              -- put your highlights for non-current windows here
            }
          },
        }
      }
      
      
      modes = {
        -- \x16 here stands for visual block mode, which you can cause by pressing CTRL + v
        [{ 'v', 'V', '\x16' }] = {
          -- your config here
        }
      }
      
      
      modes = {
        [{ 's', 'S', '\x13' }] = {
          -- your config here
        }
      }
      
      
      return {
        name = 'statusline', -- this field is required and should match your file name
        modes = {
          i = {
            hl = {
              StatusLine = {}
            }
          }
        }
      }
      
      
      require('reactive').setup {
        load = 'statusline' -- you can also use a table if you want to load several presets like that { 'statusline', 'another' }
      }
      
      
      require('reactive').load_preset 'statusline'
      
      
      operators = {
        d = {}
      }
      
      
      vim.keymap.set("n", "s", require('substitute').operator, { noremap = true })
      
      
      vim.keymap.set("n", "s", function()
        -- this way reactive will know that substitute's operator is triggered
        -- the string you pass into this function should be unique across other custom operators
        -- this method should called BEFORE the actual function
        require('reactive').set_opfunc 's'
        require('substitute').operator()
      end, { noremap = true })
      
      
      operators = {
        ['g@'] = {
          -- don't forget you can also set highlights for each custom operator, that will be applied
          -- every time the `g@` operator is triggered
          winhl = {},
          hl = {},
          opfuncs = {
            -- 's' here is that unique name we passed into the `set_opfunc` method in the mapping 
            s = {
              winhl = {
                StatusLine = { bg = '#5b21b6' }
              }
            }
          }
        }
      }
      
      
      {
        modes = {
          [{ 'n', 'i', 'v' }] = {
            -- shared mode config for a normal, insert and visual mode
          },
          no = {
            operators = {
              [{ 'd', 'c' }] = {
                -- shared mode config for delete and change operators
              },
              ['g@'] = {
                opfuncs = {
                  [{ 'firstoperator', 'secondoperator' }] = {
                    -- shared mode config for your custom operators
                  }
                }
              }
            }
          }
        }
      }
      
      
      modes = {
        n = {
          winhl = {
            WinBar = { ... }
            StatusLine = { ... }
          }
        },
        no = {
          winhl = {
            WinBar = { ... }
          }
        }
      }
      
      
      require('reactive').add_preset {
        name = 'your preset name',
        -- other fields
        -- do not forget about `lazy` field, if you want to delegate your preset activation to a user
      }
      
      
      return {
        name = 'test', -- should be the same as the file name
        modes = {
          i = {
            winhl = {},
            hl = {}
          }
        },
        -- other fields
        -- do not forget about `lazy` field, if you want to delegate your preset activation to a user
      }
      
      
      require('reactive').load_preset 'test'
      
      
      require('reactive').setup {
        configs = {
          ['your preset name'] = {
            -- here they can put custom configuration
          },
          -- alternatively, to disable your plugin they can specify a boolean value
          ['your preset name'] = false -- or true, if your plugin is lazy and a user action is required to enable it
        }
      }
      
    end,
  },
  {
    "moyiz/command-and-cursor.nvim",
    config = function()
      
      {
        "moyiz/command-and-cursor.nvim",
        event = "VeryLazy",
        opts = {},
      }
      
      
      M.defaults = {
        hl_group = "TermCursor", -- The highlight group to use.
        hl_priority = 300,       -- Priority of highlight
        inclusive = true,        -- Highlight cursor with visual selection.
        debug_position = false,  -- Show start and end positions with `vim.notify`.
      }
      
    end,
  },
  {
    "rachartier/tiny-devicons-auto-colors.nvim",
    config = function()
      
      {
          "rachartier/tiny-devicons-auto-colors.nvim",
          dependencies = {
              "nvim-tree/nvim-web-devicons"
          },
          event = "VeryLazy",
          config = function()
              require('tiny-devicons-auto-colors').setup()
          end
      }
      
      
      
      -- You can add as many colors as you like. More colors is better to estimate the nearest color for each devicon.
      local theme_colors = require("catppuccin.palettes").get_palette("macchiato")
      
      require('tiny-devicons-auto-colors').setup({
          colors = theme_colors,
      })
      
      
      require('tiny-devicons-auto-colors').setup({
          colors = {
              "#0000ff",
              "#00ffe6",
              "#00ff00",
              "#ff00ff",
              "#ff8000",
              "#6e00ff",
              "#ff0000",
              "#ffffff",
              "#ffff00",
              "#00a1ff",
              "#00ffe6"
          },
      })
      
      
      -- Default configuration
      require('tiny-devicons-auto-colors').setup({
          -- A table of color codes that the plugin will use to assign colors to devicons.
          -- It is preferable to use a color palette from a theme, but you can also define it yourself.
          -- If not provided, the plugin will fetch highlights from the current theme to generate a color palette.
          -- colors = theme_colors,
      
          -- Adjusts factors to get a better color matching.
          factors = {
              lightness = 1.75, -- Adjust the lightness factor.
              chroma = 1,       -- Adjust the chroma factor.
              hue = 1.25, 	  -- Adjust the hue factor.
          },
      
          -- Cache greatly improve the performance of the plugin. It saves all the matchings in a file.
          cache = {
              enabled = true,
              path = vim.fn.stdpath("cache") .. "/tiny-devicons-auto-colors-cache.json",
          },
      
          -- Precise search can result in better colors matching by automatically tweaking the factors.
          -- It's nice to let it enabled when cache is enabled.
          precise_search = {
              enabled = true,
              iteration = 10,   -- It goes hand in hand with 'precision'
              precision = 20,   -- The higher the precision, better the search is
              threshold = 23,   -- Threshold to consider a color as a match (larger is more permissive)
          },
      
          -- A list of icon name to ignore.
          -- You can refer to: https://github.com/nvim-tree/nvim-web-devicons/blob/master/lua/nvim-web-devicons/icons-default.lua
          -- to get the icon's name.
          --
          -- example:
          -- ignore = {
          -- 		"lua",
          -- 		"vim",
          -- 		"cs",
          -- 		"json"
          -- }
          ignore = {
          }
      
          -- Automatically reload the colors when the colorscheme changes.
          -- Warning: when reloaded, it overrides the colors that you set in `colors`.
          -- It can produce varying results according to the colorscheme, so if you always use the same colorscheme, you can keep it disabled.
          autoreload = false,
      })
      
    end,
  },
  {
    "TaDaa/vimade",
    config = function()
      
          {{
            'tadaa/vimade',
            -- default opts (you can partially set these or configure them however you like)
            opts = {
              -- Recipe can be any of 'default', 'minimalist', 'duo', and 'ripple'
              -- Set animate = true to enable animations on any recipe.
              -- See the docs for other config options.
              recipe = {'default', {animate=false}},
              -- ncmode = 'windows' will fade inactive windows.
              -- ncmode = 'focus' will only fade after you activate the `:VimadeFocus` command.
              ncmode = 'buffers',
              fadelevel = 0.4, -- any value between 0 and 1. 0 is hidden and 1 is opaque.
              -- Changes the real or theoretical background color. basebg can be used to give
              -- transparent terminals accurating dimming.  See the 'Preparing a transparent terminal'
              -- section in the README.md for more info.
              -- basebg = [23,23,23],
              basebg = '',
              tint = {
                -- bg = {rgb={0,0,0}, intensity=0.3}, -- adds 30% black to background
                -- fg = {rgb={0,0,255}, intensity=0.3}, -- adds 30% blue to foreground
                -- fg = {rgb={120,120,120}, intensity=1}, -- all text will be gray
                -- sp = {rgb={255,0,0}, intensity=0.5}, -- adds 50% red to special characters
                -- you can also use functions for tint or any value part in the tint object
                -- to create window-specific configurations
                -- see the `Tinting` section of the README for more details.
              },
              -- prevent a window or buffer from being styled. You 
              blocklist = {
                default = {
                  highlights = {
                    laststatus_3 = function(win, active)
                      -- Global statusline, laststatus=3, is currently disabled as multiple windows take
                      -- ownership of the StatusLine highlight (see #85).
                      if vim.go.laststatus == 3 then
                          -- you can also return tables (e.g. {'StatusLine', 'StatusLineNC'})
                          return 'StatusLine'
                      end
                    end,
                    -- Prevent ActiveTabs from highlighting.
                    'TabLineSel',
                    'Pmenu',
                    'PmenuSel',
                    'PmenuKind',
                    'PmenuKindSel',
                    'PmenuExtra',
                    'PmenuExtraSel',
                    'PmenuSbar',
                    'PmenuThumb',
                    -- Lua patterns are supported, just put the text between / symbols:
                    -- '/^StatusLine.*/' -- will match any highlight starting with "StatusLine"
                  },
                  buf_opts = { buftype = {'prompt'} },
                  -- buf_name = {'name1','name2', name3'},
                  -- buf_vars = { variable = {'match1', 'match2'} },
                  -- win_opts = { option = {'match1', 'match2' } },
                  -- win_vars = { variable = {'match1', 'match2'} },
                  -- win_type = {'name1','name2', name3'},
                  -- win_config = { variable = {'match1', 'match2'} },
                },
                default_block_floats = function (win, active)
                  return win.win_config.relative ~= '' and
                    (win ~= active or win.buf_opts.buftype =='terminal') and true or false
                end,
                -- any_rule_name1 = {
                --   buf_opts = {}
                -- },
                -- only_behind_float_windows = {
                --   buf_opts = function(win, current)
                --     if (win.win_config.relative == '')
                --       and (current and current.win_config.relative ~= '') then
                --         return false
                --     end
                --     return true
                --   end
                -- },
              },
              -- Link connects windows so that they style or unstyle together.
              -- Properties are matched against the active window. Same format as blocklist above
              link = {},
              groupdiff = true, -- links diffs so that they style together
              groupscrollbind = false, -- link scrollbound windows so that they style together.
              -- enable to bind to FocusGained and FocusLost events. This allows fading inactive
              -- tmux panes.
              enablefocusfading = false,
              -- Time in milliseconds before re-checking windows. This is only used when usecursorhold
              -- is set to false.
              checkinterval = 1000,
              -- enables cursorhold event instead of using an async timer.  This may make Vimade
              -- feel more performant in some scenarios. See h:updatetime.
              usecursorhold = false,
              -- when nohlcheck is disabled the highlight tree will always be recomputed. You may
              -- want to disable this if you have a plugin that creates dynamic highlights in
              -- inactive windows. 99% of the time you shouldn't need to change this value.
              nohlcheck = true,
              focus = {
                 providers = {
                    filetypes = {
                      default = {
                        -- If you use mini.indentscope, snacks.indent, or hlchunk, you can also highlight
                        -- using the same indent scope!
                        -- {'snacks', {}},
                        -- {'mini', {}},
                        -- {'hlchunk', {}},
                        {'treesitter', {
                          min_node_size = 2, 
                          min_size = 1,
                          max_size = 0,
                          -- exclude types either too large and/or mundane
                          exclude = {
                            'script_file',
                            'stream',
                            'document',
                            'source_file',
                            'translation_unit',
                            'chunk',
                            'module',
                            'stylesheet',
                            'statement_block',
                            'block',
                            'pair',
                            'program',
                            'switch_case',
                            'catch_clause',
                            'finally_clause',
                            'property_signature',
                            'dictionary',
                            'assignment',
                            'expression_statement',
                            'compound_statement',
                          }
                        }},
                        -- if treesitter fails or there isn't a good match, fallback to blanks
                        -- (similar to limelight)
                        {'blanks', {
                          min_size = 1,
                          max_size = '35%'
                        }},
                        -- if blanks fails to find a good match, fallback to static 35%
                        {'static', {
                          size = '35%'
                        }},
                      },
                      -- You can make custom configurations for any filetype.  Here are some examples.
                      -- markdown ={{'blanks', {min_size=0, max_size='50%'}}, {'static', {max_size='50%'}}}
                      -- javascript = {
                        -- -- only use treesitter (no fallbacks)
                      --   {'treesitter', { min_node_size = 2, include = {'if_statement', ...}}},
                      -- },
                      -- typescript = {
                      --   {'treesitter', { min_node_size = 2, exclude = {'if_statement'}}}, 
                      --   {'static', {size = '35%'}}
                      -- },
                      -- java = {
                        -- -- mini with a fallback to blanks
                        -- {'mini', {min_size = 1, max_size = 20}},
                        -- {'blanks', {min_size = 1, max_size = '100%' }}, 
                      -- },
                    },
                  }
                },
            }
          }}
        
      
        require('packer').startup(function()
          use({
            'TaDaa/vimade',
            config = function ()
              require('vimade').setup({
                recipe = {'default', {animate = false}},
                ncmode = 'buffers',
                fadelevel = 0.4,
                tint = {},
                -- see the lazy.nvim config above or `Lua defaults` for full breakdown
              })
            end,
          })
        end)
        
      
        require 'paq' { 'TaDaa/vimade' }
      
        require('vimade').setup({
          recipe = {'default', {animate = false}},
          ncmode = 'buffers',
          fadelevel = 0.4,
          tint = {},
          -- see the lazy.nvim config above or `Lua defaults` for full breakdown
        })
        
      
          Plug 'TaDaa/vimade'
          lua << EOF
          require('vimade').setup({
            recipe = {'default', {animate = false}},
            ncmode = 'buffers',
            fadelevel = 0.4,
            tint = {},
            -- see the lazy.nvim config above or `Lua defaults` for full breakdown
          })
          EOF
        
      
          require('lazy').setup({spec = {'tadaa/vimade', event = 'VeryLazy'}})
          
      
      require('vimade').setup{
        fadelevel = function(style, state)
          if style.win.buf_opts.syntax == 'nerdtree' then
            return 0.8
          else
            return 0.4
          end
        end}
      
      
      -- sets the overlay back to empty
      require('vimade').setup{}
      
      
      vimade.setup{
        -- Recipe can be any of 'default', 'minimalist', 'duo', and 'ripple'
        -- Set animate = true to enable animations on any recipe.
        -- See the docs for other config options.
        recipe = {'default', {animate=false}},
        -- ncmode = 'windows' will fade inactive windows.
        -- ncmode = 'focus' will only fade after you activate the `:VimadeFocus` command.
        ncmode = 'buffers',
        fadelevel = 0.4, -- any value between 0 and 1. 0 is hidden and 1 is opaque.
        tint = {
          -- bg = {rgb={0,0,0}, intensity=0.3}, -- adds 30% black to background
          -- fg = {rgb={0,0,255}, intensity=0.3}, -- adds 30% blue to foreground
          -- fg = {rgb={120,120,120}, intensity=1}, -- all text will be gray
          -- sp = {rgb={255,0,0}, intensity=0.5}, -- adds 50% red to special characters
          -- you can also use functions for tint or any value part in the tint object
          -- to create window-specific configurations
          -- see the `Tinting` section of the README for more details.
        },
      
        -- Changes the real or theoretical background color. basebg can be used to give
        -- transparent terminals accurating dimming.  See the 'Preparing a transparent terminal'
        -- section in the README.md for more info.
        -- basebg = [23,23,23],
        basebg = '',
        -- prevent a window or buffer from being styled. You 
        blocklist = {
          default = {
            highlights = {
              laststatus_3 = function(win, active)
                -- Global statusline, laststatus=3, is currently disabled as multiple windows take ownership
                -- of the StatusLine highlight (see #85).
                if vim.go.laststatus == 3 then
                    -- you can also return tables (e.g. {'StatusLine', 'StatusLineNC'})
                    return 'StatusLine'
                end
              end,
              -- Prevent ActiveTabs from highlighting.
              'TabLineSel',
              'Pmenu',
              'PmenuSel',
              'PmenuKind',
              'PmenuKindSel',
              'PmenuExtra',
              'PmenuExtraSel',
              'PmenuSbar',
              'PmenuThumb',
              -- Lua patterns are supported, just put the text between / symbols:
              -- '/^StatusLine.*/' -- will match any highlight starting with "StatusLine"
            },
            buf_opts = { buftype = {'prompt'} },
            -- buf_name = {'name1','name2', name3'},
            -- buf_vars = { variable = {'match1', 'match2'} },
            -- win_opts = { option = {'match1', 'match2' } },
            -- win_vars = { variable = {'match1', 'match2'} },
            -- win_type = {'name1','name2', name3'},
            -- win_config = { variable = {'match1', 'match2'} },
          },
          default_block_floats = function (win, active)
            return win.win_config.relative ~= '' and
              (win ~= active or win.buf_opts.buftype =='terminal') and true or false
          end,
          -- any_rule_name1 = {
          --   buf_opts = {}
          -- },
          -- only_behind_float_windows = {
          --   buf_opts = function(win, current)
          --     if (win.win_config.relative == '')
          --       and (current and current.win_config.relative ~= '') then
          --         return false
          --     end
          --     return true
          --   end
          -- },
        },
        -- Link connects windows so that they style or unstyle together.
        -- Properties are matched against the active window. Same format as blocklist above
        link = {},
        groupdiff = true, -- links diffs so that they style together
        groupscrollbind = false, -- link scrollbound windows so that they style together.
        -- enable to bind to FocusGained and FocusLost events. This allows fading inactive
        -- tmux panes.
        enablefocusfading = false,
        -- Time in milliseconds before re-checking windows. This is only used when usecursorhold
        -- is set to false.
        checkinterval = 1000,
        -- enables cursorhold event instead of using an async timer.  This may make Vimade
        -- feel more performant in some scenarios. See h:updatetime.
        usecursorhold = false,
        -- when nohlcheck is disabled the highlight tree will always be recomputed. You may
        -- want to disable this if you have a plugin that creates dynamic highlights in
        -- inactive windows. 99% of the time you shouldn't need to change this value.
        nohlcheck = true,
      }
      
      
        blocklist = {
          default = {
            highlights = {
              laststatus_3 = function(win, active)
                if vim.go.laststatus == 3 then
                    return 'StatusLine'
                end
              end,
              'TabLineSel',
              'Pmenu',
              'PmenuSel',
              'PmenuKind',
              'PmenuKindSel',
              'PmenuExtra',
              'PmenuExtraSel',
              'PmenuSbar',
              'PmenuThumb',
            },
            buf_opts = {buftype = {'prompt'}},
          },
          default_block_floats = function (win, active)
            return win.win_config.relative ~= '' and
              (win ~= active or win.buf_opts.buftype =='terminal') and true or false
          end,
        },
      
      
      
      require('vimade').setup({
        blocklist = {
          demo_tutorial = function (win, current)
            -- current can be nil
            if (win.win_config.relative == '') and (current and current.win_config.relative ~= '') then
              return false
            end
            return true
          end
        }
      })
      
      
        local Fade = require('vimade.style.fade').Fade
        vimade.setup{
          style = {
            Fade{value = 0.4}
          }
        }
        
      
        local Tint = require('vimade.style.tint').Tint
        vimade.setup{
          style = {
            Tint{
              value = {
                fg = {rgb = {0,0,0}, intensity = 0.5},
                bg = {rgb = {0,0,0}, intensity = 0.5},
                sp = {rgb = {0,0,0}, intensity = 0.5},
              }
            }
          }
        }
        
      
        local Tint = require('vimade.style.invert').Invert
        vimade.setup{
          style = {
            Invert{
              value = {
                fg = 0.5,
                bg = 0.5,
                sp = 0.5,
              }
              -- alternatively use
              -- value = 0.5 (applies 0.5 to fg, bg, and sp)
            }
          }
        }
        
      
        local Fade = require('vimade.style.fade').Fade
        local Include = require('vimade.style.include').Include
        vimade.setup{
          style = {
            Include{
              value = ['WinSeparator', 'VertSplit', 'LineNr', 'LineNrAbove', 'LineNrBelow'],
              style = {
                Fade { value = 0.4 }
              }
            }
          }
        }
        
      
        local Fade = require('vimade.style.fade').Fade
        local Exclude = require('vimade.style.exclude').Exclude
        vimade.setup{
          style = {
            Exclude{
              value = ['WinSeparator', 'VertSplit', 'LineNr', 'LineNrAbove', 'LineNrBelow'],
              style = {
                Fade { value = 0.4 }
              }
            }
          }
        }
        
      
      local Fade = require('vimade.style.fade').Fade
      local animate = require('vimade.style.value.animate')
      require('vimade').setup{style = {
        Fade {
          value = animate.Number {
            start = 1,
            to = 0.2
          }
        }
      }}
      
      
      local Fade = require('vimade.style.fade').Fade
      local direction = require('vimade.style.value.direction')
      local ease = require('vimade.style.value.ease')
      local animate = require('vimade.style.value.animate')
      require('vimade').setup{style = {
        Fade {
          value = animate.Number {
            start = 1,
            to = 0.2,
            direction = direction.IN_OUT,
            ease = ease.OUT_BOUNCE,
            duration = 1000,
            delay = 100,
          }
        }
      }}
      
      
      require('vimade').setup({recipe = {'default', {animate = true}}})
      
      
      require('vimade').setup({recipe = {'minimalist', {animate = true}}})
      
      
      require('vimade').setup({recipe = {'duo', {animate = true}}})
      
      
      require('vimade').setup({
        recipe = {'duo', {animate = true}},
        tint = {bg = {rgb={0,0,0}, intensity = 0.3}}
      })
      
      
      require('vimade').setup({recipe = {'paradox', {animate = true}}})
      
      
      require('vimade').setup({
        recipe = {'paradox', {
            animate = true,
            invert = {
              start = 0,
              to = 1,
            }
        }},
      })
      
      
      require('vimade').setup({recipe = {'ripple', {animate = true}}})
      
    end,
  },
  {
    "xzbdmw/colorful-menu.nvim",
    config = function()
      
      return {
          "xzbdmw/colorful-menu.nvim",
          config = function()
              -- You don't need to set these options.
              require("colorful-menu").setup({
                  ls = {
                      lua_ls = {
                          -- Maybe you want to dim arguments a bit.
                          arguments_hl = "@comment",
                      },
                      gopls = {
                          -- By default, we render variable/function's type in the right most side,
                          -- to make them not to crowd together with the original label.
      
                          -- when true:
                          -- foo             *Foo
                          -- ast         "go/ast"
      
                          -- when false:
                          -- foo *Foo
                          -- ast "go/ast"
                          align_type_to_right = true,
                          -- When true, label for field and variable will format like "foo: Foo"
                          -- instead of go's original syntax "foo Foo". If align_type_to_right is
                          -- true, this option has no effect.
                          add_colon_before_type = false,
                          -- See https://github.com/xzbdmw/colorful-menu.nvim/pull/36
                          preserve_type_when_truncate = true,
                      },
                      -- for lsp_config or typescript-tools
                      ts_ls = {
                          -- false means do not include any extra info,
                          -- see https://github.com/xzbdmw/colorful-menu.nvim/issues/42
                          extra_info_hl = "@comment",
                      },
                      vtsls = {
                          -- false means do not include any extra info,
                          -- see https://github.com/xzbdmw/colorful-menu.nvim/issues/42
                          extra_info_hl = "@comment",
                      },
                      ["rust-analyzer"] = {
                          -- Such as (as Iterator), (use std::io).
                          extra_info_hl = "@comment",
                          -- Similar to the same setting of gopls.
                          align_type_to_right = true,
                          -- See https://github.com/xzbdmw/colorful-menu.nvim/pull/36
                          preserve_type_when_truncate = true,
                      },
                      clangd = {
                          -- Such as "From <stdio.h>".
                          extra_info_hl = "@comment",
                          -- Similar to the same setting of gopls.
                          align_type_to_right = true,
                          -- the hl group of leading dot of "•std::filesystem::permissions(..)"
                          import_dot_hl = "@comment",
                          -- See https://github.com/xzbdmw/colorful-menu.nvim/pull/36
                          preserve_type_when_truncate = true,
                      },
                      zls = {
                          -- Similar to the same setting of gopls.
                          align_type_to_right = true,
                      },
                      roslyn = {
                          extra_info_hl = "@comment",
                      },
                      dartls = {
                          extra_info_hl = "@comment",
                      },
                      -- The same applies to pyright/pylance
                      basedpyright = {
                          -- It is usually import path such as "os"
                          extra_info_hl = "@comment",
                      },
                      pylsp = {
                          extra_info_hl = "@comment",
                          -- Dim the function argument area, which is the main
                          -- difference with pyright.
                          arguments_hl = "@comment",
                      },
                      -- If true, try to highlight "not supported" languages.
                      fallback = true,
                      -- this will be applied to label description for unsupport languages
                      fallback_extra_info_hl = "@comment",
                  },
                  -- If the built-in logic fails to find a suitable highlight group for a label,
                  -- this highlight is applied to the label.
                  fallback_highlight = "@variable",
                  -- If provided, the plugin truncates the final displayed text to
                  -- this width (measured in display cells). Any highlights that extend
                  -- beyond the truncation point are ignored. When set to a float
                  -- between 0 and 1, it'll be treated as percentage of the width of
                  -- the window: math.floor(max_width * vim.api.nvim_win_get_width(0))
                  -- Default 60.
                  max_width = 60,
              })
          end,
      }
      
      
      require("cmp").setup({
          formatting = {
              format = function(entry, vim_item)
                  local highlights_info = require("colorful-menu").cmp_highlights(entry)
      
                  -- highlight_info is nil means we are missing the ts parser, it's
                  -- better to fallback to use default `vim_item.abbr`. What this plugin
                  -- offers is two fields: `vim_item.abbr_hl_group` and `vim_item.abbr`.
                  if highlights_info ~= nil then
                      vim_item.abbr_hl_group = highlights_info.highlights
                      vim_item.abbr = highlights_info.text
                  end
      
                  return vim_item
              end,
          },
      })
      
      
      config = function()
          require("blink.cmp").setup({
              completion = {
                  menu = {
                      draw = {
                          -- We don't need label_description now because label and label_description are already
                          -- combined together in label by colorful-menu.nvim.
                          columns = { { "kind_icon" }, { "label", gap = 1 } },
                          components = {
                              label = {
                                  text = function(ctx)
                                      return require("colorful-menu").blink_components_text(ctx)
                                  end,
                                  highlight = function(ctx)
                                      return require("colorful-menu").blink_components_highlight(ctx)
                                  end,
                              },
                          },
                      },
                  },
              },
          })
      end
      
      
      config = function()
          require("blink.cmp").setup({
              completion = {
                  menu = {
                      draw = {
                          -- We don't need label_description now because label and label_description are already
                          -- combined together in label by colorful-menu.nvim.
                          columns = { { "kind_icon" }, { "label", gap = 1 } },
                          components = {
                              label = {
                                  width = { fill = true, max = 60 },
                                  text = function(ctx)
                                      local highlights_info = require("colorful-menu").blink_highlights(ctx)
                                      if highlights_info ~= nil then
                                          -- Or you want to add more item to label
                                          return highlights_info.label
                                      else
                                          return ctx.label
                                      end
                                  end,
                                  highlight = function(ctx)
                                      local highlights = {}
                                      local highlights_info = require("colorful-menu").blink_highlights(ctx)
                                      if highlights_info ~= nil then
                                          highlights = highlights_info.highlights
                                      end
                                      for _, idx in ipairs(ctx.label_matched_indices) do
                                          table.insert(highlights, { idx, idx + 1, group = "BlinkCmpLabelMatch" })
                                      end
                                      -- Do something else
                                      return highlights
                                  end,
                              },
                          },
                      },
                  },
              },
          })
      end
      
      
      formatting = {
        fields = { "kind", "abbr", "menu" },
      
        format = function(entry, vim_item)
          local kind = require("lspkind").cmp_format({
              mode = "symbol_text",
          })(entry, vim.deepcopy(vim_item))
          local highlights_info = require("colorful-menu").cmp_highlights(entry)
      
          -- highlight_info is nil means we are missing the ts parser, it's
          -- better to fallback to use default `vim_item.abbr`. What this plugin
          -- offers is two fields: `vim_item.abbr_hl_group` and `vim_item.abbr`.
          if highlights_info ~= nil then
              vim_item.abbr_hl_group = highlights_info.highlights
              vim_item.abbr = highlights_info.text
          end
          local strings = vim.split(kind.kind, "%s", { trimempty = true })
          vim_item.kind = " " .. (strings[1] or "") .. " "
          vim_item.menu = ""
      
          return vim_item
        end,
      }
      
    end,
  },
  {
    "nvzone/minty",
    config = function()
      
      { "nvzone/volt", lazy = true },
      
      {
        "nvzone/minty",
        cmd = { "Shades", "Huefy" },
      }
      
    end,
  },
  {
    "3ZsForInsomnia/pacer.nvim",
    config = function()
      
      return {
        "3ZsForInsomnia/pacer.nvim",
        cmd = { "PacerStart", "PacerResume", "PacerValidate" },
        -- Plugin will be automatically loaded when any of the above commands are used
        -- You can also add keys or events for other loading triggers:
        -- keys = { "<leader>p" }, -- e.g., load on key mapping
        -- event = "BufRead", -- e.g., load when reading any buffer
        init = function()
          -- Ensure commands are available immediately
          vim.api.nvim_create_user_command("PacerStart", function() 
            require("pacer.commands").start_pacer({args = ""}) 
          end, { nargs = "?", desc = "Start the pacer" })
          vim.api.nvim_create_user_command("PacerPause", function() 
            require("pacer.commands").pause_pacer() 
          end, { desc = "Pause the pacer" })
          vim.api.nvim_create_user_command("PacerResume", function() 
            require("pacer.commands").resume_pacer() 
          end, { desc = "Resume the pacer" })
          vim.api.nvim_create_user_command("PacerStop", function() 
            require("pacer.commands").stop_pacer() 
          end, { desc = "Stop the pacer" })
          vim.api.nvim_create_user_command("PacerValidate", function() 
            require("pacer.commands").validate_pacer() 
          end, { desc = "Validate Pacer setup" })
        end,
        opts = {
          -- Set the colors for the currently highlighted word
          highlight = {
            bg = "#335577",
            fg = "#ffffff",
      
            -- The style to apply to the currently highlighted word
            -- It can be any combination of the following: bold, italic, underline, undercurl
            style = "underline",
          },
      
          -- This is the default WPM (words per minute) to use when starting the pacer if no WPM or Preset is provided
          wpm = 300,
      
          -- The keyboard shortcut to pause the pacer. You can run `:PacerResume` to restart your existing pacer session,
          -- or `:PacerStart` to start a new session from the current position in the buffer.
          pause_key = "<C-c>",
      
          -- Determines if the cursor moves along with the pacer. If set to false, the pacer will highlight words without moving the cursor.
          -- You do _not_ need to set this to true to save your position!
          move_cursor = true,
      
          -- Sets a delay between each paragraph (or large change in code scope) to make transitions smoother.
          paragraph_delay_multiplier = 2,
      
          -- Sets the color of the dimmed text outside of the current paragraph or code scope.
          focus = {
            enabled = true,
            dim_color = "#777777",
          },
      
          -- Presets allow you to override all of your default settings in an easy way.
          -- For example, MyPreset could be a fast-paced reading preset that you can quickly switch to.
          -- They can override _any_ setting. Anything they do not override will use the default config.
          presets = {
            MyPreset = {
              wpm = 400,
            }
          }
        }
      }
      
    end,
  },
  {
    "datsfilipe/min-theme.nvim",
    config = function()
      
      { 'datsfilipe/min-theme.nvim' },
      
      
      use 'datsfilipe/min-theme.nvim'
      
      
      require('min-theme').setup({
          -- (note: if your configuration sets vim.o.background the following option will do nothing!)
          theme = 'dark', -- String: 'dark' or 'light', determines the colorscheme used
          transparent = false, -- Boolean: Sets the background to transparent
          italics = {
              comments = true, -- Boolean: Italicizes comments
              keywords = true, -- Boolean: Italicizes keywords
              functions = true, -- Boolean: Italicizes functions
              strings = true, -- Boolean: Italicizes strings
              variables = true, -- Boolean: Italicizes variables
          },
          overrides = {}, -- A dictionary of group names, can be a function returning a dictionary or a table.
      })
      
      
      require('bufferline').setup({
          highlights = require('min-theme').bufferline.highlights,
      })
      
    end,
  },
  {
    "github-main-user/lytmode.nvim",
    config = function()
      
      return {
          "github-main-user/lytmode.nvim",
          lazy = false,
          priority = 1000,
          config = function()
              require('lytmode').setup()
          end
      }
      
      
      local c = require('lytmode.colors').get_colors()
      require('lytmode').setup({
          -- Enable transparent background
          transparent = true,
      
          -- Enable italic comment
          italic_comments = true,
      
          -- Enable italic inlay type hints
          italic_inlayhints = true,
      
          -- Underline `@markup.link.*` variants
          underline_links = true,
      
          -- Disable nvim-tree background color
          disable_nvimtree_bg = true,
      
          -- Apply theme colors to terminal
          terminal_colors = true,
      
          -- Override colors (see ./lua/lytmode/colors.lua)
          color_overrides = {
              lytLineNumber = '#FFFFFF',
          },
      
          -- Override highlight groups (see ./lua/lytmode/theme.lua)
          group_overrides = {
              -- this supports the same val table as vim.api.nvim_set_hl
              -- use colors from this colorscheme by requiring lytmode.colors!
              Cursor = { fg=c.lytDarkBlue, bg=c.lytLightGreen, bold=true },
          }
      })
      
    end,
  },
  {
    "datsfilipe/vesper.nvim",
    config = function()
      
      { 'datsfilipe/vesper.nvim' },
      
      
      use 'datsfilipe/vesper.nvim'
      
      
      require('vesper').setup({
          transparent = false, -- Boolean: Sets the background to transparent
          italics = {
              comments = true, -- Boolean: Italicizes comments
              keywords = true, -- Boolean: Italicizes keywords
              functions = true, -- Boolean: Italicizes functions
              strings = true, -- Boolean: Italicizes strings
              variables = true, -- Boolean: Italicizes variables
          },
          overrides = {}, -- A dictionary of group names, can be a function returning a dictionary or a table.
          palette_overrides = {}
      })
      
      
      require('bufferline').setup({
          highlights = require('vesper').bufferline.highlights,
      })
      
    end,
  },
  {
    "sontungexpt/witch",
    config = function()
      
          -- lazy
          {
              "sontungexpt/witch",
              priority = 1000,
              lazy = false,
              config = function(_, opts)
                  require("witch").setup(opts)
              end,
          },
      
      
      
          require("witch").setup {
              theme = {
                  -- if you disable the theme, no default highlight styles will be set by default
                  -- you must to add a customs module or extras module to set the highlight styles
                  enabled = true,
      
                  -- default style of the theme
                  -- "dark", "light"
                  style = "dark",
      
                  -- more module that you want it should be loaded
                  extras = {
                      -- bracket = true,
                      -- dashboard = true,
                      -- diffview = true,
                      -- explorer = true,
                      -- indentline = true,
      
                      -- you can disable startup module by setting enabled to false
                      -- then you can add the startup module by yourself like extras module like above
                      -- ["startup.<module_name>"] = true,
                  },
      
                  -- custome your highlight module
                  -- see: witch.theme.example
                  customs = {
                      -- require("witch.theme.example"),
                  },
      
                  -- This function is called when witch starts highlighting.
                  -- It provides a unique opportunity to modify the default highlight groups.
                  -- If you wish to customize the default highlight groups, you can do so here.
                  -- This function is invoked after loading all colors and highlight options
                  -- but before applying the highlights, allowing users to adjust undesired highlights.
                  -- you can do something like this
                  --
                  -- on_highlight = function(style, colors, highlight)
                  -- 	if style == "dark" then
                  -- 		-- change the default background of witch
                  -- 		colors.bg = "#000000"
      
                  -- 		-- change the Normal highlight group of witch
                  -- 		highlight.Normal = { fg = "#ffffff", bg = "#000000" }
                  -- 	elseif style == "light" then
                  -- 		-- change the default background of witch
                  -- 		colors.bg = "#ffffff"
      
                  -- 		-- change the Normal highlight group of witch
                  -- 		highlight.Normal = { fg = "#000000", bg = "#ffffff" }
                  -- 	end
                  -- end,
      
                  --- @param style string : the current style of the theme
                  --- @param colors table : the current colors of the theme
                  --- @param highlight table : the current highlights of the theme
                  on_highlight = function(style, colors, highlight)
                  end,
              },
      
              -- dims inactive windows
              dim_inactive = {
                  enabled = true,
                  -- from 0 to 1
                  -- as nearer to 1 the dimming will be lighter
                  level = 0.48,
      
                  -- Prevent dimming the last active window when switching to a window
                  -- with specific filetypes or buftypes listed in the excluded table.
                  --
                  -- The idea of this option is when change to a window like NvimTree, Telescope, ...
                  -- where these windows are considered auxiliary tools.
                  -- the last active window retains its status as the main window
                  -- and should not be dimmed upon switching.
                  excluded = {
                      filetypes = {
                          NvimTree = true,
                      },
                      buftypes = {
                          nofile = true,
                          prompt = true,
                          terminal = true,
                      },
                  },
              },
      
              -- true if you want to use command StinvimUISwitch
              switcher = true,
      
              -- add your custom themes here
              more_themes = {
      
                  -- the key is the name of the theme must be in PascalCase
                  -- the value is the table of colors to be passed to the theme
                  -- with following format in witch.colors.example
                  -- Custom1 = {},
                  -- Custom2 = {},
              },
          }
      
      
          vim.api.nvim_create_autocmd({ "User" }, {
              pattern = "WitchHighlightDone",
              callback = function(event)
                  -- event.data is the name of the module that witch has finished highlighting
                  if event.data == "nvimtree" then
                      print("WitchHighlightDone nvimtree")
                  end
              end,
          })
      
      
          require("witch").setup {
              theme = {
                  customs = {
                      -- your module
                      require("witch.theme.example"),
                      -- ...
                  },
              },
          }
      
      
          require("witch").setup {
              theme = {
                  extras = {
                      bracket = true,
                      dashboard = true,
                      diffview = true,
                      explorer = true,
                      indentline = true,
                  },
              },
          }
      
      
          require("witch").setup {
              more_themes = {
                  -- the key is the name of the theme must be in PascalCase
                  Custom1 = {
                      bg = "#161f31", -- the background color
                      bg_dark = "#0d1829", -- the background color of floating windows
                      bg_line = "#0d1829", -- the background color of the statusline and tabline
                      bg_visual = "#253557", -- the background color of the visual selection
                      bg_highlight = "#1f2b49", -- the background color of the line the cursor is on
                      bg_gutter = "#1b305d", -- the background color of fold
                      bg_sidebar = "#1b305d", -- the background color of the sidebar, fallback to bf_dark if not defined
      
                      fg = "#c9d8ee", -- the foreground color
                      fg_dark = "#a9bad6", -- the foreground color of floating windows
                      fg_sidebar = "#a9bad6", -- the foreground color of the sidebar, fallback to fg_dark if not defined
      
                      yellow = "#f0a421",
                      yellow1 = "#e6cc4c",
                      bright_yellow = "#ffc021",
      
                      red = "#dc4154",
                      red1 = "#ff5874",
                      red2 = "#ee4c96",
      
                      cyan = "#7dcfff",
                      cyan1 = "#75c8cc",
      
                      black = "#000000",
                      white = "#ffffff",
      
                      green = "#5bcf75",
      
                      orange = "#f99635",
                      orange1 = "#f78c6c",
                      orange2 = "#f78782",
                      light_orange = "#ffd59d",
      
                      blue = "#50bcef",
                      blue1 = "#629df2",
                      blue2 = "#698ff1",
      
                      link = "#8bdafe",
      
                      teal = "#5cd0a0",
      
                      gray = "#596683",
                      graphite = "#738eaf",
                      light_gray = "#64739a",
      
                      pink = "#f36cde",
                      pink1 = "#ed66c2",
      
                      purple = "#b278ea",
      
                      brown = "#c17e70",
      
                      magenta = "#da87ea",
                      magenta1 = "#ff3483",
      
                      border = "#3d88c4",
                      dark_border = "#37518d",
                      graphite_border = "#465968",
      
                      comment = "#6675ae", -- the color of comments
                      string = "#ffd39b", -- the color of strings
                      operator = "#7bc0cc", -- the color of operators
      
                      error = "#e64152",
                      info = "#59d1f2",
                      warn = "#ffcb44",
                      hint = "#1abc9c",
                      todo = "#f78c6c",
                      unnecessary = "#375172",
      
                      -- if you want to change the terminal colors, you can do so here
                      -- the term_0 - term_15 colors has the priority over the term_black - term_bright_white colors
                      term_0 = "#000000",
                      term_8 = "#4d4d4d",
      
                      term_7 = "#ffffff",
                      term_15 = "#ffffff",
      
                      term_1 = "#fc3753",
                      term_9 = "#fc3753",
      
                      term_2 = "#37a16f",
                      term_10 = "#4ad860",
      
                      term_3 = "#f0a421",
                      term_11 = "#f0a421",
      
                      term_4 = "#1e9eff",
                      term_12 = "#1e9eff",
      
                      term_5 = "#f36cde",
                      term_13 = "#f36cde",
      
                      term_6 = "#7dcfff",
                      term_14 = "#7dcfff",
      
                      term_black = "#000000",
                      term_bright_black = "#4d4d4d",
      
                      term_white = "#ffffff",
                      term_bright_white = "#ffffff",
      
                      term_red = "#fc3753",
                      term_bright_red = "#fc3753",
      
                      term_green = "#4ad860",
                      term_bright_green = "#4ad860",
      
                      term_yellow = "#f0a421",
                      term_bright_yellow = "#f0a421",
      
                      term_blue = "#1e9eff",
                      term_bright_blue = "#1e9eff",
      
                      term_magenta = "#f36cde",
                      term_bright_magenta = "#f36cde",
      
                      term_cyan = "#7dcfff",
                      term_bright_cyan = "#7dcfff",
                  },
      
                  Custom2 = {
                      -- your colors
                  },
              },
          }
      
    end,
  },
  {
    "Abstract-IDE/Abstract-cs",
    config = function()
      
      use 'Abstract-IDE/Abstract-cs'
      
      
      -- Lua
      vim.cmd[[colorscheme abscs]]
      
    end,
  },
  {
    "rafamadriz/neon",
    config = function()
      
      use "rafamadriz/neon"
      
      
      vim.cmd[[colorscheme neon]]
      
      
      require('lualine').setup {
        options = {
          -- ... your lualine config
          theme = 'neon'
          -- ... your lualine config
        }
      }
      
      
      vim.g.neon_style = "default"
      vim.g.neon_italic_keyword = true
      vim.g.neon_italic_function = true
      vim.g.neon_transparent = true
      
      vim.cmd[[colorscheme neon]]
      
    end,
  },
  {
    "tomasiser/vim-code-dark",
  },
  {
    "Mofiqul/vscode.nvim",
    config = function()
      
      -- Packer:
      use 'Mofiqul/vscode.nvim'
      
      
      -- Lua:
      -- For dark theme (neovim's default)
      vim.o.background = 'dark'
      -- For light theme
      vim.o.background = 'light'
      
      local c = require('vscode.colors').get_colors()
      require('vscode').setup({
          -- Alternatively set style in setup
          -- style = 'light'
      
          -- Enable transparent background
          transparent = true,
      
          -- Enable italic comment
          italic_comments = true,
      
          -- Enable italic inlay type hints
          italic_inlayhints = true,
      
          -- Underline `@markup.link.*` variants
          underline_links = true,
      
          -- Disable nvim-tree background color
          disable_nvimtree_bg = true,
      
          -- Apply theme colors to terminal
          terminal_colors = true,
      
          -- Override colors (see ./lua/vscode/colors.lua)
          color_overrides = {
              vscLineNumber = '#FFFFFF',
          },
      
          -- Override highlight groups (see ./lua/vscode/theme.lua)
          group_overrides = {
              -- this supports the same val table as vim.api.nvim_set_hl
              -- use colors from this colorscheme by requiring vscode.colors!
              Cursor = { fg=c.vscDarkBlue, bg=c.vscLightGreen, bold=true },
          }
      })
      -- require('vscode').load()
      
      -- load the theme without affecting devicon colors.
      vim.cmd.colorscheme "vscode"
      
      
      require('lualine').setup({
          options = {
              -- ...
              theme = 'vscode',
              -- ...
          },
      })
      
      
      require("bufferline").setup({
          options = {
              buffer_close_icon = "",
              close_command = "bdelete %d",
              close_icon = "",
              indicator = {
                style = "icon",
                icon = " ",
              },
              left_trunc_marker = "",
              modified_icon = "●",
              offsets = { { filetype = "NvimTree", text = "EXPLORER", text_align = "center" } },
              right_mouse_command = "bdelete! %d",
              right_trunc_marker = "",
              show_close_icon = false,
              show_tab_indicators = true,
          },
          highlights = {
              fill = {
                  fg = { attribute = "fg", highlight = "Normal" },
                  bg = { attribute = "bg", highlight = "StatusLineNC" },
              },
              background = {
                  fg = { attribute = "fg", highlight = "Normal" },
                  bg = { attribute = "bg", highlight = "StatusLine" },
              },
              buffer_visible = {
                  fg = { attribute = "fg", highlight = "Normal" },
                  bg = { attribute = "bg", highlight = "Normal" },
              },
              buffer_selected = {
                  fg = { attribute = "fg", highlight = "Normal" },
                  bg = { attribute = "bg", highlight = "Normal" },
              },
              separator = {
                  fg = { attribute = "bg", highlight = "Normal" },
                  bg = { attribute = "bg", highlight = "StatusLine" },
              },
              separator_selected = {
                  fg = { attribute = "fg", highlight = "Special" },
                  bg = { attribute = "bg", highlight = "Normal" },
              },
              separator_visible = {
                  fg = { attribute = "fg", highlight = "Normal" },
                  bg = { attribute = "bg", highlight = "StatusLineNC" },
              },
              close_button = {
                  fg = { attribute = "fg", highlight = "Normal" },
                  bg = { attribute = "bg", highlight = "StatusLine" },
              },
              close_button_selected = {
                  fg = { attribute = "fg", highlight = "Normal" },
                  bg = { attribute = "bg", highlight = "Normal" },
              },
              close_button_visible = {
                  fg = { attribute = "fg", highlight = "Normal" },
                  bg = { attribute = "bg", highlight = "Normal" },
              },
          },
      })
      
    end,
  },
  {
    "askfiy/visual_studio_code",
    config = function()
      
      -- lazy
      {
          "askfiy/visual_studio_code",
          priority = 100,
          config = function()
              vim.cmd([[colorscheme visual_studio_code]])
          end,
      },
      
      
      -- packer
      {
          "askfiy/visual_studio_code",
          config = function()
              vim.cmd([[colorscheme visual_studio_code]])
          end,
      }
      
      
      require("visual_studio_code").setup({
          -- `dark` or `light`
          mode = "dark",
          -- Whether to load all color schemes
          preset = true,
          -- Whether to enable background transparency
          transparent = false,
          -- Whether to apply the adapted plugin
          expands = {
              hop = true,
              dbui = true,
              lazy = true,
              aerial = true,
              null_ls = true,
              nvim_cmp = true,
              gitsigns = true,
              which_key = true,
              nvim_tree = true,
              lspconfig = true,
              telescope = true,
              bufferline = true,
              nvim_navic = true,
              nvim_notify = true,
              vim_illuminate = true,
              nvim_treesitter = true,
              nvim_ts_rainbow = true,
              nvim_scrollview = true,
              nvim_ts_rainbow2 = true,
              indent_blankline = true,
              vim_visual_multi = true,
          },
          hooks = {
              before = function(conf, colors, utils) end,
              after = function(conf, colors, utils) end,
          },
      })
      
      
      require("visual_studio_code")
         - get_config()               -- current configuration table
         - get_colors()               -- current color highlight table
         - get_lualine_sections()     -- lualine sections table
         - get_bufferline_right()     -- bufferline custom right area
      
      require("visual_studio_code.utils")
         - hl.set(name, options)
         - hl.link(src, dst)
         - hl.get(name, option)
         - hl.bulk_set(groups)
      
      
      require("visual_studio_code.utils").hl.set("Normal", { fg = "#000000", bg = "#1E1E2E"})
      
      require("visual_studio_code.utils").hl.link("NormalFloat", "Normal")
      
      require("visual_studio_code.utils").hl.get("Normal", "fg")   -- #000000
      
      require("visual_studio_code.utils").hl.bulk_set({
          Normal = { fg = "#000000", bg = "#1E1E2E"},
          NormalFloat = { link = "Normal" },
          Cursor = { bg = "#0FE1EE", bold = true }
      })
      
      
      hooks = {
          before = function(conf, colors, utils) end,
          after = function(conf, colors, utils) end,
      }
      
      
      
      require("bufferline").setup({
          options = {
              themable = true,
              ...
          }
      })
      
      
      vim.g.VM_Extend_hl = "VM_Extend_hl"
      vim.g.VM_Cursor_hl = "VM_Cursor_hl"
      vim.g.VM_Mono_hl = "VM_Mono_hl"
      vim.g.VM_Insert_hl = "VM_Insert_hl"
      
      
      require("lualine").setup({
          options = {
              theme = "visual_studio_code",
              icons_enabled = true,
              component_separators = { left = "", right = "" },
              section_separators = { left = "", right = "" },
              disabled_filetypes = {},
              globalstatus = true,
              refresh = {
                  statusline = 100,
              },
          },
          sections = require("visual_studio_code").get_lualine_sections(),
      })
      
      
      require("bufferline").setup({
          options = {
              themable = true,
              close_icon = "",
              ...
              custom_areas = {
                  right = require("visual_studio_code").get_bufferline_right(),
              },
          }
      })
      
    end,
  },
  {
    "marko-cerovac/material.nvim",
    config = function()
      
      -- If you are using Lazy
      require('lazy').setup({
          'marko-cerovac/material.nvim'
      }, opts)
      
      -- If you are using Pckr
      require('pckr').add({
          'marko-cerovac/material.nvim'
      })
      
      
      --Lua:
      vim.cmd 'colorscheme material'
      
      
      --Lua:
      vim.g.material_style = "deep ocean"
      
      
      require('material').setup({
      
          contrast = {
              terminal = false, -- Enable contrast for the built-in terminal
              sidebars = false, -- Enable contrast for sidebar-like windows ( for example Nvim-Tree )
              floating_windows = false, -- Enable contrast for floating windows
              cursor_line = false, -- Enable darker background for the cursor line
              lsp_virtual_text = false, -- Enable contrasted background for lsp virtual text
              non_current_windows = false, -- Enable contrasted background for non-current windows
              filetypes = {}, -- Specify which filetypes get the contrasted (darker) background
          },
      
          styles = { -- Give comments style such as bold, italic, underline etc.
              comments = { --[[ italic = true ]] },
              strings = { --[[ bold = true ]] },
              keywords = { --[[ underline = true ]] },
              functions = { --[[ bold = true, undercurl = true ]] },
              variables = {},
              operators = {},
              types = {},
          },
      
          plugins = { -- Uncomment the plugins that you use to highlight them
              -- Available plugins:
              -- "blink",
              -- "coc",
              -- "colorful-winsep",
              -- "dap",
              -- "dashboard",
              -- "eyeliner",
              -- "fidget",
              -- "flash",
              -- "gitsigns",
              -- "harpoon",
              -- "hop",
              -- "illuminate",
              -- "indent-blankline",
              -- "lspsaga",
              -- "mini",
              -- "neo-tree",
              -- "neogit",
              -- "neorg",
              -- "neotest",
              -- "noice",
              -- "nvim-cmp",
              -- "nvim-navic",
              -- "nvim-notify",
              -- "nvim-tree",
              -- "nvim-web-devicons",
              -- "rainbow-delimiters",
              -- "sneak",
              -- "telescope",
              -- "trouble",
              -- "which-key",
          },
      
          disable = {
              colored_cursor = false, -- Disable the colored cursor
              borders = false, -- Disable borders between vertically split windows
              background = false, -- Prevent the theme from setting the background (NeoVim then uses your terminal background)
              term_colors = false, -- Prevent the theme from setting terminal colors
              eob_lines = false -- Hide the end-of-buffer lines
          },
      
          high_visibility = {
              lighter = false, -- Enable higher contrast text for lighter style
              darker = false -- Enable higher contrast text for darker style
          },
      
          lualine_style = "default", -- Lualine style ( can be 'stealth' or 'default' )
      
          async_loading = true, -- Load parts of the theme asynchronously for faster startup (turned on by default)
      
          custom_colors = nil, -- If you want to override the default colors, set this to a function
      
          custom_highlights = {}, -- Overwrite highlights with your own
      })
      
      
      vim.cmd 'colorscheme material'
      
      
      local material = require 'material'
      local colors = require 'material.colors'
      
      material.setup{
          custom_highlights = {
              LineNr = { bg = '#FF0000' },
              CursorLine = { fg = colors.editor.constrast , underline = true },
      
              -- Dynamically override highlight groups with functions to ensure colors are
              -- updated when changing styles at runtime
              TabLine = function(colors, _)
                  return {
                      fg = colors.main.gray,
                      italic = true,
                  }
              end,
              TabLineSel = function(_, highlights)
                  return vim.tbl_extend(
                      "force",
                      highlights.main_highlights.editor()["TabLineSel"],
                      { bold = true }
                  )
              end,
      
              -- This is a list of possible values
              YourHighlightGroup = {
                  fg = "#SOME_COLOR", -- foreground color
                  bg = "#SOME_COLOR", -- background color
                  sp = "#SOME_COLOR", -- special color (for colored underlines, undercurls...)
                  bold = false, -- make group bold
                  italic = false, -- make group italic
                  underline = false, -- make group underlined
                  undercurl = false, -- make group undercurled
                  underdot = false, -- make group underdotted
                  underdash = false, -- make group underslashed
                  striketrough = false, -- make group striked trough
                  reverse = false, -- reverse the fg and bg colors
                  link = "SomeOtherGroup" -- link to some other highlight group
              }
          },
      
          -- Custom colors must be a function that takes in the default colors table as
          -- a parameter, and then modifies them.
          -- To see the available colors, see lua/material/colors/init.lua
          custom_colors = function(colors)
              colors.editor.bg = "#SOME_COLOR"
              colors.main.purple = "#SOME_COLOR"
              colors.lsp.error = "#SOME_COLOR"
          end
      }
      
      
      require('material').setup({
          -- ... other settings
          disable = {
              -- ... other settings
              background = true, 
          },
      })
      
      
      require('lualine').setup {
        options = {
          -- ... your lualine config
          theme = 'auto'
          or
          theme = 'material'
          -- ... your lualine config
        }
      }
      
      line_style
      
      require('material').setup({
          lualine_style = 'default' -- the default style
          or
          lualine_style = 'stealth' -- the stealth style
      })
      
      
      require('lualine').setup {
        options = {
          -- ... your lualine config
          theme = 'material-nvim' -- the default style
          or
          theme = 'material-stealth' -- the stealth style
          -- ... your lualine config
        }
      }
      
    end,
  },
  {
    "bluz71/vim-nightfly-colors",
    config = function()
      
      { "bluz71/vim-nightfly-colors", name = "nightfly", lazy = false, priority = 1000 },
      
      
      vim.pack.add({
        { src = "https://github.com/bluz71/vim-nightfly-colors", name = "nightfly" },
      })
      
      
      -- Lua initialization file
      vim.cmd [[colorscheme nightfly]]
      
      
      -- Lua initialization file
      vim.g.nightflyCursorColor = true
      
      
      -- Lua initialization file
      vim.g.nightflyItalics = false
      
      
      -- Lua initialization file
      vim.g.nightflyNormalFloat = true
      
      
      vim.o.winborder = "single"
      
      
      -- Lua initialization file
      vim.g.nightflyTerminalColors = false
      
      
      -- Lua initialization file
      vim.g.nightflyTransparent = true
      
      
      -- Lua initialization file
      vim.g.nightflyUndercurls = false
      
      
      -- Lua initialization file
      vim.g.nightflyUnderlineMatchParen = true
      
      
      -- Lua initialization file
      vim.g.nightflyVirtualTextColor = true
      
      
      -- Lua initialization file
      vim.g.nightflyWinSeparator = 2
      
      
      -- Lua initialization file
      vim.opt.fillchars = { horiz = '━', horizup = '┻', horizdown = '┳', vert = '┃', vertleft = '┫', vertright = '┣', verthoriz = '╋', }
      
      
      -- Lua initialization file
      local custom_highlight = vim.api.nvim_create_augroup("CustomHighlight", {})
      vim.api.nvim_create_autocmd("ColorScheme", {
        pattern = "nightfly",
        callback = function()
          vim.api.nvim_set_hl(0, "Function", { fg = "#82aaff", bold = true })
        end,
        group = custom_highlight,
      })
      
      
      require("nightfly").palette
      
      
        require("nightfly").custom_colors({
          bg = "#161616",
          violet = "#ff74b8",
        })
        vim.cmd([[colorscheme nightfly]])
      
    end,
  },
  {
    "bluz71/vim-moonfly-colors",
    config = function()
      
      { "bluz71/vim-moonfly-colors", name = "moonfly", lazy = false, priority = 1000 },
      
      
      vim.pack.add({
        { src = "https://github.com/bluz71/vim-moonfly-colors", name = "moonfly" },
      })
      
      
      -- Lua initialization file
      vim.cmd [[colorscheme moonfly]]
      
      
      -- Lua initialization file
      vim.g.moonflyCursorColor = true
      
      
      -- Lua initialization file
      vim.g.moonflyItalics = false
      
      
      -- Lua initialization file
      vim.g.moonflyNormalFloat = true
      
      
      vim.o.winborder = "single"
      
      
      -- Lua initialization file
      vim.g.moonflyTerminalColors = false
      
      
      -- Lua initialization file
      vim.g.moonflyTransparent = true
      
      
      -- Lua initialization file
      vim.g.moonflyUndercurls = false
      
      
      -- Lua initialization file
      vim.g.moonflyUnderlineMatchParen = true
      
      
      -- Lua initialization file
      vim.g.moonflyVirtualTextColor = true
      
      
      -- Lua initialization file
      vim.g.moonflyWinSeparator = 2
      
      
      -- Lua initialization file
      vim.opt.fillchars = { horiz = '━', horizup = '┻', horizdown = '┳', vert = '┃', vertleft = '┫', vertright = '┣', verthoriz = '╋', }
      
      
      -- Lua initialization file
      local custom_highlight = vim.api.nvim_create_augroup("CustomHighlight", {})
      vim.api.nvim_create_autocmd("ColorScheme", {
        pattern = "moonfly",
        callback = function()
          vim.api.nvim_set_hl(0, "Function", { fg = "#74b2ff", bold = true })
        end,
        group = custom_highlight,
      })
      
      
      require("moonfly").palette
      
      
        require("moonfly").custom_colors({
          bg = "#121212",
          violet = "#ff74b8",
        })
        vim.cmd([[colorscheme moonfly]])
      
    end,
  },
  {
    "ChristianChiarulli/nvcode-color-schemes.vim",
  },
  {
    "folke/tokyonight.nvim",
    config = function()
      
      {
        "folke/tokyonight.nvim",
        lazy = false,
        priority = 1000,
        opts = {},
      }
      
      
      vim.cmd[[colorscheme tokyonight]]
      
      
      -- Lua
      require('barbecue').setup {
        -- ... your barbecue config
        theme = 'tokyonight',
        -- ... your barbecue config
      }
      
      
      -- Lua
      require('lualine').setup {
        options = {
          -- ... your lualine config
          theme = 'tokyonight'
          -- ... your lualine config
        }
      }
      
      
      ---@class tokyonight.Config
      ---@field on_colors fun(colors: ColorScheme)
      ---@field on_highlights fun(highlights: tokyonight.Highlights, colors: ColorScheme)
      M.defaults = {
        style = "moon", -- The theme comes in three styles, `storm`, a darker variant `night` and `day`
        light_style = "day", -- The theme is used when the background is set to light
        transparent = false, -- Enable this to disable setting the background color
        terminal_colors = true, -- Configure the colors used when opening a `:terminal` in Neovim
        styles = {
          -- Style to be applied to different syntax groups
          -- Value is any valid attr-list value for `:help nvim_set_hl`
          comments = { italic = true },
          keywords = { italic = true },
          functions = {},
          variables = {},
          -- Background styles. Can be "dark", "transparent" or "normal"
          sidebars = "dark", -- style for sidebars, see below
          floats = "dark", -- style for floating windows
        },
        day_brightness = 0.3, -- Adjusts the brightness of the colors of the **Day** style. Number between 0 and 1, from dull to vibrant colors
        dim_inactive = false, -- dims inactive windows
        lualine_bold = false, -- When `true`, section headers in the lualine theme will be bold
      
        --- You can override specific color groups to use other groups or a hex color
        --- function will be called with a ColorScheme table
        ---@param colors ColorScheme
        on_colors = function(colors) end,
      
        --- You can override specific highlights to use other groups or a hex color
        --- function will be called with a Highlights and ColorScheme table
        ---@param highlights tokyonight.Highlights
        ---@param colors ColorScheme
        on_highlights = function(highlights, colors) end,
      
        cache = true, -- When set to true, the theme will be cached for better performance
      
        ---@type table<string, boolean|{enabled:boolean}>
        plugins = {
          -- enable all plugins when not using lazy.nvim
          -- set to false to manually enable/disable plugins
          all = package.loaded.lazy == nil,
          -- uses your plugin manager to automatically enable needed plugins
          -- currently only lazy.nvim is supported
          auto = true,
          -- add any plugins here that you want to enable
          -- for all possible plugins, see:
          --   * https://github.com/folke/tokyonight.nvim/tree/main/lua/tokyonight/groups
          -- telescope = true,
        },
      }
      
      
      require("tokyonight").setup({
        -- use the night style
        style = "night",
        -- disable italic for functions
        styles = {
          functions = {}
        },
        -- Change the "hint" color to the "orange" color, and make the "error" color bright red
        on_colors = function(colors)
          colors.hint = colors.orange
          colors.error = "#ff0000"
        end
      })
      
      
      require("tokyonight").setup({
        on_highlights = function(hl, c)
          local prompt = "#2d3149"
          hl.TelescopeNormal = {
            bg = c.bg_dark,
            fg = c.fg_dark,
          }
          hl.TelescopeBorder = {
            bg = c.bg_dark,
            fg = c.bg_dark,
          }
          hl.TelescopePromptNormal = {
            bg = prompt,
          }
          hl.TelescopePromptBorder = {
            bg = prompt,
            fg = prompt,
          }
          hl.TelescopePromptTitle = {
            bg = prompt,
            fg = prompt,
          }
          hl.TelescopePreviewTitle = {
            bg = c.bg_dark,
            fg = c.bg_dark,
          }
          hl.TelescopeResultsTitle = {
            bg = c.bg_dark,
            fg = c.bg_dark,
          }
        end,
      })
      
      
      local colors = require("tokyonight.colors").setup() -- pass in any of the config options as explained above
      local util = require("tokyonight.util")
      
      aplugin.background = colors.bg_dark
      aplugin.my_error = util.lighten(colors.red1, 0.3) -- number between 0 and 1. 0 results in white, 1 results in red1
      
    end,
  },
  {
    "comfysage/evergarden",
    config = function()
      
      return {
        'everviolet/nvim', name = 'evergarden',
        priority = 1000, -- Colorscheme plugin is loaded first before any other plugins
        opts = {
          theme = {
            variant = 'fall', -- 'winter'|'fall'|'spring'|'summer'
            accent = 'green',
          },
          editor = {
            transparent_background = false,
            sign = { color = 'none' },
            float = {
              color = 'mantle',
              solid_border = false,
            },
            completion = {
              color = 'surface0',
            },
          },
        }
      }
      
      
      require 'evergarden'.setup {
        theme = {
          variant = 'fall', -- 'winter'|'fall'|'spring'|'summer'
          accent = 'green',
        },
        editor = {
          transparent_background = false,
          override_terminal = true,
          sign = { color = 'none' },
          float = {
            color = 'mantle',
            solid_border = false,
          },
          completion = {
            color = 'surface0',
          },
        },
        style = {
          tabline = { 'reverse' },
          search = { 'italic', 'reverse' },
          incsearch = { 'italic', 'reverse' },
          types = { 'italic' },
          keyword = { 'italic' },
          comment = { 'italic' },
        },
        overrides = {},
        color_overrides = {},
      }
      
      
      {
        integrations = {
          blink_cmp = true,
          cmp = true,
          fzf_lua = true,
          gitsigns = true,
          indent_blankline = { enable = true, scope_color = 'green' },
          mini = {
            enable = true,
            animate = true,
            clue = true,
            completion = true,
            cursorword = true,
            deps = true,
            diff = true,
            files = true,
            hipatterns = true,
            icons = true,
            indentscope = true,
            jump = true,
            jump2d = true,
            map = true,
            notify = true,
            operators = true,
            pick = true,
            starters = true,
            statusline = true,
            surround = true,
            tabline = true,
            test = true,
            trailspace = true,
          },
          nvimtree = true,
          rainbow_delimiters = true,
          symbols_outline = true,
          telescope = true,
          which_key = true,
          neotree = true,
        },
      }
      
      
      require 'evergarden'.setup {
        overrides = {
          Normal = {
            '#fddce3',
            '#1d2021',
      
            -- Additional highlight options can be included here
            style = { 'bold', 'italic' }
          },
          Keyword = {
            fg = '#ce96de',
            bg = '#ae45be',
          },
        },
      }
      
    end,
  },
  {
    "uhs-robert/oasis.nvim",
    config = function()
      
      {
        "uhs-robert/oasis.nvim",
        config = function()
          vim.cmd.colorscheme("oasis") -- or use a variant like ("oasis_desert")
        end
      }
      
      
      -- Use default theme (lagoon variant)
      vim.cmd.colorscheme("oasis")
      
      
      require('lualine').setup {
        options = {
          theme = 'oasis'  -- Automatically matches your current Oasis palette
        }
      }
      
      
      require('tabby').setup({
        theme = 'oasis'  -- Uses current Oasis palette for tab styling
      })
      
    end,
  },
  {
    "sainnhe/sonokai",
  },
  {
    "nyoom-engineering/oxocarbon.nvim",
    config = function()
      
      use {'nyoom-engineering/oxocarbon.nvim'}
      
      
      return {
        "nyoom-engineering/oxocarbon.nvim"
        -- Add in any other configuration; 
        --   event = foo, 
        --   config = bar
        --   end,
      }
      
      
      vim.opt.background = "dark" -- set this to dark or light
      vim.cmd.colorscheme "oxocarbon"
      
      
      vim.opt.background = "dark" -- set this to dark or light
      vim.cmd("colorscheme oxocarbon")
      
      
      vim.api.nvim_set_hl(0, "Normal", { bg = "none" })
      vim.api.nvim_set_hl(0, "NormalFloat", { bg = "none" })
      vim.api.nvim_set_hl(0, "NormalNC", { bg = "none" })
      
    end,
  },
  {
    "kyazdani42/blue-moon",
    config = function()
      
      use {
        "kyazdani42/blue-moon",
        config = function()
          vim.opt.termguicolors = true
          vim.cmd "colorscheme blue-moon"
        end
      }
      
    end,
  },
  {
    "mhartington/oceanic-next",
  },
  {
    "nvimdev/zephyr-nvim",
    config = function()
      
      use({
        'glepnir/zephyr-nvim',
        requires = { 'nvim-treesitter/nvim-treesitter', opt = true },
      })
      
      
      lua require('zephyr')
      
      
      -- Get zephyr color
      local zephyr =  require('zephyr').zephyr.yellow/teal/fg/bg
      
    end,
  },
  {
    "rockerBOO/boo-colorscheme-nvim",
    config = function()
      
      if vim.fn.has("termguicolors") then
        vim.opt.termguicolors = true
      end
      
      
      use 'rockerBOO/boo-colorscheme-nvim'
      
      
      require("boo-colorscheme").use({})
      
      
      require("boo-colorscheme").use({
        italic = true, -- toggle italics
        theme = "boo"
      })
      
      
      require('boo-colorscheme').use({ theme = 'sunset_cloud' })
      
    end,
  },
  {
    "jim-at-jibba/ariake.nvim",
    config = function()
      
      return {
          {
              'jim-at-jibba/ariake.nvim',
              config = function ()
      
               vim.cmd.colorscheme 'ariake'
              end
          }
      }
      
    end,
  },
  {
    "Th3Whit3Wolf/onebuddy",
  },
  {
    "ishan9299/modus-theme-vim",
    config = function()
      
      vim.cmd('colorscheme modus-vivendi') -- Dark
      -- or
      vim.cmd('colorscheme modus-operandi') -- Light
      
    end,
  },
  {
    "sainnhe/edge",
  },
  {
    "theniceboy/nvim-deus",
  },
  {
    "bkegley/gloombuddy",
  },
  {
    "Th3Whit3Wolf/one-nvim",
    config = function()
      
      vim.g.one_nvim_transparent_bg = true
      
    end,
  },
  {
    "PHSix/nvim-hybrid",
    config = function()
      
      use{
        'PHSix/nvim-hybrid',
        config = function()
          require('hybrid').setup()
          -- or use
          -- vim.cmd [[colorscheme nvim-hybrid]]
        end
      }
      
    end,
  },
  {
    "Th3Whit3Wolf/space-nvim",
    config = function()
      
      vim.g.space_nvim_transparent_bg = true
      
    end,
  },
  {
    "yonlu/omni.vim",
  },
  {
    "ray-x/aurora",
    config = function()
      
        -- lazy
         {
          'ray-x/aurora',
          init = function()
            vim.g.aurora_italic = 1
            vim.g.aurora_transparent = 1
            vim.g.aurora_bold = 1
          end,
          config = function()
              vim.cmd.colorscheme "aurora"
              -- override defaults
              vim.api.nvim_set_hl(0, '@number', {fg='#e933e3'})
          end
          }
      
    end,
  },
  {
    "ray-x/starry.nvim",
    config = function()
      
      use {'ray-x/starry.nvim', setup = function()
      -- see example setup below
      vim.g.starry_italic_comments = true
      ...
      end}
      
      
      local config = {
        border = false, -- Split window borders
        hide_eob = true, -- Hide end of buffer
        italics = {
          comments = false, -- Italic comments
          strings = false, -- Italic strings
          keywords = false, -- Italic keywords
          functions = false, -- Italic functions
          variables = false -- Italic variables
        },
      
        contrast = { -- Select which windows get the contrast background
          enable = true, -- Enable contrast
          terminal = true, -- Darker terminal
          filetypes = {}, -- Which filetypes get darker? e.g. *.vim, *.cpp, etc.
        },
      
        text_contrast = {
          lighter = false, -- Higher contrast text for lighter style
          darker = false -- Higher contrast text for darker style
        },
      
        disable = {
          background = false, -- true: transparent background
          term_colors = false, -- Disable setting the terminal colors
          eob_lines = false -- Make end-of-buffer lines invisible
        },
      
        style = {
          name = 'moonlight', -- Theme style name (moonlight, earliestsummer, etc.)
          -- " other themes: dracula, oceanic, dracula_blood, 'deep ocean', darker, palenight, monokai, mariana, emerald, middlenight_blue
          disable = {},  -- a list of styles to disable, e.g. {'bold', 'underline'}
          fix = true,
          darker_contrast = false, -- More contrast for darker style
          daylight_swith = false, -- Enable day and night style switching
          deep_black = false, -- Enable a deeper black background
        },
      
        custom_colors = {
          variable = '#f797d7',
        },
        custom_highlights = {
          LineNr = { fg = '#777777' },
          Idnetifier = { fg = '#ff4797' },
        }
      }
      require('starry').setup(config)
      
      Toggle style
      
      
      
      :lua require('starry.functions').toggle_style()
      
      
      lua require('starry.functions').change_style("dracula_blood")
      
      
      local starry = require 'starry'
      local colors = require 'starry.colors'
      
      starry.setup{
          custom_highlights = {
              LineNr = { bg = '#9F809E' }
              CursorLine = { fg = colors.editor.constrast , underline = true },
      
              -- This is a list of possible values
              -- override @string of treesitter
              @string = {
                  fg = "#339922", -- foreground color
                  bg = "NONE", -- background color
                  sp = "#779988", -- special color (for colored underlines, undercurls...)
                  bold = false, -- make group bold
                  italic = false, -- make group italic
                  underline = false, -- make group underlined
                  undercurl = false, -- make group undercurled
                  underdot = false, -- make group underdotted
                  underdash = false -- make group underslashed
                  striketrough = false, -- make group striked trough
                  reverse = false, -- reverse the fg and bg colors
                  link = "Comment" -- link to some other highlight group
              }
          },
      
          -- Custom colors must be a function that takes in the default colors table as
          -- a paramter, and then modifies them.
          -- To se the available colors, see lua/material/colors/init.lua
          custom_colors = function(colors)
              colors.editor.bg = "#SOME_COLOR"
              colors.main.purple = "#SOME_COLOR"
              colors.lsp.error = "#SOME_COLOR"
          end
      }
      vim.cmd('colorscheme oceanic')
      
    end,
  },
  {
    "tanvirtin/monokai.nvim",
    config = function()
      
      require('monokai').setup {}
      require('monokai').setup { palette = require('monokai').pro }
      require('monokai').setup { palette = require('monokai').soda }
      require('monokai').setup { palette = require('monokai').ristretto }
      
      
      {
          palette = {
              name = 'monokai',
              base1 = '#272a30',
              base2 = '#26292C',
              base3 = '#2E323C',
              base4 = '#333842',
              base5 = '#4d5154',
              base6 = '#9ca0a4',
              base7 = '#b1b1b1',
              border = '#a1b5b1',
              brown = '#504945',
              white = '#f8f8f0',
              grey = '#8F908A',
              black = '#000000',
              pink = '#f92672',
              green = '#a6e22e',
              aqua = '#66d9ef',
              yellow = '#e6db74',
              orange = '#fd971f',
              purple = '#ae81ff',
              red = '#e95678',
              diff_add = '#3d5213',
              diff_remove = '#4a0f23',
              diff_change = '#27406b',
              diff_text = '#23324d',
          },
          custom_hlgroups = {},
      }
      
      
      local monokai = require('monokai')
      local palette = monokai.classic
      monokai.setup {
          palette = {
              diff_text = '#133337',
          },
          custom_hlgroups = {
              TSInclude = {
                  fg = palette.aqua,
              },
              GitSignsAdd = {
                  fg = palette.green,
                  bg = palette.base2
              },
              GitSignsDelete = {
                  fg = palette.pink,
                  bg = palette.base2
              },
              GitSignsChange = {
                  fg = palette.orange,
                  bg = palette.base2
              },
          }
      }
      
    end,
  },
  {
    "ofirgall/ofirkai.nvim",
    config = function()
      
      use 'ofirgall/ofirkai.nvim'
      
      
      use { 'ofirgall/ofirkai.nvim', branch = 'exp' }
      
      
      -- Leave empty for default values
      require('ofirkai').setup {
      }
      
      -- Or setup with custom parameters
      require('ofirkai').setup {
      	theme = nil -- Choose theme to use, available themes: 'dark_blue'
      
      	scheme = require('ofirkai').scheme -- Option to override scheme
      	custom_hlgroups = {},              -- Option to add/override highlight groups
      	remove_italics = false,            -- Option to change all the italics style to none
      }
      
      
      require('lualine').setup {
      	options = {
      		theme = require('ofirkai.statuslines.lualine').theme,
      	}
      }
      
      
      -- bufferline.nvim, must be loaded after color scheme (working on that https://github.com/ofirgall/ofirkai.nvim/issues/2)
      require('bufferline').setup {
      	highlights = require('ofirkai.tablines.bufferline').highlights, -- Must
      	options = { -- Optional, recommended
      		themable = true, -- Must
      		separator_style = 'slant',
      		offsets = { { filetype = 'NvimTree', text = 'File Explorer', text_align = 'center' } },
      		show_buffer_icons = true,
      		numbers = 'ordinal',
      		max_name_length = 40,
      	},
      }
      
      
      -- Unfortunately you can't set them for winbar separately in lualine so I use `color` in my winbar sections
      
      -- SmiteshP/nvim-navic (displays function context)
      local navic = require('nvim-navic')
      navic.setup {
      	separator = "  "
      }
      
      local ofirkai_lualine = require('ofirkai.statuslines.lualine')
      local winbar = {
      	lualine_a = {},
      	lualine_b = {
      		{
      			'filename',
      			icon = '',
      			color = ofirkai_lualine.winbar_color,
      			padding = { left = 4 }
      		},
      	},
      	lualine_c = {
      		{
      			navic.get_location,
      			icon = "",
      			cond = navic.is_available,
      			color = ofirkai_lualine.winbar_color,
      		},
      	},
      	lualine_x = {},
      	lualine_y = {},
      	lualine_z = {}
      }
      
      require('lualine').setup {
      	options = {
      		icons_enabled = true,
      		disabled_filetypes = { -- Recommended filetypes to disable winbar
      			winbar = { 'gitcommit', 'NvimTree', 'toggleterm', 'fugitive' },
      		},
      	},
      	winbar = winbar,
      	inactive_winbar = winbar,
      }
      
      
      require('cmp').setup({
      	window = require('ofirkai.plugins.nvim-cmp').window, -- I just removed the `FloatBorder:Normal` from the highlights to allow the FloatBorder to be colored, its not a must.
      
      	-- Get lsp icons from ofirkai, requires https://github.com/onsails/lspkind.nvim
      	formatting = {
      		format = lspkind.cmp_format({
      			symbol_map = require('ofirkai.plugins.nvim-cmp').kind_icons,
      			maxwidth = 50,
      			mode = 'symbol'
      		})
      	},
      
      })
      
      
      -- Requires `WhiteBorder` to show the title.
      require('dressing').setup {
          input = {
              winhighlight = require('ofirkai.plugins.dressing').winhighlight
          }
      }
      
      
      require('nvim-tree').setup {
      	renderer = {
      		icons = {
      			git_placement = 'after',
      			modified_placement = 'after',
      			glyphs = {
      				git = {
      					unstaged = '',
      					staged = '',
      					untracked = '',
      					deleted = '',
      				},
      			},
      		},
      	},
      }
      
      
      require('noice').setup {
          popupmenu = {
              enabled = false, -- I prefer nvim-cmp
          },
          lsp = {
              signature = {
                  enabled = false -- I prefer to use ray-x/lsp_signature.nvim with minimal design
              },
              override = {
                  -- Override `vim.lsp.buf.hover` and `nvim-cmp` doc formatter with `noice` doc formatter.
                  ['vim.lsp.util.convert_input_to_markdown_lines'] = true,
                  ['vim.lsp.util.stylize_markdown'] = true,
                  ['cmp.entry.get_documentation'] = true,
              },
          },
      }
      
      
      require('notify').setup {
          background_colour = require('ofirkai').scheme.ui_bg,
      }
      
      
      local lsp_signature_cfg = {
      	bind = true,
      	use_lspsaga = false,
      	doc_lines = 0,
      	floating_window = false,
      	hint_scheme = 'LspSignatureHintVirtualText',
      	hint_prefix = ' ',
      }
      
    end,
  },
  {
    "savq/melange-nvim",
    config = function()
      
      "savq/melange-nvim";
      
      
      vim.cmd.colorscheme 'melange'
      
    end,
  },
  {
    "RRethy/base16-nvim",
    config = function()
      
      -- All builtin colorschemes can be accessed with |:colorscheme|.
      vim.cmd('colorscheme base16-gruvbox-dark-soft')
      
      -- Alternatively, you can provide a table specifying your colors to the setup function.
      require('base16-colorscheme').setup({
          base00 = '#16161D', base01 = '#2c313c', base02 = '#3e4451', base03 = '#6c7891',
          base04 = '#565c64', base05 = '#abb2bf', base06 = '#9a9bb3', base07 = '#c5c8e6',
          base08 = '#e06c75', base09 = '#d19a66', base0A = '#e5c07b', base0B = '#98c379',
          base0C = '#56b6c2', base0D = '#0184bc', base0E = '#c678dd', base0F = '#a06949',
      })
      
      
      -- To disable highlights for supported plugin(s), call the `with_config` function **before** setting the colorscheme.
      -- These are the defaults.
      require('base16-colorscheme').with_config({
          telescope = true,
          indentblankline = true,
          notify = true,
          ts_rainbow = true,
          cmp = true,
          illuminate = true,
          dapui = true,
      })
      
      -- You can get the base16 colors **after** setting the colorscheme by name (base01, base02, etc.)
      local color = require('base16-colorscheme').colors.base01
      
    end,
  },
  {
    "fenetikm/falcon",
  },
  {
    "andersevenrud/nordic.nvim",
    config = function()
      
      use {
          'andersevenrud/nordic.nvim',
          config = function()
              -- The table used in this example contains the default settings.
              -- Modify or remove these to your liking (this also applies to alternatives below):
              require('nordic').colorscheme({
                  -- Underline style used for spelling
                  -- Options: 'none', 'underline', 'undercurl'
                  underline_option = 'none',
      
                  -- Italics for certain keywords such as constructors, functions,
                  -- labels and namespaces
                  italic = true,
      
                  -- Italic styled comments
                  italic_comments = false,
      
                  -- Minimal mode: different choice of colors for Tabs and StatusLine
                  minimal_mode = false,
      
                  -- Darker backgrounds for certain sidebars, popups, etc.
                  -- Options: true, false, or a table of explicit names
                  -- Supported: terminal, qf, vista_kind, packer, nvim-tree, telescope, whichkey
                  alternate_backgrounds = false,
      
                  -- Callback function to define custom color groups
                  -- See 'lua/nordic/colors/example.lua' for example defitions
                  custom_colors = function(c, s, cs)
                    return {}
                  end
              })
          end
      }
      
    end,
  },
  {
    "AlexvZyl/nordic.nvim",
    config = function()
      
      use 'AlexvZyl/nordic.nvim'
      
      
      {
          'AlexvZyl/nordic.nvim',
          lazy = false,
          priority = 1000,
          config = function()
              require('nordic').load()
          end
      }
      
      
      vim.cmd.colorscheme('nordic')
      -- or
      require('nordic').load()
      
      
      require('lualine').setup({
          options = {
              theme = 'nordic'
          }
      })
      
      
      local palette = require('nordic.colors')
      
      
      require('nordic').setup({
          -- This callback can be used to override the colors used in the base palette.
          on_palette = function(palette) end,
          -- This callback can be used to override the colors used in the extended palette.
          after_palette = function(palette) end,
          -- This callback can be used to override highlights before they are applied.
          on_highlight = function(highlights, palette) end,
          -- Enable bold keywords.
          bold_keywords = false,
          -- Enable italic comments.
          italic_comments = true,
          -- Enable editor background transparency.
          transparent = {
              -- Enable transparent background.
              bg = false,
              -- Enable transparent background for floating windows.
              float = false,
          },
          -- Enable brighter float border.
          bright_border = false,
          -- Reduce the overall amount of blue in the theme (diverges from base Nord).
          reduced_blue = true,
          -- Swap the dark background with the normal one.
          swap_backgrounds = false,
          -- Cursorline options.  Also includes visual/selection.
          cursorline = {
              -- Bold font in cursorline.
              bold = false,
              -- Bold cursorline number.
              bold_number = true,
              -- Available styles: 'dark', 'light'.
              theme = 'dark',
              -- Blending the cursorline bg with the buffer bg.
              blend = 0.85,
          },
          noice = {
              -- Available styles: `classic`, `flat`.
              style = 'classic',
          },
          telescope = {
              -- Available styles: `classic`, `flat`.
              style = 'flat',
          },
          leap = {
              -- Dims the backdrop when using leap.
              dim_backdrop = false,
          },
          ts_context = {
              -- Enables dark background for treesitter-context window
              dark_background = true,
          }
      })
      
      
      require('nordic').setup({
          on_palette = function(palette)
              palette.black0 = "#BF616A"
              palette.green.base = palette.cyan.base
          end,
      })
      
      
      require('nordic').setup({
          after_palette = function(palette)
              local U = require("nordic.utils")
              palette.bg_visual = U.blend(palette.orange.base, palette.bg, 0.15)
          end,
      })
      
      
      require('nordic').setup({
          on_highlight = function(highlights, palette)
              highlights.TelescopePromptTitle = {
                  fg = palette.red.bright,
                  bg = palette.green.base,
                  italic = true,
                  underline = true,
                  sp = palette.yellow.dim,
                  undercurl = false
              }
          end,
      })
      
      
      require('nordic').setup({
          on_highlight = function(highlights, _palette)
              for _, highlight in pairs(highlights) do
                  highlight.italic = false
              end
          end
      })
      
    end,
  },
  {
    "shaunsingh/nord.nvim",
    config = function()
      
      -- If you are using Packer
      use 'shaunsingh/nord.nvim'
      
      
      --Lua:
      vim.cmd[[colorscheme nord]]
      
      
      require('lualine').setup {
        options = {
          -- ... your lualine config
          theme = 'nord'
          -- ... your lualine config
        }
      }
      
      
      -- Example config in lua
      vim.g.nord_contrast = true
      vim.g.nord_borders = false
      vim.g.nord_disable_background = false
      vim.g.nord_italic = false
      vim.g.nord_uniform_diff_background = true
      vim.g.nord_bold = false
      
      -- Load the colorscheme
      require('nord').set()
      
      
      require("headlines").setup({
          markdown = {
              headline_highlights = {
                  "Headline1",
                  "Headline2",
                  "Headline3",
                  "Headline4",
                  "Headline5",
                  "Headline6",
              },
              codeblock_highlight = "CodeBlock",
              dash_highlight = "Dash",
              quote_highlight = "Quote",
          },
      })
      
      
      
      local highlights = require("nord").bufferline.highlights({
          italic = true,
          bold = true,
      })
      
      require("bufferline").setup({
          options = {
              separator_style = "thin",
          },
          highlights = highlights,
      })
      
      
      
      local highlights = require("nord").bufferline.highlights({
          italic = true,
          bold = true,
          fill = "#181c24"
      })
      
      require("bufferline").setup({
          options = {
              separator_style = "slant",
          },
          highlights = highlights,
      })
      
      
      
      {
          fill = colors.nord0_gui,
          indicator = colors.nord9_gui,
          bg = colors.nord0_gui,
          buffer_bg = colors.nord0_gui,
          buffer_bg_selected = colors.nord1_gui,
          buffer_bg_visible = "#2A2F3A",
          bold = true,
          italic = true,
      }
      
    end,
  },
  {
    "Tsuzat/NeoSolarized.nvim",
    config = function()
      
      vim.g.NeoSolarized_italics = 1 -- 0 or 1
      vim.g.NeoSolarized_visibility = 'normal' -- low, normal, high
      vim.g.NeoSolarized_diffmode = 'normal' -- low, normal, high
      vim.g.NeoSolarized_termtrans = 1 -- 0(default) or 1 -> Transparency
      vim.g.NeoSolarized_lineNr = 0 -- 0 or 1 (default) -> To Show backgroung in LineNr
      
      vim.cmd [[
          try
              colorscheme NeoSolarized
          catch /^Vim\%((\a\+)\)\=:E18/
              colorscheme default
              set background=dark
          endtry
              highlight FloatBorder guibg=NONE ctermbg=NONE  " Removes the border of float menu (LSP and Autocompletion uses it)
              highlight link NormalFloat Normal 
              highlight NormalFloat ctermbg=NONE ctermfg=NONE guibg=NONE guifg=NONE 
              highlight Pmenu ctermbg=NONE guibg=NONE 
      ]]
      
    end,
  },
  {
    "svrana/neosolarized.nvim",
    config = function()
      
      -- lua
      {
        "svrana/neosolarized.nvim",
        lazy = false,
        priority = 1000,
        config = function()
          require("neosolarized").setup({
            comment_italics = true,
            background_set = false,
          })
          vim.cmd.colorscheme("neosolarized")
        end,
        dependencies = {
          "tjdevries/colorbuddy.nvim",
        },
      }
      
    end,
  },
  {
    "ishan9299/nvim-solarized-lua",
    config = function()
      
      vim.g.solarized_italics = 1
      
      
      vim.g.solarized_visibility = 'normal'
      
      
      vim.g.solarized_diffmode = 'normal'
      
      
      -- To enable transparency
      if vim.fn.has('gui_running') == 0 then
          vim.g.solarized_termtrans = 0
      else
          vim.g.solarized_termtrans = 1
      end
      
      
       vim.g.solarized_statusline = 'normal'
       
    end,
  },
  {
    "navarasu/onedark.nvim",
    config = function()
      
      -- Using Lazy
      {
        "navarasu/onedark.nvim",
        priority = 1000, -- make sure to load this before all the other start plugins
        config = function()
          require('onedark').setup {
            style = 'darker'
          }
          -- Enable theme
          require('onedark').load()
        end
      }
      
      
      -- Using Packer
      use 'navarasu/onedark.nvim'
      
      
      -- Lua
      require('onedark').load()
      
      
      -- Lua
      require('onedark').setup {
          style = 'darker'
      }
      require('onedark').load()
      
      
      -- Lua
      require('onedark').setup  {
          -- Main options --
          style = 'dark', -- Default theme style. Choose between 'dark', 'darker', 'cool', 'deep', 'warm', 'warmer' and 'light'
          transparent = false,  -- Show/hide background
          term_colors = true, -- Change terminal color as per the selected theme style
          ending_tildes = false, -- Show the end-of-buffer tildes. By default they are hidden
          cmp_itemkind_reverse = false, -- reverse item kind highlights in cmp menu
      
          -- toggle theme style ---
          toggle_style_key = nil, -- keybind to toggle theme style. Leave it nil to disable it, or set it to a string, for example "<leader>ts"
          toggle_style_list = {'dark', 'darker', 'cool', 'deep', 'warm', 'warmer', 'light'}, -- List of styles to toggle between
      
          -- Change code style ---
          -- Options are italic, bold, underline, none
          -- You can configure multiple style with comma separated, For e.g., keywords = 'italic,bold'
          code_style = {
              comments = 'italic',
              keywords = 'none',
              functions = 'none',
              strings = 'none',
              variables = 'none'
          },
      
          -- Lualine options --
          lualine = {
              transparent = false, -- lualine center bar transparency
          },
      
          -- Custom Highlights --
          colors = {}, -- Override default colors
          highlights = {}, -- Override highlight groups
      
          -- Plugins Config --
          diagnostics = {
              darker = true, -- darker colors for diagnostic
              undercurl = true,   -- use undercurl instead of underline for diagnostics
              background = true,    -- use background color for virtual text
          },
      }
      
      
      require('onedark').setup {
        colors = {
          bright_orange = "#ff8800",    -- define a new color
          green = '#00ffaa',            -- redefine an existing color
        },
        highlights = {
          ["@lsp.type.keyword"] = { fg = "$green" },
          ["@lsp.type.property"] = {fg = '$bright_orange', bg = '#00ff00', fmt = 'bold'},
          ["@lsp.type.function"] =  {fg = '#0000ff', sp = '$cyan', fmt = 'underline,italic'},
          ["@lsp.type.method"] = { link = "@function" },
        -- To add language specific config
          ["@lsp.type.variable.go"] = { fg = "none" },
        }
      }
      
      
      require('onedark').setup {
        colors = {
          bright_orange = "#ff8800",    -- define a new color
          green = '#00ffaa',            -- redefine an existing color
        },
        highlights = {
          TSKeyword = {fg = '$green'},
          TSString = {fg = '$bright_orange', bg = '#00ff00', fmt = 'bold'},
          TSFunction = {fg = '#0000ff', sp = '$cyan', fmt = 'underline,italic'},
          TSFuncBuiltin = {fg = '#0059ff'}
        }
      }
      
      
      require('lualine').setup {
        options = {
          theme = 'onedark'
          -- ... your lualine config
        }
      }
      
    end,
  },
  {
    "sainnhe/gruvbox-material",
  },
  {
    "sainnhe/everforest",
  },
  {
    "neanias/everforest-nvim",
    config = function()
      
      require("lazy").setup({
        "neanias/everforest-nvim",
        version = false,
        lazy = false,
        priority = 1000, -- make sure to load this before all the other start plugins
        -- Optional; default configuration will be used if setup isn't called.
        config = function()
          require("everforest").setup({
            -- Your config here
          })
        end,
      })
      
      
      use({
        "neanias/everforest-nvim",
        -- Optional; default configuration will be used if setup isn't called.
        config = function()
          require("everforest").setup()
        end,
      })
      
      
      -- In Lua
      vim.cmd([[colorscheme everforest]])
      
      -- Alternatively
      require("everforest").load()
      
      
      require("lualine").setup({
        options = {
          -- ... other configuration
          theme = "everforest", -- Can also be "auto" to detect automatically.
        }
      })
      
      
      require("everforest").setup({
        ---Controls the "hardness" of the background. Options are "soft", "medium" or "hard".
        ---Default is "medium".
        background = "medium",
        ---How much of the background should be transparent. 2 will have more UI
        ---components be transparent (e.g. status line background)
        transparent_background_level = 0,
        ---Whether italics should be used for keywords and more.
        italics = false,
        ---Disable italic fonts for comments. Comments are in italics by default, set
        ---this to `true` to make them _not_ italic!
        disable_italic_comments = false,
        ---By default, the colour of the sign column background is the same as the as normal text
        ---background, but you can use a grey background by setting this to `"grey"`.
        sign_column_background = "none",
        ---The contrast of line numbers, indent lines, etc. Options are `"high"` or
        ---`"low"` (default).
        ui_contrast = "low",
        ---Dim inactive windows. Only works in Neovim. Can look a bit weird with Telescope.
        ---
        ---When this option is used in conjunction with show_eob set to `false`, the
        ---end of the buffer will only be hidden inside the active window. Inside
        ---inactive windows, the end of buffer filler characters will be visible in
        ---dimmed symbols. This is due to the way Vim and Neovim handle `EndOfBuffer`.
        dim_inactive_windows = false,
        ---Some plugins support highlighting error/warning/info/hint texts, by
        ---default these texts are only underlined, but you can use this option to
        ---also highlight the background of them.
        diagnostic_text_highlight = false,
        ---Which colour the diagnostic text should be. Options are `"grey"` or `"coloured"` (default)
        diagnostic_virtual_text = "coloured",
        ---Some plugins support highlighting error/warning/info/hint lines, but this
        ---feature is disabled by default in this colour scheme.
        diagnostic_line_highlight = false,
        ---By default, this color scheme won't colour the foreground of |spell|, instead
        ---colored under curls will be used. If you also want to colour the foreground,
        ---set this option to `true`.
        spell_foreground = false,
        ---Whether to show the EndOfBuffer highlight.
        show_eob = true,
        ---Style used to make floating windows stand out from other windows. `"bright"`
        ---makes the background of these windows lighter than |hl-Normal|, whereas
        ---`"dim"` makes it darker.
        ---
        ---Floating windows include for instance diagnostic pop-ups, scrollable
        ---documentation windows from completion engines, overlay windows from
        ---installers, etc.
        ---
        ---NB: This is only significant for dark backgrounds as the light palettes
        ---have the same colour for both values in the switch.
        float_style = "bright",
        ---Inlay hints are special markers that are displayed inline with the code to
        ---provide you with additional information. You can use this option to customize
        ---the background color of inlay hints.
        ---
        ---Options are `"none"` or `"dimmed"`.
        inlay_hints_background = "none",
        ---You can override specific highlights to use other groups or a hex colour.
        ---This function will be called with the highlights and colour palette tables.
        ---@param highlight_groups Highlights
        ---@param palette Palette
        on_highlights = function(highlight_groups, palette) end,
        ---You can override colours in the palette to use different hex colours.
        ---This function will be called once the base and background colours have
        ---been mixed on the palette.
        ---@param palette Palette
        colours_override = function(palette) end,
      })
      
      
      require("everforest").setup({
        on_highlights = function(hl, palette)
          hl.DiagnosticError = { fg = palette.none, bg = palette.none, sp = palette.red }
          hl.DiagnosticWarn = { fg = palette.none, bg = palette.none, sp = palette.yellow }
          hl.DiagnosticInfo = { fg = palette.none, bg = palette.none, sp = palette.blue }
          hl.DiagnosticHint = { fg = palette.none, bg = palette.none, sp = palette.green }
        end,
      })
      
      
      require("everforest").setup({
        on_highlights = function(hl, palette)
          -- The default highlights for TSBoolean is linked to `Purple` which is fg
          -- purple and bg none. If we want to just add a bold style to the existing,
          -- we need to have the existing *and* the bold style. (We could link to
          -- `PurpleBold` here otherwise.)
          hl.TSBoolean = { fg = palette.purple, bg = palette.none, bold = true }
        end,
      })
      
      
      require("everforest").setup({
        on_highlights = function(hl, palette)
          hl.TSDanger = {}
        end,
      })
      
      
      require("everforest").setup({
        colours_override = function (palette)
          palette.red = "#b86466"
        end
      })
      
    end,
  },
  {
    "NTBBloodbath/doom-one.nvim",
    config = function()
      
      return {
          'NTBBloodbath/doom-one.nvim',
          config = function()
              -- Add color to cursor
      		vim.g.doom_one_cursor_coloring = false
      		-- Set :terminal colors
      		vim.g.doom_one_terminal_colors = true
      		-- Enable italic comments
      		vim.g.doom_one_italic_comments = false
      		-- Enable TS support
      		vim.g.doom_one_enable_treesitter = true
      		-- Color whole diagnostic text or only underline
              vim.g.doom_one_diagnostics_text_color = false
      		-- Enable transparent background
      		vim.g.doom_one_transparent_background = false
      
              -- Pumblend transparency
      		vim.g.doom_one_pumblend_enable = false
      		vim.g.doom_one_pumblend_transparency = 20
      
              -- Plugins integration
      		vim.g.doom_one_plugin_neorg = true
      		vim.g.doom_one_plugin_barbar = false
      		vim.g.doom_one_plugin_telescope = false
      		vim.g.doom_one_plugin_neogit = true
      		vim.g.doom_one_plugin_nvim_tree = true
      		vim.g.doom_one_plugin_dashboard = true
      		vim.g.doom_one_plugin_startify = true
      		vim.g.doom_one_plugin_whichkey = true
      		vim.g.doom_one_plugin_indent_blankline = true
      		vim.g.doom_one_plugin_vim_illuminate = true
      		vim.g.doom_one_plugin_lspsaga = false
          end
      }
      
      
      use({
          'NTBBloodbath/doom-one.nvim',
          setup = function()
              -- Add color to cursor
      		vim.g.doom_one_cursor_coloring = false
      		-- Set :terminal colors
      		vim.g.doom_one_terminal_colors = true
      		-- Enable italic comments
      		vim.g.doom_one_italic_comments = false
      		-- Enable TS support
      		vim.g.doom_one_enable_treesitter = true
      		-- Color whole diagnostic text or only underline
              vim.g.doom_one_diagnostics_text_color = false
      		-- Enable transparent background
      		vim.g.doom_one_transparent_background = false
      
              -- Pumblend transparency
      		vim.g.doom_one_pumblend_enable = false
      		vim.g.doom_one_pumblend_transparency = 20
      
              -- Plugins integration
      		vim.g.doom_one_plugin_neorg = true
      		vim.g.doom_one_plugin_barbar = false
      		vim.g.doom_one_plugin_telescope = false
      		vim.g.doom_one_plugin_neogit = true
      		vim.g.doom_one_plugin_nvim_tree = true
      		vim.g.doom_one_plugin_dashboard = true
      		vim.g.doom_one_plugin_startify = true
      		vim.g.doom_one_plugin_whichkey = true
      		vim.g.doom_one_plugin_indent_blankline = true
      		vim.g.doom_one_plugin_vim_illuminate = true
      		vim.g.doom_one_plugin_lspsaga = false
      	end,
      	config = function()
              vim.cmd("colorscheme doom-one")
          end,
      })
      
      
      require("headlines").setup({
          norg = {
              headline_highlights = {"Headline1", "Headline2", "Headline3", "Headline4", "Headline5", "Headline6"},
              codeblock_highlight = {"NeorgCodeBlock"},
          }
      })
      
    end,
  },
  {
    "dracula/vim",
  },
  {
    "Mofiqul/dracula.nvim",
    config = function()
      
      -- Using Packer:
      use 'Mofiqul/dracula.nvim'
      
      
      -- Lua:
      vim.cmd[[colorscheme dracula]]
      -- or
      vim.cmd[[colorscheme dracula-soft]]
      
      
      require('lualine').setup {
        options = {
          -- ...
          theme = 'dracula-nvim'
          -- ...
        }
      }
      
      
      return {
        -- add dracula
        { "Mofiqul/dracula.nvim" },
      
        -- Configure LazyVim to load dracula
        {
          "LazyVim/LazyVim",
          opts = {
            colorscheme = "dracula",
          },
        },
      }
      
      
      local dracula = require("dracula")
      dracula.setup({
        -- customize dracula color palette
        colors = {
          bg = "#282A36",
          fg = "#F8F8F2",
          selection = "#44475A",
          comment = "#6272A4",
          red = "#FF5555",
          orange = "#FFB86C",
          yellow = "#F1FA8C",
          green = "#50fa7b",
          purple = "#BD93F9",
          cyan = "#8BE9FD",
          pink = "#FF79C6",
          bright_red = "#FF6E6E",
          bright_green = "#69FF94",
          bright_yellow = "#FFFFA5",
          bright_blue = "#D6ACFF",
          bright_magenta = "#FF92DF",
          bright_cyan = "#A4FFFF",
          bright_white = "#FFFFFF",
          menu = "#21222C",
          visual = "#3E4452",
          gutter_fg = "#4B5263",
          nontext = "#3B4048",
          white = "#ABB2BF",
          black = "#191A21",
        },
        -- show the '~' characters after the end of buffers
        show_end_of_buffer = true, -- default false
        -- use transparent background
        transparent_bg = true, -- default false
        -- set custom lualine background color
        lualine_bg_color = "#44475a", -- default nil
        -- set italic comment
        italic_comment = true, -- default false
        -- overrides the default highlights with table see `:h synIDattr`
        overrides = {},
        -- You can use overrides as table like this
        -- overrides = {
        --   NonText = { fg = "white" }, -- set NonText fg to white
        --   NvimTreeIndentMarker = { link = "NonText" }, -- link to NonText highlight
        --   Nothing = {} -- clear highlight of Nothing
        -- },
        -- Or you can also use it like a function to get color from theme
        -- overrides = function (colors)
        --   return {
        --     NonText = { fg = colors.white }, -- set NonText fg to white of theme
        --   }
        -- end,
      })
      
      
      local colors = require('dracula').colors()
      
    end,
  },
  {
    "niyabits/calvera-dark.nvim",
    config = function()
      
      -- If you are using Packer
      use 'yashguptaz/calvera-dark.nvim'
      
      
      --Lua:
      
      -- Optional Example Configuration
      vim.g.calvera_italic_keywords = false
      vim.g.calvera_borders = true
      vim.g.calvera_contrast = true
      vim.g.calvera_hide_eob = true
      vim.g.calvera_custom_colors = {contrast = "#0f111a"}
      
      -- Required Setting
      require('calvera').set()
      
      
      require('lualine').setup {
        options = {
          -- ... your lualine config
          theme = 'calvera-nvim'
          -- ... your lualine config
        }
      }
      
      
      -- Example config in lua
      vim.g.calvera_italic_comments = true
      vim.g.calvera_italic_keywords = true
      vim.g.calvera_italic_functions = true
      vim.g.calvera_italic_variables = false
      vim.g.calvera_contrast = true
      vim.g.calvera_borders = false
      vim.g.calvera_disable_background = false
      vim.g.transparent_bg = true
      --vim.g.calvera_custom_colors = { black = "#000000", bg = "#0F111A" }
      
      -- Load the colorscheme
      require('calvera').set()
      
      
      --Lua:
      vim.api.nvim_set_keymap('n', '<leader>me', [[<Cmd>lua require('calvera.functions').toggle_eob()<CR>]], { noremap = true, silent = true })
      
    end,
  },
  {
    "nxvu699134/vn-night.nvim",
    config = function()
      
      -- Packer
      use {'nxvu699134/vn-night.nvim'}
      
      
      --Lua:
      require('vn-night').setup()
      
      
      require('lualine').setup {options = {theme = 'vn-night'}}
      
      
      require('vn-night.galaxyline')
      
    end,
  },
  {
    "adisen99/codeschool.nvim",
    config = function()
      
      use {"adisen99/codeschool.nvim", requires = {"rktjmp/lush.nvim"}}
      
      
      vim.o.background = "dark" -- or "light" for light mode
      
      -- Load and setup function to choose plugin and language highlights
      require('lush')(require('codeschool').setup({
        plugins = {
          "buftabline",
          "coc",
          "cmp", -- nvim-cmp
          "fzf",
          "gitgutter",
          "gitsigns",
          "lsp",
          "lspsaga",
          "nerdtree",
          "netrw",
          "nvimtree",
          "neogit",
          "packer",
          "signify",
          "startify",
          "syntastic",
          "telescope",
          "treesitter"
        },
        langs = {
          "c",
          "clojure",
          "coffeescript",
          "csharp",
          "css",
          "elixir",
          "golang",
          "haskell",
          "html",
          "java",
          "js",
          "json",
          "jsx",
          "lua",
          "markdown",
          "moonscript",
          "objc",
          "ocaml",
          "purescript",
          "python",
          "ruby",
          "rust",
          "scala",
          "typescript",
          "viml",
          "xml"
        }
      }))
      
      
      vim.cmd(colorscheme codeschool)
      
      
      g.codeschool_hls_lspreference = "orange"
      g.codeschool_hls_cursor = "orange"
      g.codeschool_hls_highlight = "orange"
      g.codeschool_italicize_booleans = true
      g.codeschool_tabline_sel = "fg0"
      }))
      
    end,
  },
  {
    "projekt0n/github-nvim-theme",
    config = function()
      
      -- Install without configuration
      use ({ 'projekt0n/github-nvim-theme' })
      
      -- Or with configuration
      use({
        'projekt0n/github-nvim-theme',
        config = function()
          require('github-theme').setup({
            -- ...
          })
      
          vim.cmd('colorscheme github_dark')
        end
      })
      
      
      -- Install without configuration
      { 'projekt0n/github-nvim-theme', name = 'github-theme' }
      
      -- Or with configuration
      {
        'projekt0n/github-nvim-theme',
        name = 'github-theme',
        lazy = false, -- make sure we load this during startup if it is your main colorscheme
        priority = 1000, -- make sure to load this before all the other start plugins
        config = function()
          require('github-theme').setup({
            -- ...
          })
      
          vim.cmd('colorscheme github_dark')
        end,
      }
      
      
      vim.cmd('colorscheme github_dark')
      
      
      vim.cmd('colorscheme github_dark')
      
      
      vim.cmd('colorscheme github_dark_default')
      
      
      vim.cmd('colorscheme github_dark_dimmed')
      
      
      vim.cmd('colorscheme github_dark_high_contrast')
      
      
      vim.cmd('colorscheme github_dark_colorblind')
      
      
      vim.cmd('colorscheme github_dark_tritanopia')
      
      
      vim.cmd('colorscheme github_light')
      
      
      vim.cmd('colorscheme github_light_default')
      
      
      vim.cmd('colorscheme github_light_high_contrast')
      
      
      vim.cmd('colorscheme github_light_colorblind')
      
      
      vim.cmd('colorscheme github_light_tritanopia')
      
      
      -- Default options
      require('github-theme').setup({
        options = {
          -- Compiled file's destination location
          compile_path = vim.fn.stdpath('cache') .. '/github-theme',
          compile_file_suffix = '_compiled', -- Compiled file suffix
          hide_end_of_buffer = true, -- Hide the '~' character at the end of the buffer for a cleaner look
          hide_nc_statusline = true, -- Override the underline style for non-active statuslines
          transparent = false,       -- Disable setting bg (make neovim's background transparent)
          terminal_colors = true,    -- Set terminal colors (vim.g.terminal_color_*) used in `:terminal`
          dim_inactive = false,      -- Non focused panes set to alternative background
          module_default = true,     -- Default enable value for modules
          styles = {                 -- Style to be applied to different syntax groups
            comments = 'NONE',       -- Value is any valid attr-list value `:help attr-list`
            functions = 'NONE',
            keywords = 'NONE',
            variables = 'NONE',
            conditionals = 'NONE',
            constants = 'NONE',
            numbers = 'NONE',
            operators = 'NONE',
            strings = 'NONE',
            types = 'NONE',
          },
          inverse = {                -- Inverse highlight for different types
            match_paren = false,
            visual = false,
            search = false,
          },
          darken = {                 -- Darken floating windows and sidebar-like windows
            floats = true,
            sidebars = {
              enable = true,
              list = {},             -- Apply dark background to specific windows
            },
          },
          modules = {                -- List of various plugins and additional options
            -- ...
          },
        },
        palettes = {},
        specs = {},
        groups = {},
      })
      
      -- setup must be called before loading
      vim.cmd('colorscheme github_dark')
      
      
      require('github-theme').setup({
        options = {
          styles = {
            comments = 'italic',
            keywords = 'bold',
            types = 'italic,bold',
          }
        }
      })
      
      
      -- Palettes are the base color defines of a colorscheme.
      -- You can override these palettes for each colorscheme defined by github-theme.
      local palettes = {
        -- Everything defined under `all` will be applied to each style.
        all = {
          -- Each palette defines these colors:
          --   black, gray, blue, green, magenta, pink, red, white, yellow, cyan
          --
          -- These colors have 2 shades: base, and bright
      
          -- Passing a string sets the base
          red = '#ff0000',
        },
        github_dark = {
          -- Defining multiple shades is done by passing a table
          red = {
            base = '#8e1519',
            bright = '#ee0000',
          },
        },
        github_dark_dimmed = {
          -- A palette also defines the following:
          --   bg0, bg1, bg2, bg3, bg4, fg0, fg1, fg2, fg3, sel0, sel1, comment
          --
          -- These are the different foreground and background shades used by the theme.
          -- The base bg and fg is 1, 0 is normally the dark alternative. The others are
          -- incrementally lighter versions.
          bg1 = '#444c56',
      
          -- sel is different types of selection colors.
          sel0 = '#adbac7', -- Popup bg, visual selection bg
          sel1 = '#22272e', -- Popup sel bg, search bg
      
          -- comment is the definition of the comment color.
          comment = '#636e7b',
        },
      }
      
      -- Spec's (specifications) are a mapping of palettes to logical groups that will be
      -- used by the groups. Some examples of the groups that specs map would be:
      --   - syntax groups (functions, types, keywords, ...)
      --   - diagnostic groups (error, warning, info, hints)
      --   - git groups (add, removed, changed)
      --
      -- You can override these just like palettes
      local specs = {
        -- As with palettes, the values defined under `all` will be applied to every style.
        all = {
          syntax = {
            -- Specs allow you to define a value using either a color or template. If the string does
            -- start with `#` the string will be used as the path of the palette table. Defining just
            -- a color uses the base version of that color.
            keyword = 'magenta',
      
            -- Adding either `.bright` will change the value
            conditional = 'magenta.bright',
            number = 'orange',
          },
          git = {
            -- A color define can also be used
            changed = '#ffa261',
          },
        },
        github_dark = {
          syntax = {
            -- As with palettes, a specific style's value will be used over the `all`'s value.
            operator = 'orange',
          },
        },
      }
      
      -- Groups are the highlight group definitions. The keys of this table are the name of the highlight
      -- groups that will be overridden. The value is a table with the following keys:
      --   - fg, bg, style, sp, link,
      --
      -- Just like `spec` groups support templates. This time the template is based on a spec object.
      local groups = {
        -- As with specs and palettes, the values defined under `all` will be applied to every style.
        all = {
          -- If `link` is defined it will be applied over any other values defined
          Whitespace = { link = 'Comment' },
      
          -- Specs are used for the template. Specs have their palette's as a field that can be accessed
          IncSearch = { bg = 'palette.cyan' },
        },
        github_dark = {
          -- As with specs and palettes, a specific style's value will be used over the `all`'s value.
          PmenuSel = { bg = '#73daca', fg = 'bg0' },
        },
      }
      
      require('github-theme').setup({ palettes = palettes, specs = specs, groups = groups })
      
      -- setup must be called before loading
      vim.cmd('colorscheme github_dark')
      
      
      require('github-theme').setup({
        palettes = {
          -- Custom duskfox with black background
          github_dark = {
            bg1 = '#000000', -- Black background
            bg0 = '#1d1d2b', -- Alt backgrounds (floats, statusline, ...)
            bg3 = '#121820', -- 55% darkened from stock
            sel0 = '#131b24', -- 55% darkened from stock
          },
        },
        specs = {
          all = {
            inactive = 'bg0', -- Default value for other styles
          },
          github_dark_dimmed = {
            inactive = '#090909', -- Slightly lighter then black background
          },
        },
        groups = {
          all = {
            NormalNC = { fg = 'fg1', bg = 'inactive' }, -- Non-current windows
          },
        },
      })
      
      
      -- Returns a table with each colorscheme and the palette associated with it
      local palettes = require('github-theme.palette').load()
      
      -- Returns the palette of the specified colorscheme
      local palette = require('github-theme.palette').load('github_dark_dimmed')
      
      print(vim.inspect(palette.red))
      -- {
      --   base = '#f47067',
      --   bright = '#ff938a'
      -- }
      
      
      -- Returns a table with each colorscheme and the spec associated with it
      local specs = require('github-theme.spec').load()
      
      -- Returns the spec of the specified colorscheme
      local spec = require('github-theme.spec').load('github_light')
      
      print(vim.inspect(spec.git))
      -- {
      --   add = '#1a7f37',
      --   changed = '#9a6700',
      --   conflict = '#bc4c00',
      --   ignored = '#6e7781',
      --   removed = '#d1242f'
      -- }
      
      
      local palette = require('github-theme.palette').load('github_dark')
      local Color = require('github-theme.lib.color')
      
      local bg = Color.from_hex(palette.canvas.default)
      local red = Color.from_hex('#ff0000')
      
      -- Blend the bg with red. The blend factor is from 0 to 1
      -- with 0 being full bg and 1 being full red
      local red_bg = bg:blend(red, 0.2)
      
      print(red_bg:to_css())
      -- '#592b31'
      
      -- Brighten bg by adding 10 to the value of the color as a hsv
      local alt_bg = bg:brighten(10)
      print(vim.inspect(alt_bg:to_hsv()))
      -- {
      --   hue = 212.30769230769,
      --   saturation = 21.311475409836,
      --   value = 33.921568627451
      -- }
      
      
      require('github-theme').compile() -- lua api version
      
      
      vim.cmd('colorscheme github_dark')
      require('lualine').setup({ ... })
      
    end,
  },
  {
    "kdheepak/monochrome.nvim",
    config = function()
      
      use {'kdheepak/monochrome.nvim', config = function()
          vim.cmd 'colorscheme monochrome'
      end}
      
    end,
  },
  {
    "rose-pine/neovim",
  },
  {
    "zenbones-theme/zenbones.nvim",
    config = function()
      
      {
          "zenbones-theme/zenbones.nvim",
          -- Optionally install Lush. Allows for more configuration or extending the colorscheme
          -- If you don't want to install lush, make sure to set g:zenbones_compat = 1
          -- In Vim, compat mode is turned on as Lush only works in Neovim.
          dependencies = "rktjmp/lush.nvim",
          lazy = false,
          priority = 1000,
          -- you can set set configuration options here
          -- config = function()
          --     vim.g.zenbones_darken_comments = 45
          --     vim.cmd.colorscheme('zenbones')
          -- end
      }
      
    end,
  },
  {
    "catppuccin/nvim",
    config = function()
      
      { "catppuccin/nvim", name = "catppuccin", priority = 1000 }
      
      
      add({ source = "catppuccin/nvim", name = "catppuccin" })
      
      
      use { "catppuccin/nvim", as = "catppuccin" }
      
      
      vim.cmd.colorscheme "catppuccin"
      
      
      require("catppuccin").setup({
          flavour = "auto", -- latte, frappe, macchiato, mocha
          background = { -- :h background
              light = "latte",
              dark = "mocha",
          },
          transparent_background = false, -- disables setting the background color.
          float = {
              transparent = false, -- enable transparent floating windows
              solid = false, -- use solid styling for floating windows, see |winborder|
          },
          show_end_of_buffer = false, -- shows the '~' characters after the end of buffers
          term_colors = false, -- sets terminal colors (e.g. `g:terminal_color_0`)
          dim_inactive = {
              enabled = false, -- dims the background color of inactive window
              shade = "dark",
              percentage = 0.15, -- percentage of the shade to apply to the inactive window
          },
          no_italic = false, -- Force no italic
          no_bold = false, -- Force no bold
          no_underline = false, -- Force no underline
          styles = { -- Handles the styles of general hi groups (see `:h highlight-args`):
              comments = { "italic" }, -- Change the style of comments
              conditionals = { "italic" },
              loops = {},
              functions = {},
              keywords = {},
              strings = {},
              variables = {},
              numbers = {},
              booleans = {},
              properties = {},
              types = {},
              operators = {},
              -- miscs = {}, -- Uncomment to turn off hard-coded styles
          },
          lsp_styles = { -- Handles the style of specific lsp hl groups (see `:h lsp-highlight`).
              virtual_text = {
                  errors = { "italic" },
                  hints = { "italic" },
                  warnings = { "italic" },
                  information = { "italic" },
                  ok = { "italic" },
              },
              underlines = {
                  errors = { "underline" },
                  hints = { "underline" },
                  warnings = { "underline" },
                  information = { "underline" },
                  ok = { "underline" },
              },
              inlay_hints = {
                  background = true,
              },
          },
          color_overrides = {},
          custom_highlights = {},
          default_integrations = true,
          auto_integrations = false,
          integrations = {
              cmp = true,
              gitsigns = true,
              nvimtree = true,
              notify = false,
              mini = {
                  enabled = true,
                  indentscope_color = "",
              },
              -- For more plugins integrations please scroll down (https://github.com/catppuccin/nvim#integrations)
          },
      })
      
      -- setup must be called before loading
      vim.cmd.colorscheme "catppuccin"
      
      
      local latte = require("catppuccin.palettes").get_palette "latte"
      local frappe = require("catppuccin.palettes").get_palette "frappe"
      local macchiato = require("catppuccin.palettes").get_palette "macchiato"
      local mocha = require("catppuccin.palettes").get_palette "mocha"
      
      
      require("catppuccin").setup {
          color_overrides = {
              all = {
                  text = "#ffffff",
              },
              latte = {
                  base = "#ff0000",
                  mantle = "#242424",
                  crust = "#474747",
              },
              frappe = {},
              macchiato = {},
              mocha = {},
          }
      }
      
      
      require("catppuccin").setup {
          custom_highlights = function(colors)
              return {
                  Comment = { fg = colors.flamingo },
                  TabLineSel = { bg = colors.pink },
                  CmpBorder = { fg = colors.surface2 },
                  Pmenu = { bg = colors.none },
              }
          end
      }
      
      
      require("catppuccin").setup {
          highlight_overrides = {
              all = function(colors)
                  return {
                      NvimTreeNormal = { fg = colors.none },
                      CmpBorder = { fg = "#3e4145" },
                  }
              end,
              latte = function(latte)
                  return {
                      Normal = { fg = latte.base },
                  }
              end,
              frappe = function(frappe)
                  return {
                      ["@comment"] = { fg = frappe.surface2, style = { "italic" } },
                  }
              end,
              macchiato = function(macchiato)
                  return {
                      LineNr = { fg = macchiato.overlay1 },
                  }
              end,
              mocha = function(mocha)
                  return {
                      Comment = { fg = mocha.flamingo },
                  }
              end,
          },
      }
      
      
      require("catppuccin").setup({
          integrations = {
              cmp = true,
              gitsigns = true,
              nvimtree = true,
              notify = false,
              mini = {
                  enabled = true,
                  indentscope_color = "",
              },
          }
      })
      
      
      require("catppuccin").setup({
          default_integrations = false,
      })
      
      
      require("catppuccin").setup({
          auto_integrations = true,
      })
      
      
      aerial = false
      
      
      alpha = true
      
      
      barbar = false
      
      
      barbecue = {
          dim_dirname = true, -- directory name is dimmed by default
          bold_basename = true,
          dim_context = false,
          alt_background = false,
      },
      
      
      require("barbecue").setup {
        theme = "catppuccin", -- catppuccin-latte, catppuccin-frappe, catppuccin-macchiato, catppuccin-mocha
      }
      
      
      beacon = false
      
      
      blink_cmp = {
          style = 'bordered',
      }
      
      
      use "akinsho/bufferline.nvim" {
        after = "catppuccin",
        config = function()
          require("bufferline").setup {
            highlights = require("catppuccin.special.bufferline").get_theme()
          }
        end
      }
      
      
      local mocha = require("catppuccin.palettes").get_palette "mocha"
      bufferline.setup {
          highlights = require("catppuccin.special.bufferline").get_theme {
              styles = { "italic", "bold" },
              custom = {
                  all = {
                      fill = { bg = "#000000" },
                  },
                  mocha = {
                      background = { fg = mocha.text },
                  },
                  latte = {
                      background = { fg = "#000000" },
                  },
              },
          },
      }
      
      
      buffon = false
      
      
      coc_nvim = false
      
      
      coc_nvim = true,
      
      
      lsp_styles = {
          virtual_text = {
              errors = { "italic" },
              hints = { "italic" },
              warnings = { "italic" },
              information = { "italic" },
              ok = { "italic" },
          },
          underlines = {
              errors = { "underline" },
              hints = { "underline" },
              warnings = { "underline" },
              information = { "underline" },
              ok = { "underline" },
          },
          inlay_hints = {
              background = true,
          },
      },
      
      
      colorful_winsep = {
          enabled = false,
          color = "red",
      }
      
      
      dashboard = true
      
      
      diffview = false
      
      
      dropbar = {
          enabled = false,
          color_mode = false, -- enable color for kind's texts, not just kind's icons
      },
      
      
      local ctp_feline = require('catppuccin.special.feline')
      
      ctp_feline.setup()
      
      require("feline").setup({
          components = ctp_feline.get_statusline(),
      })
      
      
      local clrs = require("catppuccin.palettes").get_palette()
      local ctp_feline = require('catppuccin.special.feline')
      local U = require "catppuccin.utils.colors"
      
      ctp_feline.setup({
          assets = {
              left_separator = "",
              right_separator = "",
              mode_icon = "",
              dir = "󰉖",
              file = "󰈙",
              lsp = {
                  server = "󰅡",
                  error = "",
                  warning = "",
                  info = "",
                  hint = "",
              },
              git = {
                  branch = "",
                  added = "",
                  changed = "",
                  removed = "",
              },
          },
          sett = {
              text = U.vary_color({ latte = latte.base }, clrs.surface0),
              bkg = U.vary_color({ latte = latte.crust }, clrs.surface0),
              diffs = clrs.mauve,
              extras = clrs.overlay1,
              curr_file = clrs.maroon,
              curr_dir = clrs.flamingo,
              show_modified = false, -- show if the file has been modified
              show_lazy_updates = false -- show the count of updatable plugins from lazy.nvim
                                        -- need to set checker.enabled = true in lazy.nvim first
                                        -- the icon is set in ui.icons.plugin in lazy.nvim
          },
          mode_colors = {
              ["n"] = { "NORMAL", clrs.lavender },
              ["no"] = { "N-PENDING", clrs.lavender },
              ["i"] = { "INSERT", clrs.green },
              ["ic"] = { "INSERT", clrs.green },
              ["t"] = { "TERMINAL", clrs.green },
              ["v"] = { "VISUAL", clrs.flamingo },
              ["V"] = { "V-LINE", clrs.flamingo },
              [""] = { "V-BLOCK", clrs.flamingo },
              ["R"] = { "REPLACE", clrs.maroon },
              ["Rv"] = { "V-REPLACE", clrs.maroon },
              ["s"] = { "SELECT", clrs.maroon },
              ["S"] = { "S-LINE", clrs.maroon },
              [""] = { "S-BLOCK", clrs.maroon },
              ["c"] = { "COMMAND", clrs.peach },
              ["cv"] = { "COMMAND", clrs.peach },
              ["ce"] = { "COMMAND", clrs.peach },
              ["r"] = { "PROMPT", clrs.teal },
              ["rm"] = { "MORE", clrs.teal },
              ["r?"] = { "CONFIRM", clrs.mauve },
              ["!"] = { "SHELL", clrs.green },
          },
          view = {
              lsp = {
                  progress = true, -- if true the status bar will display an lsp progress indicator
                  name = false, -- if true the status bar will display the lsp servers name, otherwise it will display the text "Lsp"
                  exclude_lsp_names = {}, -- lsp server names that should not be displayed when name is set to true
                  separator = "|", -- the separator used when there are multiple lsp servers
              },
          }
      })
      
      
      vim.api.nvim_create_autocmd("ColorScheme", {
          pattern = "*",
          callback = function()
              package.loaded["feline"] = nil
              package.loaded["catppuccin.special.feline"] = nil
              require("feline").setup {
                  components = require("catppuccin.special.feline").get_statusline(),
              }
          end,
      })
      
      
      fern = false
      
      
      fidget = false
      
      
      require("fidget").setup {
          notification = {
              window = {
                  winblend = 0,
              },
          }
          -- ... the rest of your fidget config
      }
      
      
      flash = true
      
      
      fzf = true
      
      
      gitgraph = false
      
      
      gitsigns = true
      
      
      gitsigns = {
        enabled = true,
        -- align with the transparent_background option by default
        transparent = false,
      }
       
      
      grug_far = false
      
      
      harpoon = false
      
      
      headlines = false
      
      
      hop = false
      
      
      indent_blankline = {
          enabled = true,
          scope_color = "", -- catppuccin color (eg. `lavender`) Default: text
          colored_indent_levels = false,
      },
      
      
      
      leap = false
      
      
      lightspeed = false
      
      
      lir = {
          enabled = false,
          git_status = false
      }
      
      
      lsp_saga = false
      
      
      require("lspsaga").setup {
          ui = {
              kind = require("catppuccin.groups.integrations.lsp_saga").custom_kind(),
          },
      }
      
      
      require('lualine').setup {
          options = {
              theme = "catppuccin"
              -- ... the rest of your lualine config
          }
      }
      
      
      markview = false
      
      
      mason = false
      
      
      mini = {
          enabled = true,
          indentscope_color = "", -- catppuccin color (eg. `lavender`) Default: text
      },
      
      
      neotree = true
      
      
      neogit = true
      
      
      neotest = false
      
      
      noice = false
      
      
      notifier = false
      
      
      cmp = true
      
      
      copilot_vim = false,
      
      
      dap = true
      
      
      local sign = vim.fn.sign_define
      
      sign("DapBreakpoint", { text = "●", texthl = "DapBreakpoint", linehl = "", numhl = ""})
      sign("DapBreakpointCondition", { text = "●", texthl = "DapBreakpointCondition", linehl = "", numhl = ""})
      sign("DapLogPoint", { text = "◆", texthl = "DapLogPoint", linehl = "", numhl = ""})
      
      
      dap_ui = true
      
      
      navic = {
          enabled = false,
          custom_bg = "NONE", -- "lualine" will set background to mantle
      },
      
      
      
      -- You NEED to enable highlight in nvim-navic setting or it won't work
      require("nvim-navic").setup {
          highlight = true
      }
      
      
      notify = false
      
      
      nvim_surround = false
      
      
      nvimtree = true
      
      
      treesitter_context = true
      
      
      ts_rainbow2 = false
      
      
      ts_rainbow = false
      
      
      ufo = true
      
      
      window_picker = false
      
      
      octo = false
      
      
      overseer = false
      
      
      pounce = false
      
      
      rainbow_delimiters = true
      
      
      require('reactive').setup {
        load = { 'catppuccin-mocha-cursor', 'catppuccin-mocha-cursorline' }
      }
      
      
      render_markdown = true
      
      
      snacks = {
          enabled = false,
          indent_scope_color = "", -- catppuccin color (eg. `lavender`) Default: text
      }
      
      
      symbols_outline = false
      
      
      telekasten = false
      
      
      telescope = {
          enabled = true,
      }
      
      
      lsp_trouble = false
      
      
      dadbod_ui = false
      
      
      gitgutter = false
      
      
      illuminate = {
          enabled = true,
          lsp = false
      }
      
      
      sandwich = false
      
      
      signify = false
      
      
      vim_sneak = false
      
      
      vimwiki = false
      
      
      which_key = false
      
      
      require("catppuccin").setup({ -- Note: On windows we replace `/` with `\` by default
          compile_path = vim.fn.stdpath "cache" .. "/catppuccin"
      })
      
      
      require("nvim-treesitter.configs").setup {
          highlight = {
              enable = true,
              additional_vim_regex_highlighting = false
          },
      }
      
    end,
  },
  {
    "FrenzyExists/aquarium-vim",
    config = function()
      
      use 'frenzyexists/aquarium-vim'
      
    end,
  },
  {
    "EdenEast/nightfox.nvim",
  },
  {
    "kvrohit/substrata.nvim",
    config = function()
      
      use 'kvrohit/substrata.nvim'
      
      
      -- Lua
      vim.cmd [[colorscheme substrata]]
      
      
      -- Example config in lua
      vim.g.substrata_italic_functions = true
      
      -- Load the colorscheme
      vim.cmd [[colorscheme substrata]]
      
    end,
  },
  {
    "ldelossa/vimdark",
  },
  {
    "Everblush/nvim",
    config = function()
      
      { 'Everblush/nvim', as = 'everblush' }
      
      
      { 'Everblush/nvim', name = 'everblush' }
      
      
      vim.cmd('colorscheme everblush')
      
      
      require('everblush').setup({
      
          -- Default options
          override = {},
          transparent_background = false,
          nvim_tree = {
              contrast = false,
          },
      
          -- Configuration examples
      
          -- Override the default highlights using Everblush or other colors
          override = {
              Normal = { fg = '#ffffff', bg = 'comment' },
          },
      
          -- Set transparent background
          transparent_background = true,
      
          -- Set contrast for nvim-tree highlights
          nvim_tree = {
              contrast = true,
          },
      })
      
      
      require('lualine').setup({
          options = { 'theme' = 'everblush' }
      })
      
      
      vim.g.lightline = {
          'colorscheme' = 'everblush',
      }
      
      
      vim.g.airline_theme = 'everblush'
      vim.g.airline_powerline_fonts = 1 -- For powerline symbols in statusline
      vim.g['airline#extensions#tabline#enabled'] = 1 -- To enable custom tabline
      
    end,
  },
  {
    "adisen99/apprentice.nvim",
    config = function()
      
      use {"adisen99/apprentice.nvim", requires = {"rktjmp/lush.nvim"}}
      
      
      vim.o.background = "dark" -- or "light" for light mode
      
      -- Load and setup function to choose plugin and language highlights
      require('lush')(require('apprentice').setup({
        plugins = {
          "buftabline",
          "coc",
          "cmp", -- nvim-cmp
          "fzf",
          "gitgutter",
          "gitsigns",
          "lsp",
          "lspsaga",
          "nerdtree",
          "netrw",
          "nvimtree",
          "neogit",
          "packer",
          "signify",
          "startify",
          "syntastic",
          "telescope",
          "treesitter"
        },
        langs = {
          "c",
          "clojure",
          "coffeescript",
          "csharp",
          "css",
          "elixir",
          "golang",
          "haskell",
          "html",
          "java",
          "js",
          "json",
          "jsx",
          "lua",
          "markdown",
          "moonscript",
          "objc",
          "ocaml",
          "purescript",
          "python",
          "ruby",
          "rust",
          "scala",
          "typescript",
          "viml",
          "xml"
        }
      }))
      
      
      vim.cmd(colorscheme apprentice)
      
      
      g.apprentice_hls_lspreference = "bright_yellow"
      g.apprentice_hls_cursor = "bright_yellow"
      g.apprentice_hls_highlight = "bright_yellow"
      g.apprentice_italicize_booleans = true
      g.apprentice_tabline_sel = "fg0"
      }))
      
    end,
  },
  {
    "olimorris/onedarkpro.nvim",
    config = function()
      
      -- Lazy
      {
        "olimorris/onedarkpro.nvim",
        priority = 1000, -- Ensure it loads first
      }
      
      -- somewhere in your config:
      vim.cmd("colorscheme onedark")
      
      
      -- Packer
      use "olimorris/onedarkpro.nvim"
      
      -- somewhere in your config:
      vim.cmd("colorscheme onedark")
      
      
      require("onedarkpro").setup({
        colors = {}, -- Override default colors or create your own
        highlights = {}, -- Override default highlight groups or create your own
        styles = { -- For example, to apply bold and italic, use "bold,italic"
          types = "NONE", -- Style that is applied to types
          methods = "NONE", -- Style that is applied to methods
          numbers = "NONE", -- Style that is applied to numbers
          strings = "NONE", -- Style that is applied to strings
          comments = "NONE", -- Style that is applied to comments
          keywords = "NONE", -- Style that is applied to keywords
          constants = "NONE", -- Style that is applied to constants
          functions = "NONE", -- Style that is applied to functions
          operators = "NONE", -- Style that is applied to operators
          variables = "NONE", -- Style that is applied to variables
          parameters = "NONE", -- Style that is applied to parameters
          conditionals = "NONE", -- Style that is applied to conditionals
          virtual_text = "NONE", -- Style that is applied to virtual text
        },
        filetypes = { -- Override which filetype highlight groups are loaded
          c = true,
          comment = true,
          go = true,
          html = true,
          java = true,
          javascript = true,
          json = true,
          latex = true,
          lua = true,
          markdown = true,
          php = true,
          python = true,
          ruby = true,
          rust = true,
          scss = true,
          toml = true,
          typescript = true,
          typescriptreact = true,
          vue = true,
          xml = true,
          yaml = true,
        },
        plugins = { -- Override which plugin highlight groups are loaded
          aerial = true,
          barbar = true,
          blink_cmp = true,
          codecompanion = true,
          copilot = true,
          dashboard = true,
          flash_nvim = true,
          gitgraph_nvim = true,
          gitsigns = true,
          hop = true,
          indentline = true,
          leap = true,
          lsp_saga = true,
          lsp_semantic_tokens = true,
          marks = true,
          mini_diff = true,
          mini_icons = true,
          mini_indentscope = true,
          mini_test = true,
          neotest = true,
          neo_tree = true,
          nvim_cmp = true,
          nvim_bqf = true,
          nvim_dap = true,
          nvim_dap_ui = true,
          nvim_hlslens = true,
          nvim_lsp = true,
          nvim_navic = true,
          nvim_notify = true,
          nvim_tree = true,
          nvim_ts_rainbow = true,
          op_nvim = true,
          packer = true,
          persisted = true,
          polygot = true,
          rainbow_delimiters = true,
          render_markdown = true,
          startify = true,
          telescope = true,
          toggleterm = true,
          treesitter = true,
          trouble = true,
          vim_ultest = true,
          which_key = true,
          vim_dadbod_ui = true,
        },
      
        options = {
          cursorline = false, -- Use cursorline highlighting?
          transparency = false, -- Use a transparent background?
          terminal_colors = true, -- Use the theme's colors for Neovim's :terminal?
          lualine_transparency = false, -- Center bar transparency?
          highlight_inactive_windows = false, -- When the window is out of focus, change the normal background?
        }
      })
      
      
      vim.cmd("colorscheme onedark")
      
      
      require("onedarkpro").setup({
        colors = {
          red = "#FF0000"
        }
      })
      
      
      require("onedarkpro").setup({
        colors = {
          my_new_red = "#f44336",
          my_new_green = "require('onedarkpro.helpers').darken('green', 10, 'onedark')"
        }
      })
      
      
      require("onedarkpro").setup({
        highlights = {
          Error = {
            fg = "${my_new_red}",
            bg = "${my_new_green}"
          },
        }
      })
      
      
      require("onedarkpro").setup({
        colors = {
          onedark = { bg = "#FFFF00" }, -- yellow
          onelight = { bg = "#00FF00" }, -- green
        }
      })
      
      
      require("onedarkpro").setup({
        colors = {
          dark = { bg = "#FFFF00" }, -- yellow
          light = { bg = "#00FF00" }, -- green
        }
      })
      
      
      require("onedarkpro").setup({
        highlights = {
          Comment = { fg = "#FF0000", bg = "#FFFF00", italic = true }
        }
      })
      
      
      require("onedarkpro").setup({
        highlights = {
          Comment = { fg = "${my_new_red}", bg = "${yellow}", italic = true }
        }
      })
      
      
      require("onedarkpro").setup({
        highlights = {
          Comment = { link = "Substitute" }
        }
      })
      
      
      require("onedarkpro").setup({
        highlights = {
          Comment = { underline = true, extend = true }
        }
      })
      
      
      require("onedarkpro").setup({
        highlights = {
          MyNewHighlightGroup = { fg = "${red}" }
        }
      })
      
      
      require("onedarkpro").setup({
        highlights = {
          ["@lsp.type.comment"] = {}
        }
      })
      
      
      require("onedarkpro").setup({
        highlights = {
          Comment = {
            fg = { onedark = "${yellow}", onelight = "${my_new_red}" }
          }
        }
      })
      
      
      require("onedarkpro").setup({
        highlights = {
          Comment = {
            fg = { dark = "${yellow}", light = "${my_new_red}" }
          }
        }
      })
      
      
      require("onedarkpro").setup({
        highlights = {
          Comment = { ns_id = 1, fg = "${light_gray}" }
        }
      })
      
      
      require("onedarkpro").setup({
        highlights = {
          Comment = { italic = true },
          Directory = { bold = true },
          ErrorMsg = { italic = true, bold = true }
        }
      })
      
      
      require("onedarkpro").setup({
        styles = {
          types = "NONE",
          methods = "NONE",
          numbers = "NONE",
          strings = "NONE",
          comments = "italic",
          keywords = "bold,italic",
          constants = "NONE",
          functions = "italic",
          operators = "NONE",
          variables = "NONE",
          parameters = "NONE",
          conditionals = "italic",
          virtual_text = "NONE",
        }
      })
      
      
      require("onedarkpro").setup({
        filetypes = {
          markdown = false,
          ruby = false,
        }
      })
      
      
      require("onedarkpro").setup({
        filetypes = {
          all = false
        }
      })
      
      
      require("onedarkpro").setup({
        filetypes = {
          all = false,
          markdown = true,
          ruby = true,
        }
      })
      
      
      require("onedarkpro").setup({
        highlights = {
          ["@field.yaml"] = { fg = "${blue}", italic = true }
        }
      })
      
      
      require("onedarkpro").setup({
        plugins = {
          nvim_lsp = false,
          polygot = false,
          treesitter = false
        }
      })
      
      
      require("onedarkpro").setup({
        plugins = {
          all = false
        }
      })
      
      
      require("onedarkpro").setup({
        plugins = {
          all = false,
          nvim_lsp = true,
          treesitter = true
        }
      })
      
      
      require("onedarkpro").setup({
        colors = {
          cursorline = "#FF0000" -- This is optional. The default cursorline color is based on the background
        },
        options = {
          cursorline = true
        }
      })
      
      
      require("onedarkpro").setup({
        options = {
          transparency = true
        }
      })
      
      
      require("onedarkpro").setup({
        options = {
          terminal_colors = false
        }
      })
      
      
      require("onedarkpro").setup({
        options = {
          highlight_inactive_windows = true
        }
      })
      
      
      -- Your configuration
      require("onedarkpro").setup({
        themes = {
          vaporwave = "~/.config/nvim/lua/plugins/colors/vaporwave.lua",
        },
      })
      vim.cmd([[colorscheme vaporwave]])
      
      -- ~/.config/nvim/colors/vaporwave.lua
      require("onedarkpro.config").set_theme("vaporwave")
      require("onedarkpro").load()
      
      
      
      local color = require("onedarkpro.helpers")
      
      local colors = color.get_colors()
      print(colors.purple) -- #c678dd (if using the Onedark theme)
      
      
      local color = require("onedarkpro.helpers")
      
      local colors = color.get_preloaded_colors()
      print(colors.purple) -- #c678dd (if using the Onedark theme)
      
      
      local color = require("onedarkpro.helpers")
      
      -- Load the red color from the onedark theme and lighten it by an amount of 7
      print(color.lighten("red", 7, "onedark")) -- #e68991
      
      
      local color = require("onedarkpro.helpers")
      
      -- Darken Red1 by an amount of 10
      print(color.darken("#FF0000", 10)) -- #cc0000
      
      
      require("onedarkpro").setup({
        colors = {
          dark_red = "require('onedarkpro.helpers').darken('red', 10, 'onedark')",
        },
        highlights = {
          CustomRedHighlight = {
            fg = "${dark_red}",
          },
        }
      })
      
      
      function ToggleTheme()
        if vim.o.background == "dark" then
          vim.cmd("colorscheme onelight")
        else
          vim.cmd("colorscheme onedark")
        end
      end
      
    end,
  },
  {
    "rmehri01/onenord.nvim",
    config = function()
      
      -- If you are using Packer
      use 'rmehri01/onenord.nvim'
      
      
      -- Lua
      require('onenord').setup()
      
      
      require('lualine').setup {
        options = {
          -- ... your lualine config
          theme = 'onenord'
          -- ... your lualine config
        }
      }
      
      
      require('onenord').setup({
        theme = nil, -- "dark" or "light". Alternatively, remove the option and set vim.o.background instead
        borders = true, -- Split window borders
        fade_nc = false, -- Fade non-current windows, making them more distinguishable
        -- Style that is applied to various groups: see `highlight-args` for options
        styles = {
          comments = "NONE",
          strings = "NONE",
          keywords = "NONE",
          functions = "NONE",
          variables = "NONE",
          diagnostics = "underline",
        },
        disable = {
          background = false, -- Disable setting the background color
          float_background = false, -- Disable setting the background color for floating windows
          cursorline = false, -- Disable the cursorline
          eob_lines = true, -- Hide the end-of-buffer lines
        },
        -- Inverse highlight for different groups
        inverse = {
          match_paren = false,
        },
        custom_highlights = {}, -- Overwrite default highlight groups
        custom_colors = {}, -- Overwrite default colors
      })
      
      
      local colors = require("onenord.colors").load()
      
      require("onenord").setup({
        custom_highlights = {
        ["@constructor"] = { fg = colors.dark_blue, style = 'bold' },
        },
        custom_colors = {
          red = "#ffffff",
        },
      })
      
      
      local colors = require("onenord.colors").load()
      
      require("onenord").setup({
        custom_highlights = {
          light = {
            ["@constructor"] = { fg = colors.dark_blue, style = 'bold' }, -- only applies in light theme
          },
        },
        custom_colors = {
          blue = "#0000ff", -- applies in both themes
          light = {
            red = "#000000", -- only applies in light theme
          },
          dark = {
            red = "#ffffff", -- only applies in dark theme
          },
        },
      })
      
    end,
  },
  {
    "RishabhRD/gruvy",
  },
  {
    "nvim-mini/mini.nvim#plugin-colorschemes",
  },
  {
    "luisiacc/gruvbox-baby",
    config = function()
      
      -- Example config in Lua
      vim.g.gruvbox_baby_function_style = "NONE"
      vim.g.gruvbox_baby_keyword_style = "italic"
      
      -- Each highlight group must follow the structure:
      -- ColorGroup = {fg = "foreground color", bg = "background_color", style = "some_style(:h attr-list)"}
      -- See also :h highlight-guifg
      -- Example:
      vim.g.gruvbox_baby_highlights = {Normal = {fg = "#123123", bg = "NONE", style="underline"}}
      
      -- Enable telescope theme
      vim.g.gruvbox_baby_telescope_theme = 1
      
      -- Enable transparent mode
      vim.g.gruvbox_baby_transparent_mode = 1
      
      -- Load the colorscheme
      vim.cmd[[colorscheme gruvbox-baby]]
      
      
      telescope.setup({
        defaults = {
          ...
          borderchars = {
            prompt = { "─", " ", " ", " ", "─", "─", " ", " " },
            results = { " " },
            preview = { " " },
          },
        }
      })
      
      
      local colors = require("gruvbox-baby.colors").config()
      vim.g.gruvbox_baby_highlights = {Normal = {fg = colors.orange}}
      
    end,
  },
  {
    "titanzero/zephyrium",
    config = function()
      
      use 'titanzero/zephyrium'
      
      
      require 'zephyrium' -- or
      vim.cmd [[colorscheme zephyrium]]
      
    end,
  },
  {
    "rebelot/kanagawa.nvim",
    config = function()
      
      use "rebelot/kanagawa.nvim"
      
      
      vim.cmd("colorscheme kanagawa")
      
      
      -- Default options:
      require('kanagawa').setup({
          compile = false,             -- enable compiling the colorscheme
          undercurl = true,            -- enable undercurls
          commentStyle = { italic = true },
          functionStyle = {},
          keywordStyle = { italic = true},
          statementStyle = { bold = true },
          typeStyle = {},
          transparent = false,         -- do not set background color
          dimInactive = false,         -- dim inactive window `:h hl-NormalNC`
          terminalColors = true,       -- define vim.g.terminal_color_{0,17}
          colors = {                   -- add/modify theme and palette colors
              palette = {},
              theme = { wave = {}, lotus = {}, dragon = {}, all = {} },
          },
          overrides = function(colors) -- add/modify highlights
              return {}
          end,
          theme = "wave",              -- Load "wave" theme
          background = {               -- map the value of 'background' option to a theme
              dark = "wave",           -- try "dragon" !
              light = "lotus"
          },
      })
      
      -- setup must be called before loading
      vim.cmd("colorscheme kanagawa")
      
      
        vim.cmd("colorscheme kanagawa-wave")
        vim.cmd("colorscheme kanagawa-dragon")
        vim.cmd("colorscheme kanagawa-lotus")
        
      
        require("kanagawa").load("wave")
        
      
      require('kanagawa').setup({
          ...,
          colors = {
              palette = {
                  -- change all usages of these colors
                  sumiInk0 = "#000000",
                  fujiWhite = "#FFFFFF",
              },
              theme = {
                  -- change specific usages for a certain theme, or for all of them
                  wave = {
                      ui = {
                          float = {
                              bg = "none",
                          },
                      },
                  },
                  dragon = {
                      syn = {
                          parameter = "yellow",
                      },
                  },
                  all = {
                      ui = {
                          bg_gutter = "none"
                      }
                  }
              }
          },
          ...
      })
      
      
      require('kanagawa').setup({
          ...,
          overrides = function(colors)
              return {
                  -- Assign a static color to strings
                  String = { fg = colors.palette.carpYellow, italic = true },
                  -- theme colors will update dynamically when you change theme!
                  SomePluginHl = { fg = colors.theme.syn.type, bold = true },
              }
          end,
          ...
      })
      
      
      colors = {
          theme = {
              all = {
                  ui = {
                      bg_gutter = "none"
                  }
              }
          }
      }
      
      
      overrides = function(colors)
          local theme = colors.theme
          return {
              NormalFloat = { bg = "none" },
              FloatBorder = { bg = "none" },
              FloatTitle = { bg = "none" },
      
              -- Save an hlgroup with dark background and dimmed foreground
              -- so that you can use it where your still want darker windows.
              -- E.g.: autocmd TermOpen * setlocal winhighlight=Normal:NormalDark
              NormalDark = { fg = theme.ui.fg_dim, bg = theme.ui.bg_m3 },
      
              -- Popular plugins that open floats will link to NormalFloat by default;
              -- set their background accordingly if you wish to keep them dark and borderless
              LazyNormal = { bg = theme.ui.bg_m3, fg = theme.ui.fg_dim },
              MasonNormal = { bg = theme.ui.bg_m3, fg = theme.ui.fg_dim },
          }
      end,
      
      
      { "🭽", "▔", "🭾", "▕", "🭿", "▁", "🭼", "▏" }
      
      
      overrides = function(colors)
          local theme = colors.theme
          return {
              TelescopeTitle = { fg = theme.ui.special, bold = true },
              TelescopePromptNormal = { bg = theme.ui.bg_p1 },
              TelescopePromptBorder = { fg = theme.ui.bg_p1, bg = theme.ui.bg_p1 },
              TelescopeResultsNormal = { fg = theme.ui.fg_dim, bg = theme.ui.bg_m1 },
              TelescopeResultsBorder = { fg = theme.ui.bg_m1, bg = theme.ui.bg_m1 },
              TelescopePreviewNormal = { bg = theme.ui.bg_dim },
              TelescopePreviewBorder = { bg = theme.ui.bg_dim, fg = theme.ui.bg_dim },
          }
      end,
      
      
      overrides = function(colors)
          local theme = colors.theme
          return {
              Pmenu = { fg = theme.ui.shade0, bg = theme.ui.bg_p1 },  -- add `blend = vim.o.pumblend` to enable transparency
              PmenuSel = { fg = "NONE", bg = theme.ui.bg_p2 },
              PmenuSbar = { bg = theme.ui.bg_m1 },
              PmenuThumb = { bg = theme.ui.bg_p2 },
          }
      end,
      
      
      overrides = function(colors)
        local theme = colors.theme
        local makeDiagnosticColor = function(color)
          local c = require("kanagawa.lib.color")
          return { fg = color, bg = c(color):blend(theme.ui.bg, 0.95):to_hex() }
        end
      
        return {
          DiagnosticVirtualTextHint  = makeDiagnosticColor(theme.diag.hint),
          DiagnosticVirtualTextInfo  = makeDiagnosticColor(theme.diag.info),
          DiagnosticVirtualTextWarn  = makeDiagnosticColor(theme.diag.warning),
          DiagnosticVirtualTextError = makeDiagnosticColor(theme.diag.error),
        }
      end
      
      
      -- Get the colors for the current theme
      local colors = require("kanagawa.colors").setup()
      local palette_colors = colors.palette
      local theme_colors = colors.theme
      
      -- Get the colors for a specific theme
      local wave_colors = require("kanagawa.colors").setup({ theme = 'wave' })
      
      
      vim.api.nvim_create_autocmd("ColorScheme", {
          pattern = "kanagawa",
          callback = function()
              if vim.o.background == "light" then
                  vim.fn.system("kitty +kitten themes Kanagawa_light")
              elseif vim.o.background == "dark" then
                  vim.fn.system("kitty +kitten themes Kanagawa_dragon")
              else
                  vim.fn.system("kitty +kitten themes Kanagawa")
              end
          end,
      })
      
    end,
  },
  {
    "thesimonho/kanagawa-paper.nvim",
    config = function()
      
      {
        "thesimonho/kanagawa-paper.nvim",
        lazy = false,
        priority = 1000,
        opts = {},
      }
      
      
      vim.cmd.colorscheme("kanagawa-paper")
      vim.cmd.colorscheme("kanagawa-paper-ink")
      vim.cmd.colorscheme("kanagawa-paper-canvas")
      
      
      return {
        "thesimonho/kanagawa-paper.nvim",
        lazy = false,
        priority = 1000,
        init = function()
          vim.cmd.colorscheme("kanagawa-paper-ink")
        end,
        opts = {...},
      }
      
      
      require("kanagawa-paper").setup({
       -- enable undercurls for underlined text
       undercurl = true,
       -- transparent background
       transparent = false,
       -- highlight background for the left gutter
       gutter = false,
       -- background for diagnostic virtual text
       diag_background = true,
       -- dim inactive windows. Disabled when transparent
       dim_inactive = false,
       -- set colors for terminal buffers
       terminal_colors = true,
       -- cache highlights and colors for faster startup.
       -- see Cache section for more details.
       cache = false,
      
       styles = {
        -- style for comments
        comment = { italic = true },
        -- style for functions
        functions = { italic = false },
        -- style for keywords
        keyword = { italic = false, bold = false },
        -- style for statements
        statement = { italic = false, bold = false },
        -- style for types
        type = { italic = false },
       },
       -- override default palette and theme colors
       colors = {
        palette = {},
        theme = {
         ink = {},
         canvas = {},
        },
       },
       -- adjust overall color balance for each theme [-1, 1]
       color_offset = {
        ink = { brightness = 0, saturation = 0 },
        canvas = { brightness = 0, saturation = 0 },
       },
       -- override highlight groups
       overrides = function(colors)
        return {}
       end,
      
       -- uses lazy.nvim, if installed, to automatically enable needed plugins
       auto_plugins = true,
       -- enable highlights for all plugins (disabled if using lazy.nvim)
       all_plugins = package.loaded.lazy == nil,
       -- manually enable/disable individual plugins.
       -- check the `groups/plugins` directory for the exact names
       plugins = {
        -- examples:
        -- rainbow_delimiters = true
        -- which_key = false
       },
      
       -- enable integrations with other applications
       integrations = {
        -- automatically set wezterm theme to match the current neovim theme
        wezterm = {
         enabled = false,
         -- neovim will write the theme name to this file
         -- wezterm will read from this file to know which theme to use
         path = (os.getenv("TEMP") or "/tmp") .. "/nvim-theme",
        },
       },
      })
      
      
      local kanagawa_paper = require("lualine.themes.kanagawa-paper-ink")
      -- local kanagawa_paper = require("lualine.themes.kanagawa-paper-canvas")
      
      require("lualine").setup({
       options = {
        theme = kanagawa_paper,
        -- ... your lualine config
       },
      })
      
      
      require("lualine").setup({
       options = {
        theme = function()
          -- pcall and fallback theme is to handle the case of theme switching/previewing
          local ok, t = pcall(
            require,
            "lualine.themes." .. (vim.o.background == "light" and "kanagawa-paper-canvas" or "kanagawa-paper-ink")
          )
          if ok then
            theme = t
          else
            theme = require("some other fallback theme")
          end
          return theme
        end,
        -- ... your lualine config
       },
      })
      
      
      require("kanagawa-paper").setup({
       integrations = {
        wezterm = {
         enabled = true,
         path = (os.getenv("TEMP") or "/tmp") .. "/nvim-theme"
        },
       },
      })
      
      
      config.color_scheme_dirs = { "~/.config/wezterm/colors" } -- or wherever you want to store the themes
      
      
      -- default colorscheme after neovim exits
      local theme_default = "kanagawa-paper-ink"
      
      -- this should match the path set in the neovim config
      -- it's best to use a temporary directory for this
      local theme_file = (os.getenv("TEMP") or "/tmp") .. "/nvim-theme"
      
      -- relative path to the directory containing the tabline themes
      -- e.g. if I have placed the tabline extra themes in ./colors/wezterm_tabline then this would be "colors.wezterm_tabline"
      -- this is treated as a relative lua module that will be required by the theme switcher
      local tabline_theme_dir = "colors.wezterm_tabline"
      
      
      require('kanagawa-paper').setup({
        colors = {
          palette = {
            -- change all usages of these color names
            sumiInk0 = "#000000",
            fujiWhite = "#FFFFFF",
          },
          theme = {
            -- change specific usages for a specific theme
            ink = {
              ui = {
                float = {
                  fg = "#ff0000",
                },
              },
            },
            canvas = {
            -- ...
            }
          },
        }
      })
      
      
      require("kanagawa-paper").setup({
       overrides = function(colors)
        return {
         -- Assign a static color to strings
         String = { fg = colors.palette.carpYellow, italic = true },
         -- theme colors will update dynamically when you change theme!
         SomePluginHl = { fg = colors.theme.syn.type, bold = true },
        }
       end,
      })
      
      
      -- Get the colors for the current theme
      local colors = require("kanagawa-paper.colors")
      local palette_colors = colors.palette
      local theme_colors = colors.theme
      
      
      {
        "thesimonho/kanagawa-paper.nvim",
        lazy = false,
        priority = 1000,
        opts = function()
          local colors = require("kanagawa-paper.colors")
          local palette_colors = colors.palette
          return {
            colors = {
              theme = {
                ink = {
                  ui = {
                    bg_dim = palette_colors.boatYellow2,
                  },
                },
              },
            },
          }
        end
      }
      
    end,
  },
  {
    "kevinm6/kurayami.nvim",
    config = function()
      
      {
         "kevinm6/kurayami.nvim",
         event = "VimEnter",               -- load plugin on VimEnter or
         -- lazy = false,                  --   don't lazy load plugin
         priority = 1000,                  
         config = function()        
            vim.cmd.colorscheme('kurayami')   -- this is enough to initialize and load plugin
         end,
      }
      
      
         "kevinm6/kurayami.nvim",
         event = "VimEnter",               -- load plugin on VimEnter or
         -- lazy = false,                  --   don't lazy load plugin
         priority = 1000,                  
         ---Use this config to override some highlights
         config = function(_, opts)        
           ---override or add highlights passing table, same as `:h nvim_set_hl()`
           ---@usage
           opts.override = {
             Number = { fg = "#015a60", bg = "NONE", bold = true },
             -- HiGroup = { fg = "#HexCol", bg = "#HexCol" }
           }
           require("kurayami").setup(opts)
           vim.cmd.colorscheme('kurayami')
         end
      }
      
    end,
  },
  {
    "tiagovla/tokyodark.nvim",
    config = function()
      
      local default_config = {
          transparent_background = false, -- set background to transparent
          gamma = 1.00, -- adjust the brightness of the theme
          styles = {
              comments = { italic = true }, -- style for comments
              keywords = { italic = true }, -- style for keywords
              identifiers = { italic = true }, -- style for identifiers
              functions = {}, -- style for functions
              variables = {}, -- style for variables
          },
          custom_highlights = {} or function(highlights, palette) return {} end, -- extend highlights
          custom_palette = {} or function(palette) return {} end, -- extend palette
          terminal_colors = true, -- enable terminal colors
      }
      
    end,
  },
  {
    "cpea2506/one_monokai.nvim",
    config = function()
      
      {
        "cpea2506/one_monokai.nvim",
      }
      
      
      vim.cmd.colorscheme "one_monokai"
      
      
      require("one_monokai").setup({
          -- your custom options here
      })
      
      
      require("one_monokai").setup({
          transparent = false,
          colors = {},
          highlights = function(colors)
              return {}
          end,
          italics = true,
      })
      
      
      colors["<color-name>"]:darken(alpha)
      colors["<color-name>"]:lighten(alpha)
      
      
      require("one_monokai").setup({
          transparent = true,  -- Enable transparent background
          colors = {
              pink = "#ec6075", -- Override a default color
              lmao = "#ffffff", -- Define a new color as hexadecimal string
              human = 0xFFABCD, -- Define a new color as number
              alien = 16755661, -- Why not?
          },
          highlights = function(colors)
              -- Customize highlight groups
              -- The key-value pairs are passed to "nvim_set_hl"
              return {
                  Normal = { bg = colors.lmao },
                  DiffChange = { fg = colors.white:darken(0.3) },
                  ErrorMsg = { fg = colors.pink, standout = true },
                  ["@lsp.type.keyword"] = { link = "@keyword" }
              }
          end,
          italics = false, -- Disable italic
      })
      
      
      require("lualine").setup {
        options = {
            -- ...other options
            theme = "one_monokai"
        }
      }
      
    end,
  },
  {
    "phha/zenburn.nvim",
    config = function()
      
      use {
          "phha/zenburn.nvim",
          config = function() require("zenburn").setup() end
      }
      
      
      require("paq") {
          "phha/zenburn.nvim";
      }
      
      
      require("zenburn").setup()
      
      
      require("lualine").setup {
          options = {
              theme = "zenburn",
          }
      }
      
    end,
  },
  {
    "kvrohit/rasmus.nvim",
    config = function()
      
      use 'kvrohit/rasmus.nvim'
      
      
      {
        "kvrohit/rasmus.nvim",
        priority = 1000,
        config = function()
          vim.cmd([[colorscheme rasmus]])
        end,
      }
      
      
      -- Lua
      vim.cmd [[colorscheme rasmus]]
      
      
      -- Example config in lua
      
      -- Configure the appearance
      vim.g.rasmus_italic_functions = true
      vim.g.rasmus_bold_functions = true
      
      -- Set the colorscheme variant to monochrome
      vim.g.rasmus_variant = "monochrome"
      
      -- Load the colorscheme
      vim.cmd [[colorscheme rasmus]]
      
    end,
  },
  {
    "chrsm/paramount-ng.nvim",
    config = function()
      
      use {
        "chrsm/paramount-ng.nvim",
        requires = { "rktjmp/lush.nvim" }
      }
      
    end,
  },
  {
    "lmburns/kimbox",
    config = function()
      
      use({"lmburns/kimbox", config = [[require("kimbox").load()]]})
      -- or
      use({
          "lmburns/kimbox",
          config = function()
              require("kimbox").setup({
                  -- options
              })
              require("kimbox").load()
              -- or
              vim.cmd("colorscheme kimbox")
          end,
      })
      
      
      -- Colors can be accessed with
      local c = require("kimbox.bufferline").colors()
      
      -- Theme itself
      local t = require("kimbox.bufferline").theme()
      
      require("bufferline").setup({
        -- configuration stuff
        highlights = require("kimbox.bufferline").theme()
      })
      
      
      -- Colors can be accessed with
      local c = require("kimbox.lualine").colors()
      
      -- Theme itself
      local t = require("kimbox.lualine").theme()
      
      require("lualine").setup({
        -- configuration stuff
        theme = 'kimbox' -- 'auto' works as well
      })
      
      
      -- These options can also be set using:
      vim.g.kimbox_config = {
        -- ...options from above
      }
      
      require("kimbox").setup({
          ---Background color:
          ---    burnt_coffee : #231A0C   -- legacy: "medium"
          ---    cannon       : #221A02   -- legacy: "ocean"
          ---    used_oil     : #221A0F   -- legacy: "vscode"
          ---    deep         : #0F111B
          ---    zinnwaldite  : #291804   -- legacy: "darker"
          ---    eerie        : #1C0B28
          style = "cannon",
          ---Allow changing background color
          toggle_style = {
              ---Key used to cycle through the backgrounds in `toggle_style.bgs`
              key = "<Leader>ts",
              ---List of background names
              bgs = require("kimbox.config").bg_colors
          },
          ---New Lua-Treesitter highlight groups
          ---See below (New Lua Treesitter Highlight Groups) for an explanation
          ---  Location where Treesitter capture groups changed to '@capture.name'
          ---  Commit:    030b422d1
          ---  Vim patch: patch-8.2.0674
          langs08 = true,
          ---Used with popup menus (coc.nvim mainly) --
          popup = {
              background = false, -- use background color for PMenu
          },
          -- ━━━ Plugin Related ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
          diagnostics = {
              background = true, -- use background color for virtual text
          },
          -- ━━━ General Formatting ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
          allow_bold = true,
          allow_italic = false,
          allow_underline = false,
          allow_undercurl = true,
          allow_reverse = false,
          transparent = false,   -- don't set background
          term_colors = true,    -- if true enable the terminal
          ending_tildes = false, -- show the end-of-buffer tildes
          -- ━━━ Custom Highlights ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
          ---Override default colors
          ---@type table<Kimbox.Color.S_t, string>
          colors = {},
          ---Override highlight groups
          ---@type Kimbox.Highlight.Map
          highlights = {},
          ---Plugins and langauges that can be disabled
          ---To view options: print(require("kimbox.highlights").{langs,langs08,plugins})
          ---@type {langs: Kimbox.Highlight.Langs[], langs08: Kimbox.Highlight.Langs08[], plugins: Kimbox.Highlight.Plugins[]}
          disabled = {
              ---Disabled languages
              ---@see Kimbox.Highlight.Langs
              langs = {},
              ---Disabled languages with '@' treesitter highlights
              ---@see Kimbox.Highlight.Langs08
              langs08 = {},
              ---Disabled plugins
              ---@see Kimbox.Highlight.Plugins
              plugins = {},
          },
          ---Run a function before the colorscheme is loaded
          ---@type fun(): nil
          run_before = nil,
          ---Run a function after the colorscheme is loaded
          ---@type fun(): nil
          run_after = nil,
      })
      
      require("kimbox").load()
      
      
      require("kimbox").setup({
          colors = {
              bright_orange = "#ff8800", -- define a new color
              green = "#77A172",         -- redefine an existing color
              myblue = "#418292",
          },
          highlights = {
              TSKeyword = {fg = "$green"},
              TSString = {fg = "$bright_orange", bg = "#FF5813", gui = "bold"},
              TSFunction = {fg = "#88C0D0", sp = "$aqua", gui = "underline,italic"},
              ["@function.macro.lua"] = {fg = "$myblue", sp = "$aqua", gui = "underline,italic"},
          },
      })
      
    end,
  },
  {
    "qaptoR-nvim/chocolatier.nvim",
  },
  {
    "rockyzhang24/arctic.nvim",
    config = function()
      
      use {
        "rockyzhang24/arctic.nvim",
        requires = { "rktjmp/lush.nvim" }
      }
      
      
      {
        "rockyzhang24/arctic.nvim",
        dependencies = { "rktjmp/lush.nvim" },
        name = "arctic",
        branch = "main",
        priority = 1000,
        config = function()
          vim.cmd("colorscheme arctic")
        end
      }
      
      
      -- Lua
      vim.cmd("colorscheme arctic")
      
    end,
  },
  {
    "ramojus/mellifluous.nvim",
    config = function()
      
      use({
          "ramojus/mellifluous.nvim",
          -- version = "v0.*", -- uncomment for stable config (some features might be missed if/when v1 comes out)
          config = function()
              require("mellifluous").setup({}) -- optional, see configuration section.
              vim.cmd("colorscheme mellifluous")
          end,
      })
      
      
      require("mellifluous").setup({
          styles = { -- see :h attr-list for options. set {} for NONE, { option = true } for option
              main_keywords = { bold = true },
          },
      })
      
      
      require("mellifluous").setup({
          mellifluous = {
              neutral = true, -- set this to false for original mellifluous (when it was called meliora theme)
          },
      })
      
      
      require("mellifluous").setup({
          <colorset_name> = { -- name any of the defined colorsets
              color_overrides = {
                  dark = { -- for dark theme
                      bg = function(bg) -- bg is used for bg shades and may be used for some colorset colors
                          return <new bg>
                      end,
                      colors = function(colors)
                          return {
                              <new colors> -- check "Available colors" section for colors that can be used and overriden.
                          }
                      end,
                  },
                  light = { -- for light theme
                      -- same keys as in dark variant
                  },
              },
          },
      })
      
      
      require("mellifluous").setup({
          -- invert bg shades for all colorsets
          color_overrides = {
              dark = {
                  colors = function(colors)
                      return {
                          bg2 = colors.bg:darkened(2),
                          bg3 = colors.bg:darkened(4),
                          bg4 = colors.bg:darkened(6),
                          bg5 = colors.bg:darkened(8),
                      }
                  end,
              }
          },
          -- modify some colors for mellifluous colorset
          mellifluous = {
              color_overrides = {
                  dark = {
                      bg = function(bg)
                          return bg:lightened(2)
                      end,
                      colors = function(colors)
                          return {
                              main_keywords = "#e0e066",
                              operators = colors.functions:desaturated(10),
                          }
                      end,
                  },
              },
          },
      })
      
      
      require("mellifluous").setup({
          -- highlight overrides for all colorsets
          highlight_overrides = {
              dark = function(highlighter, colors) -- dark theme
                  -- set highlights here (using highlighter)
              end,
              light = function(highlighter, colors) -- light theme
                  -- set highlights here (using highlighter)
              end,
          },
          -- highlight overrides for specific colorset
          <colorset_name> = {
              highlight_overrides = {
                  dark = function(highlighter, colors) -- dark variant of the colorset
                      -- set highlights here (using highlighter)
                  end,
                  light = function(highlighter, colors) -- light variant of the colorset
                      -- set highlights here (using highlighter)
                  end,
              },
          },
      })
      
      
      highlighter.set(name, definition_map)
      
      
      highlighter.get(name)
      
    end,
  },
  {
    "Yazeed1s/minimal.nvim",
    config = function()
      
      use 'Yazeed1s/minimal.nvim'
      
      
      -- Lua
      vim.cmd[[colorscheme minimal]] -- for minimal
      vim.cmd[[colorscheme minimal-base16]] -- for minimal-base16
      -- or, for lunarVim
      lvim.colorscheme = 'minimal'
      lvim.colorscheme = 'minimal-base16'
      
      
      -- Example config in lua
      vim.g.minimal_italic_functions = true
      vim.g.minimal_italic_comments = false
      -- Load the colorscheme
      vim.cmd [[colorscheme minimal]]
      -- or 
      vim.cmd [[colorscheme minimal-base16]]
      
    end,
  },
  {
    "lewpoly/sherbet.nvim",
    config = function()
      
      use "lewpoly/sherbet.nvim"
      
      
      vim.cmd("colorscheme sherbet")
      
      
      vim.g.sherbet_italic_keywords = true
      vim.g.sherbet_italic_functions = false
      vim.g.sherbet_italic_comments = true
      vim.g.sherbet_italic_loops = true
      vim.g.sherbet_italic_conditionals = true
      
    end,
  },
  {
    "Mofiqul/adwaita.nvim",
    config = function()
      
      -- Lazy.nvim:
      require('lazy').setup({
          -- your other plugins
          
          -- this theme
          {
              "Mofiqul/adwaita.nvim",
              lazy = false,
              priority = 1000,
          },
      })
      
      
      -- Packer:
      use 'Mofiqul/adwaita.nvim'
      
      
      -- Lua:
      vim.g.adwaita_darker = true -- for darker version
      vim.g.adwaita_disable_cursorline = true -- to disable cursorline
      vim.g.adwaita_transparent = true -- makes the background transparent
      vim.cmd([[colorscheme adwaita]])
      
      
      -- Lua with Lazy.nvim:
      {
          "Mofiqul/adwaita.nvim",
          lazy = false,
          priority = 1000,
          
          -- configure and set on startup
          config = function()
              vim.g.adwaita_darker = true             -- for darker version
              vim.g.adwaita_disable_cursorline = true -- to disable cursorline
              vim.g.adwaita_transparent = true        -- makes the background transparent
              vim.cmd('colorscheme adwaita')
          end
      }
      
      
      require("lualine").setup({
          options = {
              -- ...
              theme = "adwaita",
              -- ...
          },
      })
      
    end,
  },
  {
    "olivercederborg/poimandres.nvim",
    config = function()
      
      -- Lua
      
      { 
        'olivercederborg/poimandres.nvim',
        lazy = false,
        priority = 1000,
        config = function()
          require('poimandres').setup {
            -- leave this setup function empty for default config
            -- or refer to the configuration section
            -- for configuration options
          }
        end,
      
        -- optionally set the colorscheme within lazy config
        init = function()
          vim.cmd("colorscheme poimandres")
        end
      }
      
      
      -- Lua
      
      use { 
        'olivercederborg/poimandres.nvim',
        config = function()
          require('poimandres').setup {
            -- leave this setup function empty for default config
            -- or refer to the configuration section
            -- for configuration options
          }
        end
      }
      
      
      -- Lua
      
      vim.cmd('colorscheme poimandres')
      
      
      require('poimandres').setup {
        bold_vert_split = false, -- use bold vertical separators
        dim_nc_background = false, -- dim 'non-current' window backgrounds
        disable_background = false, -- disable background
        disable_float_background = false, -- disable background for floats
        disable_italics = false, -- disable italics
      }
      
      
      require('lualine').setup {
        options = {
          -- ... your lualine config
          theme = 'poimandres'
          -- ... your lualine config
        }
      }
      
    end,
  },
  {
    "mellow-theme/mellow.nvim",
    config = function()
      
      use("mellow-theme/mellow.nvim")
      
      
      -- Lua
      vim.cmd([[colorscheme mellow]])
      
      
      -- Example config in lua
      
      -- Configure the appearance
      vim.g.mellow_italic_functions = true
      vim.g.mellow_bold_functions = true
      
      vim.g.mellow_highlight_overrides = {
        ["NormalNC"] = { link = "Normal" }
      }
      
      -- Load the colorscheme
      vim.cmd([[colorscheme mellow]])
      
    end,
  },
  {
    "gbprod/nord.nvim",
    config = function()
      
      require("lazy").setup({
        {
          "gbprod/nord.nvim",
          lazy = false,
          priority = 1000,
          config = function()
            require("nord").setup({})
            vim.cmd.colorscheme("nord")
          end,
        },
        install = {
          colorscheme = { "nord" },
        },
      });
      
      
      -- Lua
      vim.cmd.colorscheme("nord")
      
      
      require("nord").setup({
        -- your configuration comes here
        -- or leave it empty to use the default settings
        transparent = false, -- Enable this to disable setting the background color
        terminal_colors = true, -- Configure the colors used when opening a `:terminal` in Neovim
        diff = { mode = "bg" }, -- enables/disables colorful backgrounds when used in diff mode. values : [bg|fg]
        borders = true, -- Enable the border between verticaly split windows visible
        errors = { mode = "bg" }, -- Display mode for errors and diagnostics
                                  -- values : [bg|fg|none]
        search = { theme = "vim" }, -- theme for highlighting search results
                                    -- values : [vim|vscode]
        styles = {
          -- Style to be applied to different syntax groups
          -- Value is any valid attr-list value for `:help nvim_set_hl`
          comments = { italic = true },
          keywords = {},
          functions = {},
          variables = {},
      
          -- To customize lualine/bufferline
          bufferline = {
            current = {},
            modified = { italic = true },
          },
      
          lualine_bold = false, -- When `true`, section headers in the lualine theme will be bold
        },
      
        -- colorblind mode
        -- see https://github.com/EdenEast/nightfox.nvim#colorblind
        -- simulation mode has not been implemented yet.
        colorblind = {
          enable = false,
          preserve_background = false,
          severity = {
            protan = 0.0,
            deutan = 0.0,
            tritan = 0.0,
          },
        },
      
        -- Override the default colors
        ---@param colors Nord.Palette
        on_colors = function(colors) end,
      
        --- You can override specific highlights to use other groups or a hex color
        --- function will be called with all highlights and the colorScheme table
        ---@param colors Nord.Palette
        on_highlights = function(highlights, colors) end,
      })
      
      
      require('lualine').setup {
        options = {
          -- ... your lualine config
          theme = 'nord'
          -- ... your lualine config
        }
      }
      
      
      require("lazy").setup({
          {
            "dnlhc/glance.nvim",
            opts = require("nord.plugins.glance").make_opts({
              folds = {
                folded = false,
              },
            }),
          }
        }
      )
      
      
      require("bufferline").setup({
          options = {
              separator_style = "thin",
          },
          highlights = require("nord.plugins.bufferline").akinsho(),
      })
      
      
      require("toggleterm").setup(
          require("nord.plugins.toggleterm").make_opts({
            -- your custom options
          })
      )
      
    end,
  },
  {
    "Yazeed1s/oh-lucy.nvim",
    config = function()
      
      use 'Yazeed1s/oh-lucy.nvim'
      
      
      -- Lua
      vim.cmd[[colorscheme oh-lucy]] -- for oh-lucy
      vim.cmd[[colorscheme oh-lucy-evening]] -- for oh-lucy-evening
      -- or, for lunarVim
      lvim.colorscheme = 'oh-lucy'
      lvim.colorscheme = 'oh-lucy-evening'
      
      
      -- Example config in lua
      
      -- oh-lucy
      vim.g.oh_lucy_italic_functions = true
      vim.g.oh_lucy_italic_comments = false
      -- The key is 'oh_lucy_'
      
      -- oh-lucy-evening
      vim.g.oh_lucy_evening_italic_functions = true
      vim.g.oh_lucy_evening_italic_comments = false
      -- The key is 'oh_lucy_evening_'
      
      -- Load the colorscheme
      vim.cmd [[colorscheme oh-lucy]]
      -- or 
      vim.cmd [[colorscheme oh-lucy-evening]]
      
    end,
  },
  {
    "embark-theme/vim",
    config = function()
      
      use { 'embark-theme/vim', as = 'embark' }
      
      
      vim.cmd('colorscheme embark')
      
      
      use {
        'embark-theme/vim',
        as = 'embark',
        config = function()
          vim.cmd('colorscheme embark')
        end
      }
      
      
      require('lualine').setup {
        options = {
          theme = 'embark',
        }
      }
      
    end,
  },
  {
    "nyngwang/nvimgelion",
    config = function()
      
      {
        'nyngwang/nvimgelion',
        config = function ()
          -- do whatever you want for further customization~
        end
      }
      
      
      vim.api.nvim_create_autocmd({ 'ColorScheme', 'FileType' }, {
        callback = function ()
          vim.cmd([[
            hi IndentBlanklineChar gui=nocombine guifg=#444C55
            hi IndentBlanklineSpaceChar gui=nocombine guifg=#444C55
            hi IndentBlanklineContextChar gui=nocombine guifg=#FB5E2A
            hi IndentBlanklineContextStart gui=underline guisp=#FB5E2A
          ]])
        end,
      })
      
    end,
  },
  {
    "maxmx03/fluoromachine.nvim",
    config = function()
      
      return {
          {
              'maxmx03/fluoromachine.nvim',
              lazy = false,
              priority = 1000,
              config = function ()
               local fm = require 'fluoromachine'
      
               fm.setup {
                  glow = true,
                  theme = 'fluoromachine',
                  transparent = true,
               }
      
               vim.cmd.colorscheme 'fluoromachine'
              end
          }
      }
      
      
      lspconfig.lua_ls.setup {
        settings = {
          Lua = {
            runtime = {
              version = 'LuaJIT',
            },
            workspace = {
              checkThirdParty = false,
              library = {
                vim.env.VIMRUNTIME,
                '~/.local/share/nvim/lazy/fluoromachine.nvim',
              },
            },
            hint = {
              enable = true,
            },
            completion = {
              callSnippet = 'Replace',
            },
          },
        },
        capabilities = capabilities,
      }
      
      
      {
          theme = 'fluoromachine',
          brightness = 0.05,
          glow = true,
          transparent = false,
          styles = {
            comments = {},
            functions = {},
            variables = {},
            numbers = {},
            constants = {},
            parameters = {},
            keywords = {},
            types = {},
          },
          colors = {},
          overrides = {},
          plugins = {
            bufferline = true,
            cmp = true,
            dashboard = true,
            editor = true,
            gitsign = true,
            hop = true,
            ibl = true,
            illuminate = true,
            lazy = true,
            minicursor = true,
            ministarter = true,
            minitabline = true,
            ministatusline = true,
            navic = true,
            neogit = true,
            neotree = true,
            noice = true,
            notify = true,
            lspconfig = true,
            syntax = true,
            telescope = true,
            treesitter = true,
            tree = true,
            wk = true,
          },
      }
      
      
      ---@type fluoromachine
      local fm = require 'fluoromachine'
      
      fm.setup {
        glow = true,
        theme = 'retrowave',
        transparent = false,
        plugins = {
          neotree = false,
        }
      }
      
      vim.cmd.colorscheme('fluoromachine')
      
      
      local fm = require 'fluoromachine'
      
      fm.setup {
          overrides = {
             ['@type'] = { italic = true, bold = false },
             ['@function'] = { italic = false, bold = false },
             ['@comment'] = { italic = true },
             ['@keyword'] = { italic = false },
             ['@constant'] = { italic = false, bold = false },
             ['@variable'] = { italic = true },
             ['@field'] = { italic = true },
             ['@parameter'] = { italic = true },
         }
      }
      
      vim.cmd.colorscheme 'fluoromachine'
      
      
      local fm = require 'fluoromachine'
      
      function overrides(c,color)
          local darken = color.darken
          local lighten = color.lighten
          local blend = color.blend
          local shade = color.shade
          local tint = color.tint
          return {
           TelescopeResultsBorder = { fg = c.bgdark, bg = c.bgdark },
           TelescopeResultsNormal = { bg = c.bgdark },
           TelescopePreviewNormal = { bg = c.bg },
           TelescopePromptBorder = { fg = c.bgdark, bg = c.bgdark },
           TelescopeTitle = { fg = c.red, bg = shade(c.red,5) },
           TelescopePromptPrefix = { fg = c.purple },
          }
      end
      
      fm.setup {
        overrides = overrides
      }
      
      
      
      local fm = require 'fluoromachine'
      
      fm.setup {
        glow = true,
        theme = 'retrowave',
        colors = function(_, color)
          local darken = color.darken
          local lighten = color.lighten
          local blend = color.blend
          local shade = color.shade
          local tint = color.tint
          return {
            bg = '#190920',
            bgdark = darken('#190920', 20),
            cyan = '#49eaff',
            red = '#ff1e34',
            yellow = '#ffe756',
            orange = '#f38e21',
            pink = '#ffadff',
            purple = '#9544f7',
          }
        end,
      }
      
      vim.cmd.colorscheme 'fluoromachine'
      
      
      local lualine = require 'lualine'
      
      lualine.setup {
        options = {
          theme = 'fluoromachine'
        }
      }
      
    end,
  },
  {
    "dasupradyumna/midnight.nvim",
    config = function()
      
      -- LazySpec (plugin specification)
      -- return {
      { 'dasupradyumna/midnight.nvim', lazy = false, priority = 1000 }
      -- `lazy` and `priority` are only needed if this is your primary colorscheme to load it first
      -- }
      
      
      -- inside setup function
      -- packer.startup(function(use)
      use { 'dasupradyumna/midnight.nvim' }
      -- end)
      
      
      -- Lua
      vim.cmd.colorscheme 'midnight'
      
      
      require('midnight').setup {
          HighlightGroup = {
              fg = ForegroundColor, -- :h guifg
              bg = BackgroundColor, -- :h guibg
              sp = SpecialColor, -- :h guisp
              style = RenderStyle, -- :h attr-list
              -- OR
              link = TargetHiglightGroup -- :h :hi-link (link to "TargetHiglightGroup")
              -- OR
              clear = true -- :h :hi-clear (clear "HighlightGroup"; `false` ignores this option)
          },
          ...
      }
      
      
      local colors = require('midnight.colors')
      local p = colors.palette -- raw color palette
      local c = colors.components -- component color palette
      
    end,
  },
  {
    "sonjiku/yawnc.nvim",
    config = function()
      
      not bothered enough to actually write this, sorry
      
      
      use { "sonjiku/yawnc.nvim" }
      
    end,
  },
  {
    "uncleTen276/dark_flat.nvim",
    config = function()
      
      {"sekke276/dark_flat.nvim"}
      
      
      vim.cmd.colorscheme "dark_flat"
      
      
      require("dark_flat").setup({
          transparent = false,
          colors = {},
          themes = function(colors)
              return {}
          end,
          italics = true,
      })
      
      
      require("dark_flat").setup({
          transparent = true,  -- enable transparent window
          colors = {
              lmao = "#ffffff", -- add new color
              pink = "#ec6075", -- replace default color
          },
          themes = function(colors)
              -- change highlight of some groups,
              -- the key and value will be passed respectively to "nvim_set_hl"
              return {
                  Normal = { bg = colors.lmao },
                  DiffChange = { fg = colors.white:darken(0.3) },
                  ErrorMsg = { fg = colors.pink, standout = true },
                  ["@lsp.type.keyword"] = { link = "@keyword" }
              }
          end,
          italics = false, -- disable italics
      })
      
    end,
  },
  {
    "zootedb0t/citruszest.nvim",
    config = function()
      
      {
        "zootedb0t/citruszest.nvim",
        lazy = false,
        priority = 1000,
      },
      
      
      use { "zootedb0t/citruszest.nvim" }
      
      
      vim.cmd("colorscheme citruszest")
      
      
          -- For using default config leave this empty.
          require("citruszest").setup({
              option = {
                  transparent = false, -- Enable/Disable transparency
                  bold = false,
                  italic = true,
              },
              -- Override default highlight style in this table
              -- E.g If you want to override `Constant` highlight style
              style = {
              -- This will change Constant foreground color and make it bold.
              Constant = { fg = "#FFFFFF", bold = true}
              },
          })
      
      
      local lualine = require 'lualine'
      
      lualine.setup {
        options = {
          theme = 'citruszest',
        }
      }
      
    end,
  },
  {
    "2nthony/vitesse.nvim",
    config = function()
      
      require("lazy").setup {
        {
          "2nthony/vitesse.nvim",
          dependencies = {
            "tjdevries/colorbuddy.nvim"
          },
        }
      }
      
      
      use {
        "2nthony/vitesse.nvim",
        requires = {
          "tjdevries/colorbuddy.nvim"
        }
      }
      
      
      require("lualine").setup {
        options = {
          theme = "vitesse",
        }
      }
      
      
      require("bufferline").setup {
        options = {
          highlights = require("vitesse.plugins.bufferline"),
        },
      }
      
      
      require("vitesse").setup {
        comment_italics = true,
        transparent_background = true,
        transparent_float_background = true, -- aka pum(popup menu) background
        reverse_visual = false,
        dim_nc = false,
        cmp_cmdline_disable_search_highlight_group = false, -- disable search highlight group for cmp item
        -- if `transparent_float_background` false, make telescope border color same as float background
        telescope_border_follow_float_background = false,
        -- similar to above, but for lspsaga
        lspsaga_border_follow_float_background = false,
        -- diagnostic virtual text background, like error lens
        diagnostic_virtual_text_background = false,
      
        -- override the `lua/vitesse/palette.lua`, go to file see fields
        colors = {},
        themes = {},
      }
      
      
      vim.opt.winblend = 0
      vim.opt.pumblend = 0
      
      
      local slant = require("vitesse.features.bufferline.slant")
      
      -- you can override or customize
      -- slant.highlights.buffer_selected.bold = false
      
      require("bufferline").setup {
        options = {
          separator_style = "slant",
        },
        highlights = slant.highlights,
      }
      
    end,
  },
  {
    "xero/miasma.nvim",
    config = function()
      
      {
        "xero/miasma.nvim",
        lazy = false,
        priority = 1000,
        config = function()
          vim.cmd("colorscheme miasma")
        end,
      }
      
      
      use {"xero/miasma.nvim"}
      vim.cmd("colorscheme miasma")
      
    end,
  },
  {
    "Verf/deepwhite.nvim",
    config = function()
      
      -- for packer.nvim
      use {
          'Verf/deepwhite.nvim',
          config = function()
              vim.cmd [[colorscheme deepwhite]]
          end,
      }
      
      -- for lazy.nvim
      {
          'Verf/deepwhite.nvim',
          lazy = false,
          priority = 1000,
          config = function()
              vim.cmd [[colorscheme deepwhite]]
          end,
      }
      
      
      require('deepwhite').setup({
          -- If you have some anti-blue light setting (f.lux, light bulb, or low blue light mode monitor),
          -- turn it on, this will set the background color to a cooler color to prevent the background from being too warm.
          low_blue_light = true
      })
      -- for lualine
      require('lualine').setup({
              options = {
                  theme = 'deepwhite',
              },
          })
      -- for barbar
      require('barbar').setup({
              icons = {
                  filetype = {
                      custom_colors = true,
                  },
              },
      })
      
    end,
  },
  {
    "judaew/ronny.nvim",
    config = function()
      
      return require("packer").startup(function(use)
          use {
              "judaew/ronny.nvim",
              config = function()
                  vim.cmd.colorscheme("ronny")
                  require("ronny").setup()
              end
          }
      end)
      
      
      require("lazy").setup({
          {
              "judaew/ronny.nvim",
              priority = 1000,
              config = function()
                  vim.cmd.colorscheme("ronny")
                  require("ronny").setup()
              end
          }
      })
      
      
      require("ronny").setup({
          display = {
              -- Enable original Monokai colors
              monokai_original  = false,
              -- Highlight only LineNr (current line number) for cursorline
              -- option. This also enables cursorline (:set cursorline)
              only_CursorLineNr = true,
              -- Highlight LineNr for relativenumbers. This also enables
              -- relativenumbers option (:set relativenumbers)
              hi_relativenumber = false,
              -- Highlight unfocused windows when using :split or :vsplit
              hi_unfocus_window = false,
              -- Highlight formatted @text (e.g., italic, strong) in yellow
              -- in addition to font attributes to make the text more visible
              hi_formatted_text = true,
              -- Highlight comment in italics
              hi_comment_italic = true
          }
      })
      
    end,
  },
  {
    "ribru17/bamboo.nvim",
    config = function()
      
      -- Using lazy.nvim
      {
        'ribru17/bamboo.nvim',
        lazy = false,
        priority = 1000,
        config = function()
          require('bamboo').setup {
            -- optional configuration here
          }
          require('bamboo').load()
        end,
      },
      
      
      -- Lua
      require('bamboo').load()
      
      
      -- Lua
      require('bamboo').setup {
        -- Main options --
        -- NOTE: to use the light theme, set `vim.o.background = 'light'`
        style = 'vulgaris', -- Choose between 'vulgaris' (regular), 'multiplex' (greener), and 'light'
        toggle_style_key = nil, -- Keybind to toggle theme style. Leave it nil to disable it, or set it to a string, e.g. "<leader>ts"
        toggle_style_list = { 'vulgaris', 'multiplex', 'light' }, -- List of styles to toggle between
        transparent = false, -- Show/hide background
        dim_inactive = false, -- Dim inactive windows/buffers
        term_colors = true, -- Change terminal color as per the selected theme style
        ending_tildes = false, -- Show the end-of-buffer tildes. By default they are hidden
        cmp_itemkind_reverse = false, -- reverse item kind highlights in cmp menu
      
        -- Change code style ---
        -- Options are anything that can be passed to the `vim.api.nvim_set_hl` table
        -- You can also configure styles with a string, e.g. keywords = 'italic,bold'
        code_style = {
          comments = { italic = true },
          conditionals = { italic = true },
          keywords = {},
          functions = {},
          namespaces = { italic = true },
          parameters = { italic = true },
          strings = {},
          variables = {},
        },
      
        -- Lualine options --
        lualine = {
          transparent = false, -- lualine center bar transparency
        },
      
        -- Custom Highlights --
        colors = {}, -- Override default colors
        highlights = {}, -- Override highlight groups
      
        -- Plugins Config --
        diagnostics = {
          darker = false, -- darker colors for diagnostic
          undercurl = true, -- use undercurl instead of underline for diagnostics
          background = true, -- use background color for virtual text
        },
      }
      
      
      require('bamboo').setup {
        colors = {
          bright_orange = '#ff8800', -- define a new color
          green = '#00ffaa', -- redefine an existing color
        },
        highlights = {
          -- make comments blend nicely with background, similar to other color schemes
          ['@comment'] = { fg = '$grey' },
      
          ['@keyword'] = { fg = '$green' },
          ['@string'] = { fg = '$bright_orange', bg = '#00ff00', fmt = 'bold' },
          ['@function'] = { fg = '#0000ff', sp = '$cyan', fmt = 'underline,italic' },
          ['@function.builtin'] = { fg = '#0059ff' },
        },
      }
      
      
      require('bamboo').setup {
        colors = {
          bright_orange = '#ff8800', -- define a new color
          green = '#00ffaa', -- redefine an existing color
        },
        highlights = {
          TSKeyword = { fg = '$green' },
          TSString = { fg = '$bright_orange', bg = '#00ff00', fmt = 'bold' },
          TSFunction = { fg = '#0000ff', sp = '$cyan', fmt = 'underline,italic' },
          TSFuncBuiltin = { fg = '#0059ff' },
        },
      }
      
    end,
  },
  {
    "cryptomilk/nightcity.nvim",
    config = function()
      
      vim.cmd.colorscheme('nightcity')
      
      
          -- kabuki or afterlife
          style = 'kabuki', -- The theme comes in two styles: kabuki or afterlife
          terminal_colors = true, -- Use colors used when opening a `:terminal`
          invert_colors = {
              -- Invert colors for the following syntax groups
              cursor = true,
              diff = true,
              error = true,
              search = true,
              selection = false,
              signs = false,
              statusline = true,
              tabline = false,
          },
          font_style = {
              -- Style to be applied to different syntax groups
              comments = { italic = true },
              keywords = { italic = true },
              functions = { bold = true },
              variables = {},
              search = { bold = true },
          },
          -- Plugin integrations. Use `default = false` to disable all integrations.
          plugins = { default = true },
          --- You can override specific highlights to use other groups or a hex color
          --- function will be called with a Highlights and ColorScheme table
          ---@param groups Highlight groups
          ---@param colors ColorScheme
          on_highlights = function(groups, colors) end,
      
      
      require('nightcity').setup({
          plugins = {
              default = true,
              ['hrsh7th/nvim-cmp'] = false
          }
      })
      
      
      require('nightcity').setup({
          on_highlights = function(groups, c)
              groups.String = { fg = c.green, bg = c.none }
      
              groups['@lsp.typemod.parameter.readonly'] = { italic = true }
              groups['@lsp.typemod.variable.readonly']  = { italic = true }
          end
      })
      
    end,
  },
  {
    "polirritmico/monokai-nightasty.nvim",
    config = function()
      
      -- Lazy
      {
        "polirritmico/monokai-nightasty.nvim",
        lazy = false,
        priority = 1000,
      }
      
      
      vim.opt.background = "dark" -- default to dark or light style
      
      local opts = {...} -- options should be setted through a setup call:
      require("monokai-nightasty").setup(opts) -- ...and then load the theme:
      require("monokai-nightasty").load()
      
      -- As an alternative, pass the options directly into load and it will run setup
      -- the first time it is executed:
      require("monokai-nightasty").load(opts)
      
      
      require("monokai-nightasty").toggle()
      
      
      ---@class monokai.Config
      ---@field dark_style_background monokai.BackgroundConfig default, dark, transparent, #RRGGBB
      ---@field light_style_background monokai.BackgroundConfig default, dark, transparent, #RRGGBB
      ---@field on_colors fun(colors: ColorScheme)
      ---@field on_highlights fun(highlights: monokai.Highlights, colors: ColorScheme)
      ---@field hl_styles monokai.HighlightStylesConfig Styles to be applied to selected syntax groups
      ---@field color_headers boolean Enable header colors for each header level (h1, h2, etc.)
      ---@field dim_inactive boolean dims inactive windows
      ---@field lualine_bold boolean Lualine headers will be bold or regular
      ---@field lualine_style monokai.LualineStyleConfig Possible values: "dark", "light" or "default" (default follows dark/light style)
      ---@field markdown_header_marks boolean Add headers marks highlights (the `#` character) to Treesitter highlight query
      ---@field terminal_colors boolean|table|fun(colors: ColorScheme):table
      ---@field auto_enable_plugins boolean Automatically enable supported plugins through lazy.nvim
      ---@field plugins table<string, boolean> List of manually enabled/disabled plugins.
      ---@field cache boolean Enables/Disable the cache
      
      
      M.defaults = {
        dark_style_background = "default", -- default, dark, transparent, #RRGGBB
        light_style_background = "default", -- default, dark, transparent, #RRGGBB
        hl_styles = {
          -- Custom styles for this groups: (See `:help nvim_set_hl`, Parameters, {val} for supported keys)
          comments = { italic = true },
          keywords = { italic = false },
          functions = {},
          variables = {},
          -- Background styles for floating windows and sidebars (panels):
          floats = "default", -- default, dark, transparent
          sidebars = "default", -- default, dark, transparent
        },
      
        color_headers = false, -- Enable header colors for each header level (h1, h2, etc.)
        dim_inactive = false, -- dims inactive windows
        lualine_bold = true, -- Lualine headers will be bold or regular
        lualine_style = "default", -- "dark", "light" or "default" (default follows dark/light style)
        markdown_header_marks = false, -- Add headers marks highlights (the `#` character) to Treesitter highlight query
      
        -- Set the colors for terminal-mode (`:h terminal-config`). `false` to disable it.
        -- Pass a table with `terminal_color_x` values: `{ terminal_color_8 = "#e6e6e6" }`.
        -- Also accepts a function:
        -- 
      
      {
        "polirritmico/monokai-nightasty.nvim",
        lazy = false,
        priority = 1000,
        keys = {
          { "<leader>tt", "<Cmd>MonokaiToggleLight<CR>", desc = "Monokai-Nightasty: Toggle dark/light theme." },
        },
        ---@module "monokai-nightasty"
        ---@type monokai.UserConfig
        opts = {
          dark_style_background = "default", -- default | dark | transparent | #RRGGBB
          light_style_background = "default", -- default | dark | transparent | #RRGGBB
          markdown_header_marks = true,
          -- hl_styles = { comments = { italic = false } },
          terminal_colors = function(colors) return { fg = colors.fg_dark } end,
        },
        config = function(_, opts)
          vim.opt.cursorline = true -- Highlight line at the cursor position
          vim.o.background = "dark" -- Default to dark theme
      
          require("monokai-nightasty").load(opts)
        end,
      }
      
      
      return {
        "polirritmico/monokai-nightasty.nvim",
        lazy = false,
        priority = 1000,
        keys = {
          { "<leader>tt", "<Cmd>MonokaiToggleLight<CR>", desc = "Monokai-Nightasty: Toggle dark/light theme." },
        },
        ---@module "monokai-nightasty"
        ---@type monokai.UserConfig
        opts = {
          dark_style_background = "transparent", -- default, dark, transparent, #RRGGBB
          light_style_background = "default", -- default, dark, transparent, #RRGGBB
          color_headers = true, -- Enable header colors for each header level (h1, h2, etc.)
          lualine_bold = true, -- Lualine a and z sections font width
          lualine_style = "default", -- "dark", "light" or "default" (Follows dark/light style)
          markdown_header_marks = true, -- Add headers marks highlights (the `#` character) to Treesitter highlight query
          -- Style to be applied to selected syntax groups. See `:help nvim_set_hl`
          hl_styles = {
            keywords = { italic = true },
            comments = { italic = true },
            floats = "dark",
          },
      
          -- This also could be a table like this: `terminal_colors = { Normal = { fg = "#e6e6e6" } }`
          terminal_colors = function(colors)
            return { fg = colors.fg_dark }
          end,
      
          --- You can override specific color/highlights. Theme color values
          --- in `extras/palettes`. Also could be any hex RGB color you like.
          on_colors = function(colors)
            if vim.o.background == "light" then
              -- Custom colors for light theme
              colors.comment = "#2d7e79"
              colors.lualine.normal_bg = "#7ebd00"
            else
              -- Custom colors for dark theme
              colors.border = colors.magenta
              colors.lualine.normal_bg = colors.green
            end
          end,
      
          on_highlights = function(highlights, colors)
            -- You could add styles like bold, underline, italic
            highlights.TelescopeSelection = { bold = true }
            highlights.TelescopeBorder = { fg = colors.grey }
            highlights["@lsp.type.property.lua"] = { fg = colors.fg }
          end,
        },
        config = function(_, opts)
          -- Highlight line at the cursor position
          vim.opt.cursorline = true
      
          -- Default to dark theme
          vim.o.background = "dark"  -- dark | light
      
          -- Open new Nvim instances with the light theme when the sun hits the screen
          local date_output = vim.api.nvim_exec2("!date +'\\%H\\%M'", { output = true })
          local system_time = tonumber(string.match(date_output["output"], "%d%d%d%d"))
          if system_time >= 1345 and system_time < 1630 then
            vim.o.background = "light"
          end
      
          require("monokai-nightasty").load(opts)
        end,
      }
      
      
      opts = {
        on_colors = function(colors)
          colors.charcoal_medium = "#455455"
        end
      }
      
      
      opts = {
        on_highlights(hl, c)
          hl["Folded"] = { fg = c.orange, bg = c.bg_float, italic = false },
          hl["LineNr"] = { fg = c.grey },
        end,
      }
      
      
      {
        on_colors = function(colors)
          local is_light = vim.o.background == "light"
          colors.comment = is_light and "#2d7e79" or colors.grey
          colors.border = not is_light and colors.magenta or colors.border
      
          if is_light then
            colors.orange = "#f59263",
          end
        end,
      
        on_highlights = function(highlights, colors)
          local is_light = vim.o.background == "light"
      
          highlights["@variable.member.lua"] = {
            fg = is_light and colors.magenta or colors.grey,
            underline = is_light,
          },
        end,
      }
      
      
      local opts = require("monokai-nightasty.config").extend()
      local colors = require("monokai-nightasty.colors").setup(opts)
      
      some_plugin_config.title = colors.blue
      example_plugin_config = {
        foo = colors.bg_dark,
        bar = colors.green,
        buz = opts.transparent and colors.none or colors.bg
      }
      
      
      local opts = require("monokai-nightasty.config").extend()
      local colors = require("monokai-nightasty.colors").setup(opts)
      local utils = require("monokai-nightasty.utils")
      
      some_plugin_config.example = utils.lighten(colors.bg, 0.5)
      some_plugin_config.another = utils.darken(colors.bg, 0.3)
      
    end,
  },
  {
    "oxfist/night-owl.nvim",
    config = function()
      
      use("oxfist/night-owl.nvim")
      
      
      require("lazy").setup({
        "oxfist/night-owl.nvim",
        lazy = false, -- make sure we load this during startup if it is your main colorscheme
        priority = 1000, -- make sure to load this before all the other start plugins
        config = function()
          -- load the colorscheme here
          require("night-owl").setup()
          vim.cmd.colorscheme("night-owl")
        end,
      })
      
      
      require("night-owl").setup()
      vim.cmd.colorscheme("night-owl")
      
      
      -- This Lualine config should be somewhere in your config files
      require('lualine').setup {
        options = {
          -- ... other configs
          theme = 'night-owl'
          -- ... other configs
        }
      }
      
      
      local night_owl = require("night-owl")
      
      -- 👇 Add your own personal settings here
      --@param options Config|nil
      night_owl.setup({
          -- These are the default settings
          bold = true,
          italics = true,
          underline = true,
          undercurl = true,
          transparent_background = false,
      })
      
    end,
  },
  {
    "svermeulen/text-to-colorscheme",
    config = function()
      
      use { "svermeulen/text-to-colorscheme.nvim" }
      
      
      vim.o.background = "dark"
      
      require('text-to-colorscheme').setup {
        ai = {
          openai_api_key = "<OPENAI_API_KEY>",
        },
      }
      
      vim.cmd([[colorscheme text-to-colorscheme]])
      
      
      require('text-to-colorscheme').setup {
        ai = {
           openai_api_key = os.getenv("OPENAI_API_KEY"),
        },
      }
      
      
      require('text-to-colorscheme').setup {
        ai = {
           openai_api_key = os.getenv("OPENAI_API_KEY"),
           gpt_model = "gpt-4",
        },
      }
      
      
      -- setup must be called before loading the colorscheme
      -- Default options:
      require("text-to-colorscheme").setup({
        ai = {
           gpt_model = "gpt-4",
           openai_api_key = nil, -- Set your own OpenAI API key to this value
           green_darkening_amount = 0.85, -- Often, the generated theme results in green colors that seem to our human eyes to be more bright than it actually is, therefore this is a fudge factor to account for this, to darken greens to better match the brightness of other colors.  Enabled or disabled with auto_darken_greens flag
           auto_darken_greens = true,
           minimum_foreground_contrast = 0.4, -- This is used to touch up the generated theme to avoid generating foregrounds that match the background too closely.  Enabled or disabled with enable_minimum_foreground_contrast flag
           enable_minimum_foreground_contrast = true,
           temperature = 0, -- Set this to a value between 0 and 1, where 0 means it will generate similar looking color schemes every time, and 1 means that each time will be very different.  See openai docs for more information on this setting
        },
        disable_builtin_schemes = false,  -- Set to true to disable all pre-generated color schemes, so that only your custom ones show in T2CSelect
        undercurl = true,
        underline = true,
        verbose_logs = false, -- When true, will output logs to echom, to help debugging issues with this plugin
        bold = true,
        italic = {
           strings = true,
           comments = true,
           operators = false,
           folds = true,
        },
        strikethrough = true,
        invert_selection = false,
        save_as_hsv = false, -- When true, T2CSave will save colors as HSV instead of hex
        invert_signs = false,
        invert_tabline = false,
        invert_intend_guides = false,
        inverse = true,
        dim_inactive = false,
        transparent_mode = false,
        hsv_palettes = {},
        hex_palettes = {},
        overrides = {},
        default_palette = "gruvbox",
      })
      
      
      require("text-to-colorscheme").setup({
          overrides = {
              SignColumn = {bg = "#ff9900"}
          }
      })
      
    end,
  },
  {
    "miikanissi/modus-themes.nvim",
    config = function()
      
      { "miikanissi/modus-themes.nvim", priority = 1000 }
      
      
      use({ "miikanissi/modus-themes.nvim" })
      
      
      vim.cmd([[colorscheme modus]]) -- modus_operandi, modus_vivendi
      
      
      -- Default options
      require("modus-themes").setup({
      	-- Theme comes in two styles `modus_operandi` and `modus_vivendi`
      	-- `auto` will automatically set style based on background set with vim.o.background
      	style = "auto",
      	variant = "default", -- Theme comes in four variants `default`, `tinted`, `deuteranopia`, and `tritanopia`
      	transparent = false, -- Transparent background (as supported by the terminal)
      	dim_inactive = false, -- "non-current" windows are dimmed
      	hide_inactive_statusline = false, -- Hide statuslines on inactive windows. Works with the standard **StatusLine**, **LuaLine** and **mini.statusline**
      	line_nr_column_background = true, -- Distinct background colors in line number column. `false` will disable background color and fallback to Normal background
      	sign_column_background = true, -- Distinct background colors in sign column. `false` will disable background color and fallback to Normal background
      	styles = {
      		-- Style to be applied to different syntax groups
      		-- Value is any valid attr-list value for `:help nvim_set_hl`
      		comments = { italic = true },
      		keywords = { italic = true },
      		functions = {},
      		variables = {},
      	},
      
      	--- You can override specific color groups to use other groups or a hex color
      	--- Function will be called with a ColorScheme table
      	--- Refer to `extras/lua/modus_operandi.lua` or `extras/lua/modus_vivendi.lua` for the ColorScheme table
      	---@param colors ColorScheme
      	on_colors = function(colors) end,
      
      	--- You can override specific highlights to use other groups or a hex color
      	--- Function will be called with a Highlights and ColorScheme table
      	--- Refer to `extras/lua/modus_operandi.lua` or `extras/lua/modus_vivendi.lua` for the Highlights and ColorScheme table
      	---@param highlights Highlights
      	---@param colors ColorScheme
      	on_highlights = function(highlights, colors) end,
      })
      
      
      require("modus-themes").setup({
      	style = "modus_operandi", -- Always use modus_operandi regardless of `vim.o.background`
      	variant = "deuteranopia", -- Use deuteranopia variant
      	styles = {
      		functions = { italic = true }, -- Enable italics for functions
      	},
      
      	on_colors = function(colors)
      		colors.error = colors.red_faint -- Change error color to the "faint" variant
      	end,
      	on_highlights = function(highlight, color)
      		highlight.Boolean = { fg = color.green } -- Change Boolean highlight to use the green color
      	end,
      })
      
    end,
  },
  {
    "alexmozaidze/palenight.nvim",
    config = function()
      
      vim.opt.background = "dark"
      
      
      { "alexmozaidze/palenight.nvim" }
      
      
      use "alexmozaidze/palenight.nvim"
      
      
      vim.cmd.colorscheme "palenight"
      
      
      {
         -- Some terminals don't display italics very well,
         -- thus, they're disabled by default.
         italic = false,
      
         -- Fallback color palette for non-truecolor terminals,
         -- such as tty or some really old terminal.
         --
         -- Available options:
         -- "auto" => 16 color palette if in linux tty, 256 otherwise.
         -- 256    => 256 color palette.
         -- 16     => 16 color palette.
         cterm_palette = "auto",
      }
      
      
      local colors = require "palenight/colors/truecolor"
      local hl = vim.api.nvim_set_hl
      local autocmd = vim.api.nvim_create_autocmd
      
      autocmd("ColorScheme", {
         pattern = "palenight",
         callback = function()
            -- Directly setting a color
            hl(0, "Operator", { fg = colors.purple })
            -- Linking to another highlight group
            hl(0, "Operator", { link = "Macro" })
         end,
      })
      
      
      {
         "alexmozaidze/palenight.nvim",
         init = function()
            -- Changing internal colors
            local colors = require "palenight/colors/truecolor"
            colors.comment = "#ff00ff"
            -- Changing internal group table
            local groups = require "palenight/groups"
            groups["@function"].fg = "#ff0000"
         end,
      }
      
    end,
  },
  {
    "scottmckendry/cyberdream.nvim",
    config = function()
      
      {
          "scottmckendry/cyberdream.nvim",
          lazy = false,
          priority = 1000,
      }
      
      
      use { "scottmckendry/cyberdream.nvim" }
      
      
      {
          require("lualine").setup({
              -- ... other config
              options = {
                  theme = "auto", -- "auto" will set the theme dynamically based on the colorscheme
              },
              -- ... other config
          })
      }
      
      
      vim.cmd("colorscheme cyberdream")
      
      
      require("cyberdream").setup({
          -- Set light or dark variant
          variant = "default", -- use "light" for the light variant. Also accepts "auto" to set dark or light colors based on the current value of `vim.o.background`
      
          -- Enable transparent background
          transparent = false,
      
          -- Reduce the overall saturation of colours for a more muted look
          saturation = 1, -- accepts a value between 0 and 1. 0 will be fully desaturated (greyscale) and 1 will be the full color (default)
      
          -- Enable italics comments
          italic_comments = false,
      
          -- Replace all fillchars with ' ' for the ultimate clean look
          hide_fillchars = false,
      
          -- Apply a modern borderless look to pickers like Telescope, Snacks Picker & Fzf-Lua
          borderless_pickers = false,
      
          -- Set terminal colors used in `:terminal`
          terminal_colors = true,
      
          -- Improve start up time by caching highlights. Generate cache with :CyberdreamBuildCache and clear with :CyberdreamClearCache
          cache = false,
      
          -- Override highlight groups with your own colour values
          highlights = {
              -- Highlight groups to override, adding new groups is also possible
              -- See `:h highlight-groups` for a list of highlight groups or run `:hi` to see all groups and their current values
      
              -- Example:
              Comment = { fg = "#696969", bg = "NONE", italic = true },
      
              -- More examples can be found in `lua/cyberdream/extensions/*.lua`
          },
      
          -- Override a highlight group entirely using the built-in colour palette
          overrides = function(colors) -- NOTE: This function nullifies the `highlights` option
              -- Example:
              return {
                  Comment = { fg = colors.green, bg = "NONE", italic = true },
                  ["@property"] = { fg = colors.magenta, bold = true },
              }
          end,
      
          -- Override colors
          colors = {
              -- For a list of colors see `lua/cyberdream/colours.lua`
      
              -- Override colors for both light and dark variants
              bg = "#000000",
              green = "#00ff00",
      
              -- If you want to override colors for light or dark variants only, use the following format:
              dark = {
                  magenta = "#ff00ff",
                  fg = "#eeeeee",
              },
              light = {
                  red = "#ff5c57",
                  cyan = "#5ef1ff",
              },
          },
      
          -- Disable or enable colorscheme extensions
          extensions = {
              telescope = true,
              notify = true,
              mini = true,
              ...
          },
      })
      
      
      -- Add a custom keybinding to toggle the colorscheme
      vim.api.nvim_set_keymap("n", "<leader>tt", ":CyberdreamToggleMode<CR>", { noremap = true, silent = true })
      
      
      -- The event data property will contain a string with either "default" or "light" respectively
      vim.api.nvim_create_autocmd("User", {
          pattern = "CyberdreamToggleMode",
          callback = function(event)
              -- Your custom code here!
              -- For example, notify the user that the colorscheme has been toggled
              print("Switched to " .. event.data .. " mode!")
          end,
      })
      
    end,
  },
  {
    "HoNamDuong/hybrid.nvim",
    config = function()
      
      use { "HoNamDuong/hybrid.nvim" }
      
      
      {
          "HoNamDuong/hybrid.nvim",
          lazy = false,
          priority = 1000,
          opts = {},
      }
      
      
      vim.cmd.colorscheme("hybrid")
      
      
      -- Default options:
      require("hybrid").setup({
          terminal_colors = true,
          undercurl = true,
          underline = true,
          bold = true,
          italic = {
              strings = false,
              emphasis = true,
              comments = true,
              folds = true,
          },
          strikethrough = true,
          inverse = true,
          transparent = false,
          overrides = function(highlights, colors) end,
      })
      
      
      require("hybrid").setup({
          overrides = function(hl, c)
              local background = "#1d1f21"
              hl.TelescopeNormal = {
                  fg = c.fg,
                  bg = background,
              }
              hl.TelescopeBorder = {
                  fg = c.fg_hard,
                  bg = c.bg,
              }
              hl.TelescopeTitle = {
                  fg = c.fg_hard,
                  bg = c.bg,
                  bold = true,
              }
          end,
      })
      
    end,
  },
  {
    "samharju/synthweave.nvim",
  },
  {
    "loganswartz/sunburn.nvim",
    config = function()
      
      {
          'loganswartz/sunburn.nvim',
          dependencies = { 'loganswartz/polychrome.nvim' },
          -- you could do this, or use the standard vimscript `colorscheme sunburn`
          config = function()
              vim.cmd.colorscheme 'sunburn'
          end,
      }
      
    end,
  },
  {
    "ptdewey/darkearth-nvim",
    config = function()
      
      {
          "ptdewey/darkearth-nvim",
          priority = 1000,
      },
      
      
      vim.pack.add({ "https://github.com/ptdewey/darkearth-nvim" })
      
      
      vim.cmd.colorscheme("darkearth")
      
    end,
  },
  {
    "uloco/bluloco.nvim",
    config = function()
      
      use {
          'uloco/bluloco.nvim',
          requires = { 'rktjmp/lush.nvim' }
      }
      
      
      {
        'uloco/bluloco.nvim',
        lazy = false,
        priority = 1000,
        dependencies = { 'rktjmp/lush.nvim' },
        config = function()
          -- your optional config goes here, see below.
        end,
      },
      
      
      require("bluloco").setup({
        style = "auto",               -- "auto" | "dark" | "light"
        transparent = false,
        italics = false,
        terminal = vim.fn.has("gui_running") == 1, -- bluoco colors are enabled in gui terminals per default.
        guicursor = true,
        rainbow_headings = false,     -- if you want different colored headings for each heading level
      })
      
      vim.opt.termguicolors = true
      vim.cmd('colorscheme bluloco')
      
      
      require('lualine').setup {
        options = {
          theme = 'auto'
        }
      }
      
      
      local auto_dark_mode = require('auto-dark-mode')
      
      local function isAuto()
        return require('bluloco').config.style == 'auto'
      end
      
      auto_dark_mode.setup({
        update_interval = 1000,
        set_dark_mode = function()
          if isAuto() then
            vim.o.background = 'dark'
          end
        end,
        set_light_mode = function()
          if isAuto() then
            vim.o.background = 'light'
          end
        end
      })
      
    end,
  },
  {
    "slugbyte/lackluster.nvim",
    config = function()
       
      -- example lazy.nvim install setup
      return {
          "slugbyte/lackluster.nvim",
          lazy = false,
          priority = 1000,
          init = function()
              vim.cmd.colorscheme("lackluster")
              -- vim.cmd.colorscheme("lackluster-hack") -- my favorite
              -- vim.cmd.colorscheme("lackluster-mint")
          end,
      }
      
      
      require('lualine').setup({
        options = {
          theme = "lackluster",
        },
      })
      
       
      local lackluster = require("lackluster")
      
      -- !must called setup() before setting the colorscheme!
      lackluster.setup({
          -- tweak_color allows you to overwrite the default colors in the lackluster theme
          tweak_color = {
              -- you can set a value to a custom hexcode like' #aaaa77' (hashtag required)
              -- or if the value is 'default' or nil it will use lackluster's default color
              -- lack = "#aaaa77",
              lack = "default", 
              luster = "default",
              orange = "default",
              yellow = "default",
              green = "default",
              blue = "default",
              red = "default",
              -- WARN: Watchout! messing with grays is probs a bad idea, its very easy to shoot yourself in the foot!
              -- black = "default",
              -- gray1 = "default",
              -- gray2 = "default",
              -- gray3 = "default",
              -- gray4 = "default",
              -- gray5 = "default",
              -- gray6 = "default",
              -- gray7 = "default",
              -- gray8 = "default",
              -- gray9 = "default",
      
          },
      })
      
      -- !must set colorscheme after calling setup()!
      vim.cmd.colorscheme("lackluster")
      
       
      local lackluster = require("lackluster")
      
      local color = lackluster.color -- blue, green, red, orange, black, lack, luster, gray1-9
      
      -- !must called setup() before setting the colorscheme!
      lackluster.setup({
          -- You can overwrite the following syntax colors by setting them to one of...
          --   1) a hexcode like "#a1b2c3" for a custom color.
          --   2) "default" or nil will just use whatever lackluster's default is.
          tweak_syntax = {
              string = "default",
              -- string = "#a1b2c3", -- custom hexcode
              -- string = color.green, -- lackluster color
              string_escape = "default",
              comment = "default",
              builtin = "default", -- builtin modules and functions
              type = "default",
              keyword = "default",
              keyword_return = "default",
              keyword_exception = "default",
          },
          -- You can overwrite the following background colors by setting them to one of...
          --   1) a hexcode like "#a1b2c3" for a custom color
          --   2) "none" for transparency
          --   3) "default" or nil will just use whatever lackluster's default is.
          tweak_background = {
              normal = 'default',    -- main background
              -- normal = 'none',    -- transparent
              -- normal = '#a1b2c3',    -- hexcode 
              -- normal = color.green,    -- lackluster color
              telescope = 'default', -- telescope
              menu = 'default',      -- nvim_cmp, wildmenu ... (bad idea to transparent)
              popup = 'default',     -- lazy, mason, whichkey ... (bad idea to transparent)
          },
      })
      
      -- !must set colorscheme after calling setup()!
      vim.cmd.colorscheme("lackluster")
      
       
      --  When testing transparent backgrounds I found that comments where often hard to read, 
      --  and menus didn't look good but using setup() tweaks you can easily address that!
      local lackluster = require("lackluster")
      
      -- !must called setup() before setting the colorscheme!
      lackluster.setup({
          tweak_syntax = {
              comment = lackluster.color.gray4, -- or gray5
          },
          tweak_background = {
              normal = 'none',
              telescope = 'none',
              menu = lackluster.color.gray3,
              popup = 'default',
          },
      })
      
      -- !must set colorscheme after calling setup()!
      vim.cmd.colorscheme("lackluster")
      
       
      local lackluster = require("lackluster")
      
      -- !must called setup() before setting the colorscheme!
      lackluster.setup({
          tweak_ui = {
              disable_undercurl = false, -- set to true if you want underline instead of undercurl
              enable_end_of_buffer = false, -- set to true to show the end_of_buffer ~ symbols in the gutter
          },
      })
      
      -- !must set colorscheme after calling setup()!
      vim.cmd.colorscheme("lackluster")
      
      
      local lackluster = require("lackluster")
      
      -- !must called setup() before setting the colorscheme!
      lackluster.setup({
          -- tweak_highlight allows you to update or overwrite the value passed into
          -- vim.api.nvim_set_hl which allows you to have complete control over modifying all
          -- highlights on a granular level.
          tweak_highlight = {
            -- modify @keyword's highlights to be bold and italic
            ["@keyword"] = {
              overwrite = false, -- overwrite falsey will extend/update lackluster's defaults (nil also does this)
              bold = true,
              italic = true,
              -- see `:help nvim_set_hl` for all possible keys
            },
            -- overwrite @function to link to @keyword
            ["@function"] = {
              overwrite = true, -- overwrite == true will force overwrite lackluster's default highlights
              link = "@keyword",
            },
          },
      })
      
      -- !must set colorscheme after calling setup()!
      vim.cmd.colorscheme("lackluster")
      
      
      local lackluster = require("lackluster")
      
      -- if for some reason you want to disable the highlights related to a specific plugin you 
      -- can set any of these to true and the highlights will not be set
      
      -- !must called setup() before setting the colorscheme!
      lackluster.setup({
          disable_plugin = {
              bufferline = false,
              cmp = false,
              dashboard = false,
              flash = false,
              git_gutter = false,
              git_signs = false,
              headline = false,
              indentmini = false,
              lazy = false,
              lightbulb = false,
              lsp_config = false,
              mason = false,
              mini_diff = false,
              navic = false,
              noice = false,
              notify = false,
              oil = false,
              rainbow_delimiter = false, -- if you want color-rainbows you should disable this
              scollbar = false,
              telescope = false,
              todo_comments = false,
              tree = false,
              trouble = false,
              which_key = false,
              yanky = false,
          },
      })
      
      -- !must set colorscheme after calling setup()!
      vim.cmd.colorscheme("lackluster")
      
       
      
      -- nvim-web-devicons does not play well with colorschemes so if lackluster style icons
      -- run the following setup before you load lackluster.
      local lackluster = require("lackluster")
      -- !must called setup() before setting the colorscheme!
      require('nvim-web-devicons').setup({
          color_icons = false,
          override = {
              ["default_icon"] = {
                  color = lackluster.color.gray4,
                  name = "Default",
              }
          }
      })
      vim.cmd.colorscheme("lackluster")
      
    end,
  },
  {
    "0xstepit/flow.nvim",
    config = function()
      
      {
        "0xstepit/flow.nvim",
        lazy = false,
        priority = 1000,
        tag = "vX.0.0",
        opts = {
              -- Your configuration options here.
          },
      }
      
      
      require("flow").setup{}
      vim.cmd "colorscheme flow"
      
      
      return {
        "0xstepit/flow.nvim",
        lazy = false,
        priority = 1000,
        tag = "v2.0.1",
          opts = {
            theme = {
              style = "dark", --  "dark" | "light"
              contrast = "default", -- "default" | "high"
              transparent = false, -- true | false
            },
            colors = {
              mode = "default", -- "default" | "dark" | "light"
              fluo = "pink", -- "pink" | "cyan" | "yellow" | "orange" | "green"
              custom = {
                saturation = "", -- "" | string representing an integer between 0 and 100
                light = "", -- "" | string representing an integer between 0 and 100
              },
            },
            ui = {
              borders = "inverse", -- "theme" | "inverse" | "fluo" | "none"
              aggressive_spell = false, -- true | false
            },
          },
          config = function(_, opts)
            require("flow").setup(opts)
            vim.cmd("colorscheme flow")
          end,
        },
      }
      
    end,
  },
  {
    "samharju/serene.nvim",
    config = function()
      
      {
          "samharju/serene.nvim",
          -- for using as main:
          --config = function() vim.cmd.colorscheme("serene") end,
      }
      
      
      vim.cmd([[colorscheme serene]])
      vim.cmd([[colorscheme serene-transparent]])
      
    end,
  },
  {
    "killitar/obscure.nvim",
    config = function()
      
      {
        "killitar/obscure.nvim",
        lazy = false,
        priority = 1000,
        opts = {}
      }
      
      
      vim.cmd[[colorscheme obscure]]
      
      
      {
        transparent = false,
        terminal_colors = true,
        dim_inactive = true,
        styles = {
          keywords = { italic = true },
          identifiers = {},
          functions = {},
          variables = {},
          booleans = {},
          comments = { italic = true },
        },
      
        --- You can override specific highlights to use other groups or a hex color
        --- function will be called with a Highlights and ColorScheme table
        on_highlights = function(highlights, colors) end,
      
        plugins = {
          -- enable all plugins when not using lazy.nvim
          -- set to false to manually enable/disable plugins
          all = package.loaded.lazy == nil,
          -- uses your plugin manager to automatically enable needed plugins
          -- currently only lazy.nvim is supported
          auto = true,
          -- add any plugins here that you want to enable
          -- for all possible plugins, see:
          --   * https://github.com/killitar/obscure.nvim/tree/main/lua/obscure/groups
          -- flash = true,
        },
      }
      
      
      
      require("obscure").setup({
          styles = {
              booleans = { italic = true, bold = true },
          },
          on_highlights = function(hl,c)
              hl.Comment = { fg = "#ffffff" }
              -- Or
              hl.Comment = { fg = c.orange }
          end
      })
      
      
      local colors = require("obscure.palettes").get_palette("obscure") -- pass in any of the config options as explained above
      
      plugin.bg = colors.yellow
      
    end,
  },
  {
    "bakageddy/alduin.nvim",
    config = function()
      
      use { "bakageddy/alduin.nvim" }
      
      
      { "bakageddy/alduin.nvim", priority = 1000 , config = true, opts = ...}
      
      
      vim.cmd([[colorscheme alduin]])
      
      
      -- Default options:
      require("alduin").setup({
        terminal_colors = true, -- add neovim terminal colors
        inverse = true, -- invert background for search, diffs, statuslines and errors
        palette_overrides = {},
        overrides = {},
      })
      vim.cmd("colorscheme alduin")
      
    end,
  },
  {
    "diegoulloao/neofusion.nvim",
    config = function()
      
      { "diegoulloao/neofusion.nvim", priority = 1000 , config = true, opts = ... }
      
      
      use { "diegoulloao/neofusion.nvim" }
      
      
      vim.o.background = "dark"
      vim.cmd([[ colorscheme neofusion ]])
      
      
      -- Default options:
      require("neofusion").setup({
        terminal_colors = true, -- add neovim terminal colors
        undercurl = true,
        underline = true,
        bold = true,
        italic = {
          strings = true,
          emphasis = true,
          comments = true,
          operators = false,
          folds = true,
        },
        strikethrough = true,
        invert_selection = false,
        invert_signs = false,
        invert_tabline = false,
        invert_intend_guides = false,
        inverse = true, -- invert background for search, diffs, statuslines and errors
        palette_overrides = {},
        overrides = {},
        dim_inactive = false,
        transparent_mode = false,
      })
      
      vim.cmd([[ colorscheme neofusion ]])
      
      
      require("lualine").setup({
        options = {
          theme = require("neofusion.lualine"),
          -- rest,
        }
      })
      
      
      require("neofusion").setup({
        palette_overrides = {
          bright_green = "#ec30ac",
          -- rest,
        }
      })
      
      vim.cmd([[ colorscheme neofusion ]])
      
      
      require("neofusion").setup({
        overrides = {
          SignColumn = { bg = "#ec30ac" },
          -- rest,
        }
      })
      
      vim.cmd([[ colorscheme neofusion ]])
      
      
      require("neofusion").setup({
        overrides = {
          ["@lsp.type.method"] = { bg = "#ec30ac" },
          ["@comment.lua"] = { bg = "#000000" },
          -- rest,
        }
      })
      
      vim.cmd([[ colorscheme neofusion ]])
      
    end,
  },
  {
    "m15a/nvim-srcerite",
    config = function()
      
      vim.cmd.colorscheme 'srcerite'
      
      
      vim.g.srcerite_inverse_vidual = false
      
      
      vim.g.srcerite_inverse_search = true
      
      
      vim.g.srcerite_inverse_match_paren = true
      
    end,
  },
  {
    "neko-night/nvim",
    config = function()
      
      {
        "neko-night/nvim",
        lazy = false,
        priority = 1000,
        opts = {},
      }
      
      
      return require('packer').startup(function(use)
          -- Other packages can be listed here...
      
          -- NekoNight Theme
        use 'neko-night/nvim'  
      end)
      
      
      vim.cmd[[colorscheme nekonight]]
      
      
      -- Lua
      require('barbecue').setup {
        -- ... your barbecue config
        theme = 'nekonight',
        -- ... your barbecue config
      }
      
      
      -- Lua
      require('lualine').setup {
        options = {
          -- ... your lualine config
          theme = 'nekonight'
          -- ... your lualine config
        }
      }
      
      
      ---@class nekonight.Config
      ---@field on_colors fun(colors: ColorScheme)
      ---@field on_highlights fun(highlights: nekonight.Highlights, colors: ColorScheme)
      M.defaults = {
        style = "moon", -- The theme comes in three styles, `storm`, a darker variant `night` and `day`
        light_style = "day", -- The theme is used when the background is set to light
        transparent = false, -- Enable this to disable setting the background color
        terminal_colors = true, -- Configure the colors used when opening a `:terminal` in Neovim
        styles = {
          -- Style to be applied to different syntax groups
          -- Value is any valid attr-list value for `:help nvim_set_hl`
          comments = { italic = true },
          keywords = { italic = true },
          functions = {},
          variables = {},
          -- Background styles. Can be "dark", "transparent" or "normal"
          sidebars = "dark", -- style for sidebars, see below
          floats = "dark", -- style for floating windows
        },
        day_brightness = 0.3, -- Adjusts the brightness of the colors of the **Day** style. Number between 0 and 1, from dull to vibrant colors
        dim_inactive = false, -- dims inactive windows
        lualine_bold = false, -- When `true`, section headers in the lualine theme will be bold
      
        --- You can override specific color groups to use other groups or a hex color
        --- function will be called with a ColorScheme table
        ---@param colors ColorScheme
        on_colors = function(colors) end,
      
        --- You can override specific highlights to use other groups or a hex color
        --- function will be called with a Highlights and ColorScheme table
        ---@param highlights nekonight.Highlights
        ---@param colors ColorScheme
        on_highlights = function(highlights, colors) end,
      
        cache = true, -- When set to true, the theme will be cached for better performance
      
        ---@type table<string, boolean|{enabled:boolean}>
        plugins = {
          -- enable all plugins when not using lazy.nvim
          -- set to false to manually enable/disable plugins
          all = package.loaded.lazy == nil,
          -- uses your plugin manager to automatically enable needed plugins
          -- currently only lazy.nvim is supported
          auto = true,
          -- add any plugins here that you want to enable
          -- for all possible plugins, see:
          --   * https://github.com/BrunoCiccarino/nekonight/tree/main/lua/nekonight/groups
          -- telescope = true,
        },
      }
      
      
      require("nekonight").setup({
        -- use the night style
        style = "night",
        -- disable italic for functions
        styles = {
          functions = {}
        },
        -- Change the "hint" color to the "orange" color, and make the "error" color bright red
        on_colors = function(colors)
          colors.hint = colors.orange
          colors.error = "#ff0000"
        end
      })
      
      
      require("nekonight").setup({
        on_highlights = function(hl, c)
          local prompt = "#2d3149"
          hl.TelescopeNormal = {
            bg = c.bg_dark,
            fg = c.fg_dark,
          }
          hl.TelescopeBorder = {
            bg = c.bg_dark,
            fg = c.bg_dark,
          }
          hl.TelescopePromptNormal = {
            bg = prompt,
          }
          hl.TelescopePromptBorder = {
            bg = prompt,
            fg = prompt,
          }
          hl.TelescopePromptTitle = {
            bg = prompt,
            fg = prompt,
          }
          hl.TelescopePreviewTitle = {
            bg = c.bg_dark,
            fg = c.bg_dark,
          }
          hl.TelescopeResultsTitle = {
            bg = c.bg_dark,
            fg = c.bg_dark,
          }
        end,
      })
      
    end,
  },
  {
    "ptdewey/monalisa-nvim",
    config = function()
      
      {
          "ptdewey/monalisa-nvim",
          priority = 1000,
      }
      
      
      vim.pack.add({ "https://github.com/ptdewey/monalisa-nvim" })
      
      
      vim.cmd.colorscheme("monalisa")
      
    end,
  },
  {
    "ntk148v/slack.nvim",
    config = function()
      
      use { "ntk148v/slack.nvim" }
      
      
      { "ntk148v/slack.nvim" }
      
      
      vim.cmd("colorscheme slack")
      
    end,
  },
  {
    "mcauley-penney/techbase.nvim",
    config = function()
      
      {
          "mcauley-penney/techbase.nvim",
          config = function(_, opts)
              vim.cmd.colorscheme("techbase")
          end,
          priority = 1000
      }
      
      
      {
          "mcauley-penney/techbase.nvim",
          opts = {
            italic_comments = false,
      
            -- set to true to make the background, floating windows, statusline,
            -- signcolumn, foldcolumn, and tabline transparent
            transparent = false,
      
            -- Here, you can disable plugins. All plugins that techbase supports
            -- are enabled by default. You do not need to specify the ones you
            -- want to enable, only those you wish to disable. This table
            -- accepts key-pair values.
            plugin_support = {
              visual_whitespace = false,
            },
      
            -- You can enable *only* some plugins by using the "only" table
            -- inside of the "plugin_support" table. This table accepts strings.
            -- plugin_support = {
            --   only = { "visual_whitespace" }
            -- },
      
            -- allows you to override any highlight group for finer-grained control
            hl_overrides = {},
          },
          init = function() vim.cmd.colorscheme("techbase") end,
          priority = 1000
      }
      
      
       require('lualine').setup {
        options = {
          theme = "techbase"
          -- ... your lualine config
        }
      }
      
    end,
  },
  {
    "y3owk1n/base16-pro-max.nvim",
    config = function()
      
      {
        "y3owk1n/base16-pro-max.nvim",
        config = function()
          require("base16-pro-max").setup({ --[[ your config ]] })
          vim.cmd.colorscheme("base16-pro-max")
        end
      }
      
      
      use {
        "y3owk1n/base16-pro-max.nvim",
        config = function()
          require("base16-pro-max").setup({ --[[ your config ]] })
          vim.cmd.colorscheme("base16-pro-max")
        end
      }
      
      
      -- Minimal setup with Kanagawa-inspired colors
      {
        "y3owk1n/base16-pro-max.nvim",
        priority = 1000,
        config = function()
          require("base16-pro-max").setup {
            colors = {
              base00 = "#1f1f28", base01 = "#2a2a37", base02 = "#3a3a4e",
              base03 = "#4e4e5e", base04 = "#9e9eaf", base05 = "#c5c5da",
              base06 = "#dfdfef", base07 = "#e6e6f0", base08 = "#ff5f87",
              base09 = "#ff8700", base0A = "#ffaf00", base0B = "#5fff87",
              base0C = "#5fd7ff", base0D = "#5fafff", base0E = "#af87ff",
              base0F = "#d7875f",
            },
            styles = { italic = true, transparency = true },
            plugins = { enable_all = true },
          }
          vim.cmd.colorscheme "base16-pro-max"
        end,
      }
      
      
      -- Load from Base16 YAML scheme file
      {
        "y3owk1n/base16-pro-max.nvim",
        priority = 1000,
        config = function()
          local yaml_parser = require("base16-pro-max.parser")
      
          require("base16-pro-max").setup {
            -- Load colors from YAML file
            colors = yaml_parser.get_base16_colors("~/.config/nvim/schemes/gruvbox-dark.yaml"),
            styles = { italic = true, transparency = true },
            plugins = { enable_all = true },
          }
          vim.cmd.colorscheme "base16-pro-max"
        end,
      }
      
      
      local yaml_parser = require("base16-pro-max.parser")
      
      -- Basic usage: load colors from a YAML file
      local colors = yaml_parser.get_base16_colors("~/path/to/scheme.yaml") -- or `yml` extension
      
      require("base16-pro-max").setup({
        colors = colors,
        -- your other config...
      })
      
      
      scheme: "Rosé Pine Moon"
      author: "Emilia Dunfelt <edun@dunfelt.se>"
      slug: "rose-pine-moon"
      base00: "232136"
      base01: "2a273f"
      base02: "393552"
      base03: "6e6a86"
      base04: "908caa"
      base05: "e0def4"
      base06: "e0def4"
      base07: "56526e"
      base08: "eb6f92"
      base09: "f6c177"
      base0A: "ea9a97"
      base0B: "3e8fb0"
      base0C: "9ccfd8"
      base0D: "c4a7e7"
      base0E: "f6c177"
      base0F: "56526e"
      
      
      system: "base16"
      name: "Gruvbox dark"
      author: "Tinted Theming (https://github.com/tinted-theming), morhetz (https://github.com/morhetz/gruvbox)"
      variant: "dark"
      palette:
        base00: "#282828"
        base01: "#3c3836"
        base02: "#504945"
        base03: "#665c54"
        base04: "#928374"
        base05: "#ebdbb2"
        base06: "#fbf1c7"
        base07: "#f9f5d7"
        base08: "#cc241d"
        base09: "#d65d0e"
        base0A: "#d79921"
        base0B: "#98971a"
        base0C: "#689d6a"
        base0D: "#458588"
        base0E: "#b16286"
        base0F: "#9d0006"
      
      
      local yaml_parser = require("base16-pro-max.parser")
      
      -- Clear all cached data
      yaml_parser.clear_cache()
      
      -- Get cache statistics
      local stats = yaml_parser.get_cache_stats()
      print(vim.inspect(stats))
      
      -- Cache is automatically saved on VimLeavePre
      -- Cache location: vim.fn.stdpath("cache") .. "/base16_cache/schemes_cache.lua"
      
      
      require("base16-pro-max").setup({
        colors = {
          base00 = "#282828", base01 = "#3c3836", base02 = "#504945",
          base03 = "#665c54", base04 = "#928374", base05 = "#ebdbb2",
          base06 = "#fbf1c7", base07 = "#f9f5d7", base08 = "#cc241d",
          base09 = "#d65d0e", base0A = "#d79921", base0B = "#98971a",
          base0C = "#689d6a", base0D = "#458588", base0E = "#b16286",
          base0F = "#9d0006",
        },
      })
      
      
      require("base16-pro-max").setup({
        colors = {
          base00 = "#2e3440", base01 = "#3b4252", base02 = "#434c5e",
          base03 = "#4c566a", base04 = "#d8dee9", base05 = "#e5e9f0",
          base06 = "#eceff4", base07 = "#8fbcbb", base08 = "#bf616a",
          base09 = "#d08770", base0A = "#ebcb8b", base0B = "#a3be8c",
          base0C = "#88c0d0", base0D = "#81a1c1", base0E = "#b48ead",
          base0F = "#5e81ac",
        },
      })
      
      
      require("base16-pro-max").setup({
        colors = {
          base00 = "#232136", base01 = "#2a273f", base02 = "#393552",
          base03 = "#6e6a86", base04 = "#908caa", base05 = "#e0def4",
          base06 = "#e0def4", base07 = "#56526e", base08 = "#eb6f92",
          base09 = "#f6c177", base0A = "#ea9a97", base0B = "#3e8fb0",
          base0C = "#9ccfd8", base0D = "#c4a7e7", base0E = "#f6c177",
          base0F = "#56526e",
        },
      })
      
      
      require("base16-pro-max").setup({
        colors = {
          base00 = "#24273a", base01 = "#1e2030", base02 = "#363a4f",
          base03 = "#494d64", base04 = "#5b6078", base05 = "#cad3f5",
          base06 = "#f4dbd6", base07 = "#b7bdf8", base08 = "#ed8796",
          base09 = "#f5a97f", base0A = "#eed49f", base0B = "#a6da95",
          base0C = "#8bd5ca", base0D = "#8aadf4", base0E = "#c6a0f6",
          base0F = "#f0c6c6",
        },
      })
      
      
      require("base16-pro-max").setup({
        -- Base16 colors (required)
        colors = {
          base00 = "#000000", -- Default background
          base01 = "#000000", -- Lighter background (status bars)
          base02 = "#000000", -- Selection background
          base03 = "#000000", -- Comments, line highlighting
          base04 = "#000000", -- Dark foreground (status bars)
          base05 = "#000000", -- Default foreground
          base06 = "#000000", -- Light foreground
          base07 = "#000000", -- Lightest foreground
          base08 = "#000000", -- Red (variables, errors)
          base09 = "#000000", -- Orange (integers, constants)
          base0A = "#000000", -- Yellow (classes, search)
          base0B = "#000000", -- Green (strings, success)
          base0C = "#000000", -- Cyan (support, regex)
          base0D = "#000000", -- Blue (functions, info)
          base0E = "#000000", -- Purple (keywords, changes)
          base0F = "#000000", -- Brown (deprecated)
        },
      
        -- Style options
        styles = {
          italic = false,                    -- Enable italic text
          bold = false,                      -- Enable bold text
          transparency = false,              -- Transparent background
          use_cterm = false,                 -- Use cterm colors
          dim_inactive_windows = false,      -- Dim inactive windows
          blends = {
            subtle = 10,                     -- Barely visible (10%)
            medium = 15,                     -- Noticeable (15%)
            strong = 25,                     -- Prominent (25%)
            super = 50,                      -- Very prominent (50%)
          },
        },
      
        -- Plugin integrations
        plugins = {
          enable_all = false,                -- Enable all supported plugins
        },
      
        -- Setup vim.g globals
        setup_globals = {
          terminal_colors = false,           -- Set terminal colors (`vim.g.terminal_color_*`)
          base16_gui_colors = false,         -- Set base16 gui colors (`vim.g.base16_gui*`)
        },
      
        -- Semantic color groups
        color_groups = {
          backgrounds = {
            normal = "bg",
            dim = "bg_dim",
            light = "bg_light",
            selection = "bg_light",
            cursor_line = function(function_refs) return function_refs.blend_fn(function_refs.colors.bg_light, function_refs.colors.bg, 0.6) end,
            cursor_column = function(function_refs) return function_refs.blend_fn(function_refs.colors.bg_dim, function_refs.colors.bg, 0.3) end,
          },
          foregrounds = {
            normal = "fg",
            dim = "fg_dim",
            dark = "fg_dark",
            light = "fg_light",
            bright = "fg_bright",
            comment = "fg_dark",
            line_number = function(function_refs) return function_refs.blend_fn(function_refs.colors.fg_dim, function_refs.colors.bg, 0.7) end,
            border = "fg_dim",
          },
          syntax = {
            variable = "fg",
            constant = "brown",
            string = "green",
            number = "orange",
            boolean = "orange",
            keyword = "purple",
            function_name = "blue",
            type = "yellow",
            comment = "fg_dark",
            operator = "cyan",
            delimiter = "fg_dark",
            deprecated = "brown",
          },
          states = {
            error = "red",
            warning = "yellow",
            info = "blue",
            hint = "cyan",
            success = "green",
          },
          diff = {
            added = "green",
            removed = "red",
            changed = "orange",
            text = "blue",
          },
          git = {
            added = "green",
            removed = "red",
            changed = "orange",
            untracked = "brown",
          },
          search = {
            match = "yellow",
            current = "orange",
            incremental = "orange",
          },
          markdown = {
            heading1 = "red",
            heading2 = "orange",
            heading3 = "yellow",
            heading4 = "green",
            heading5 = "cyan",
            heading6 = "blue",
          },
          modes = {
            normal = "blue",
            insert = "green",
            visual = "yellow",
            visual_line = "yellow",
            replace = "cyan",
            command = "red",
          },
        },
      
        -- Additional highlight groups
        highlight_groups = {},
      
        -- Pre-highlight callback
        before_highlight = nil,
      })
      
      
      local yaml_parser = require("base16-pro-max.parser")
      
      -- Option 1: Load from YAML file
      local colors = yaml_parser.get_base16_colors("~/schemes/gruvbox.yaml")
      
      -- Option 2: Mix YAML colors with manual overrides
      local colors = vim.tbl_extend("force",
        yaml_parser.get_base16_colors("~/schemes/base.yaml"),
        {
          base08 = "#ff0000", -- Override red
          base0B = "#00ff00", -- Override green
        }
      )
      
      -- Option 3: Conditional loading
      local colors = {}
      local condition = some_condition() -- e.g., vim.fn.filereadable
      if condition then
        colors = yaml_parser.get_base16_colors("~/schemes/custom.yaml")
      else
        -- Fallback to manual colors
        colors = {
          base00 = "#1f1f28", base01 = "#2a2a37", -- ...
        }
      end
      
      require("base16-pro-max").setup({ colors = colors })
      
      
      require("base16-pro-max").setup({
        colors = { --[[ your base16 colors ]] },
        color_groups = {
          syntax = {
            -- Use a different color for functions
            function_name = "cyan", -- Use semantic alias
            operator = "base0A",    -- Use raw base16 color
            -- Use a custom function for comments
            -- Using function, you can access the raw colors and blend functions
            -- `function_refs.colors` -> semantic color palette
            -- `function_refs.blend_fn` -> blend colors function
            --
            -- NOTE: To understand more, refer to the source code on how these are being used for color_groups
            comment = function(function_refs)
              return function_refs.blend_fn(function_refs.colors.fg_dim, function_refs.colors.bg, 0.8)
            end,
          },
        },
      })
      
      
      -- Table format
      -- In table format, you can use the semantic aliases and apply anything from `vim.api.keyset.highlight`
      require("base16-pro-max").setup({
        colors = { --[[ your base16 colors ]] },
        highlight_groups = {
          -- Custom highlight using base16 colors
          MyCustomHighlight = {
            fg = "red",          -- Use semantic alias
            bg = "base01",       -- Use raw base16 color
            bold = true,
          },
          -- Link to existing highlight
          MyOtherHighlight = { link = "Function" },
        },
      })
      
      
      -- Function format
      -- In function format, you have more access to the raw functions
      -- `function_refs.get_group_color_fn` -> get colors from color groups
      -- `function_refs.get_bg_fn` -> get background color (or transparent)
      -- `function_refs.blend_fn` -> blend colors
      -- `function_refs.styles_config` -> styles configuration
      -- `function_refs.colors` -> semantic color palette
      --
      -- NOTE: To understand more, refer to the source code on how these are being used to apply highlights in a consistent
      -- way
      require("base16-pro-max").setup({
        colors = { --[[ your base16 colors ]] },
        highlight_groups = function(function_refs)
          return {
            MyCustomHighlight = {
              fg = function_refs.get_group_color_fn("syntax", "function_name", function_refs.colors),
              bg = function_refs.get_bg_fn(function_refs.get_group_color_fn("backgrounds", "normal", function_refs.colors)),
              bold = function_refs.styles_config.bold,
            },
            MyOtherHighlight = { link = "Function" },
          }
        end,
      })
      
      
      -- Dark theme with transparency and italics
      require("base16-pro-max").setup({
        colors = { --[[ dark colors ]] },
        styles = {
          transparency = true,
          italic = true,
          bold = true,
          dim_inactive_windows = true,
        },
      })
      
      -- Light theme with subtle blends
      require("base16-pro-max").setup({
        colors = { --[[ light colors ]] },
        styles = {
          blends = {
            subtle = 5,
            medium = 10,
            strong = 15,
            super = 25,
          },
        },
      })
      
      
      require("base16-pro-max").setup({
        colors = { --[[ your colors ]] },
        plugins = {
          -- Enable all supported plugins
          enable_all = true,
          -- Or enable specific plugins
          nvim_mini_mini_icons = true,
          saghen_blink_cmp = true,
          folke_which_key_nvim = true,
        },
      })
      
      
      local base16_pro_max = require("base16-pro-max")
      local yaml_parser = require("base16-pro-max.parser")
      
      -- Setup the plugin (required)
      base16_pro_max.setup(config)
      
      -- Apply the colorscheme
      vim.cmd.colorscheme("base16-pro-max")
      
      -- Get semantic color palette
      local colors = base16_pro_max.colors()
      
      -- Get specific color
      local red = base16_pro_max.get_color("red")
      local bg = base16_pro_max.get_color("bg")
      
      -- Get multiple colors
      local palette = base16_pro_max.get_colors({"red", "blue", "green"})
      
      -- Get raw base16 colors
      local raw = base16_pro_max.raw_colors()
      
      -- Get color from groups
      local error_color = base16_pro_max.get_group_color("states", "error")
      
      -- Blend colors
      local blended = base16_pro_max.blend_colors("#ff0000", "#000000", 0.5)
      
      -- Validate colors
      local valid, missing = base16_pro_max.validate_colors(my_colors)
      
      -- YAML Parser API
      local colors = yaml_parser.get_base16_colors("path/to/scheme.yaml")
      yaml_parser.clear_cache()
      local stats = yaml_parser.get_cache_stats()
      
    end,
  },
  {
    "ellisonleao/gruvbox.nvim",
    config = function()
      
      use { "ellisonleao/gruvbox.nvim" }
      
      
      { "ellisonleao/gruvbox.nvim", priority = 1000 , config = true, opts = ...}
      
      
      vim.o.background = "dark" -- or "light" for light mode
      vim.cmd([[colorscheme gruvbox]])
      
      
      -- Default options:
      require("gruvbox").setup({
        terminal_colors = true, -- add neovim terminal colors
        undercurl = true,
        underline = true,
        bold = true,
        italic = {
          strings = true,
          emphasis = true,
          comments = true,
          operators = false,
          folds = true,
        },
        strikethrough = true,
        invert_selection = false,
        invert_signs = false,
        invert_tabline = false,
        inverse = true, -- invert background for search, diffs, statuslines and errors
        contrast = "", -- can be "hard", "soft" or empty string
        palette_overrides = {},
        overrides = {},
        dim_inactive = false,
        transparent_mode = false,
      })
      vim.cmd("colorscheme gruvbox")
      
      
      require("gruvbox").setup({
          palette_overrides = {
              bright_green = "#990000",
          }
      })
      vim.cmd("colorscheme gruvbox")
      
      
      require("gruvbox").setup({
          overrides = {
              SignColumn = {bg = "#ff9900"}
          }
      })
      vim.cmd("colorscheme gruvbox")
      
      
      require("gruvbox").setup({
          overrides = {
              ["@lsp.type.method"] = { bg = "#ff9900" },
              ["@comment.lua"] = { bg = "#000000" },
          }
      })
      vim.cmd("colorscheme gruvbox")
      
    end,
  },
  {
    "metalelf0/jellybeans-nvim",
  },
  {
    "lalitmee/cobalt2.nvim",
    config = function()
      
      {
          "lalitmee/cobalt2.nvim",
          event = { "ColorSchemePre" }, -- if you want to lazy load
          dependencies = { "tjdevries/colorbuddy.nvim", tag = "v1.0.0" },
          init = function()
              require("colorbuddy").colorscheme("cobalt2")
          end,
      },
      
      
      use {
          'lalitmee/cobalt2.nvim',
          requires = 'tjdevries/colorbuddy.nvim'
      }
      
      
      require('colorbuddy').colorscheme('cobalt2')
      
    end,
  },
  {
    "calind/selenized.nvim",
    config = function()
      
      { "calind/selenized.nvim" }
      
      
      use { "calind/selenized.nvim" }
      
      
      vim.cmd.colorscheme "selenized"
      
    end,
  },
  {
    "tjdevries/colorbuddy.nvim",
    config = function()
      
      -- Lua
      {
        "tjdevries/colorbuddy.nvim",
      }
      
      
      use "tjdevries/colorbuddy.nvim"
      
      
      vim.cmd.colorscheme("colorbuddy")
      -- or
      vim.cmd.colorscheme("gruvbuddy")
      
      
      -- file: colors/my-colorscheme-name.lua
      
      local colorbuddy = require('colorbuddy')
      
      -- Set up your custom colorscheme if you want
      colorbuddy.colorscheme("my-colorscheme-name")
      
      -- And then modify as you like
      local Color = colorbuddy.Color
      local colors = colorbuddy.colors
      local Group = colorbuddy.Group
      local groups = colorbuddy.groups
      local styles = colorbuddy.styles
      
      -- Use Color.new(<name>, <#rrggbb>) to create new colors
      -- They can be accessed through colors.<name>
      Color.new('background',  '#282c34')
      Color.new('red',         '#cc6666')
      Color.new('green',       '#99cc99')
      Color.new('yellow',      '#f0c674')
      
      -- Define highlights in terms of `colors` and `groups`
      Group.new('Function'        , colors.yellow      , colors.background , styles.bold)
      Group.new('luaFunctionCall' , groups.Function    , groups.Function   , groups.Function)
      
      -- Define highlights in relative terms of other colors
      Group.new('Error'           , colors.red:light() , nil               , styles.bold)
      
      -- If you want multiple styles, just add them!
      Group.new('italicBoldFunction', colors.green, groups.Function, styles.bold + styles.italic)
      
      -- If you want the same style as a different group, but without a style: just subtract it!
      Group.new('boldFunction', colors.yellow, colors.background, groups.italicBoldFunction - styles.italic)
      
    end,
  },
  {
    "norcalli/nvim-base16.lua",
    config = function()
      
      local theme_names = base16.theme_names()
      base16_position = 1
      function cycle_theme()
        base16_position = (base16_position % #theme_names) + 1
        base16(base16.themes[theme_names[base16_position]], true)
      end
      
      
      lua << EOF
      local base16 = require 'base16'
      base16(base16.themes.brewer, true)
      EOF
      
      
      lua << EOF
      nvim = require 'nvim'
      local base16 = require 'base16'
      base16(base16.themes[nvim.env.BASE16_THEME or "3024"], true)
      EOF
      
      
      base16(base16.themes["brewer"], true)
      
      
      print(vim.inspect(base16.theme_names()))
      
      
      local theme = base16.theme_from_array {
      	"383838"; "404040"; "606060"; "6f6f6f";
      	"808080"; "dcdccc"; "c0c0c0"; "ffffff";
      	"dca3a3"; "dfaf8f"; "e0cf9f"; "5f7f5f";
      	"93e0e3"; "7cb8bb"; "dc8cc3"; "000000";
      }
      base16(theme, true)
      
      
      base16.themes["zenburn"] == {
      	base00 = "383838"; base01 = "404040"; base02 = "606060"; base03 = "6f6f6f";
      	base04 = "808080"; base05 = "dcdccc"; base06 = "c0c0c0"; base07 = "ffffff";
      	base08 = "dca3a3"; base09 = "dfaf8f"; base0A = "e0cf9f"; base0B = "5f7f5f";
      	base0C = "93e0e3"; base0D = "7cb8bb"; base0E = "dc8cc3"; base0F = "000000";
      }
      
    end,
  },
  {
    "rktjmp/lush.nvim",
    config = function()
      
      return {
          "rktjmp/lush.nvim",
          -- if you wish to use your own colorscheme:
          -- { dir = '/absolute/path/to/colorscheme', lazy = true },
      }
      
    end,
  },
  {
    "roobert/palette.nvim",
    config = function()
      
      {
        "roobert/palette.nvim",
        lazy = false,
        priority = 1000,
        config = function()
          require("palette").setup({
            palettes = {
              main = "custom_main_palette",
              accent = "custom_accent_palette",
              state = "custom_state_palette",
            },
      
            custom_palettes = {
              main = {
                custom_main_palette = {
                  color0 = "#191d33",
                  color1 = "#1A1E39",
                  color2 = "#383f5e",
                  color3 = "#4e5470",
                  color4 = "#7b7f94",
                  color5 = "#a7a9b7",
                  color6 = "#bdbfc9",
                  color7 = "#d3d4db",
                  color8 = "#e9e9ed",
                },
              },
              accent = {
                custom_accent_palette = {
                  accent0 = "#D97C8F",
                  accent1 = "#D9AE7E",
                  accent2 = "#D9D87E",
                  accent3 = "#A5D9A7",
                  accent4 = "#8BB9C8",
                  accent5 = "#C9A1D3",
                  accent6 = "#B8A1D9",
                },
              },
              state = {
                custom_state_palette = {
                  error = "#D97C8F",
                  warning = "#D9AE7E",
                  hint = "#D9D87E",
                  ok = "#A5D9A7",
                  info = "#8BB9C8",
                },
              },
            },
          })
      
          vim.cmd([[colorscheme palette]])
        end,
      },
      
      
      {
        'roobert/palette.nvim',
        lazy = false,
        priority = 1000,
        config = function()
          vim.cmd("colorscheme palette")
        end
      }
      
      
      {
        "roobert/palette.nvim",
        lazy = false,
        priority = 1000,
        config = function()
          require("palette").setup({
            palettes = {
              -- dark or light
              main = "light",
      
              -- pastel, bright or dark
              accent = "dark",
              state = "dark",
            },
      
            italics = true,
            transparent_background = false,
          })
        end,
      },
      
      
      {
        "roobert/palette.nvim",
        lazy = false,
        priority = 1000,
        config = function()
          require("palette").setup({
            palettes = {
              main = "dust_dusk",
            },
      
            italics = true,
            transparent_background = false,
      
            custom_palettes = {
              main = {
                -- dusk theme taken from roobert/dust.nvim
                dust_dusk = {
                  color0 = "#121527",
                  color1 = "#1A1E39",
                  color2 = "#232A4D",
                  color3 = "#3E4D89",
                  color4 = "#687BBA",
                  color5 = "#A4B1D6",
                  color6 = "#bdbfc9",
                  color7 = "#DFE5F1",
                  color8 = "#e9e9ed",
                }
              },
              accent = {},
              state = {},
            }
          })
      
          vim.cmd([[colorscheme palette]])
        end,
      },
      
      
      {
        "roobert/palette.nvim",
        lazy = false,
        priority = 1000,
        config = function()
          require("palette").setup({
            palettes = {
              main = "team_zissou",
              accent = "pastel",
              state = "pastel",
            },
      
            custom_palettes = {
              main = {
                -- a blue theme, based off the built-in dark palette
                team_zissou = vim.tbl_extend(
                  "force",
                  require("palette.generator").generate_colors(
                    require("palette.colors").main["dark"],
                    "#04213b"
                  ),
                  {
                    -- override background and cursor-line
                    color0 = "#191d33",
                    color1 = "#1A1E39",
                    -- override most prominent colors (strings, etc.)
                    color7 = "#e9e9ed",
                    color8 = "#d3d4db",
                  }
                ),
              },
            }
          })
      
          vim.cmd([[colorscheme palette]])
        end,
      },
      
      
      {
          "roobert/palette.nvim",
          lazy = false,
          priority = 1000,
          config = function()
              -- Reference the dark palette
              local dark_palette = require("palette.colors").main["dark"]
      
              -- Lighten the cursor-line
              dark_palette.color1 = require("palette.utils").lighten(dark_palette["color1"])
      
              require("palette").setup({
                palettes = {
                  -- Reference the custom theme
                  main = "custom_lighter_cursorline",
                },
                custom_palettes = {
                  main = {
                    -- Create a custom theme
                    custom_lighter_cursorline = dark_palette,
                  }
                },
              })
      
              vim.cmd([[colorscheme palette]])
          end,
      }
      
      
      {
        "roobert/palette.nvim",
        lazy = false,
        priority = 1000,
        config = function()
          -- alias so we can easily reference theme colors
          a = require("palette.theme").accent
      
          require("palette").setup({
            -- custom highlight groups can override any highlight groups
            custom_highlight_group = "group_name",
            custom_highlight_groups = {
              group_name = {
                -- add one table per override:
                {
                  -- highlight group, or nil
                  "Normal",
                  -- foreground, or nil
                  a.accent0,
                  -- background, or nil
                  "#00ff00",
                  -- style(s) to apply, or nil
                  { "italic", "underline", "bold" },
                },
              }
            }
          })
      
          vim.cmd([[colorscheme palette]])
        end,
      },
      
      
      {
        "roobert/palette.nvim",
        lazy = false,
        priority = 1000,
        config = function()
          require("palette").setup({})
      
          vim.cmd([[colorscheme palette]])
      
          -- example of specific highlight group override..
          vim.cmd([[highlight Normal guifg="#ff0000"]])
      
          -- example of specific highlight group override using palette color
          a = require("palette.theme").accent
          vim.cmd([[highlight Normal guifg=a.accent0]])
        end,
      },
      
      
      {
        "roobert/palette.nvim",
        lazy = false,
        priority = 1000,
        config = function()
          require("palette").setup({
            caching = true,
            -- typically: ~/.cache/nvim/palette/
            cache_dir = vim.fn.stdpath("cache") .. "/palette",
          })
      
          vim.cmd([[colorscheme palette]])
        end,
      },
      
      
      {
        "roobert/palette.nvim",
        lazy = false,
        priority = 1000,
        config = function()
          require("palette").setup({
            palettes = {
              -- built in colorscheme: grey
              main = "dust_dusk",
              -- built in accents: pastel, bright, dark
              accent = "pastel",
              state = "pastel",
            },
      
            italics = true,
            transparent_background = false,
      
            custom_palettes = {
              main = {
                dust_dusk = {
                  color0 = "#121527",
                  color1 = "#1A1E39",
                  color2 = "#232A4D",
                  color3 = "#3E4D89",
                  color4 = "#687BBA",
                  color5 = "#A4B1D6",
                  color6 = "#bdbfc9",
                  color7 = "#DFE5F1",
                  color8 = "#e9e9ed",
                },
              },
            },
            accent = {},
            state = {},
          })
      
          vim.cmd([[colorscheme palette]])
        end,
      },
      
      
      {
        "username/colorscheme_name.nvim",
        lazy = false,
        priority = 1000,
        config = function()
          vim.cmd([[colorscheme colorscheme_name]])
        end,
      },
      
      
      :lua print(vim.inspect(require("palette.theme")))
      
    end,
  },
  {
    "Iron-E/nvim-highlite",
    config = function()
      
      local install_path = vim.fn.stdpath('data') .. '/lazy/lazy.nvim'
      if not vim.loop.fs_stat(install_path) then
        vim.fn.system {
          'git', 'clone', '--filter=blob:none',
          'https://github.com/folke/lazy.nvim.git', '--branch=stable',
          install_path
        }
      end
      
      vim.opt.rtp:prepend(install_path)
      require('lazy').setup {
        {'folke/lazy.nvim', tag = 'stable'},
        {'Iron-E/nvim-highlite',
          config = function()
            vim.opt.termguicolors = true -- optional
            vim.api.nvim_command 'colorscheme highlite'
          end,
          lazy = false,
          priority = 1000,
          version = '^2.0',
        },
      }
      
      
        -- packer.nvim example
        local install_path = vim.fn.stdpath('data')..'/site/pack/packer/opt/packer.nvim'
      
        if not vim.loop.fs_stat(vim.fn.glob(install_path)) then
          vim.fn.system {'git', 'clone', 'https://github.com/wbthomason/packer.nvim', install_path}
        end
      
        vim.api.nvim_command 'packadd packer.nvim'
      
        return require('packer').startup {function(use)
          use {'wbthomason/packer.nvim', opt = true}
          use 'Iron-E/nvim-highlite'
        end}
        
      
        vim.opt.termguicolors = true
        vim.api.nvim_command 'colorscheme highlite'
        
      
      -- Import nvim-highlite
      local highlite = require('highlite')
      
      -- First, define some colors
      local red = {'#FF0000', 1, 'red'}
      local black = {'#000000', 0, 'black'}
      local white = {'#FFFFFF', 255, 'white'}
      
      -- Highlight 'Identifier'
      highlite.highlight('Identifier', {bg = red, fg = black, style = 'bold'})
      
      -- Highlight 'Function' conditionally according to background color.
      highlite.highlight('Function', {bg = black, fg = red, light = {bg = white}})
      
      -- Link 'Example' to 'Identifier'
      highlite.highlight('Example', 'Identifier')
      
      -- You can also reference specific attributes of another highlight group.
      highlite.highlight('AnotherExample', {bg = highlite.group'SpellBad'.bg, fg = white})
      
      
      -- First, define some colors
      local red = {'#FF0000', 1, 'red'}
      local black = {'#000000', 0, 'black'}
      local white = {'#FFFFFF', 255, 'white'}
      
      -- Next define some highlight groups.
      local highlight_groups = {
        -- Any field which can be set to "NONE" doesn't need to be set, it will be automatically assumed to be "NONE".
        Identifier = {bg = red, fg = black, style = 'bold'},
        -- If your colorscheme should respond to multiple background settings, you can do that too:
        Function = {bg = black, fg = red, light = {bg = white}},
        --[[ Note that light/dark differentiation is completely optional. ]]
      
        -- You can also reference specific attributes of another highlight group.
        SomethingElse = function(self) return {fg = self.Identifier.fg, bg = self.Function.bg} end,
      }
      
      -- The rest is mostly handled by the template.
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-base16.md",
  },
  {
    "ThemerCorp/themer.lua",
    config = function()
      
          use({
              "themercorp/themer.lua",
              config = function()
      	      require("themer").setup({
      	          colorscheme = "rose_pine",
      	          styles = {
      	            	["function"] = { style = 'italic' },
      	             	functionbuiltin = { style = 'italic' },
      	             	variable = { style = 'italic' },
      	              	variableBuiltIn = { style = 'italic' },
      	            	parameter  = { style = 'italic' },
      	          },
      	      })
              end
          })
      
      
      {
          colorscheme = "rose_pine", -- default colorscheme
          transparent = false,
          term_colors = true,
          dim_inactive = false,
          disable_telescope_themes = {},
          styles = {
              heading = {
                  h1 = {},
                  h2 = {},
              },
              ["function"] = {},
              functionBuiltIn = {},
              variable = {},
              variableBuiltIn = {},
              include = {},
              identifier = {},
              keyword = {},
              keywordBuiltIn = {},
              struct = {},
              string = {},
              parameter = {},
              field = {},
              type = {},
              typeBuiltIn = {},
              property = {},
              comment = {},
              punctuation = {},
              constructor = {},
              operator = {},
              constant = {},
              constantBuiltIn = {},
              todo = {},
              character = {},
              conditional = {},
              number = {},
              statement = {},
              uri = {},
              diagnostic = {
                  underline = {
                      error = {},
                      warn = {},
                      info = {},
                      hint = {},
                  },
                  virtual_text = {
                      error = {},
                      warn = {},
                      info = {},
                      hint = {},
                  },
              },
          },
          remaps = {
              palette = {},
              -- per colorscheme palette remaps, for example:
              -- remaps.palette = {
              --     rose_pine = {
              --     	fg = "#000000"
              --     }
              -- },
              -- remaps.highlights = {
              --     rose_pine = {
      	      --	base = {
              --     	  Normal = { bg = "#000000" }
             	--	},
             	--     }
              -- },
              --
              -- Also you can do remaps.highlights.globals  for global highlight remaps
              highlights = {},
          },
      
          langs = {
              html = true,
              md = true,
          },
      
          plugins = {
              treesitter = true,
              indentline = true,
              barbar = true,
              bufferline = true,
              cmp = true,
              gitsigns = true,
              lsp = true,
              telescope = true,
          },
          enable_installer = false, -- enable installer module
      }
      
      
      require("themer").setup({ enable_installer = true })
      
      
      require("themer.modules.core.api").get_cp("catppuccin")
      
      
      -- Generated by Themer
      return {
        ["cursorlinenr"] = "#ff9e3b",
        ["dimmed"] = { ["inactive"] = "#54546d", ["subtle"] = "#727169" },
        ["built_in"] = {
          ["function"] = "#7fb4ca",
          ["constant"] = "#7fb4ca",
          ["keyword"] = "#957fb8",
          ["variable"] = "#e46876",
          ["type"] = "#7aa89f",
        },
        ["gitsigns"] = { ["remove"] = "#c34043", ["add"] = "#76946a", ["change"] = "#dca561" },
        ["pum"] = {
          ["sbar"] = "#223249",
          ["sel"] = { ["fg"] = "#0", ["bg"] = "#2d4f67" },
          ["fg"] = "#dcd7ba",
          ["bg"] = "#223249",
          ["thumb"] = "#2d4f67",
        },
        ["heading"] = { ["h1"] = "#7e9cd8", ["h2"] = "#0" },
        ["uri"] = "#7fb4ca",
        ["inc_search"] = { ["fg"] = "#223249", ["bg"] = "#ff9e3b" },
        ["syntax"] = {
          ["tag"] = "#957fb8",
          ["constant"] = "#ffa066",
          ["preproc"] = "#ffa066",
          ["string"] = "#98bb6c",
          ["parameter"] = "#e6c384",
          ["field"] = "#e6c384",
          ["variable"] = "#0",
          ["number"] = "#d27e99",
          ["statement"] = "#957fb8",
          ["todo"] = { ["fg"] = "#658594", ["bg"] = "#223249" },
          ["function"] = "#7e9cd8",
          ["punctuation"] = "#9cabca",
          ["struct"] = "#7aa89f",
          ["operator"] = "#c0a36e",
          ["conditional"] = "#957fb8",
          ["type"] = "#7aa89f",
          ["comment"] = "#727169",
          ["keyword"] = "#957fb8",
          ["property"] = "#e6c384",
          ["constructor"] = "#957fb8",
          ["include"] = "#ffa066",
        },
        ["border"] = "#54546d",
        ["fg"] = "#dcd7ba",
        ["match"] = "#7e9cd8",
        ["diagnostic"] = { ["warn"] = "#ff9e3b", ["info"] = "#658594", ["error"] = "#e82424", ["hint"] = "#6a9589" },
        ["bg"] = { ["alt"] = "#16161d", ["selected"] = "#363646", ["base"] = "#1f1f28" },
        ["diff"] = { ["text"] = "#49443c", ["remove"] = "#43242b", ["add"] = "#2b3328", ["change"] = "#252535" },
        ["accent"] = "#7fb4ca",
        ["search_result"] = { ["fg"] = "#dcd7ba", ["bg"] = "#2d4f67", ["telescope"] = "#7fb4ca" },
      }
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-colors.md",
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-hues.md",
  },
  {
    "loganswartz/polychrome.nvim",
    config = function()
      
      -- colors/your_theme.lua
      
      local Colorscheme = require('polychrome').Colorscheme
      
      Colorscheme.define('your_theme', function ()
          Normal { fg = rgb(150, 150, 219), bg = rgb(20, 20, 20) }
          Comment { fg = rgb(135, 135, 135) }
          Conceal { fg = rgb(222, 222, 222), bg = Comment.fg }
          Cursor { Reverse }
          Directory { fg = '#00ffff' }
          SpellBad { Undercurl }
          Error { fg = 'red' }
          Todo { Error, Standout, Underdouble, Italic }
      
          Constant { fg = rgb(0, 255, 255) }
          Boolean { Constant }
          _'@string.escape' { Constant }
          _'@number' { Constant }
      end):apply()
      
      
      local Colorscheme = require('polychrome').Colorscheme
      
      -- replace `your_theme` with the name of your colorscheme
      Colorscheme.define('your_theme', function ()
          -- Normal { }
          -- Comment { }
      
          -- ...many other highlight groups
      end)
      
      
          -- most groups can be specified like this
          Constant { fg = rgb(0, 255, 0), bg = '#ff0000' }
      
          -- specify a GUI feature
          Underline { underline = true }
      
          -- link a group to another one (equivalent to `:hi link Boolean Constant`)
          Boolean { Constant }
      
          -- groups that use `@` or other special characters (ex. treesitter groups)
          -- need a slightly different syntax: _'<name>' instead of <name>
          _'@punctuation.delimiter' { fg = rgb(0, 255, 0), bg = oklch(0, 0, 0) }
      
      
      -- your_theme/lua/your_theme/highlights.lua
      local Colorscheme = require('polychrome').Colorscheme
      
      local theme = Colorscheme.define('your_theme', function ()
          -- Normal { fg = rgb(150, 150, 219), bg = rgb(20, 20, 20) }
      end)
      
      return theme
      
      
      -- your_theme/lua/your_theme/palette.lua
      
      local rgb = require('polychrome.color.rgb')
      
      local palette = {
          red = rgb(255, 0, 0),
          green = rgb(0, 255, 0),
          blue = rgb(0, 0, 255),
      }
      
      return palette
      
      
      -- your_theme/lua/your_theme/init.lua
      
      local theme = require('your_theme.highlights')
      
      return theme
      
      
      -- your_theme/colors/your_theme.lua
      
      local theme = require('your_theme')
      -- or
      -- local theme = require('your_theme.highlights')
      
      theme:apply()
      
      
      {
          'you/your_theme',
          dependencies = {
              'loganswartz/polychrome.nvim'
          },
      }
      
      
          Strikethrough { strikethrough = true }
          Underline { underline = true }
          Underdouble { underdouble = true }
          Undercurl { undercurl = true }
          Underdotted { underdotted = true }
          Underdashed { underdashed = true }
          Reverse { reverse = true }
          Standout { standout = true }
          Bold { bold = true }
          Italic { italic = true }
      
      
          SpellBad { Underdotted }
          SpellCap { underdashed = Underdashed.underdashed }
      
      
      Colorscheme.define('your_theme', function (_)
          ...
      end, { inject_gui_groups = false })
      
    end,
  },
  {
    "flashcodes-themayankjha/fkthemes.nvim",
    config = function()
      
      {
        "flashcodes-themayankjha/Fkthemes.nvim",
        event = "VeryLazy",
        dependencies = {
          "MunifTanjim/nui.nvim",
          "nvim-telescope/telescope.nvim",
          -- Add your themes here
        },
        config = function()
          require("fkthemes").setup({
            themes = { "tokyonight", "catppuccin", "gruvbox" },
            default_theme = "tokyonight",
            transparent_background = true,
          })
        end,
      }
      
      
      {
        transparent_background = false, -- Transparent UI
        themes = {
          "tokyonight",
          "catppuccin",
          "gruvbox",
          "rose-pine",
          "material",
          "moonlight",
        },
        default_theme = "tokyonight",
        keymaps = {
          enable = true, -- Disable to remove default keymaps
          open_picker = {
            lhs = "<leader>tp",
            rhs = "<cmd>FkThemePicker<cr>",
            mode = "n",
            desc = "Open Theme Picker",
          },
          next_theme = {
            lhs = "<leader>tn",
            rhs = "<cmd>FkThemeNext<cr>",
            mode = "n",
            desc = "Next Theme",
          },
        },
      }
      
      
      dependencies = {
        "nvim-telescope/telescope.nvim",
      
        -- Material
        "marko-cerovac/material.nvim",
      
        -- Tokyonight
        {
          "folke/tokyonight.nvim",
          config = function()
            require("tokyonight").setup({
              transparent = true,
              styles = {
                sidebars = "transparent",
                floats = "transparent",
              },
            })
          end,
        },
      
        -- Rose Pine
        { "rose-pine/neovim", name = "rose-pine" },
      
        -- Catppuccin
        {
          "catppuccin/nvim",
          name = "catppuccin",
          priority = 1000,
          config = function()
            require("catppuccin").setup({
              flavour = "mocha",
              transparent_background = true,
            })
          end,
        },
      
        -- Others
        "shaunsingh/moonlight.nvim",
        "morhetz/gruvbox",
      }
      
      
      require("fkthemes").setup({
        themes = { "catppuccin", "tokyonight", "dracula" },
      })
      
      
      require("fkthemes").setup({
        themes = {
          light = { "github_light", "solarized_light" },
          dark  = { "catppuccin", "tokyonight", "dracula" },
        },
      })
      
      -- Optional command
      vim.api.nvim_create_user_command("FkThemesLight", function()
        require("fkthemes").load_theme_set("light")
      end, { desc = "Load Light Themes" })
      
    end,
  },
  {
    "4e554c4c/darkman.nvim",
    config = function()
      
      {
        '4e554c4c/darkman.nvim',
        event = 'VimEnter',
        build = 'go build -o bin/darkman.nvim',
        opts = {
          -- configuration here
        },
      }
      
      
      {
        change_background = true,
        send_user_event = false,
        colorscheme = nil, -- can be { dark = "x", light = "y" }
      }
      
    end,
  },
  {
    "f-person/auto-dark-mode.nvim",
    config = function()
      
      -- Lua
      {
        "f-person/auto-dark-mode.nvim",
        opts = {
          -- your configuration comes here
          -- or leave it empty to use the default settings
          -- refer to the configuration section below
        }
      }
      
      
      {
          set_dark_mode = function()
              vim.api.nvim_set_option_value("background", "dark", {})
          end,
          set_light_mode = function()
              vim.api.nvim_set_option_value("background", "light", {})
          end,
          update_interval = 3000,
          fallback = "dark"
      }
      
    end,
  },
  {
    "zaldih/themery.nvim",
    config = function()
      
      return {
          "zaldih/themery.nvim",
          lazy = false,
          config = function()
            require("themery").setup({
              -- add the config here
            })
          end
        }
      
      
      -- Minimal config
      require("themery").setup({
        themes = {"gruvbox", "ayu", ...}, -- Your list of installed colorschemes.
        livePreview = true, -- Apply theme while picking. Default to true.
      })
      
      
      -- Set custom name to the list
      require("themery").setup({
        themes = {{
          name = "Day",
          colorscheme = "kanagawa-lotus",
        },
        {
          name = "Night",
          colorscheme = "kanagawa-dragon",
        }},
      })
      
      
      -- Using before and after.
      require("themery").setup({
        themes = {{
          name = "Gruvbox dark",
          colorscheme = "gruvbox",
          before = [[
            -- All this block will be executed before apply "set colorscheme"
            vim.opt.background = "dark"
          ]],
        },
        {
          name = "Gruvbox light",
          colorscheme = "gruvbox",
          before = [[
            vim.opt.background = "light"
          ]],
          after = [[-- Same as before, but after if you need it]]
        }},
        [...]
      })
      
      
      require("themery").setup({
        themes = {{}},
        globalBefore = [[ -- Executed before each.]],
        globalAfter = [[ -- Executed after each. ]]
      })
      
      
      vim.keymap.set("n", "<leader>tt", function()
      	local themery = require("themery")
      	local currentTheme = themery.getCurrentTheme()
      	if currentTheme and currentTheme.name == "gruvbox light" then
      		themery.setThemeByName("gruvbox dark", true)
      	else
      		themery.setThemeByName("gruvbox light", true)
      	end
      end, { noremap = true })
      
    end,
  },
  {
    "linrongbin16/colorbox.nvim",
    config = function()
      
      require("colorbox").setup({
        policy = { seconds = 1, implement = "shuffle" },
        timing = "interval",
      })
      
      
      require('lazy').setup({
        {
          'linrongbin16/colorbox.nvim',
      
          -- don't lazy load
          lazy = false,
          -- load with highest priority
          priority = 1000,
      
          build = function() require("colorbox").update() end,
          config = function() require("colorbox").setup() end,
        }
      })
      
      
      require('pckr').add({
        {
          'linrongbin16/colorbox.nvim',
      
          run = function() require("colorbox").update() end,
          config = function() require("colorbox").setup() end,
        };
      })
      
      
      require("colorbox").setup(opts)
      
      
        function(color:string, spec:colorbox.ColorSpec):boolean
        
      
      require("colorbox").setup({
        background = "dark",
      })
      
      
      require("colorbox").setup({
        post_hook = function(color, spec)
          vim.notify(string.format("Colorscheme changed to: %s", vim.inspect(color)))
        end,
      })
      
      
      function(color:string, spec:colorbox.ColorSpec):nil
      
      
      require("colorbox").setup({
        policy = "single",
        timing = "startup",
      })
      
      
      require("colorbox").setup({
        policy = "shuffle",
        timing = "startup",
      })
      
      
      require("colorbox").setup({
        policy = { seconds = 1, implement = "shuffle" },
        timing = "interval",
      })
      
      
      require("colorbox").setup({
        timing = "filetype",
        policy = {
          mapping = {
            lua = "PaperColor",
            yaml = "everforest",
            markdown = "kanagawa",
            python = "iceberg",
          },
          empty = "tokyonight",
          fallback = "solarized8",
        },
      })
      
      
      require("colorbox").setup({
        filter = false,
      })
      
      
      require("colorbox").setup({
        filter = {
          "primary",
          function(color, spec)
            return spec.github_stars >= 1000
          end
        },
      })
      
      
      local function colorname_disabled(colorname)
        for _, c in ipairs({
          "iceberg",
          "ayu",
          "edge",
          "nord",
        }) do
          if string.lower(c) == string.lower(colorname) then
            return true
          end
        end
        return false
      end
      
      require("colorbox").setup({
        filter = function(color, spec)
          for _, c in ipairs(spec.color_names) do
            if colorname_disabled(c) then
              return false
            end
          end
          return true
        end
      })
      
      
      local function plugin_disabled(spec)
        for _, p in ipairs({
          "cocopon/iceberg.vim",
          "folke/tokyonight.nvim",
          "ayu-theme/ayu-vim",
          "shaunsingh/nord.nvim",
        }) do
          if string.lower(p) == string.lower(spec.handle) then
            return true
          end
        end
        return false
      end
      
      require("colorbox").setup({
        filter = function(color, spec)
          return not plugin_disabled(spec)
        end
      })
      
    end,
  },
  {
    "CWood-sdf/pineapple",
    config = function()
      
      {
          "CWood-sdf/pineapple",
          dependencies = require("YOUR_LUA_DIRECTORY.pineapple"),
          opts = {
              installedRegistry = "YOUR_LUA_DIRECTORY.pineapple",
              colorschemeFile = "after/plugin/theme.lua"
          },
          cmd = "Pineapple",
      }
      
      
      {
          colorschemeSet = function(scheme)
              return "vim.cmd('colorscheme " .. scheme .. "')\n lvim.colorscheme = '" .. scheme .. "'"
          end
      }
      
      
      require('telescope').load_extension('pineapple')
      require('telescope').extensions.pineapple.colorschemes()
      
      
      
      vim.api.nvim_create_autocmd("User", {
          pattern = "PineappleColorschemePost",
          callback = function(ev)
              print("The colorscheme was set to " .. ev.data[1])
          end,
      })
      
    end,
  },
  {
    "BrunoCiccarino/gardenal",
  },
  {
    "LmanTW/themify.nvim/tree/main",
  },
  {
    "nishu-murmu/ThemeSwitch.nvim",
    config = function()
      
      return {
          "nishu-murmu/ThemeSwitch.nvim"
      }
      
      
      require("ThemeSwitch")
      
      
      require("ThemeSwitch").setup({
          keymap = --your mappings
      })
      
    end,
  },
  {
    "Erl-koenig/theme-hub.nvim",
    config = function()
      
      {
          "erl-koenig/theme-hub.nvim",
          dependencies = {
              "nvim-lua/plenary.nvim",
              -- Optional: for themes that use lush (will be notified if a theme requires it)
              -- "rktjmp/lush.nvim"
          },
          config = function()
              require("theme-hub").setup({
                  -- Configuration options (see below)
              })
          end,
      }
      
      
      require("theme-hub").setup({
          install_dir = vim.fn.stdpath("data") .. "/theme-hub",
          auto_install_on_select = true,
          apply_after_install = true,
          persistent = false,
      })
      
      
      -- Add to your telescope dependencies
      dependencies = {
          "nvim-telescope/telescope-ui-select.nvim",
      }
      
      -- In your config call
      require("telescope").load_extension("ui-select")
      
      
      require("fzf-lua").register_ui_select({})
      
      
      vim.ui.select = MiniPick.ui_select
      
    end,
  },
  {
    "Bekaboo/deadcolumn.nvim",
    config = function()
      
          lua require('lazy').setup({
              { 'Bekaboo/deadcolumn.nvim' }
          })
          
      
          require('packer').startup(function(use)
              use 'Bekaboo/deadcolumn.nvim'
          end)
          
      
      local opts = {
          scope = 'line', ---@type string|fun(): integer
          ---@type string[]|boolean|fun(mode: string): boolean
          modes = function(mode)
              return mode:find('^[iRss\x13]') ~= nil
          end,
          blending = {
              threshold = 0.5,
              colorcode = '#000000',
              hlgroup = { 'Normal', 'bg' },
          },
          warning = {
              alpha = 0.4,
              offset = 0,
              colorcode = '#FF0000',
              hlgroup = { 'Error', 'bg' },
          },
          extra = {
              ---@type string?
              follow_tw = nil,
          },
      }
      
      require('deadcolumn').setup(opts) -- Call the setup function
      
      
              require('deadcolumn').setup({
                  scope = function()
                      local max = 0
                      for i = -50, 50 do
                          local len = vim.fn.strdisplaywidth(
                              vim.fn.getline(vim.fn.line('.') + i)
                          )
                          if len > max then
                              max = len
                          end
                      end
                      return max
                  end
              })
            
      
            require('deadcolumn').setup({
                -- Dynamically adjusts the colorcolumn behavior based on editing
                -- mode:
                -- 1. In insert/replace/selection mode: update the color gradually
                --    based on current line length
                -- 2. In other modes: update the color based on longest visible line,
                --    if there's any line that exceeds the colorcolumn limit, show
                --    the colorcolumn with warning color, else conceal the
                --    colorcolumn entirely
                scope = function()
                  if vim.fn.mode():find('^[iRss\x13]') ~= nil then
                    return vim.fn.strdisplaywidth(vim.fn.getline('.'))
                  end
      
                  -- Don't show in read-only buffers
                  if not vim.bo.ma or vim.bo.ro then
                    return 0
                  end
      
                  -- Find maximum length within visible range
                  local max_len = math.max(
                    unpack(
                      vim.tbl_map(
                        vim.fn.strdisplaywidth,
                        vim.api.nvim_buf_get_lines(
                          0,
                          vim.fn.line('w0') - 1,
                          vim.fn.line('w$'),
                          false
                        )
                      )
                    )
                  )
      
                  if max_len >= cc_resolve(vim.wo.cc) then
                    return max_len
                  end
                  return 0
                end,
            })
            
      
         require('deadcolumn').setup({
             blending = {
                 colorcode = '#1F2430',
                 hlgroup = { 'NonText', 'bg' },
             },
         })
         
    end,
  },
  {
    "ecthelionvi/NeoColumn.nvim",
    config = function()
      
      vim.keymap.set("n", "<leader>h", "<cmd>ToggleNeoColumn<cr>", { noremap = true, silent = true })
      
    end,
  },
  {
    "m4xshen/smartcolumn.nvim",
    config = function()
      
        custom_colorcolumn = function ()
           return "100"
        end
        
    end,
  },
  {
    "utilyre/barbecue.nvim",
    config = function()
      
        {
          "utilyre/barbecue.nvim",
          name = "barbecue",
          version = "*",
          dependencies = {
            "SmiteshP/nvim-navic",
            "nvim-tree/nvim-web-devicons", -- optional dependency
          },
          opts = {
            -- configurations go here
          },
        }
        
      
        use({
          "utilyre/barbecue.nvim",
          tag = "*",
          requires = {
            "SmiteshP/nvim-navic",
            "nvim-tree/nvim-web-devicons", -- optional dependency
          },
          after = "nvim-web-devicons", -- keep this if you're using NvChad
          config = function()
            require("barbecue").setup()
          end,
        })
        
      
        -- hide barbecue globally
        require("barbecue.ui").toggle(false)
      
        -- show barbecue globally
        require("barbecue.ui").toggle(true)
      
        -- toggle barbecue globally
        require("barbecue.ui").toggle()
        
      
        -- update the current window's winbar
        require("barbecue.ui").update()
      
        -- update the given window's winbar
        require("barbecue.ui").update(winnr)
        
      
        -- navigate to the second entry
        require("barbecue.ui").navigate(2)
      
        -- navigate to the last entry
        require("barbecue.ui").navigate(-1)
      
        -- just like before but on the given window
        require("barbecue.ui").navigate(index, winnr)
        
      
        -- triggers CursorHold event faster
        vim.opt.updatetime = 200
      
        require("barbecue").setup({
          create_autocmd = false, -- prevent barbecue from updating itself automatically
        })
      
        vim.api.nvim_create_autocmd({
          "WinScrolled", -- or WinResized on NVIM-v0.9 and higher
          "BufWinEnter",
          "CursorHold",
          "InsertLeave",
      
          -- include this if you have set `show_modified` to `true`
          "BufModifiedSet",
        }, {
          group = vim.api.nvim_create_augroup("barbecue.updater", {}),
          callback = function()
            require("barbecue.ui").update()
          end,
        })
        
      
        require("barbecue").setup({
          theme = {
            -- this highlight is used to override other highlights
            -- you can take advantage of its `bg` and set a background throughout your winbar
            -- (e.g. basename will look like this: { fg = "#c0caf5", bold = true })
            normal = { fg = "#c0caf5" },
      
            -- these highlights correspond to symbols table from config
            ellipsis = { fg = "#737aa2" },
            separator = { fg = "#737aa2" },
            modified = { fg = "#737aa2" },
      
            -- these highlights represent the _text_ of three main parts of barbecue
            dirname = { fg = "#737aa2" },
            basename = { bold = true },
            context = {},
      
            -- these highlights are used for context/navic icons
            context_file = { fg = "#ac8fe4" },
            context_module = { fg = "#ac8fe4" },
            context_namespace = { fg = "#ac8fe4" },
            context_package = { fg = "#ac8fe4" },
            context_class = { fg = "#ac8fe4" },
            context_method = { fg = "#ac8fe4" },
            context_property = { fg = "#ac8fe4" },
            context_field = { fg = "#ac8fe4" },
            context_constructor = { fg = "#ac8fe4" },
            context_enum = { fg = "#ac8fe4" },
            context_interface = { fg = "#ac8fe4" },
            context_function = { fg = "#ac8fe4" },
            context_variable = { fg = "#ac8fe4" },
            context_constant = { fg = "#ac8fe4" },
            context_string = { fg = "#ac8fe4" },
            context_number = { fg = "#ac8fe4" },
            context_boolean = { fg = "#ac8fe4" },
            context_array = { fg = "#ac8fe4" },
            context_object = { fg = "#ac8fe4" },
            context_key = { fg = "#ac8fe4" },
            context_null = { fg = "#ac8fe4" },
            context_enum_member = { fg = "#ac8fe4" },
            context_struct = { fg = "#ac8fe4" },
            context_event = { fg = "#ac8fe4" },
            context_operator = { fg = "#ac8fe4" },
            context_type_parameter = { fg = "#ac8fe4" },
          },
        })
        
      
        require("barbecue").setup({
          attach_navic = false, -- prevent barbecue from automatically attaching nvim-navic
        })
      
        require("lspconfig")[server].setup({
          -- ...
      
          on_attach = function(client, bufnr)
            -- ...
      
            if client.server_capabilities["documentSymbolProvider"] then
              require("nvim-navic").attach(client, bufnr)
            end
      
            -- ...
          end,
      
          -- ...
        })
        
      
      {
        ---Whether to attach navic to language servers automatically.
        ---
        ---@type boolean
        attach_navic = true,
      
        ---Whether to create winbar updater autocmd.
        ---
        ---@type boolean
        create_autocmd = true,
      
        ---Buftypes to enable winbar in.
        ---
        ---@type string[]
        include_buftypes = { "" },
      
        ---Filetypes not to enable winbar in.
        ---
        ---@type string[]
        exclude_filetypes = { "netrw", "toggleterm" },
      
        modifiers = {
          ---Filename modifiers applied to dirname.
          ---
          ---See: `:help filename-modifiers`
          ---
          ---@type string
          dirname = ":~:.",
      
          ---Filename modifiers applied to basename.
          ---
          ---See: `:help filename-modifiers`
          ---
          ---@type string
          basename = "",
        },
      
        ---Whether to display path to file.
        ---
        ---@type boolean
        show_dirname = true,
      
        ---Whether to display file name.
        ---
        ---@type boolean
        show_basename = true,
      
        ---Whether to replace file icon with the modified symbol when buffer is
        ---modified.
        ---
        ---@type boolean
        show_modified = false,
      
        ---Get modified status of file.
        ---
        ---NOTE: This can be used to get file modified status from SCM (e.g. git)
        ---
        ---@type fun(bufnr: number): boolean
        modified = function(bufnr) return vim.bo[bufnr].modified end,
      
        ---Whether to show/use navic in the winbar.
        ---
        ---@type boolean
        show_navic = true,
      
        ---Get leading custom section contents.
        ---
        ---NOTE: This function shouldn't do any expensive actions as it is run on each
        ---render.
        ---
        ---@type fun(bufnr: number, winnr: number): barbecue.Config.custom_section
        lead_custom_section = function() return " " end,
      
        ---@alias barbecue.Config.custom_section
        ---|string # Literal string.
        ---|{ [1]: string, [2]: string? }[] # List-like table of `[text, highlight?]` tuples in which `highlight` is optional.
        ---
        ---Get custom section contents.
        ---
        ---NOTE: This function shouldn't do any expensive actions as it is run on each
        ---render.
        ---
        ---@type fun(bufnr: number, winnr: number): barbecue.Config.custom_section
        custom_section = function() return " " end,
      
        ---@alias barbecue.Config.theme
        ---|'"auto"' # Use your current colorscheme's theme or generate a theme based on it.
        ---|string # Theme located under `barbecue.theme` module.
        ---|barbecue.Theme # Same as '"auto"' but override it with the given table.
        ---
        ---Theme to be used for generating highlight groups dynamically.
        ---
        ---@type barbecue.Config.theme
        theme = "auto",
      
        ---Whether context text should follow its icon's color.
        ---
        ---@type boolean
        context_follow_icon_color = false,
      
        symbols = {
          ---Modification indicator.
          ---
          ---@type string
          modified = "●",
      
          ---Truncation indicator.
          ---
          ---@type string
          ellipsis = "…",
      
          ---Entry separator.
          ---
          ---@type string
          separator = "",
        },
      
        ---@alias barbecue.Config.kinds
        ---|false # Disable kind icons.
        ---|table<string, string> # Type to icon mapping.
        ---
        ---Icons for different context entry kinds.
        ---
        ---@type barbecue.Config.kinds
        kinds = {
          File = "",
          Module = "",
          Namespace = "",
          Package = "",
          Class = "",
          Method = "",
          Property = "",
          Field = "",
          Constructor = "",
          Enum = "",
          Interface = "",
          Function = "",
          Variable = "",
          Constant = "",
          String = "",
          Number = "",
          Boolean = "",
          Array = "",
          Object = "",
          Key = "",
          Null = "",
          EnumMember = "",
          Struct = "",
          Event = "",
          Operator = "",
          TypeParameter = "",
        },
      }
      
    end,
  },
  {
    "Bekaboo/dropbar.nvim",
    config = function()
      
        require('lazy').setup({
          {
            'Bekaboo/dropbar.nvim',
            -- optional, but required for fuzzy finder support
            dependencies = {
              'nvim-telescope/telescope-fzf-native.nvim',
              build = 'make'
            },
            config = function()
              local dropbar_api = require('dropbar.api')
              vim.keymap.set('n', '<Leader>;', dropbar_api.pick, { desc = 'Pick symbols in winbar' })
              vim.keymap.set('n', '[;', dropbar_api.goto_context_start, { desc = 'Go to start of current context' })
              vim.keymap.set('n', '];', dropbar_api.select_next_context, { desc = 'Select next context' })
            end
          }
        })
        
      
        require('packer').startup(function(use)
          use({
            'Bekaboo/dropbar.nvim',
            requires = {
              'nvim-telescope/telescope-fzf-native.nvim',
              run = 'make'
            },
            config = function ()
              local dropbar_api = require('dropbar.api')
              vim.keymap.set('n', '<Leader>;', dropbar_api.pick, { desc = 'Pick symbols in winbar' })
              vim.keymap.set('n', '[;', dropbar_api.goto_context_start, { desc = 'Go to start of current context' })
              vim.keymap.set('n', '];', dropbar_api.select_next_context, { desc = 'Select next context' })
            end
          })
        end)
        
      
      vim.ui.select = require('dropbar.utils.menu').select
      
      
          function(buf, win, _)
            buf = vim._resolve_bufnr(buf)
            if
              not vim.api.nvim_buf_is_valid(buf)
              or not vim.api.nvim_win_is_valid(win)
            then
              return false
            end
      
            if
              not vim.api.nvim_buf_is_valid(buf)
              or not vim.api.nvim_win_is_valid(win)
              or vim.fn.win_gettype(win) ~= ''
              or vim.wo[win].winbar ~= ''
              or vim.bo[buf].ft == 'help'
            then
              return false
            end
      
            local stat = vim.uv.fs_stat(vim.api.nvim_buf_get_name(buf))
            if stat and stat.size > 1024 * 1024 then
              return false
            end
      
            return vim.bo[buf].ft == 'markdown'
              or pcall(vim.treesitter.get_parser, buf)
              or not vim.tbl_isempty(vim.lsp.get_clients({
                bufnr = buf,
                method = vim.lsp.protocol.Methods.textDocument_documentSymbol,
              }))
          end,
          
      
          {
            'TermOpen',
            'BufEnter',
            'BufWinEnter',
            'BufWritePost',
            'FileType',
            'LspAttach',
          }
          
      
          {
            'CursorMoved',
            'WinEnter',
            'WinResized',
          }
          
      
          {
            'BufModifiedSet',
            'FileChangedShellPost',
            'TextChanged',
            'ModeChanged',
          }
          
      
          {
            'DirChanged',
            'VimResized',
          }
          
      
          function(buf, _)
            local sources = require('dropbar.sources')
            local utils = require('dropbar.utils')
            if vim.bo[buf].ft == 'markdown' then
              return {
                sources.path,
                sources.markdown,
              }
            end
            if vim.bo[buf].buftype == 'terminal' then
              return {
                sources.terminal,
              }
            end
            return {
              sources.path,
              utils.source.fallback({
                sources.lsp,
                sources.treesitter,
              }),
            }
          end
          
      
          {
            ['q'] = '<C-w>q',
            ['<Esc>'] = '<C-w>q',
            ['<LeftMouse>'] = function()
              local menu = utils.menu.get_current()
              if not menu then
                return
              end
              local mouse = vim.fn.getmousepos()
              local clicked_menu = utils.menu.get({ win = mouse.winid })
              -- If clicked on a menu, invoke the corresponding click action,
              -- else close all menus and set the cursor to the clicked window
              if clicked_menu then
                clicked_menu:click_at({ mouse.line, mouse.column - 1 }, nil, 1, 'l')
                return
              end
              utils.menu.exec('close')
              utils.bar.exec('update_current_context_hl')
              if vim.api.nvim_win_is_valid(mouse.winid) then
                vim.api.nvim_set_current_win(mouse.winid)
              end
            end,
            ['<CR>'] = function()
              local menu = utils.menu.get_current()
              if not menu then
                return
              end
              local cursor = vim.api.nvim_win_get_cursor(menu.win)
              local component = menu.entries[cursor[1]]:first_clickable(cursor[2])
              if component then
                menu:click_on(component, nil, 1, 'l')
              end
            end,
            ['<MouseMove>'] = function()
              local menu = utils.menu.get_current()
              if not menu then
                return
              end
              local mouse = vim.fn.getmousepos()
              if M.opts.menu.hover then
                utils.menu.update_hover_hl(mouse)
              end
              if M.opts.menu.preview then
                utils.menu.update_preview(mouse)
              end
            end,
            ['i'] = function()
              local menu = utils.menu.get_current()
              if not menu then
                return
              end
              menu:fuzzy_find_open()
            end,
          },
          
      
          {
            enable = true,
            -- if false, only the scrollbar thumb will be shown
            background = true
          }
          
      
          {
            style = 'minimal',
            row = function(menu)
              return menu.prev_menu
                  and menu.prev_menu.clicked_at
                  and menu.prev_menu.clicked_at[1] - vim.fn.line('w0')
                or 0
            end,
            ---@param menu dropbar_menu_t
            col = function(menu)
              if menu.prev_menu then
                return menu.prev_menu._win_configs.width
                  + (menu.prev_menu.scrollbar and 1 or 0)
              end
              local mouse = vim.fn.getmousepos()
              local bar = require('dropbar.api').get_dropbar(
                vim.api.nvim_win_get_buf(menu.prev_win),
                menu.prev_win
              )
              if not bar then
                return mouse.wincol
              end
              local _, range = bar:get_component_at(math.max(0, mouse.wincol - 1))
              return range and range.start or mouse.wincol
            end,
            relative = 'win',
            win = function(menu)
              return menu.prev_menu and menu.prev_menu.win
                or vim.fn.getmousepos().winid
            end,
            height = function(menu)
              return math.max(
                1,
                math.min(
                  #menu.entries,
                  vim.go.pumheight ~= 0 and vim.go.pumheight
                    or math.ceil(vim.go.lines / 4)
                )
              )
            end,
            width = function(menu)
              local min_width = vim.go.pumwidth ~= 0 and vim.go.pumwidth or 8
              if vim.tbl_isempty(menu.entries) then
                return min_width
              end
              return math.max(
                min_width,
                math.max(unpack(vim.tbl_map(function(entry)
                  return entry:displaywidth()
                end, menu.entries)))
              )
            end,
            zindex = function(menu)
              if not menu.prev_menu then
                return
              end
              return menu.prev_menu.scrollbar
                  and menu.prev_menu.scrollbar.thumb
                  and vim.api.nvim_win_get_config(menu.prev_menu.scrollbar.thumb).zindex
                or vim.api.nvim_win_get_config(menu.prev_win).zindex
            end,
          }
          
      
          keymaps = {
            ['<LeftMouse>'] = function()
              ---@type dropbar_menu_t
              local menu = utils.menu.get_current()
              if not menu then
                return
              end
              local mouse = vim.fn.getmousepos()
              if not mouse then
                return
              end
              if mouse.winid ~= menu.win then
                local default_func = M.opts.menu.keymaps['<LeftMouse>']
                if type(default_func) == 'function' then
                  default_func()
                end
                menu:fuzzy_find_close(false)
                return
              elseif mouse.winrow > vim.api.nvim_buf_line_count(menu.buf) then
                return
              end
              vim.api.nvim_win_set_cursor(menu.win, { mouse.line, mouse.column - 1 })
              menu:fuzzy_find_click_on_entry(function(entry)
                return entry:get_component_at(mouse.column - 1, true)
              end)
            end,
            ['<MouseMove>'] = function()
              ---@type dropbar_menu_t
              local menu = utils.menu.get_current()
              if not menu then
                return
              end
              local mouse = vim.fn.getmousepos()
              if not mouse then
                return
              end
              -- If mouse is not in the menu window or on the border, end preview
              -- and clear hover highlights
              if
                mouse.winid ~= menu.win
                or mouse.line <= 0
                or mouse.column <= 0
                or mouse.winrow > #menu.entries
              then
                menu = menu:root() --[[@as dropbar_menu_t]]
                if menu then
                  menu:finish_preview(true)
                  if M.opts.menu.hover then
                    menu:update_hover_hl()
                  end
                end
                return
              end
              if M.opts.menu.preview then
                menu:preview_symbol_at({ mouse.line, mouse.column - 1 }, true)
              end
              if M.opts.menu.hover then
                menu:update_hover_hl({ mouse.line, mouse.column - 1 })
              end
            end,
            ['<Up>'] = api.fuzzy_find_prev,
            ['<Down>'] = api.fuzzy_find_next,
            ['<C-k>'] = api.fuzzy_find_prev,
            ['<C-j>'] = api.fuzzy_find_next,
            ['<C-p>'] = api.fuzzy_find_prev,
            ['<C-n>'] = api.fuzzy_find_next,
            ['<CR>'] = api.fuzzy_find_click,
            ['<S-Enter>'] = function()
              api.fuzzy_find_click(-1)
            end,
          }
          
      
          win_configs = {
            relative = 'win',
            anchor = 'NW',
            height = 1,
            win = function(menu)
              return menu.win
            end,
            width = function(menu)
              local function border_width(border)
                if not border then
                  border = vim.go.winborder
                end
      
                if type(border) == 'string' then
                  if border == '' or border == 'none' or border == 'shadow' then
                    return 0
                  end
                  return 2 -- left and right border
                end
      
                local left, right = 1, 1
                if
                  (#border == 1 and border[1] == '')
                  or (#border == 4 and border[4] == '')
                  or (#border == 8 and border[8] == '')
                then
                  left = 0
                end
                if
                  (#border == 1 and border[1] == '')
                  or (#border == 4 and border[4] == '')
                  or (#border == 8 and border[4] == '')
                then
                  right = 0
                end
                return left + right
              end
              local menu_width = menu._win_configs.width
                + border_width(menu._win_configs.border)
              local self_width = menu._win_configs.width
              local self_border = border_width(
                (
                  M.opts.fzf.win_configs
                  and M.eval(M.opts.fzf.win_configs.border, menu)
                )
                  or (menu.fzf_win_configs and M.eval(
                    menu.fzf_win_configs.border,
                    menu
                  ))
                  or menu._win_configs.border
              )
      
              if self_width + self_border > menu_width then
                return self_width - self_border
              else
                return menu_width - self_border
              end
            end,
            row = function(menu)
              local menu_border = menu._win_configs.border or vim.go.border
              if
                type(menu_border) == 'string'
                and menu_border ~= 'shadow'
                and menu_border ~= 'none'
                and menu_border ~= ''
              then
                return menu._win_configs.height + 1
              elseif menu_border == 'none' or menu_border == '' then
                return menu._win_configs.height
              end
              local len_menu_border = #menu_border
              if
                len_menu_border == 1 and menu_border[1] ~= ''
                or (len_menu_border == 2 or len_menu_border == 4) and menu_border[2] ~= ''
                or len_menu_border == 8 and menu_border[8] ~= ''
              then
                return menu._win_configs.height + 1
              else
                return menu._win_configs.height
              end
            end,
            col = function(menu)
              local menu_border = menu._win_configs.border or vim.go.border
              if
                type(menu_border) == 'string'
                and menu_border ~= 'shadow'
                and menu_border ~= 'none'
                and menu_border ~= ''
              then
                return -1
              end
              if
                type(menu_border) == 'table' and menu_border[#menu_border] ~= ''
              then
                return -1
              end
              return 0
            end,
          },
          
      
          prompt = '%#htmlTag# '
          
      
          char_pattern = '[%w%p]'
          
      
          retain_inner_spaces = true
          
      
          fuzzy_find_on_click = true
          
      
          function(_)
            return M.opts.icons.kinds.symbols.Folder, 'DropBarIconKindFolder'
          end
          
      
          function(path)
            local icon_kind_opts = M.opts.icons.kinds
            local file_icon = icon_kind_opts.symbols.File
            local file_icon_hl = 'DropBarIconKindFile'
            local devicons_ok, devicons = pcall(require, 'nvim-web-devicons')
            if not devicons_ok then
              return file_icon, file_icon_hl
            end
      
            -- Try to find icon using the filename, explicitly disable the
            -- default icon so that we can try to find the icon using the
            -- filetype if the filename does not have a corresponding icon
            local devicon, devicon_hl = devicons.get_icon(
              vim.fs.basename(path),
              vim.fn.fnamemodify(path, ':e'),
              { default = false }
            )
      
            -- No corresponding devicon found using the filename, try finding icon
            -- with filetype if the file is loaded as a buf in nvim
            if not devicon then
              ---@type integer?
              local buf = vim.iter(vim.api.nvim_list_bufs()):find(function(buf)
                return vim.api.nvim_buf_get_name(buf) == path
              end)
              if buf then
                local filetype =
                  vim.api.nvim_get_option_value('filetype', { buf = buf })
                devicon, devicon_hl = devicons.get_icon_by_filetype(filetype)
              end
            end
      
            file_icon = devicon and devicon .. ' ' or file_icon
            file_icon_hl = devicon_hl
      
            return file_icon, file_icon_hl
          end
          
      
          {
            Array = '󰅪 ',
            BlockMappingPair = '󰅩 ',
            Boolean = ' ',
            BreakStatement = '󰙧 ',
            Call = '󰃷 ',
            CaseStatement = '󱃙 ',
            Class = ' ',
            Color = '󰏘 ',
            Constant = '󰏿 ',
            Constructor = ' ',
            ContinueStatement = '→ ',
            Copilot = ' ',
            Declaration = '󰙠 ',
            Delete = '󰩺 ',
            DoStatement = '󰑖 ',
            Element = '󰅩 ',
            Enum = ' ',
            EnumMember = ' ',
            Event = ' ',
            Field = ' ',
            File = '󰈔 ',
            Folder = '󰉋 ',
            ForStatement = '󰑖 ',
            Function = '󰊕 ',
            GotoStatement = '󰁔 ',
            Identifier = '󰀫 ',
            IfStatement = '󰇉 ',
            Interface = ' ',
            Keyword = '󰌋 ',
            List = '󰅪 ',
            Log = '󰦪 ',
            Lsp = ' ',
            Macro = '󰁌 ',
            MarkdownH1 = '󰉫 ',
            MarkdownH2 = '󰉬 ',
            MarkdownH3 = '󰉭 ',
            MarkdownH4 = '󰉮 ',
            MarkdownH5 = '󰉯 ',
            MarkdownH6 = '󰉰 ',
            Method = '󰆧 ',
            Module = '󰏗 ',
            Namespace = '󰅩 ',
            Null = '󰢤 ',
            Number = '󰎠 ',
            Object = '󰅩 ',
            Operator = '󰆕 ',
            Package = '󰆦 ',
            Pair = '󰅪 ',
            Property = ' ',
            Reference = '󰦾 ',
            Regex = ' ',
            Repeat = '󰑖 ',
            Return = '󰌑 ',
            RuleSet = '󰅩 ',
            Scope = '󰅩 ',
            Section = '󰅩 ',
            Snippet = '󰩫 ',
            Specifier = '󰦪 ',
            Statement = '󰅩 ',
            String = '󰉾 ',
            Struct = ' ',
            SwitchStatement = '󰺟 ',
            Table = '󰅩 ',
            Terminal = ' ',
            Text = ' ',
            Type = ' ',
            TypeParameter = '󰆩 ',
            Unit = ' ',
            Value = '󰎠 ',
            Variable = '󰀫 ',
            WhileStatement = '󰑖 ',
      
          }
          
      
          {
            separator = ' ',
            extends = '…',
          }
          
      
          {
            separator = ' ',
            indicator = ' ',
          }
          
      
          function(symbol)
            -- Update current context highlights if the symbol
            -- is shown inside a menu
            if symbol.entry and symbol.entry.menu then
              symbol.entry.menu:update_current_context_hl(symbol.entry.idx)
            elseif symbol.bar then
              symbol.bar:update_current_context_hl(symbol.bar_idx)
            end
      
            -- Determine menu configs
            local prev_win = nil ---@type integer?
            local entries_source = nil ---@type dropbar_symbol_t[]?
            local init_cursor = nil ---@type integer[]?
            local win_configs = {}
            if symbol.bar then -- If symbol inside a dropbar
              prev_win = symbol.bar.win
              entries_source = symbol.opts.siblings
              init_cursor = symbol.opts.sibling_idx
                and { symbol.opts.sibling_idx, 0 }
              if symbol.bar.in_pick_mode then
                ---@param tbl number[]
                local function tbl_sum(tbl)
                  local sum = 0
                  for _, v in ipairs(tbl) do
                    sum = sum + v
                  end
                  return sum
                end
                win_configs.relative = 'win'
                win_configs.win = vim.api.nvim_get_current_win()
                win_configs.row = 0
                win_configs.col = symbol.bar.padding.left
                  + tbl_sum(vim.tbl_map(
                    function(component)
                      return component:displaywidth()
                        + symbol.bar.separator:displaywidth()
                    end,
                    vim.tbl_filter(function(component)
                      return component.bar_idx < symbol.bar_idx
                    end, symbol.bar.components)
                  ))
              end
            elseif symbol.entry and symbol.entry.menu then -- If inside a menu
              prev_win = symbol.entry.menu.win
              entries_source = symbol.opts.children
            end
      
            -- Toggle existing menu
            if symbol.menu then
              symbol.menu:toggle({
                prev_win = prev_win,
                win_configs = win_configs,
              })
              return
            end
      
            -- Create a new menu for the symbol
            if not entries_source or vim.tbl_isempty(entries_source) then
              return
            end
      
            local menu = require('dropbar.menu')
            local configs = require('dropbar.configs')
            symbol.menu = menu.dropbar_menu_t:new({
              prev_win = prev_win,
              cursor = init_cursor,
              win_configs = win_configs,
              ---@param sym dropbar_symbol_t
              entries = vim.tbl_map(function(sym)
                local menu_indicator_icon = configs.opts.icons.ui.menu.indicator
                local menu_indicator_on_click = nil
                if not sym.children or vim.tbl_isempty(sym.children) then
                  menu_indicator_icon =
                    string.rep(' ', vim.fn.strdisplaywidth(menu_indicator_icon))
                  menu_indicator_on_click = false
                end
                return menu.dropbar_menu_entry_t:new({
                  components = {
                    sym:merge({
                      name = '',
                      icon = menu_indicator_icon,
                      icon_hl = 'dropbarIconUIIndicator',
                      on_click = menu_indicator_on_click,
                    }),
                    sym:merge({
                      on_click = function()
                        local root_menu = symbol.menu and symbol.menu:root()
                        if root_menu then
                          root_menu:close(false)
                        end
                        if current_menu then
                          current_menu:close(false)
                        end
                        sym:jump()
                      end,
                    }),
                  },
                })
              end, entries_source),
            })
            symbol.menu:toggle()
          end,
          
      
          function() end
          
      
          function() end
          
      
          function(_, win)
            -- Workaround for Vim:E5002: Cannot find window number
            local ok, cwd = pcall(vim.fn.getcwd, win)
            return ok and cwd or vim.fn.getcwd()
          end
          
      
          function(_)
            return true
          end
          
      
          function(sym)
            return sym
          end
          
      
          function(sym)
            return sym:merge({
              name = sym.name .. '[+]',
              icon = ' ',
              name_hl = 'DiffAdded',
              icon_hl = 'DiffAdded',
              -- ...
            })
          end
          
      
          {
            'block_mapping_pair',
            'array',
            'boolean',
            'break_statement',
            'call',
            'case_statement',
            'class',
            'constant',
            'constructor',
            'continue_statement',
            'delete',
            'do_statement',
            'element',
            'enum',
            'enum_member',
            'event',
            'for_statement',
            'function',
            'goto_statement',
            'if_statement',
            'interface',
            'keyword',
            'macro',
            'method',
            'namespace',
            'null',
            'number',
            'operator',
            'package',
            'pair',
            'property',
            'reference',
            'repeat',
            'return_statement',
            'rule_set',
            'scope',
            'section',
            'specifier',
            'struct',
            'switch_statement',
            'table',
            'type',
            'type_parameter',
            'unit',
            'value',
            'variable',
            'while_statement',
            'declaration',
            'field',
            'identifier',
            'object',
            'statement',
          }
          
      
          {
            'File',
            'Module',
            'Namespace',
            'Package',
            'Class',
            'Method',
            'Property',
            'Field',
            'Constructor',
            'Enum',
            'Interface',
            'Function',
            'Variable',
            'Constant',
            'String',
            'Number',
            'Boolean',
            'Array',
            'Object',
            'Keyword',
            'Null',
            'EnumMember',
            'Struct',
            'Event',
            'Operator',
            'TypeParameter',
          }
          
      
          function(_)
            return M.opts.icons.kinds.symbols.Terminal or ' '
          end
          
      
          name = function(buf)
            local name = vim.api.nvim_buf_get_name(buf)
            -- the second result val is the terminal object
            local term = select(2, require("toggleterm.terminal").indentify(name))
            if term then
              return term.display_name or term.name
            else
              return name
            end
          end
          
      
      local dropbar = require('dropbar')
      local sources = require('dropbar.sources')
      local utils = require('dropbar.utils')
      
      vim.api.nvim_set_hl(0, 'DropBarFileName', { fg = '#FFFFFF', italic = true })
      
      local custom_path = {
        get_symbols = function(buff, win, cursor)
          local symbols = sources.path.get_symbols(buff, win, cursor)
          symbols[#symbols].name_hl = 'DropBarFileName'
          if vim.bo[buff].modified then
            symbols[#symbols].name = symbols[#symbols].name .. ' [+]'
            symbols[#symbols].name_hl = 'DiffAdded'
          end
          return symbols
        end,
      }
      
      dropbar.setup({
        bar = {
          sources = function(buf, _)
            if vim.bo[buf].ft == 'markdown' then
              return {
                custom_path,
                sources.markdown,
              }
            end
            if vim.bo[buf].buftype == 'terminal' then
              return {
                sources.terminal,
              }
            end
            return {
              custom_path,
              utils.source.fallback {
                sources.lsp,
                sources.treesitter,
              },
            }
          end,
        },
      })
      
      
      require('dropbar').setup({
        bar = {
          enable = function(buf, win, _)
            buf = vim._resolve_bufnr(buf)
            if
              not vim.api.nvim_buf_is_valid(buf)
              or not vim.api.nvim_win_is_valid(win)
            then
              return false
            end
      
            if
              not vim.api.nvim_buf_is_valid(buf)
              or not vim.api.nvim_win_is_valid(win)
              or vim.fn.win_gettype(win) ~= ''
              or vim.wo[win].winbar ~= ''
              or vim.bo[buf].ft == 'help'
            then
              return false
            end
      
            local stat = vim.uv.fs_stat(vim.api.nvim_buf_get_name(buf))
            if stat and stat.size > 1024 * 1024 then
              return false
            end
      
            return vim.bo[buf].bt == 'terminal'
              or vim.bo[buf].ft == 'markdown'
              or pcall(vim.treesitter.get_parser, buf)
              or not vim.tbl_isempty(vim.lsp.get_clients({
                bufnr = buf,
                method = vim.lsp.protocol.Methods.textDocument_documentSymbol,
              }))
          end,
        },
        sources = {
          path = {
            relative_to = function(buf, win)
              -- Show full path in oil or fugitive buffers
              local bufname = vim.api.nvim_buf_get_name(buf)
              if
                vim.startswith(bufname, 'oil://')
                or vim.startswith(bufname, 'fugitive://')
              then
                local root = bufname:gsub('^%S+://', '', 1)
                while root and root ~= vim.fs.dirname(root) do
                  root = vim.fs.dirname(root)
                end
                return root
              end
      
              local ok, cwd = pcall(vim.fn.getcwd, win)
              return ok and cwd or vim.fn.getcwd()
            end,
          },
        },
      })
      
      
      local bar = require('dropbar.bar')
      local custom_source = {
        get_symbols = function(_, _, _)
          return {
            bar.dropbar_symbol_t:new({
              icon = ' ',
              icon_hl = 'WarningMsg',
              name = 'Hello',
              name_hl = 'Keyword',
              on_click = function(self)
                vim.notify('Have you smiled today? ' .. self.icon)
              end,
            }),
            bar.dropbar_symbol_t:new({
              name = 'dropbar',
              name_hl = 'Title',
            }),
          }
        end,
      }
      
      
      require('dropbar').setup({
        bar = {
          sources = {
            custom_source,
          },
        },
      })
      
      
      local bar = require('dropbar.bar')
      local menu = require('dropbar.menu')
      local custom_source = {
        get_symbols = function(_, _, _)
          return {
            bar.dropbar_symbol_t:new({
              icon = ' ',
              icon_hl = 'WarningMsg',
              name = 'Hello',
              name_hl = 'Keyword',
              on_click = function(self)
                self.menu = menu.dropbar_menu_t:new({
                  entries = {
                    menu.dropbar_menu_entry_t:new({
                      components = {
                        bar.dropbar_symbol_t:new({
                          icon = ' ',
                          icon_hl = 'WarningMsg',
                          name = 'World',
                          name_hl = 'Keyword',
                          on_click = function(sym)
                            vim.notify('Have you smiled today? ' .. sym.icon)
                          end,
                        }),
                      },
                    }),
                  },
                })
                self.menu:toggle()
              end,
            }),
            bar.dropbar_symbol_t:new({
              name = 'dropbar',
              icon = ' ',
              name_hl = 'Special',
              icon_hl = 'Error',
            }),
          }
        end,
      }
      
      
      local bar = require('dropbar.bar')
      local custom_source = {
        get_symbols = function(buf, win, _)
          return {
            bar.dropbar_symbol_t:new({
              name = 'Section 1',
              name_hl = 'Keyword',
              siblings = {
                bar.dropbar_symbol_t:new({
                  name = 'Section 2',
                  name_hl = 'WarningMsg',
                }),
                bar.dropbar_symbol_t:new({
                  name = 'Section 3',
                  name_hl = 'Error',
                }),
                bar.dropbar_symbol_t:new({
                  name = 'Section 4',
                  name_hl = 'String',
                  children = {
                    bar.dropbar_symbol_t:new({
                      buf = buf,
                      win = win,
                      name = 'Section 4.1',
                      name_hl = 'String',
                      -- Will jump to line 3, col 4 (0-indexed) when clicked in the
                      -- menu
                      range = {
                        start = { line = 3, character = 4 },
                        ['end'] = { line = 5, character = 6 },
                      }
                    }),
                  },
                }),
              },
            }),
          }
        end,
      }
      
      
      require('dropbar').setup({
        bar = {
          sources = {
            custom_source,
          },
        },
      })
      
      
      local bar = require('dropbar.bar')
      local custom_source = {
        get_symbols = function(_, _, _)
          return {
            bar.dropbar_symbol_t:new(setmetatable({
              name = 'Section 1',
              name_hl = 'Keyword',
            }, {
              __index = function(self, key)
                if key == 'siblings' then
                  self[siblings] = -- [[ compute siblings ]]
                  return self[siblings]
                end
                if key == 'children' then
                  self[children] = -- [[ compute children ]]
                  return self[children]
                end
                -- ...
              end,
            })),
          }
        end,
      }
      
    end,
  },
  {
    "SmiteshP/nvim-navic",
    config = function()
      
      use {
          "SmiteshP/nvim-navic",
          requires = "neovim/nvim-lspconfig"
      }
      
      
      local navic = require("nvim-navic")
      
      require("lspconfig").clangd.setup {
          on_attach = function(client, bufnr)
              navic.attach(client, bufnr)
          end
      }
      
      
      local on_attach = function(client, bufnr)
          ...
          if client.server_capabilities.documentSymbolProvider then
              navic.attach(client, bufnr)
          end
          ...
      end
      
      require("lspconfig").clangd.setup {
          on_attach = on_attach
      }
      
      
      navic.setup {
          icons = {
              File          = "󰈙 ",
              Module        = " ",
              Namespace     = "󰌗 ",
              Package       = " ",
              Class         = "󰌗 ",
              Method        = "󰆧 ",
              Property      = " ",
              Field         = " ",
              Constructor   = " ",
              Enum          = "󰕘",
              Interface     = "󰕘",
              Function      = "󰊕 ",
              Variable      = "󰆧 ",
              Constant      = "󰏿 ",
              String        = "󰀬 ",
              Number        = "󰎠 ",
              Boolean       = "◩ ",
              Array         = "󰅪 ",
              Object        = "󰅩 ",
              Key           = "󰌋 ",
              Null          = "󰟢 ",
              EnumMember    = " ",
              Struct        = "󰌗 ",
              Event         = " ",
              Operator      = "󰆕 ",
              TypeParameter = "󰊄 ",
          },
          lsp = {
              auto_attach = false,
              preference = nil,
          },
          highlight = false,
          separator = " > ",
          depth_limit = 0,
          depth_limit_indicator = "..",
          safe_output = true,
          lazy_update_context = false,
          click = false,
          format_text = function(text)
              return text
          end,
      }
      
      
      
      vim.api.nvim_set_hl(0, "NavicIconsFile",          {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsModule",        {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsNamespace",     {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsPackage",       {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsClass",         {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsMethod",        {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsProperty",      {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsField",         {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsConstructor",   {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsEnum",          {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsInterface",     {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsFunction",      {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsVariable",      {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsConstant",      {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsString",        {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsNumber",        {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsBoolean",       {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsArray",         {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsObject",        {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsKey",           {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsNull",          {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsEnumMember",    {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsStruct",        {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsEvent",         {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsOperator",      {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicIconsTypeParameter", {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicText",               {default = true, bg = "#000000", fg = "#ffffff"})
      vim.api.nvim_set_hl(0, "NavicSeparator",          {default = true, bg = "#000000", fg = "#ffffff"})
      
      
      navic.setup {
        icons = {
          File = ' ',
          Module = ' ',
          Namespace = ' ',
          Package = ' ',
          Class = ' ',
          Method = ' ',
          Property = ' ',
          Field = ' ',
          Constructor = ' ',
          Enum = ' ',
          Interface = ' ',
          Function = ' ',
          Variable = ' ',
          Constant = ' ',
          String = ' ',
          Number = ' ',
          Boolean = ' ',
          Array = ' ',
          Object = ' ',
          Key = ' ',
          Null = ' ',
          EnumMember = ' ',
          Struct = ' ',
          Event = ' ',
          Operator = ' ',
          TypeParameter = ' '
        }
      }
      
      
      vim.o.statusline = "%{%v:lua.require'nvim-navic'.get_location()%}"
      --  OR
      vim.o.winbar = "%{%v:lua.require'nvim-navic'.get_location()%}"
      
      
      local navic = require("nvim-navic")
      
      table.insert(components.active[1], {
          provider = function()
              return navic.get_location()
          end,
          enabled = function()
              return navic.is_available()
          end
      })
      
      require("feline").setup({components = components})
      --  OR
      require("feline").winbar.setup({components = components})
      
      
      local navic = require("nvim-navic")
      
      require("lualine").setup({
          sections = {
              lualine_c = {
                  {
                      "navic",
          
                      -- Component specific options
                      color_correction = nil, -- Can be nil, "static" or "dynamic". This option is useful only when you have highlights enabled.
                                              -- Many colorschemes don't define same backgroud for nvim-navic as their lualine statusline backgroud.
                                              -- Setting it to "static" will perform a adjustment once when the component is being setup. This should
                                              --   be enough when the lualine section isn't changing colors based on the mode.
                                              -- Setting it to "dynamic" will keep updating the highlights according to the current modes colors for
                                              --   the current section.
          
                      navic_opts = nil  -- lua table with same format as setup's option. All options except "lsp" options take effect when set here.
                  }
              }
          },
          -- OR in winbar
          winbar = {
              lualine_c = {
                  {
                      "navic",
                      color_correction = nil,
                      navic_opts = nil
                  }
              }
          }
      })
      
      -- OR a more hands on approach
      require("lualine").setup({
          sections = {
              lualine_c = {
                  {
                    function()
                        return navic.get_location()
                    end,
                    cond = function()
                        return navic.is_available()
                    end
                  },
              }
          },
          -- OR in winbar
          winbar = {
              lualine_c = {
                  {
                    function()
                        return navic.get_location()
                    end,
                    cond = function()
                        return navic.is_available()
                    end
                  },
              }
          }
      })
      
      
      local navic = require("nvim-navic")
      local gl = require("galaxyline")
      
      gl.section.right[1]= {
          nvimNavic = {
              provider = function()
                  return navic.get_location()
              end,
              condition = function()
                  return navic.is_available()
              end
          }
      }
      
      
       {
          {
              name  = "myclass",
              type  = "Class",
              icon  = "󰌗 ",
              kind  = 5,
              scope = {
                  start = { line = 1, character = 0 },
                  end = { line = 10, character = 0 }
              }
          },
          {
              name  = "mymethod",
              type  = "Method",
              icon  = "󰆧 ",
              kind  = 6,
              scope = {
                  start = { line = 2, character = 4 },
                  end = { line = 5, character = 4 }
              }
          }
       }
      
      
      -- Customized navic.get_location() that combines namespaces into a single string.
      -- Example: `adam::bob::charlie > foo` is transformed into `a::b::charlie > foo`
      function()
          local navic = require("nvim-navic")
          local old_data = navic.get_data()
          local new_data = {}
          local cur_ns = nil
          local ns_comps = {}
      
          for _, comp in ipairs(old_data) do
              if comp.type == "Namespace" then
                  cur_ns = comp
                  table.insert(ns_comps, comp.name)
              else
                  -- On the first non-namespace component $c$, collect
                  -- previous NS components into a single one and
                  -- insert it in front of $c$.
                  if cur_ns ~= nil then
                      -- Concatenate name and insert
                      local num_comps = #ns_comps
                      local comb_name = ""
                      for idx = 1, num_comps do
                          local ns_name = ns_comps[idx]
      
                          -- No "::" in front of first component
                          local join = (idx == 1) and "" or "::"
      
                          if idx ~= num_comps then
                              comb_name = comb_name .. join .. ns_name:sub(1, 1)
                          else
                              comb_name = comb_name .. join .. ns_name
                          end
                      end
      
                      cur_ns.name = comb_name
                      table.insert(new_data, cur_ns)
                      cur_ns = nil
                  end
      
                  table.insert(new_data, comp)
              end
          end
      
          return navic.format_data(new_data)
      end
      
    end,
  },
  {
    "luukvbaal/statuscol.nvim",
    config = function()
      
      {
        "luukvbaal/statuscol.nvim", config = function()
          -- local builtin = require("statuscol.builtin")
          require("statuscol").setup({
            -- configuration goes here, for example:
            -- relculright = true,
            -- segments = {
            --   { text = { builtin.foldfunc }, click = "v:lua.ScFa" },
            --   {
            --     sign = { namespace = { "diagnostic/signs" }, maxwidth = 2, auto = true },
            --     click = "v:lua.ScSa"
            --   },
            --   { text = { builtin.lnumfunc }, click = "v:lua.ScLa", },
            --   {
            --     sign = { name = { ".*" }, maxwidth = 2, colwidth = 1, auto = true, wrap = true },
            --     click = "v:lua.ScSa"
            --   },
            -- }
          })
        end,
      }
      
      
      local builtin = require("statuscol.builtin")
      local cfg = {
        setopt = true,         -- Whether to set the 'statuscolumn' option, may be set to false for those who
                               -- want to use the click handlers in their own 'statuscolumn': _G.Sc[SFL]a().
                               -- Although I recommend just using the segments field below to build your
                               -- statuscolumn to benefit from the performance optimizations in this plugin.
        -- builtin.lnumfunc number string options
        thousands = false,     -- or line number thousands separator string ("." / ",")
        relculright = false,   -- whether to right-align the cursor line number with 'relativenumber' set
        -- Builtin 'statuscolumn' options
        ft_ignore = nil,       -- Lua table with 'filetype' values for which 'statuscolumn' will be unset
        bt_ignore = nil,       -- Lua table with 'buftype' values for which 'statuscolumn' will be unset
        -- Default segments (fold -> sign -> line number + separator), explained below
        segments = {
          { text = { "%C" }, click = "v:lua.ScFa" },
          { text = { "%s" }, click = "v:lua.ScSa" },
          {
            text = { builtin.lnumfunc, " " },
            condition = { true, builtin.not_empty },
            click = "v:lua.ScLa",
          }
        },
        clickmod = "c",         -- modifier used for certain actions in the builtin clickhandlers:
                                -- "a" for Alt, "c" for Ctrl and "m" for Meta.
        clickhandlers = {       -- builtin click handlers, keys are pattern matched
          Lnum                    = builtin.lnum_click,
          FoldClose               = builtin.foldclose_click,
          FoldOpen                = builtin.foldopen_click,
          FoldOther               = builtin.foldother_click,
          DapBreakpointRejected   = builtin.toggle_breakpoint,
          DapBreakpoint           = builtin.toggle_breakpoint,
          DapBreakpointCondition  = builtin.toggle_breakpoint,
          ["diagnostic/signs"]    = builtin.diagnostic_click,
          gitsigns                = builtin.gitsigns_click,
        },
      }
      
      
      {
        text = { "%C" },       -- table of strings or functions returning a string
        click = "v:lua.ScFa",  -- %@ click function label, applies to each text element
        hl = "FoldColumn",     -- %# highlight group label, applies to each text element
        condition = { true },  -- table of booleans or functions returning a boolean
        sign = {               -- table of fields that configure a sign segment
          -- at least one of "name", "text", and "namespace" is required
          -- legacy signs are matched against the defined sign name e.g. "DapBreakpoint"
          -- extmark signs can be matched against either the namespace or the sign text itself
          name = { ".*" },     -- table of Lua patterns to match the legacy sign name against
          text = { ".*" },     -- table of Lua patterns to match the extmark sign text against
          namespace = { ".*" },-- table of Lua patterns to match the extmark sign namespace against
          -- below values list the default when omitted:
          maxwidth = 1,        -- maximum number of signs that will be displayed in this segment
          colwidth = 2,        -- number of display cells per sign in this segment
          auto = false,        -- boolean or string indicating what will be drawn when no signs
                               -- matching the pattern are currently placed in the buffer.
          wrap = false,        -- when true, signs in this segment will also be drawn on the
                               -- virtual or wrapped part of a line (when v:virtnum != 0).
          fillchar = " ",      -- character used to fill a segment with less signs than maxwidth
          fillcharhl = nil,    -- highlight group used for fillchar (SignColumn/CursorLineSign if omitted)
          foldclosed = false,  -- when true, show signs from lines in a closed fold on the first line
        }
      }
      
      
      {
        lnum = 43,             -- v:lnum
        relnum = 5,            -- v:relnum
        virtnum = 0,           -- v:virtnum
        buf = 1,               -- buffer handle of drawn window
        win = 1000,            -- window handle of drawn window
        actual_curbuf = 1,     -- buffer handle of |g:actual_curwin|
        actual_curwin = 1000,  -- window handle of |g:actual_curbuf|
        nu = true,             -- 'number' option value
        rnu = true,            -- 'relativenumber' option value
        empty = true,          -- statuscolumn is currently empty
        fold = {
          width = 1,           -- current width of the fold column
          -- 'fillchars' option values:
          close = "",         -- foldclose
          open = "",          -- foldopen
          sep = " "            -- foldsep
        },
        -- FFI data:
        tick = 251ULL,         -- display_tick value
        wp = cdata<struct 112 *>: 0x560b56519a50 -- win_T pointer handle
      }
      
      
      local builtin = require("statuscol.builtin")
      require("statuscol").setup({
        segments = {
          {
            text = {
              " ",                -- whitespace padding
              function(args)      -- custom line number highlight function
                return ((args.lnum % 2 > 0) and "%#DiffDelete#%=" or "%#DiffAdd#%=").."%l"
              end,
              " ",                -- whitespace padding
            },
            condition = {
              true,               -- always shown
              function(args)      -- shown only for the current window
                return args.actual_curwin == args.win
              end,
              builtin.not_empty,  -- only shown when the rest of the statuscolumn is not empty
            },
          }
        }
      })
      
      
      local cfg = {
        --- The click actions have the following signature:
        ---@param args (table): {
        ---   minwid = minwid,            -- 1st argument to 'statuscolumn' %@ callback
        ---   clicks = clicks,            -- 2nd argument to 'statuscolumn' %@ callback
        ---   button = button,            -- 3rd argument to 'statuscolumn' %@ callback
        ---   mods = mods,                -- 4th argument to 'statuscolumn' %@ callback
        ---   mousepos = f.getmousepos()  -- getmousepos() table, containing clicked line number/window id etc.
        --- }
        clickhandlers = {
          FoldOther = false,  -- Disable builtin clickhandler
          Lnum = function(args)
            if args.button == "l" and args.mods:find("c") then
              print("I Ctrl-left clicked on line "..args.mousepos.line)
            end
          end,
        }
      }
      
      require("statuscol").setup(cfg)
      
    end,
  },
  {
    "mawkler/hml.nvim",
    config = function()
      
      {
        'mawkler/hml.nvim',
        opts = {}
      }
      
      
      {
        signs = {
          H = 'H', -- Sign to use for the `H` line number
          M = 'M', -- Sign to use for the `M` line number
          L = 'L', -- Sign to use for the `L` line number
        },
      }
      
    end,
  },
  {
    "neur1n/noline.nvim",
  },
  {
    "OXY2DEV/bars.nvim",
    config = function()
      
      {
          "OXY2DEV/bars.nvim",
      },
      
      
      return {
          "OXY2DEV/bars.nvim",
      };
      
      
      local MiniDeps = require("mini.deps");
      
      MiniDeps.add({
          source = "OXY2DEV/bars.nvim"
      });
      
      
      require("bars").setup({
          global = false
      });
      
      
      require("bars.statusline").setup({
          ignore_filwtypes = { "help" }
      });
      
    end,
  },
  {
    "NTBBloodbath/galaxyline.nvim",
    config = function()
      
      use({
        "NTBBloodbath/galaxyline.nvim",
        -- your statusline
        config = function()
          require("galaxyline.themes.eviline")
        end,
        -- some optional icons
        requires = { "kyazdani42/nvim-web-devicons", opt = true }
      })
      
      
      require("galaxyline").section.left[1] = {
        FileSize = {
          provider = "FileSize",
          condition = function()
            return vim.fn.empty(vim.fn.expand("%:t")) ~= 1
          end,
          icon = "   ",
          highlight = { colors.green, colors.purple },
          separator = "",
          separator_highlight = { colors.purple, colors.darkblue },
        }
      }
      
      
      ---- source provider functions
      -- Code diagnostics
      local diagnostic = require("galaxyline.providers.diagnostic")
      -- Version control
      local vcs = require("galaxyline.providers.vcs")
      -- Core files information
      local fileinfo = require("galaxyline.providers.fileinfo")
      -- Extensions, aka plugins
      local extension = require("galaxyline.providers.extensions")
      -- Neovim highlighting
      local colors = require("galaxyline.highlighting")
      -- Buffer information, e.g. corresponding icon
      local buffer = require("galaxyline.providers.buffer")
      -- Search results
      local search = require("galaxyline.providers.search")
      -- Spacing
      local whitespace = require("galaxyline.providers.whitespace")
      -- Active language server information
      local lspclient = require("galaxyline.providers.lsp")
      
      
      ---- Providers
      BufferIcon  = buffer.get_buffer_type_icon
      BufferNumber = buffer.get_buffer_number
      FileTypeName = buffer.get_buffer_filetype
      -- Git Provider
      GitBranch = vcs.get_git_branch
      DiffAdd = vcs.diff_add             -- support vim-gitgutter vim-signify gitsigns
      DiffModified = vcs.diff_modified   -- support vim-gitgutter vim-signify gitsigns
      DiffRemove = vcs.diff_remove       -- support vim-gitgutter vim-signify gitsigns
      -- Search Provider
      SearchResults = search.get_results,
      -- File Provider
      LineColumn = fileinfo.line_column
      FileFormat = fileinfo.get_file_format
      FileEncode = fileinfo.get_file_encode
      FileSize = fileinfo.get_file_size
      FileIcon = fileinfo.get_file_icon
      FileName = fileinfo.get_current_file_name
      LinePercent = fileinfo.current_line_percent
      ScrollBar = extension.scrollbar_instance
      VistaPlugin = extension.vista_nearest
      -- Whitespace
      Whitespace = whitespace.get_item
      -- Diagnostic Provider
      DiagnosticError = diagnostic.get_diagnostic_error
      DiagnosticWarn = diagnostic.get_diagnostic_warn
      DiagnosticHint = diagnostic.get_diagnostic_hint
      DiagnosticInfo = diagnostic.get_diagnostic_info
      -- LSP
      GetLspClient = lspclient.get_lsp_client
      
      
      ---- Public libs
      -- Get file icon color
      require("galaxyline.providers.fileinfo").get_file_icon_color
      -- Custom file icon with color
      local my_icons = require("galaxyline.providers.fileinfo").define_file_icon()
      my_icons['your file type here'] = { color code, icon}
      -- If your filetype does is not defined in neovim  you can use file extensions
      my_icons['your file ext  in here'] = { color code, icon}
      
      ---- built-in conditions
      local condition = require("galaxyline.condition")
      -- if buffer not empty return true else false
      condition.buffer_not_empty
      -- if winwidth(0)/ 2 > 40 true else false
      condition.hide_in_width
      -- find git root, you can use this to check if the project is a git workspace
      condition.check_git_workspace()
      
      
      ---- built-in theme
      local colors = require("galaxyline.themes.colors").default
      --- Palette:
      -- bg = "#202328"
      -- fg = "#bbc2cf"
      -- yellow = "#ECBE7B"
      -- cyan = "#008080"
      -- darkblue = "#081633"
      -- green = "#98be65"
      -- orange = "#FF8800"
      -- violet = "#a9a1e1"
      -- magenta = "#c678dd"
      -- blue = "#51afef"
      -- red = "#ec5f67"
      
    end,
  },
  {
    "tjdevries/express_line.nvim",
    config = function()
      
      -- require this lua file somewhere in your `init.vim`, or use `:lua`
      
      require('el').setup {
        -- An example generator can be seen in `Setup`.
        -- A default one is supplied if you do not want to customize it.
        generator = function(win_id)
          ...
        end
      }
      
      
      
      local generator = function()
          local el_segments = {}
      
          -- Statusline options can be of several different types.
          -- Option 1, just a string.
      
          table.insert(el_segments, '[literal_string]')
      
          -- Keep in mind, these can be the builtin strings,
          -- which are found in |:help statusline|
          table.insert(el_segments, '%f')
      
          -- expresss_line provides a helpful wrapper for these.
          -- You can check out el.builtin
          local builtin = require('el.builtin')
          table.insert(el_segments, builtin.file)
      
          -- Option 2, just a function that returns a string.
          local extensions = require('el.extensions')
          table.insert(el_segments, extensions.mode) -- mode returns the current mode.
      
          -- Option 3, returns a function that takes in a Window and a Buffer.
          --  See |:help el.Window| and |:help el.Buffer|
          --
          --  With this option, you don't have to worry about escaping / calling
          --  the function in the correct way to get the current buffer and window.
          local file_namer = function(_window, buffer)
            return buffer.name
          end
          table.insert(el_segments, file_namer)
      
          -- Option 4, you can return a coroutine.
          --  In lua, you can cooperatively multi-thread.
          --  You can use `coroutine.yield()` to yield execution to another coroutine.
          --
          --  For example, in luvjob.nvim, there is `co_wait` which is a coroutine
          --  version of waiting for a job to complete. So you can start multiple
          --  jobs at once and wait for them to all be done.
          table.insert(el_segments, extensions.git_changes)
      
          -- Option 5, there are several helper functions provided to asynchronously
          --  run timers which update buffer or window variables at a certain frequency.
          --
          --  These can be used to set infrequrently updated values without waiting.
          local helper = require("el.helper")
          table.insert(el_segments, helper.async_buf_setter(
            win_id,
            'el_git_stat',
            extensions.git_changes,
            5000
          ))
      
          return el_segments
      end
      
      -- And then when you're all done, just call
      require('el').setup { generator = generator }
      
      
      local extensions = require('el.extensions')
      local subscribe = require('el.subscribe')
      local generator = function(_window, buffer)
         local segments = {}
      end
      require('el').setup({generator = generator})
      
      
         -- ...
         table.insert(segments,
          subscribe.buf_autocmd(
            "el_git_status",
            "BufWritePost",
            function(window, buffer)
              local changes =  extensions.git_changes(window, buffer)
              if changes then
                return changes
              end
            end
          ))
          -- ...
      
      
         -- ...
         table.insert(segments,
          subscribe.buf_autocmd(
            "el_git_branch",
            "BufEnter",
            function(window, buffer)
              local branch = extensions.git_branch(window, buffer)
              if branch then
                return branch
              end
            end
          ))
         -- ...
      
      
         -- ...
         table.insert(segments, extensions.mode)
          -- ...
      
      
         -- ...
         table.insert(segments,
          subscribe.buf_autocmd(
            "el_file_icon",
            "BufRead",
            function(_, buffer)
              return extensions.file_icon(_, buffer)
            end
          ))
      
    end,
  },
  {
    "sontungexpt/sttusline",
    config = function()
      
          -- lazy
          {
              "sontungexpt/sttusline",
              dependencies = {
                  "nvim-tree/nvim-web-devicons",
              },
              event = { "BufEnter" },
              config = function(_, opts)
                  require("sttusline").setup {
                      -- statusline_color = "#000000",
                      statusline_color = "StatusLine",
      
                      -- | 1 | 2 | 3
                      -- recommended: 3
                      laststatus = 3,
                      disabled = {
                          filetypes = {
                              -- "NvimTree",
                              -- "lazy",
                          },
                          buftypes = {
                              -- "terminal",
                          },
                      },
                      components = {
                          "mode",
                          "filename",
                          "git-branch",
                          "git-diff",
                          "%=",
                          "diagnostics",
                          "lsps-formatters",
                          "copilot",
                          "indent",
                          "encoding",
                          "pos-cursor",
                          "pos-cursor-progress",
                      },
                  }
              end,
          },
      
      
      -- Change NewComponent to your component name
      local NewComponent = require("sttusline.component").new()
      
      -- The component will be update when the event is triggered
      -- To disable default event, set NewComponent.set_event = {}
      NewComponent.set_event {}
      
      -- The component will be update when the user event is triggered
      -- To disable default user_event, set NewComponent.set_user_event = {}
      NewComponent.set_user_event { "VeryLazy" }
      
      -- The component will be update every time interval
      NewComponent.set_timing(false)
      
      -- The component will be update when the require("sttusline").setup() is called
      NewComponent.set_lazy(true)
      
      -- The config of the component
      -- After set_config, the config will be available in the component
      -- You can access the config by NewComponent.get_config()
      NewComponent.set_config {}
      
      -- The number of spaces to add before and after the component
      NewComponent.set_padding(1)
      -- or NewComponent.set_padding{ left = 1, right = 1 }
      
      -- The colors of the component. Rely on the return value of the update function, you have 3 ways to set the colors
      -- If the return value is string
      -- NewComponent.set_colors { fg = colors.set_black, bg = colors.set_white }
      -- If the return value is table of string
      -- NewComponent.set_colors { { fg = "#009900", bg = "#ffffff" }, { fg = "#000000", bg = "#ffffff" }}
      -- -- so if the return value is { "string1", "string2" }
      -- -- then the string1 will be highlight with { fg = "#009900", bg = "#ffffff" }
      -- -- and the string2 will be highlight with { fg = "#000000", bg = "#ffffff" }
      --
      -- -- if you don't want to add highlight for the string1 now
      -- -- because it will auto update new colors when the returning value in update function is a table that contains the color options,
      -- -- you can add a empty table in the first element
      -- -- {
      --     colors = {
      --         {},
      --         { fg = "#000000", bg = "#ffffff" }
      --     },
      -- -- }
      --
      -- NOTE: The colors options can be the colors name or the colors options
      -- -- colors = {
      -- --  { fg = "#009900", bg = "#ffffff" },
      -- --  "DiagnosticsSignError",
      -- -- },
      -- -- So if the return value is { "string1", "string2" }
      -- -- then the string1 will be highlight with { fg = "#009900", bg = "#ffffff" }
      -- -- and the string2 will be highlight with the colors options of the DiagnosticsSignError highlight
      -- -- Or you can set the fg(bg) follow the colors options of the DiagnosticsSignError highlight
      -- -- {
      -- --  colors = {
      -- --      { fg = "DiagnosticsSignError", bg = "#ffffff" },
      -- --      "DiagnosticsSignError",
      -- --  },
      -- -- }
      
      NewComponent.set_colors {} -- { fg = colors.set_black, bg = colors.set_white }
      
      -- The function will return the value of the component to display on the statusline(required).
      -- Must return a string or a table of string or a table of  { "string", { fg = "color", bg = "color" } }
      -- NewComponent.set_update(function() return { "string1", "string2" } end)
      -- NewComponent.set_update(function() return { { "string1", {fg = "#000000", bg ="#fdfdfd"} },  "string3", "string4" } end)
      NewComponent.set_update(function() return "" end)
      
      
      -- The function will call when the component is highlight
      NewComponent.set_onhighlight(function() end)
      
      -- The function will return the condition to display the component when the component is update
      -- Must return a boolean
      NewComponent.set_condition(function() return true end)
      
      -- The function will call on the first time component load
      NewComponent.set_onload(function() end)
      
      
      return NewComponent
      
      
          -- Create new component with name Datetime
          local Datetime = require("sttusline.component").new()
      
          Datetime.set_config {
              style = "default",
          }
      
          Datetime.set_timing(true)
      
          Datetime.set_update(function()
              local style = Datetime.get_config().style
              local fmt = style
              if style == "default" then
                  fmt = "%A, %B %d | %H.%M"
              elseif style == "us" then
                  fmt = "%m/%d/%Y"
              elseif style == "uk" then
                  fmt = "%d/%m/%Y"
              elseif style == "iso" then
                  fmt = "%Y-%m-%d"
              end
              return os.date(fmt) .. ""
          end)
      
          require("sttusline").setup {
              components = {
                  -- ...
                  -- Add your component
                  Datetime,
              }
          }
      
      
          require("sttusline").setup {
              -- ...
              components = {
                  -- "mode",
                  -- "filename",
                  -- "git-branch",
                  -- "git-diff",
                  -- "%=",
                  -- "diagnostics",
                  -- "lsps-formatters",
                  -- "copilot",
                  -- "indent",
                  -- "encoding",
                  -- "pos-cursor",
                  -- "pos-cursor-progress",
              },
          }
      
      
          require("sttusline").setup {
              components = {
                  -- ... your components
                  "%=", -- add the empty space
                  -- ... your components
              },
          }
      
      
      local mode = require("sttusline.components.mode")
      
      mode.set_config{
          mode_colors = {
              ["STTUSLINE_NORMAL_MODE"] = { fg = "#000000", bg = "#ffffff" },
          },
      }
      
      -- after override default component, you need to add it to components option in setup function
      require("sttusline").setup {
          components = {
              -- ... your components
              mode,
              -- ... your components
          },
      }
      
      
          local datetime = require("sttusline.components.datetime")
      
          datetime.set_config {
            style = "default",
          }
      
      
          local mode = require("sttusline.components.mode")
      
          mode.set_config {
          modes = {
              ["n"] = { "NORMAL", "STTUSLINE_NORMAL_MODE" },
              ["no"] = { "NORMAL (no)", "STTUSLINE_NORMAL_MODE" },
              ["nov"] = { "NORMAL (nov)", "STTUSLINE_NORMAL_MODE" },
              ["noV"] = { "NORMAL (noV)", "STTUSLINE_NORMAL_MODE" },
              ["noCTRL-V"] = { "NORMAL", "STTUSLINE_NORMAL_MODE" },
              ["niI"] = { "NORMAL i", "STTUSLINE_NORMAL_MODE" },
              ["niR"] = { "NORMAL r", "STTUSLINE_NORMAL_MODE" },
              ["niV"] = { "NORMAL v", "STTUSLINE_NORMAL_MODE" },
      
              ["nt"] = { "TERMINAL", "STTUSLINE_NTERMINAL_MODE" },
              ["ntT"] = { "TERMINAL (ntT)", "STTUSLINE_NTERMINAL_MODE" },
      
              ["v"] = { "VISUAL", "STTUSLINE_VISUAL_MODE" },
              ["vs"] = { "V-CHAR (Ctrl O)", "STTUSLINE_VISUAL_MODE" },
              ["V"] = { "V-LINE", "STTUSLINE_VISUAL_MODE" },
              ["Vs"] = { "V-LINE", "STTUSLINE_VISUAL_MODE" },
              [""] = { "V-BLOCK", "STTUSLINE_VISUAL_MODE" },
      
              ["i"] = { "INSERT", "STTUSLINE_INSERT_MODE" },
              ["ic"] = { "INSERT (completion)", "STTUSLINE_INSERT_MODE" },
              ["ix"] = { "INSERT completion", "STTUSLINE_INSERT_MODE" },
      
              ["t"] = { "TERMINAL", "STTUSLINE_TERMINAL_MODE" },
              ["!"] = { "SHELL", "STTUSLINE_TERMINAL_MODE" },
      
              ["R"] = { "REPLACE", "STTUSLINE_REPLACE_MODE" },
              ["Rc"] = { "REPLACE (Rc)", "STTUSLINE_REPLACE_MODE" },
              ["Rx"] = { "REPLACEa (Rx)", "STTUSLINE_REPLACE_MODE" },
              ["Rv"] = { "V-REPLACE", "STTUSLINE_REPLACE_MODE" },
              ["Rvc"] = { "V-REPLACE (Rvc)", "STTUSLINE_REPLACE_MODE" },
              ["Rvx"] = { "V-REPLACE (Rvx)", "STTUSLINE_REPLACE_MODE" },
      
              ["s"] = { "SELECT", "STTUSLINE_SELECT_MODE" },
              ["S"] = { "S-LINE", "STTUSLINE_SELECT_MODE" },
              [""] = { "S-BLOCK", "STTUSLINE_SELECT_MODE" },
      
              ["c"] = { "COMMAND", "STTUSLINE_COMMAND_MODE" },
              ["cv"] = { "COMMAND", "STTUSLINE_COMMAND_MODE" },
              ["ce"] = { "COMMAND", "STTUSLINE_COMMAND_MODE" },
      
              ["r"] = { "PROMPT", "STTUSLINE_CONFIRM_MODE" },
              ["rm"] = { "MORE", "STTUSLINE_CONFIRM_MODE" },
              ["r?"] = { "CONFIRM", "STTUSLINE_CONFIRM_MODE" },
              ["x"] = { "CONFIRM", "STTUSLINE_CONFIRM_MODE" },
          },
          mode_colors = {
              ["STTUSLINE_NORMAL_MODE"] = { fg = colors.blue },
              ["STTUSLINE_INSERT_MODE"] = { fg = colors.green },
              ["STTUSLINE_VISUAL_MODE"] = { fg = colors.purple },
              ["STTUSLINE_NTERMINAL_MODE"] = { fg = colors.gray },
              ["STTUSLINE_TERMINAL_MODE"] = { fg = colors.cyan },
              ["STTUSLINE_REPLACE_MODE"] = { fg = colors.red },
              ["STTUSLINE_SELECT_MODE"] = { fg = colors.magenta },
              ["STTUSLINE_COMMAND_MODE"] = { fg = colors.yellow },
              ["STTUSLINE_CONFIRM_MODE"] = { fg = colors.yellow },
              },
          },
          auto_hide_on_vim_resized = true,
      
      
          local diagnostics = require("sttusline.components.diagnostics")
          diagnostics.set_config {
              icons = {
                  ERROR = "",
                  INFO = "",
                  HINT = "󰌵",
                  WARN = "",
              },
              order = { "ERROR", "WARN", "INFO", "HINT" },
          }
      
      
      local encoding = require("sttusline.components.encoding")
      
      encoding.set_config {
      	["utf-8"] = "󰉿",
      	["utf-16"] = "",
      	["utf-32"] = "",
      	["utf-8mb4"] = "",
      	["utf-16le"] = "",
      	["utf-16be"] = "",
      }
      
      
          local filename = require("sttusline.components.filename")
          filename.set_config {
              color = { fg = colors.orange },
          }
      
      
          local git_branch = require("sttusline.components.git-branch")
      
          git_branch.set_config {
              icons =  ""
          }
      
      
          local git_diff = require("sttusline.components.git-diff")
      
          git_diff.set_config {
              icons = {
                  added = "",
                  changed = "",
                  removed = "",
              },
              order = { "added", "changed", "removed" },
          }
      
      
      local indent = require("sttusline.components.indent")
      
      indent.set_colors { fg = colors.cyan }
      
      
      local lsps_formatters = require("sttusline.components.lsps-formatters")
      
      lsps_formatters.set_colors { fg = colors.magenta }
      
      
      local copilot = require("sttusline.components.copilot")
      
      copilot.set_colors { fg = colors.yellow }
      copilot.set_config {
          icons = {
              normal = "",
              error = "",
              warning = "",
              inprogress = "",
          },
      }
      
      
      local pos_cursor = require("sttusline.components.pos-cursor")
      pos_cursor.set_colors { fg = colors.fg }
      
      
      local pos_cursor_progress = require("sttusline.components.pos-cursor-progress")
      pos_cursor_rogress.set_colors { fg = colors.orange }
      
    end,
  },
  {
    "nvim-lualine/lualine.nvim",
    config = function()
      
      use {
        'nvim-lualine/lualine.nvim',
        requires = { 'nvim-tree/nvim-web-devicons', opt = true }
      }
      
      
      {
          'nvim-lualine/lualine.nvim',
          dependencies = { 'nvim-tree/nvim-web-devicons' }
      }
      
      
      require('lualine').setup {
        options = {
          icons_enabled = true,
          theme = 'auto',
          component_separators = { left = '', right = ''},
          section_separators = { left = '', right = ''},
          disabled_filetypes = {
            statusline = {},
            winbar = {},
          },
          ignore_focus = {},
          always_divide_middle = true,
          always_show_tabline = true,
          globalstatus = false,
          refresh = {
            statusline = 1000,
            tabline = 1000,
            winbar = 1000,
            refresh_time = 16, -- ~60fps
            events = {
              'WinEnter',
              'BufEnter',
              'BufWritePost',
              'SessionLoadPost',
              'FileChangedShellPost',
              'VimResized',
              'Filetype',
              'CursorMoved',
              'CursorMovedI',
              'ModeChanged',
            },
          }
        },
        sections = {
          lualine_a = {'mode'},
          lualine_b = {'branch', 'diff', 'diagnostics'},
          lualine_c = {'filename'},
          lualine_x = {'encoding', 'fileformat', 'filetype'},
          lualine_y = {'progress'},
          lualine_z = {'location'}
        },
        inactive_sections = {
          lualine_a = {},
          lualine_b = {},
          lualine_c = {'filename'},
          lualine_x = {'location'},
          lualine_y = {},
          lualine_z = {}
        },
        tabline = {},
        winbar = {},
        inactive_winbar = {},
        extensions = {}
      }
      
      
      require('lualine').get_config()
      
      
      
      require('lualine').setup()
      
      
      options = { theme = 'gruvbox' }
      
      
      local custom_gruvbox = require'lualine.themes.gruvbox'
      
      -- Change the background of lualine_c section for normal mode
      custom_gruvbox.normal.c.bg = '#112233'
      
      require('lualine').setup {
        options = { theme  = custom_gruvbox },
        ...
      }
      
      
      options = {
        section_separators = { left = '', right = '' },
        component_separators = { left = '', right = '' }
      }
      
      
      options = { section_separators = '', component_separators = '' }
      
      
      sections = {lualine_a = {'mode'}}
      
      
      local function hello()
        return [[hello world]]
      end
      sections = { lualine_a = { hello } }
      
      
      sections = { lualine_a = {'FugitiveHead'} }
      
      
      sections = { lualine_c = {'%=', '%t%m', '%3p'} }
      
      
      sections = { lualine_a = { 'g:coc_status', 'bo:filetype' } }
      
      
      sections = { lualine_c = { "os.date('%a')", 'data', "require'lsp-status'.status()" } }
      
      
          require('lualine').setup {
            options = { fmt = string.lower },
            sections = { lualine_a = {
              { 'mode', fmt = function(str) return str:sub(1,1) end } },
                        lualine_b = {'branch'} }
          }
      
      
      options = {
        theme = 'auto', -- lualine theme
        component_separators = { left = '', right = '' },
        section_separators = { left = '', right = '' },
        disabled_filetypes = {     -- Filetypes to disable lualine for.
            statusline = {},       -- only ignores the ft for statusline.
            winbar = {},           -- only ignores the ft for winbar.
        },
      
        ignore_focus = {},         -- If current filetype is in this list it'll
                                   -- always be drawn as inactive statusline
                                   -- and the last window will be drawn as active statusline.
                                   -- for example if you don't want statusline of
                                   -- your file tree / sidebar window to have active
                                   -- statusline you can add their filetypes here.
                                   --
                                   -- Can also be set to a function that takes the
                                   -- currently focused window as its only argument
                                   -- and returns a boolean representing whether the
                                   -- window's statusline should be drawn as inactive.
      
        always_divide_middle = true, -- When set to true, left sections i.e. 'a','b' and 'c'
                                     -- can't take over the entire statusline even
                                     -- if neither of 'x', 'y' or 'z' are present.
      
        always_show_tabline = true -- When set to true, if you have configured lualine for displaying tabline
                                -- then tabline will always show. If set to false, then tabline will be displayed
                                -- only when there are more than 1 tab. (see :h showtabline)
      
        globalstatus = false,        -- enable global statusline (have a single statusline
                                     -- at bottom of neovim instead of one for  every window).
                                     -- This feature is only available in neovim 0.7 and higher.
      
        refresh = {                  -- sets how often lualine should refresh it's contents (in ms)
          statusline = 100,         -- The refresh option sets minimum time that lualine tries
          tabline = 100,            -- to maintain between refresh. It's not guarantied if situation
          winbar = 100              -- arises that lualine needs to refresh itself before this time
                                    -- it'll do it.
          refresh_time = 16,        -- ~60fps the time after which refresh queue is processed. Mininum refreshtime for lualine
          events = {                -- The auto command events at which lualine refreshes
            'WinEnter',
            'BufEnter',
            'BufWritePost',
            'SessionLoadPost',
            'FileChangedShellPost',
            'VimResized',
            'Filetype',
            'CursorMoved',
            'CursorMovedI',
            'ModeChanged',
          },
                                     -- Also you can force lualine's refresh by calling refresh function
                                     -- like require('lualine').refresh()
        }
      }
      
      
      sections = {
        lualine_a = {
          {
            'mode',
            icons_enabled = true, -- Enables the display of icons alongside the component.
            -- Defines the icon to be displayed in front of the component.
            -- Can be string|table
            -- As table it must contain the icon as first entry and can use
            -- color option to custom color the icon. Example:
            -- {'branch', icon = ''} / {'branch', icon = {'', color={fg='green'}}}
      
            -- icon position can also be set to the right side from table. Example:
            -- {'branch', icon = {'', align='right', color={fg='green'}}}
            icon = nil,
      
            separator = nil,      -- Determines what separator to use for the component.
                                  -- Note:
                                  --  When a string is provided it's treated as component_separator.
                                  --  When a table is provided it's treated as section_separator.
                                  --  Passing an empty string disables the separator.
                                  --
                                  -- These options can be used to set colored separators
                                  -- around a component.
                                  --
                                  -- The options need to be set as such:
                                  --   separator = { left = '', right = ''}
                                  --
                                  -- Where left will be placed on left side of component,
                                  -- and right will be placed on its right.
                                  --
      
            cond = nil,           -- Condition function, the component is loaded when the function returns `true`.
      
            draw_empty = false,   -- Whether to draw component even if it's empty.
                                  -- Might be useful if you want just the separator.
      
            -- Defines a custom color for the component:
            --
            -- 'highlight_group_name' | { fg = '#rrggbb'|cterm_value(0-255)|'color_name(red)', bg= '#rrggbb', gui='style' } | function
            -- Note:
            --  '|' is synonymous with 'or', meaning a different acceptable format for that placeholder.
            -- color function has to return one of other color types ('highlight_group_name' | { fg = '#rrggbb'|cterm_value(0-255)|'color_name(red)', bg= '#rrggbb', gui='style' })
            -- color functions can be used to have different colors based on state as shown below.
            --
            -- Examples:
            --   color = { fg = '#ffaa88', bg = 'grey', gui='italic,bold' },
            --   color = { fg = 204 }   -- When fg/bg are omitted, they default to the your theme's fg/bg.
            --   color = 'WarningMsg'   -- Highlight groups can also be used.
            --   color = function(section)
            --      return { fg = vim.bo.modified and '#aa3355' or '#33aa88' }
            --   end,
            color = nil, -- The default is your theme's color for that section and mode.
      
            -- Specify what type a component is, if omitted, lualine will guess it for you.
            --
            -- Available types are:
            --   [format: type_name(example)], mod(branch/filename),
            --   stl(%f/%m), var(g:coc_status/bo:modifiable),
            --   lua_expr(lua expressions), vim_fun(viml function name)
            --
            -- Note:
            -- lua_expr is short for lua-expression and vim_fun is short for vim-function.
            type = nil,
      
            padding = 1, -- Adds padding to the left and right of components.
                         -- Padding can be specified to left or right independently, e.g.:
                         --   padding = { left = left_padding, right = right_padding }
      
            fmt = nil,   -- Format function, formats the component's output.
                         -- This function receives two arguments:
                         -- - string that is going to be displayed and
                         --   that can be changed, enhanced and etc.
                         -- - context object with information you might
                         --   need. E.g. tabnr if used with tabs.
            on_click = nil, -- takes a function that is called when component is clicked with mouse.
                         -- the function receives several arguments
                         -- - number of clicks in case of multiple clicks
                         -- - mouse button used (l(left)/r(right)/m(middle)/...)
                         -- - modifiers pressed (s(shift)/c(ctrl)/a(alt)/m(meta)...)
          }
        }
      }
      
      
      sections = {
        lualine_a = {
          {
            'buffers',
            show_filename_only = true,   -- Shows shortened relative path when set to false.
            hide_filename_extension = false,   -- Hide filename extension when set to true.
            show_modified_status = true, -- Shows indicator when the buffer is modified.
      
            mode = 0, -- 0: Shows buffer name
                      -- 1: Shows buffer index
                      -- 2: Shows buffer name + buffer index
                      -- 3: Shows buffer number
                      -- 4: Shows buffer name + buffer number
      
            max_length = vim.o.columns * 2 / 3, -- Maximum width of buffers component,
                                                -- it can also be a function that returns
                                                -- the value of `max_length` dynamically.
            filetype_names = {
              TelescopePrompt = 'Telescope',
              dashboard = 'Dashboard',
              packer = 'Packer',
              fzf = 'FZF',
              alpha = 'Alpha'
            }, -- Shows specific buffer name for that filetype ( { `filetype` = `buffer_name`, ... } )
      
            -- Automatically updates active buffer color to match color of other components (will be overidden if buffers_color is set)
            use_mode_colors = false,
      
            buffers_color = {
              -- Same values as the general color option can be used here.
              active = 'lualine_{section}_normal',     -- Color for active buffer.
              inactive = 'lualine_{section}_inactive', -- Color for inactive buffer.
            },
      
            symbols = {
              modified = ' ●',      -- Text to show when the buffer is modified
              alternate_file = '#', -- Text to show to identify the alternate file
              directory =  '',     -- Text to show when the buffer is a directory
            },
          }
        }
      }
      
      
      sections = {
        lualine_a = {
          {
            'datetime',
            -- options: default, us, uk, iso, or your own format string ("%H:%M", etc..)
            style = 'default'
          }
        }
      }
      
      
      sections = {
        lualine_a = {
          {
            'diagnostics',
      
            -- Table of diagnostic sources, available sources are:
            --   'nvim_lsp', 'nvim_diagnostic', 'nvim_workspace_diagnostic', 'coc', 'ale', 'vim_lsp'.
            -- or a function that returns a table as such:
            --   { error=error_cnt, warn=warn_cnt, info=info_cnt, hint=hint_cnt }
            sources = { 'nvim_diagnostic', 'coc' },
      
            -- Displays diagnostics for the defined severity types
            sections = { 'error', 'warn', 'info', 'hint' },
      
            diagnostics_color = {
              -- Same values as the general color option can be used here.
              error = 'DiagnosticError', -- Changes diagnostics' error color.
              warn  = 'DiagnosticWarn',  -- Changes diagnostics' warn color.
              info  = 'DiagnosticInfo',  -- Changes diagnostics' info color.
              hint  = 'DiagnosticHint',  -- Changes diagnostics' hint color.
            },
            symbols = {error = 'E', warn = 'W', info = 'I', hint = 'H'},
            colored = true,           -- Displays diagnostics status in color if set to true.
            update_in_insert = false, -- Update diagnostics in insert mode.
            always_visible = false,   -- Show diagnostics even if there are none.
          }
        }
      }
      
      
      sections = {
        lualine_a = {
          {
            'diff',
            colored = true, -- Displays a colored diff status if set to true
            diff_color = {
              -- Same color values as the general color option can be used here.
              added    = 'LuaLineDiffAdd',    -- Changes the diff's added color
              modified = 'LuaLineDiffChange', -- Changes the diff's modified color
              removed  = 'LuaLineDiffDelete', -- Changes the diff's removed color you
            },
            symbols = {added = '+', modified = '~', removed = '-'}, -- Changes the symbols used by the diff.
            source = nil, -- A function that works as a data source for diff.
                          -- It must return a table as such:
                          --   { added = add_count, modified = modified_count, removed = removed_count }
                          -- or nil on failure. count <= 0 won't be displayed.
          }
        }
      }
      
      
      sections = {
        lualine_a = {
          {
            'fileformat',
            symbols = {
              unix = '', -- e712
              dos = '',  -- e70f
              mac = '',  -- e711
            }
          }
        }
      }
      
      
      sections = {
        lualine_a = {
          {
            'filename',
            file_status = true,      -- Displays file status (readonly status, modified status)
            newfile_status = false,  -- Display new file status (new file means no write after created)
            path = 0,                -- 0: Just the filename
                                     -- 1: Relative path
                                     -- 2: Absolute path
                                     -- 3: Absolute path, with tilde as the home directory
                                     -- 4: Filename and parent dir, with tilde as the home directory
      
            shorting_target = 40,    -- Shortens path to leave 40 spaces in the window
                                     -- for other components. (terrible name, any suggestions?)
            symbols = {
              modified = '[+]',      -- Text to show when the file is modified.
              readonly = '[-]',      -- Text to show when the file is non-modifiable or readonly.
              unnamed = '[No Name]', -- Text to show for unnamed buffers.
              newfile = '[New]',     -- Text to show for newly created file before first write
            }
          }
        }
      }
      
      
      sections = {
        lualine_a = {
          {
            'filetype',
            colored = true,   -- Displays filetype icon in color if set to true
            icon_only = false, -- Display only an icon for filetype
            icon = { align = 'right' }, -- Display filetype icon on the right hand side
            -- icon =    {'X', align='right'}
            -- Icon string ^ in table is ignored in filetype component
          }
        }
      }
      
      
      sections = {
        lualine_a = {
          {
            'encoding',
            -- Show '[BOM]' when the file has a byte-order mark
              show_bomb = false,
          }
        }
      }
      
      
      sections = {
        lualine_a = {
          {
            'searchcount',
            maxcount = 999,
            timeout = 500,
          }
        }
      }
      
      
      sections = {
        lualine_a = {
          {
            'tabs',
            tab_max_length = 40,  -- Maximum width of each tab. The content will be shorten dynamically (example: apple/orange -> a/orange)
            max_length = vim.o.columns / 3, -- Maximum width of tabs component.
                                            -- Note:
                                            -- It can also be a function that returns
                                            -- the value of `max_length` dynamically.
            mode = 0, -- 0: Shows tab_nr
                      -- 1: Shows tab_name
                      -- 2: Shows tab_nr + tab_name
      
            path = 0, -- 0: just shows the filename
                      -- 1: shows the relative path and shorten $HOME to ~
                      -- 2: shows the full path
                      -- 3: shows the full path and shorten $HOME to ~
      
            -- Automatically updates active tab color to match color of other components (will be overidden if buffers_color is set)
            use_mode_colors = false,
      
            tabs_color = {
              -- Same values as the general color option can be used here.
              active = 'lualine_{section}_normal',     -- Color for active tab.
              inactive = 'lualine_{section}_inactive', -- Color for inactive tab.
            },
      
            show_modified_status = true,  -- Shows a symbol next to the tab name if the file has been modified.
            symbols = {
              modified = '[+]',  -- Text to show when the file is modified.
            },
      
            fmt = function(name, context)
              -- Show + if buffer is modified in tab
              local buflist = vim.fn.tabpagebuflist(context.tabnr)
              local winnr = vim.fn.tabpagewinnr(context.tabnr)
              local bufnr = buflist[winnr]
              local mod = vim.fn.getbufvar(bufnr, '&mod')
      
              return name .. (mod == 1 and ' +' or '')
            end
          }
        }
      }
      
      
      sections = {
        lualine_a = {
          {
            'windows',
            show_filename_only = true,   -- Shows shortened relative path when set to false.
            show_modified_status = true, -- Shows indicator when the window is modified.
      
            mode = 0, -- 0: Shows window name
                      -- 1: Shows window index
                      -- 2: Shows window name + window index
      
            max_length = vim.o.columns * 2 / 3, -- Maximum width of windows component,
                                                -- it can also be a function that returns
                                                -- the value of `max_length` dynamically.
            filetype_names = {
              TelescopePrompt = 'Telescope',
              dashboard = 'Dashboard',
              packer = 'Packer',
              fzf = 'FZF',
              alpha = 'Alpha'
            }, -- Shows specific window name for that filetype ( { `filetype` = `window_name`, ... } )
      
            disabled_buftypes = { 'quickfix', 'prompt' }, -- Hide a window if its buffer's type is disabled
      
            -- Automatically updates active window color to match color of other components (will be overidden if buffers_color is set)
            use_mode_colors = false,
      
            windows_color = {
              -- Same values as the general color option can be used here.
              active = 'lualine_{section}_normal',     -- Color for active window.
              inactive = 'lualine_{section}_inactive', -- Color for inactive window.
            },
          }
        }
      }
      
      
      sections = {
        lualine_a = {
          {
            'lsp_status',
            icon = '', -- f013
            symbols = {
              -- Standard unicode symbols to cycle through for LSP progress:
              spinner = { '⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏' },
              -- Standard unicode symbol for when LSP is done:
              done = '✓',
              -- Delimiter inserted between LSP names:
              separator = ' ',
            },
            -- List of LSP names to ignore (e.g., `null-ls`):
            ignore_lsp = {},
          }
        }
      }
      
      
      tabline = {
        lualine_a = {},
        lualine_b = {'branch'},
        lualine_c = {'filename'},
        lualine_x = {},
        lualine_y = {},
        lualine_z = {}
      }
      
      
      tabline = {
        lualine_a = {'buffers'},
        lualine_b = {'branch'},
        lualine_c = {'filename'},
        lualine_x = {},
        lualine_y = {},
        lualine_z = {'tabs'}
      }
      
      
      winbar = {
        lualine_a = {},
        lualine_b = {},
        lualine_c = {'filename'},
        lualine_x = {},
        lualine_y = {},
        lualine_z = {}
      }
      
      inactive_winbar = {
        lualine_a = {},
        lualine_b = {},
        lualine_c = {'filename'},
        lualine_x = {},
        lualine_y = {},
        lualine_z = {}
      }
      
      
      tabline = {
      ......
        },
      sections = {},
      inactive_sections = {},
      
      
      extensions = {'quickfix'}
      
      
      local my_extension = { sections = { lualine_a = {'mode'} }, filetypes = {'lua'} }
      require('lualine').setup { extensions = { my_extension } }
      
      
      require('lualine').refresh({
        scope = 'tabpage',  -- scope of refresh all/tabpage/window
        place = { 'statusline', 'winbar', 'tabline' },  -- lualine segment ro refresh.
      })
      
      
      require('lualine').refresh()
      
      
      require('lualine').refresh({
        force = true,       -- do an immidiate refresh
        scope = 'tabpage',  -- scope of refresh all/tabpage/window
        place = { 'statusline', 'winbar', 'tabline' },  -- lualine segment ro refresh.
      })
      
      
      options = { disabled_filetypes = {'lua'} }
      
      
        require('lualine').hide({
          place = {'statusline', 'tabline', 'winbar'}, -- The segment this change applies to.
          unhide = false,  -- whether to re-enable lualine again/
        })
      
      
      require('lualine').hide()
      
      
      require('lualine').hide({unhide=true})
      
    end,
  },
  {
    "adelarsq/neoline.vim",
    config = function()
      
      require('lazy').setup({
        {
          'adelarsq/neoline.vim'
        },
      }, {})
      
      
      use 'adelarsq/neoline.vim'
      
      
      vim.g.neoline_disable_current_scope = 1 
      -- or with VimScript
      set g:neoline_disable_current_scope = 1 
      
    end,
  },
  {
    "ojroques/nvim-hardline",
    config = function()
      
      use {'ojroques/nvim-hardline'}
      
      
      paq {'ojroques/nvim-hardline'}
      
      
      -- init.lua:
      {'ojroques/nvim-hardline'},
      
      -- plugins/hardline.lua:
      return {
      'ojroques/nvim-hardline',
      }
      
      
      require('hardline').setup {}
      
      
      require('hardline').setup {
        bufferline = false,  -- disable bufferline
        bufferline_settings = {
          exclude_terminal = false,  -- don't show terminal buffers in bufferline
          show_index = false,        -- show buffer indexes (not the actual buffer numbers) in bufferline
        },
        theme = 'default',   -- change theme
        sections = {         -- define sections
          {class = 'mode', item = require('hardline.parts.mode').get_item},
          {class = 'high', item = require('hardline.parts.git').get_item, hide = 100},
          {class = 'med', item = require('hardline.parts.filename').get_item},
          '%<',
          {class = 'med', item = '%='},
          {class = 'low', item = require('hardline.parts.wordcount').get_item, hide = 100},
          {class = 'error', item = require('hardline.parts.lsp').get_error},
          {class = 'warning', item = require('hardline.parts.lsp').get_warning},
          {class = 'warning', item = require('hardline.parts.whitespace').get_item},
          {class = 'high', item = require('hardline.parts.filetype').get_item, hide = 60},
          {class = 'mode', item = require('hardline.parts.line').get_item},
        },
      }
      
    end,
  },
  {
    "beauwilliams/statusline.lua",
    config = function()
      
      return {
      	'beauwilliams/statusline.lua',
      	dependencies = {
      		'nvim-lua/lsp-status.nvim',
      	},
      	config = function()
      		require('statusline').setup({
      			match_colorscheme = false, -- Enable colorscheme inheritance (Default: false)
      			tabline = true, -- Enable the tabline (Default: true)
      			lsp_diagnostics = true, -- Enable Native LSP diagnostics (Default: true)
      			ale_diagnostics = false, -- Enable ALE diagnostics (Default: false)
      		})
      	end,
      }
      
      
      use 'beauwilliams/statusline.lua'
      
      
      -- Matches visual elements such as mode icon to your colorscheme
      require('statusline').setup({
        match_colorscheme = true, -- Enable colorscheme matching (Default: false)
      })
      
      
      require('statusline').setup({
        tabline = false,              -- Enable the tabline (Default: true)
      })
      
      
      -- With ALE you can get errors displayed without explicitly needing an LSP server
      require('statusline').setup({
        lsp_diagnostics = false,      -- Enable Native LSP diagnostics (Default: true)
        ale_diagnostics = true,     -- Enable ALE diagnostics (Default: false)
      })
      
      
      -- This setting will mean that you have one single statusline drawn accross the entire display
      lua vim.o.laststatus=3
      
    end,
  },
  {
    "tamton-aquib/staline.nvim",
    config = function()
      
      use 'tamton-aquib/staline.nvim'
      
      
      require('staline').setup()
      
      
      > require('staline').setup {
      >     defaults = {
      >         expand_null_ls = false,  -- This expands out all the null-ls sources to be shown
      >         left_separator  = "",
      >         right_separator = "",
      >         full_path       = false,
      >         line_column     = "[%l/%L] :%c 並%p%% ", -- `:h stl` to see all flags.
      >
      >         fg              = "#000000",  -- Foreground text color.
      >         bg              = "none",     -- Default background is transparent.
      >         inactive_color  = "#303030",
      >         inactive_bgcolor = "none",
      >         true_colors     = false,      -- true lsp colors.
      >         font_active     = "none",     -- "bold", "italic", "bold,italic", etc
      >
      >         mod_symbol      = "  ",
      >         lsp_client_symbol = " ",
      >         lsp_client_character_length = 12, -- Shorten LSP client names.
      >         branch_symbol   = " ",
      >         cool_symbol     = " ",       -- Change this to override default OS icon.
      >         null_ls_symbol = "",          -- A symbol to indicate that a source is coming from null-ls
      >     },
      >     mode_colors = {
      >         n = "#2bbb4f",
      >         i = "#986fec",
      >         c = "#e27d60",
      >         v = "#4799eb",   -- etc..
      >     },
      >     mode_icons = {
      >         n = " ",
      >         i = " ",
      >         c = " ",
      >         v = " ",   -- etc..
      >     },
      >     sections = {
      >         left = { '- ', '-mode', 'left_sep_double', ' ', 'branch' },
      >         mid  = { 'file_name' },
      >         right = { 'cool_symbol','right_sep_double', '-line_column' },
      >     },
      >     inactive_sections = {
      >         left = { 'branch' },
      >         mid  = { 'file_name' },
      >         right = { 'line_column' }
      >     },
      >     special_table = {
      >         NvimTree = { 'NvimTree', ' ' },
      >         packer = { 'Packer',' ' },        -- etc
      >     },
      >     lsp_symbols = {
      >         Error=" ",
      >         Info=" ",
      >         Warn=" ",
      >         Hint="",
      >     },
      > }
      > 
      
      	function()
      	    return "computed_dynamic_string"
      	end
      	
      
      	require('stabline').setup()
      	
      
      > 	require('stabline').setup {
      >       style       = "bar", -- others: arrow, slant, bubble
      >       stab_left   = "┃",
      >       stab_right  = " ",
      >
      >       -- fg       = Default is fg of "Normal".
      >       -- bg       = Default is bg of "Normal".
      >       inactive_bg = "#1e2127",
      >       inactive_fg = "#aaaaaa",
      >       -- stab_bg  = Default is darker version of bg.,
      >
      >       font_active = "bold",
      >       exclude_fts = { 'NvimTree', 'dashboard', 'lir' },
      >       stab_start  = "",   -- The starting of stabline
      >       stab_end    = "",
      >       numbers = function(bufn, n)
      >           return '*'..n..' '
      >       end
      > 	}
      >   
      
      > require('stabline').setup {
      >     style = "slant",
      >     bg = "#986fec",
      >     fg = "black",
      >     stab_right = "",
      > }
      > 
    end,
  },
  {
    "windwp/windline.nvim",
    config = function()
      
      local windline = require('windline')
      windline.setup({
        statuslines = {
          --- you need to define your status lines here
        }
      })
      
      
      
      
      require('wlsample.bubble')
      
      
      require('wlsample.bubble2')
      
      
      require('wlsample.evil_line')
      
      
      require('wlsample.airline')
      --  the animated alternative. you can toggle animation by press `<leader>u9`
      require('wlsample.airline_anim')
      
      
      require('wlsample.vscode')
      
      
      require('wlsample.basic')
      
      
      require('wlsample.wind')
      
      
      require('wlsample.airline_luffy')
      
      
      -- only support linux it need install cava
      lua require("windline.components.cava").toggle()
      
      
      local default = {
          filetypes={'default'},
          active={
            --- components...
          },
          inactive={
            --- components...
          }
      }
      
      local explorer = {
          filetypes = {'fern', 'NvimTree','netrw'},
          active = {
              {'  ', {'white', 'black'} },
          },
          --- show active components when the window is inactive
          always_active = true,
          --- It will display a last window statusline even that window should inactive
          show_last_status = true
      }
      
      
      
      
      local default = {
          filetypes={'default'},
          active={
            --- components...
            {'[',{'red', 'black'}},
            {'%f',{'green','black'}},
            {']',{'red','black'}},
      
            -- empty color definition uses the previous component colors
            {"%=", ''} ,
      
            -- hightlight groups can also be used
            {' ','StatusLine'},
      
            {' %3l:%-2c ',{'white','black'}}
          },
      }
      
      
      local lsp_comps = require('windline.components.lsp')
      
      basic.lsp_diagnos = {
          name = 'diagnostic',
          hl_colors = {
              red_text = {'red', 'black'}
          },
          text = function(bufnr, winid, width)
              if lsp_comps.check_lsp() then
                  return {
      
                      { '[ lsp: ', 'red_text' },
                      -- red_text define in hl_colors. It make easy cache value first
                      -- because text function run multiple time on redraw
      
                      { lsp_comps.lsp_name() , 'IncSearch'},
                      -- it use a hightlight group IncSearch
      
                      -- but you can create a hightlight on child component too
                      { lsp_comps.lsp_error({ format = '  %s' }), {'red','black'} },
      
                      { lsp_comps.lsp_warning({ format = '  %s' }), {'yellow',''} },
                      -- it have same background black with the previous component
      
                      { lsp_comps.lsp_hint({ format = '  %s' }), {'', 'blue'} },
                      -- it have same foreground yellow with the previous component
      
                      { ' ] ' },
                  }
              end
              return ''
          end,
      }
      
      
      
      local git_comps = require('windline.components.git')
      
      -- short syntax
      local git_branch = { git_comps.git_branch(), {'white', 'black'}, 100}
      
      -- syntax using table
      local git_branch = {
          text = git_comps.git_branch(),
          hl_colors = {'white','black'},
          --- component not visible if window width is less than 100
          width = 100,
      }
      
      
      
      local windline = require('windline')
      
      windline.setup({
        -- this function will run on ColorScheme autocmd
        colors_name = function(colors)
            --- add new colors
            colors.FilenameFg = colors.white_light
            colors.FilenameBg = colors.black
      
            -- this color will not update if you change a colorscheme
            colors.gray = "#fefefe"
      
            -- dynamically get color from colorscheme hightlight group
            local searchFg, searchBg = require('windline.themes').get_hl_color('Search')
            colors.SearchFg = searchFg or colors.white
            colors.SearchBg = searchBg or colors.yellow
      
            return colors
        end,
      
      })
      
      
      -- you can write your own effect
      local Hsl = require('wlanimation.hsl')
      animation.animation({
         data = {
              {'red',efffects.wrap(function(color)
                  return HSL.new(color.H + 1, color.S, color.L)
              end)},
          },
          timeout = 100,
          delay = 200,
          interval = 100,
      })
      
      
      windline.setup({
        -- hide that filetype on global statusline
          global_skip_filetypes = {
              'NvimTree',
              'lir',
          }
      })
      
      
      
      local telescope = {
          filetypes = {'TelescopePrompt'},
          active = {
              {'  ', {'white', 'black'} },
          },
          --- for global statusline (laststatus = 3). 
          --- by default it skip all floating window on global statusline but you can
          --- change it here
          global_show_float = false
      }
      
    end,
  },
  {
    "konapun/vacuumline.nvim",
    config = function()
      
      use {'konapun/vacuumline.nvim', requires = {
        'glepnir/galaxyline.nvim', branch = 'main',
        'kyazdani42/nvim-web-devicons', opt = true
      }, config = function() require('vacuumline').setup() end} -- Add this line to use defaults; otherwise, call `setup` with your config as described below wherever you configure your plugins
      
      
      use {'konapun/vacuumline.nvim', branch = 'next', requires = {
        'glepnir/galaxyline.nvim', branch = 'main',
        'kyazdani42/nvim-web-devicons', opt = true
      }, config = function() require('vacuumline').setup() end} -- Add this line to use defaults; otherwise, call `setup` with your config as described below wherever you configure your plugins
      
      
      require('vacuumline').setup({
        theme = require('vacuumline.theme.nord')
      })
      
      
      require('vacuumline').setup({
        theme = {
          line             = {foreground = '#98971a', background = '#282828'},
          segment_odd      = {foreground = '#282828', background = '#b16286'},
          segment_even     = {foreground = '#282828', background = '#98971a'},
          mode_normal      = {foreground = '#b16286'},
          mode_insert      = {foreground = '#98971a'},
          mode_command     = {foreground = '#458588'},
          mode_visual      = {foreground = '#d79921'},
          mode_visual_line = {foreground = '#689d6a'},
          mode_terminal    = {foreground = '#cc241d'},
          warning          = {foreground = '#282828', background = '#fabd2f'},
          error            = {foreground = '#282828', background = '#fb4934'},
          scroll           = {foreground = '#d79921'}
        }
      })
      
      
      
      {
        separator = {
          segment = {
            left = '',
            right = ''
          },
          section = {
            left = '',
            right = ''
          }
        },
        color = {
          foreground = {line = '#98971a', even = '#282828', odd = '#282828'},
          background = {line = '#282828', even = '#b16286', odd = '#98971a'},
        },
        segment = {
          mode = {
            map = {
              n = {label = ' ', background = '#b16286'}, -- NORMAL
              i = {label = ' ', background = '#98971a'}, -- INSERT
              c = {label = ' ', background = '#458588'}, -- COMMAND
              v = {label = ' ', background = '#d79921'}, -- VISUAL
              V = {label = ' ', background = '#fabd2f'}, -- VISUAL LINE
              t = {label = ' ', background = '#d3869b'}, -- TERMINAL
            }
          },
          file = {},
          vcs = {},
          scroll = {
            accent = '#d79921',
          },
          lines = {},
          diagnostics = {
            background = '#fb4934',
            errors = {
              foreground = '#282828',
              background = '#fb4934'
            },
            warnings = {
              foreground = '#282828',
              background = '#fabd2f'
            }
          },
          search = {},
          lsp = {
            foreground = '#98971a',
            background = '#282828'
          }
        }
      }
      
      
      separator = {
        segment = {
          left = '',
          right = ''
        },
        section = {
          left = '',
          right = ''
        }
      },
      color = {
        foreground = {line = '#98971a', even = '#282828', odd = '#282828'},
        background = {line = '#282828', even = '#b16286', odd = '#98971a'},
      }
      
      
      mode = {
        foreground = '', -- dynamic by default
        background = '', -- dynamic by default
        separator = '', -- dynamic by default
        map = {
          n = {label = ' ', background = '#b16286'}, -- NORMAL
          i = {label = ' ', background = '#98971a'}, -- INSERT
          c = {label = ' ', background = '#458588'}, -- COMMAND
          v = {label = ' ', background = '#d79921'}, -- VISUAL
          V = {label = ' ', background = '#fabd2f'}, -- VISUAL LINE
          t = {label = ' ', background = '#d3869b'}, -- TERMINAL
        }
      }
      
      
      file = {
        foreground = '', -- dynamic by default
        background = '', -- dynamic by default
        separator = '' -- dynamic by default
      }
      
      
      vcs = {
        foreground = '', -- dynamic by default
        background = '', -- dynamic by default
        separator = '' -- dynamic by default
      }
      
      
      scroll = {
        accent = '', -- used to color the scroll indicator
        foreground = '', -- dynamic by default
        background = '', -- dynamic by default
        separator = '' -- dynamic by default
      }
      
      
      lines = {
        foreground = '', -- dynamic by default
        background = '', -- dynamic by default
        separator = '', -- dynamic by default
        section_separator = '', -- dynamic by default
      }
      
      
      diagnostics = {
        separator = '', -- dynamic by default
        errors = {
          foreground = '',
          background = ''
        },
        warnings = {
          foreground = '',
          background = ''
        }
      }
      
      
      search = {
        foreground = '', -- dynamic by default
        background = '', -- dynamic by default
        separator = '' -- dynamic by default
      }
      
      
      lsp = {
        foreground = '', -- dynamic by default
        background = '' -- dynamic by default
      }
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-statusline.md",
  },
  {
    "b0o/incline.nvim",
    config = function()
      
      render = function(props)
        local filename = vim.fn.fnamemodify(vim.api.nvim_buf_get_name(props.buf), ':t')
        local modified = vim.bo[props.buf].modified
        return {
          ' ',
          filename,
          modified and { ' *', guifg = '#888888', gui = 'bold' } or '',
          ' ',
          guibg = '#111111',
          guifg = '#eeeeee',
        }
      end
      
      
      local helpers = require 'incline.helpers'
      local devicons = require 'nvim-web-devicons'
      require('incline').setup {
        window = {
          padding = 0,
          margin = { horizontal = 0 },
        },
        render = function(props)
          local filename = vim.fn.fnamemodify(vim.api.nvim_buf_get_name(props.buf), ':t')
          if filename == '' then
            filename = '[No Name]'
          end
          local ft_icon, ft_color = devicons.get_icon_color(filename)
          local modified = vim.bo[props.buf].modified
          return {
            ft_icon and { ' ', ft_icon, ' ', guibg = ft_color, guifg = helpers.contrast_color(ft_color) } or '',
            ' ',
            { filename, gui = modified and 'bold,italic' or 'bold' },
            ' ',
            guibg = '#44406e',
          }
        end,
      }
      
      
      local helpers = require 'incline.helpers'
      local navic = require 'nvim-navic'
      local devicons = require 'nvim-web-devicons'
      require('incline').setup {
        window = {
          padding = 0,
          margin = { horizontal = 0, vertical = 0 },
        },
        render = function(props)
          local filename = vim.fn.fnamemodify(vim.api.nvim_buf_get_name(props.buf), ':t')
          if filename == '' then
            filename = '[No Name]'
          end
          local ft_icon, ft_color = devicons.get_icon_color(filename)
          local modified = vim.bo[props.buf].modified
          local res = {
            ft_icon and { ' ', ft_icon, ' ', guibg = ft_color, guifg = helpers.contrast_color(ft_color) } or '',
            ' ',
            { filename, gui = modified and 'bold,italic' or 'bold' },
            guibg = '#44406e',
          }
          if props.focused then
            for _, item in ipairs(navic.get_data(props.buf) or {}) do
              table.insert(res, {
                { ' > ', group = 'NavicSeparator' },
                { item.icon, group = 'NavicIcons' .. item.type },
                { item.name, group = 'NavicText' },
              })
            end
          end
          table.insert(res, ' ')
          return res
        end,
      }
      
      
      local devicons = require 'nvim-web-devicons'
      require('incline').setup {
        render = function(props)
          local filename = vim.fn.fnamemodify(vim.api.nvim_buf_get_name(props.buf), ':t')
          if filename == '' then
            filename = '[No Name]'
          end
          local ft_icon, ft_color = devicons.get_icon_color(filename)
      
          local function get_git_diff()
            local icons = { removed = '', changed = '', added = '' }
            local signs = vim.b[props.buf].gitsigns_status_dict
            local labels = {}
            if signs == nil then
              return labels
            end
            for name, icon in pairs(icons) do
              if tonumber(signs[name]) and signs[name] > 0 then
                table.insert(labels, { icon .. signs[name] .. ' ', group = 'Diff' .. name })
              end
            end
            if #labels > 0 then
              table.insert(labels, { '┊ ' })
            end
            return labels
          end
      
          local function get_diagnostic_label()
            local icons = { error = '', warn = '', info = '', hint = '' }
            local label = {}
      
            for severity, icon in pairs(icons) do
              local n = #vim.diagnostic.get(props.buf, { severity = vim.diagnostic.severity[string.upper(severity)] })
              if n > 0 then
                table.insert(label, { icon .. n .. ' ', group = 'DiagnosticSign' .. severity })
              end
            end
            if #label > 0 then
              table.insert(label, { '┊ ' })
            end
            return label
          end
      
          return {
            { get_diagnostic_label() },
            { get_git_diff() },
            { (ft_icon or '') .. ' ', guifg = ft_color, guibg = 'none' },
            { filename .. ' ', gui = vim.bo[props.buf].modified and 'bold,italic' or 'bold' },
            { '┊  ' .. vim.api.nvim_win_get_number(props.win), group = 'DevIconWindows' },
          }
        end,
      }
      
      
      {
        'b0o/incline.nvim',
        config = function()
          require('incline').setup()
        end,
        -- Optional: Lazy load Incline
        event = 'VeryLazy',
      },
      
      
      use "b0o/incline.nvim"
      
      
      require('incline').setup()
      
      
      require('incline').setup {
        debounce_threshold = {
          falling = 50,
          rising = 10
        },
        hide = {
          cursorline = false,
          focused_win = false,
          only_win = false
        },
        highlight = {
          groups = {
            InclineNormal = {
              default = true,
              group = "NormalFloat"
            },
            InclineNormalNC = {
              default = true,
              group = "NormalFloat"
            }
          }
        },
        ignore = {
          buftypes = "special",
          filetypes = {},
          floating_wins = true,
          unlisted_buffers = true,
          wintypes = "special"
        },
        render = "basic",
        window = {
          margin = {
            horizontal = 1,
            vertical = 1
          },
          options = {
            signcolumn = "no",
            wrap = false
          },
          overlap = {
            borders = true,
            statusline = false,
            tabline = false,
            winbar = false
          },
          padding = 1,
          padding_char = " ",
          placement = {
            horizontal = "right",
            vertical = "top"
          },
          width = "fit",
          winhighlight = {
            active = {
              EndOfBuffer = "None",
              Normal = "InclineNormal",
              Search = "None"
            },
            inactive = {
              EndOfBuffer = "None",
              Normal = "InclineNormalNC",
              Search = "None"
            }
          },
          zindex = 50
        }
      }
      
    end,
  },
  {
    "rebelot/heirline.nvim",
    config = function()
      
      use({
          "rebelot/heirline.nvim",
          -- You can optionally lazy-load heirline on UiEnter
          -- to make sure all required plugins and colorschemes are loaded before setup
          -- event = "UiEnter",
          config = function()
              require("heirline").setup({...})
          end
      })
      
      
      require("heirline").setup({
          statusline = {...},
          winbar = {...},
          tabline = {...},
          statuscolumn = {...},
      })
      
    end,
  },
  {
    "Zeioth/heirline-components.nvim",
    config = function()
      
      {
        "rebelot/heirline.nvim",
        dependencies = { "Zeioth/heirline-components.nvim" },
        opts = {},
          config = function(_, opts)
            local heirline = require "heirline"
            local heirline_components = require "heirline-components.all"
      
            -- Setup
            heirline_components.init.subscribe_to_events()
            heirline.load_colors(heirline_components.hl.get_colors())
            heirline.setup(opts)
          end,
      }
      
      
      require("heirline-components.all").component.some_component()
      
      
      "rebelot/heirline.nvim",
      dependencies = {
        {
          "Zeioth/heirline-components.nvim",
          opts = {
            icons = { DiagnosticError = ";D" }
            colors = nil
          }
        }
      }
      
    end,
  },
  {
    "yaocccc/nvim-lines.lua",
    config = function()
      
      vim.g.line_powerline_enable = 1
      vim.g.line_nerdfont_enable = 1
      vim.g.line_unnamed_filename='~'
      vim.g.line_statusline_getters = {'v:lua.GitInfo', 'v:lua.CocErrCount', 'v:lua.GetFt'}
      -- git status base by coc-git
      function GitInfo()
          local branch = vim.g.coc_git_status or ''
          local diff = vim.b.coc_git_status or ''
          return (string.len(branch) > 0 and string.format(" %s ", branch) or " none ")
              .. (string.len(diff) > 0 and string.format('%s ', vim.fn.trim(diff)) or '')
      end
      -- diagnostic info base by coc
      function CocErrCount()
          local coc_diagnostic_info = vim.b.coc_diagnostic_info or { error = 0 }
          return string.format(' E%d ', coc_diagnostic_info.error)
      end
      -- show ft
      function GetFt()
          local ft = vim.api.nvim_eval('&ft')
          return string.format(' %s ', string.len(ft) > 0 and ft or '~')
      end
      
    end,
  },
  {
    "MunifTanjim/nougat.nvim",
    config = function()
      
      {
        "MunifTanjim/nougat.nvim",
      },
      
      
      use({
        "MunifTanjim/nougat.nvim",
      })
      
      
      local nougat = require("nougat")
      
      
      local stl = Bar("statusline")
      
      nougat.set_statusline(stl)
      
      
      local stl = Bar("statusline")
      local stl_inactive = Bar("statusline")
      
      -- use separate statusline focused/unfocused window
      nougat.set_statusline(function(ctx)
        return ctx.is_focused and stl or stl_inactive
      end)
      
      
      local stl_fugitive = Bar("statusline")
      local stl_help = Bar("statusline")
      
      -- set filetype specific statusline
      for ft, stl_ft in pairs({
        fugitive = stl_fugitive,
        help = stl_help,
      }) do
        nougat.set_statusline(stl_ft, { filetype = ft })
      end
      
    end,
  },
  {
    "Mr-LLLLL/lualine-ext.nvim",
  },
  {
    "mikesmithgh/git-prompt-string-lualine.nvim",
    config = function()
      
        {
          'mikesmithgh/git-prompt-string-lualine.nvim',
          enabled = true,
          lazy = true,
        }
      
      
        use({
          'mikesmithgh/git-prompt-string-lualine.nvim',
          disable = false,
          opt = true,
        })
      
      
      require('lualine').setup({
        sections = {
          lualine_b = { 'git_prompt_string', 'diff', 'diagnostics' },
        },
      })
      
      
      {
        trim_prompt_prefix = true, -- remove whitespace from beginning of prompt prefix
        -- git-prompt-string configuration options, see https://github.com/mikesmithgh/git-prompt-string?tab=readme-ov-file#configuration-options
        prompt_config = {
          prompt_prefix = nil,
          prompt_suffix = nil,
          ahead_format = nil,
          behind_format = nil,
          diverged_format = nil,
          no_upstream_remote_format = nil,
          color_disabled = false,
          color_clean = { fg = vim.g.terminal_color_2 or 'DarkGreen' },
          color_delta = { fg = vim.g.terminal_color_3 or 'DarkYellow' },
          color_dirty = { fg = vim.g.terminal_color_1 or 'DarkRed' },
          color_untracked = { fg = vim.g.terminal_color_5 or 'DarkMagenta' },
          color_no_upstream = { fg = vim.g.terminal_color_8 or 'DarkGray' },
          color_merging = { fg = vim.g.terminal_color_4 or 'DarkBlue' },
        },
      }
      
      
      -- Defines a custom color for the component:
      --
      -- 'highlight_group_name' | { fg = '#rrggbb'|cterm_value(0-255)|'color_name(red)', bg= '#rrggbb', gui='style' } | function
      -- Note:
      --  '|' is synonymous with 'or', meaning a different acceptable format for that placeholder.
      -- color function has to return one of other color types ('highlight_group_name' | { fg = '#rrggbb'|cterm_value(0-255)|'color_name(red)', bg= '#rrggbb', gui='style' })
      -- color functions can be used to have different colors based on state as shown below.
      --
      -- Examples:
      --   color = { fg = '#ffaa88', bg = 'grey', gui='italic,bold' },
      --   color = { fg = 204 }   -- When fg/bg are omitted, they default to the your theme's fg/bg.
      --   color = 'WarningMsg'   -- Highlight groups can also be used.
      --   color = function(section)
      --      return { fg = vim.bo.modified and '#aa3355' or '#33aa88' }
      --   end,
      
      
      require('lualine').setup({
        sections = {
          lualine_b = {
            {
              'git_prompt_string',
              trim_prompt_prefix = false,
              prompt_config = {
                prompt_prefix = 'git(',
                prompt_suffix = ')',
                color_clean = { fg = 'LightGreen' },
                color_delta = 'WarningMsg',
                color_dirty = function()
                  return 'ErrorMsg'
                end,
                color_untracked = { fg = '#b16286', bg = 'Black' },
                color_no_upstream = { fg = '#c7c7c7' },
                color_merging = { fg = 4 },
              },
            },
          },
        },
      })
      
    end,
  },
  {
    "sschleemilch/slimline.nvim",
    config = function()
      
      {
          -- Calls `require('slimline').setup({})`
          "sschleemilch/slimline.nvim",
          opts = {}
      },
      
      
      MiniDeps.now(function()
          MiniDeps.add('sschleemilch/slimline.nvim')
          require('slimline').setup({})
      end)
      
      
      vim.pack.add({
        "https://github.com/sschleemilch/slimline.nvim",
      })
      require("slimline").setup({})
      
      
      {
        bold = false, -- makes primary parts bold
      
        -- Global style. Can be overwritten using `configs.<component>.style`
        style = 'bg', -- or "fg"
      
        -- Component placement
        components = {
          left = {
            'mode',
            'path',
            'git',
          },
          center = {},
          right = {
            'diagnostics',
            'filetype_lsp',
            'progress',
          },
        },
      
        -- Inactive components
        -- Uses all `components` by default.
        -- E.g. for only showing `path`:
        -- components_inactive = {
        --   left = { 'path' },
        --   right = {},
        -- },
        components_inactive = {},
      
        -- Component configuration
        -- `<component>.style` can be used to overwrite the global 'style'
        -- `<component>.sep` can be used to overwrite the global 'sep.left' and `sep.right`
        -- `<component>.hl = { primary = ..., secondary = ...}` can be used to overwrite global ones
        -- `<component>.follow` can point to another component name to follow its style (e.g. 'progress' following 'mode' by default). Follow can be disabled by setting it to `false`
        -- `<component>.trunc_width` can be used to hide a component completely once the window width drops below that value
        configs = {
          mode = {
            verbose = false, -- Selects the `verbose` format
            hl = {
              normal = 'Type',
              visual = 'Keyword',
              insert = 'Function',
              replace = 'Statement',
              command = 'String',
              other = 'Function',
            },
            format = {
              ['n'] = { verbose = 'NORMAL', short = 'N' },
              ['v'] = { verbose = 'VISUAL', short = 'V' },
              ['V'] = { verbose = 'V-LINE', short = 'V-L' },
              ['\22'] = { verbose = 'V-BLOCK', short = 'V-B' },
              ['s'] = { verbose = 'SELECT', short = 'S' },
              ['S'] = { verbose = 'S-LINE', short = 'S-L' },
              ['\19'] = { verbose = 'S-BLOCK', short = 'S-B' },
              ['i'] = { verbose = 'INSERT', short = 'I' },
              ['R'] = { verbose = 'REPLACE', short = 'R' },
              ['c'] = { verbose = 'COMMAND', short = 'C' },
              ['r'] = { verbose = 'PROMPT', short = 'P' },
              ['!'] = { verbose = 'SHELL', short = 'S' },
              ['t'] = { verbose = 'TERMINAL', short = 'T' },
              ['U'] = { verbose = 'UNKNOWN', short = 'U' },
            },
          },
          path = {
            trunc_width = 60,
            directory = true, -- Whether to show the directory
            -- truncates the directory path. Can be disabled by setting `truncate = false`
            truncate = {
              chars = 1, -- number of characters for each path component
              full_dirs = 2, -- how many path components to keep unshortened
            },
            icons = {
              folder = ' ',
              modified = '',
              read_only = '',
            },
          },
          git = {
            trunc_width = 120,
            icons = {
              branch = '',
              added = '+',
              modified = '~',
              removed = '-',
            },
          },
          diagnostics = {
            trunc_width = 75,
            workspace = false, -- Whether diagnostics should show workspace diagnostics instead of current buffer
            icons = {
              ERROR = ' ',
              WARN = ' ',
              HINT = ' ',
              INFO = ' ',
            },
            severity = {
              -- vim.diagnostic.SeverityFilter options
              min = vim.diagnostic.severity.HINT,
            },
            hl = {
              error = 'DiagnosticError',
              warn = 'DiagnosticWarn',
              hint = 'DiagnosticHint',
              info = 'DiagnosticInfo',
            },
          },
          filetype_lsp = {
            trunc_width = 95,
            -- Map lsp client names to custom names or ignore them by setting to `false`
            -- E.g. { ['tsserver'] = 'TS', ['pyright'] = 'Python', ['GitHub Copilot'] = false }
            map_lsps = {},
            lsp_sep = ',', -- separator between attached LSPs
          },
          selectioncount = {
            hl = {
              primary = 'Special',
            },
            icon = '󰈈 ',
          },
          searchcount = {
            hl = {
              primary = 'Special',
            },
            icon = ' ',
            -- Options to be passed to vim.fn.searchcount, see :h searchcount
            options = {
              recompute = true,
            },
          },
          progress = {
            follow = 'mode',
            column = false, -- Enables a secondary section with the cursor column
            icon = ' ',
          },
          recording = {
            icon = ' ',
            hl = {
              primary = 'Special',
            },
          },
        },
      
        -- Spacing configuration
        spaces = {
          components = ' ', -- string between components
          left = ' ', -- string at the start of the line
          right = ' ', -- string at the end of the line
        },
      
        -- Seperator configuartion
        sep = {
          hide = {
            first = false, -- hides the first separator of the line
            last = false, -- hides the last separator of the line
          },
          left = '', -- left separator of components
          right = '', -- right separator of components
        },
      
        -- Global highlights
        hl = {
          base = 'Normal', -- highlight of the background
          primary = 'Normal', -- highlight of primary parts (e.g. filename)
          secondary = 'Comment', -- highlight of secondary parts (e.g. filepath)
        },
      
        -- Hide statusline on filetypes
        disabled_filetypes = {},
      }
      
      
      {
        style = 'fg',
        bold = true,
        configs = {
          path = {
            hl = {
              primary = 'Label',
            },
          },
          git = {
            hl = {
              primary = 'Function',
            },
          },
          filetype_lsp = {
            hl = {
              primary = 'String',
            },
          },
        },
      }
      
      
      {
        configs = {
          path = {
            hl = {
              primary = 'Define',
            },
          },
          git = {
            hl = {
              primary = 'Function',
            },
          },
          filetype_lsp = {
            hl = {
              primary = 'String',
            },
          },
        },
      }
      
      
      {
          style = "fg",
          spaces = {
              components = '',
              left = '',
              right = ''
          }
      }
      
      
      {
          spaces = {
              components = "",
              left = "",
              right = "",
          },
          sep = {
              hide = {
                  first = true,
                  last = true,
              },
              left = "",
              right = "",
          },
      }
      
      
      {
          spaces = {
              components = "─",
              left = "─",
              right = "─",
          },
      },
      
      
      vim.opt.fillchars = {
      	stl = "─",
      }
      
      
      {
          configs = {
              mode = {
                  format = {
                      ['n'] = { short = 'NOR' },
                      ['v'] = { short = 'VIS' },
                      ['V'] = { short = 'V-L' },
                      ['\22'] = { short = 'V-B' },
                      ['s'] = { short = 'SEL' },
                      ['S'] = { short = 'S-L' },
                      ['\19'] = { short = 'S-B' },
                      ['i'] = { short = 'INS' },
                      ['R'] = { short = 'REP' },
                      ['c'] = { short = 'CMD' },
                      ['r'] = { short = 'PRO' },
                      ['!'] = { short = 'SHE' },
                      ['t'] = { short = 'TER' },
                      ['U'] = { short = 'UNK' },
                  },
              },
          }
      }
      
      
      opts = {
          components = {
              center = {
                  function ()
                      return "Hello World"
                  end
              },
          }
      }
      
      
      function(active)
          return Slimline.highlights.hl_component(
              { primary = 'Hello', secondary = 'World' },
              Slimline.highlights.hls.components['path'],
              Slimline.get_sep('path'),
              'right', -- flow direction (on which side the secondary part will be rendered)
              active, -- whether the component is active or not
              'fg' -- style to use
          )
      end,
      
      
      hl = {
          primary = {
              text = '',
              sep = '',
              sep2sec = '',
          },
          secondary = {
              text = '',
              sep = '',
          }
      }
      
    end,
  },
  {
    "romgrk/barbar.nvim",
    config = function()
      
      require('lazy').setup {
        {'romgrk/barbar.nvim',
          dependencies = {
            'lewis6991/gitsigns.nvim', -- OPTIONAL: for git status
            'nvim-tree/nvim-web-devicons', -- OPTIONAL: for file icons
          },
          init = function() vim.g.barbar_auto_setup = false end,
          opts = {
            -- lazy.nvim will automatically call setup for you. put your options here, anything missing will use the default:
            -- animation = true,
            -- insert_at_start = true,
            -- …etc.
          },
          version = '^1.0.0', -- optional: only update when a new 1.x version is released
        },
      }
      
      
      -- These optional plugins should be loaded directly because of a bug in Packer lazy loading
      use 'nvim-tree/nvim-web-devicons' -- OPTIONAL: for file icons
      use 'lewis6991/gitsigns.nvim' -- OPTIONAL: for git status
      use 'romgrk/barbar.nvim'
      
      
      local map = vim.api.nvim_set_keymap
      local opts = { noremap = true, silent = true }
      
      -- Move to previous/next
      map('n', '<A-,>', '<Cmd>BufferPrevious<CR>', opts)
      map('n', '<A-.>', '<Cmd>BufferNext<CR>', opts)
      
      -- Re-order to previous/next
      map('n', '<A-<>', '<Cmd>BufferMovePrevious<CR>', opts)
      map('n', '<A->>', '<Cmd>BufferMoveNext<CR>', opts)
      
      -- Goto buffer in position...
      map('n', '<A-1>', '<Cmd>BufferGoto 1<CR>', opts)
      map('n', '<A-2>', '<Cmd>BufferGoto 2<CR>', opts)
      map('n', '<A-3>', '<Cmd>BufferGoto 3<CR>', opts)
      map('n', '<A-4>', '<Cmd>BufferGoto 4<CR>', opts)
      map('n', '<A-5>', '<Cmd>BufferGoto 5<CR>', opts)
      map('n', '<A-6>', '<Cmd>BufferGoto 6<CR>', opts)
      map('n', '<A-7>', '<Cmd>BufferGoto 7<CR>', opts)
      map('n', '<A-8>', '<Cmd>BufferGoto 8<CR>', opts)
      map('n', '<A-9>', '<Cmd>BufferGoto 9<CR>', opts)
      map('n', '<A-0>', '<Cmd>BufferLast<CR>', opts)
      
      -- Pin/unpin buffer
      map('n', '<A-p>', '<Cmd>BufferPin<CR>', opts)
      
      -- Goto pinned/unpinned buffer
      --                 :BufferGotoPinned
      --                 :BufferGotoUnpinned
      
      -- Close buffer
      map('n', '<A-c>', '<Cmd>BufferClose<CR>', opts)
      
      -- Wipeout buffer
      --                 :BufferWipeout
      
      -- Close commands
      --                 :BufferCloseAllButCurrent
      --                 :BufferCloseAllButPinned
      --                 :BufferCloseAllButCurrentOrPinned
      --                 :BufferCloseBuffersLeft
      --                 :BufferCloseBuffersRight
      
      -- Magic buffer-picking mode
      map('n', '<C-p>',   '<Cmd>BufferPick<CR>', opts)
      map('n', '<C-s-p>', '<Cmd>BufferPickDelete<CR>', opts)
      
      -- Sort automatically by...
      map('n', '<Space>bb', '<Cmd>BufferOrderByBufferNumber<CR>', opts)
      map('n', '<Space>bn', '<Cmd>BufferOrderByName<CR>', opts)
      map('n', '<Space>bd', '<Cmd>BufferOrderByDirectory<CR>', opts)
      map('n', '<Space>bl', '<Cmd>BufferOrderByLanguage<CR>', opts)
      map('n', '<Space>bw', '<Cmd>BufferOrderByWindowNumber<CR>', opts)
      
      -- Other:
      -- :BarbarEnable - enables barbar (enabled by default)
      -- :BarbarDisable - very bad command, should never be used
      
      
      vim.g.barbar_auto_setup = false -- disable auto-setup
      
      require'barbar'.setup {
        -- WARN: do not copy everything below into your config!
        --       It is just an example of what configuration options there are.
        --       The defaults are suitable for most people.
      
        -- Enable/disable animations
        animation = true,
      
        -- Automatically hide the tabline when there are this many buffers left.
        -- Set to any value >=0 to enable.
        auto_hide = false,
      
        -- Enable/disable current/total tabpages indicator (top right corner)
        tabpages = true,
      
        -- Enables/disable clickable tabs
        --  - left-click: go to buffer
        --  - middle-click: delete buffer
        clickable = true,
      
        -- Excludes buffers from the tabline
        exclude_ft = {'javascript'},
        exclude_name = {'package.json'},
      
        -- A buffer to this direction will be focused (if it exists) when closing the current buffer.
        -- Valid options are 'left' (the default), 'previous', and 'right'
        focus_on_close = 'left',
      
        -- Hide inactive buffers and file extensions. Other options are `alternate`, `current`, and `visible`.
        hide = {extensions = true, inactive = true},
      
        -- Disable highlighting alternate buffers
        highlight_alternate = false,
      
        -- Disable highlighting file icons in inactive buffers
        highlight_inactive_file_icons = false,
      
        -- Enable highlighting visible buffers
        highlight_visible = true,
      
        icons = {
          -- Configure the base icons on the bufferline.
          -- Valid options to display the buffer index and -number are `true`, 'superscript' and 'subscript'
          buffer_index = false,
          buffer_number = false,
          button = '',
          -- Enables / disables diagnostic symbols
          diagnostics = {
            [vim.diagnostic.severity.ERROR] = {enabled = true, icon = 'ﬀ'},
            [vim.diagnostic.severity.WARN] = {enabled = false},
            [vim.diagnostic.severity.INFO] = {enabled = false},
            [vim.diagnostic.severity.HINT] = {enabled = true},
          },
          gitsigns = {
            added = {enabled = true, icon = '+'},
            changed = {enabled = true, icon = '~'},
            deleted = {enabled = true, icon = '-'},
          },
          filetype = {
            -- Sets the icon's highlight group.
            -- If false, will use nvim-web-devicons colors
            custom_colors = false,
      
            -- Requires `nvim-web-devicons` if `true`
            enabled = true,
          },
          separator = {left = '▎', right = ''},
      
          -- If true, add an additional separator at the end of the buffer list
          separator_at_end = true,
      
          -- Configure the icons on the bufferline when modified or pinned.
          -- Supports all the base icon options.
          modified = {button = '●'},
          pinned = {button = '', filename = true},
      
          -- Use a preconfigured buffer appearance— can be 'default', 'powerline', or 'slanted'
          preset = 'default',
      
          -- Configure the icons on the bufferline based on the visibility of a buffer.
          -- Supports all the base icon options, plus `modified` and `pinned`.
          alternate = {filetype = {enabled = false}},
          current = {buffer_index = true},
          inactive = {button = '×'},
          visible = {modified = {buffer_number = false}},
        },
      
        -- If true, new buffers will be inserted at the start/end of the list.
        -- Default is to insert after current buffer.
        insert_at_end = false,
        insert_at_start = false,
      
        -- Sets the maximum padding width with which to surround each tab
        maximum_padding = 1,
      
        -- Sets the minimum padding width with which to surround each tab
        minimum_padding = 1,
      
        -- Sets the maximum buffer name length.
        maximum_length = 30,
      
        -- Sets the minimum buffer name length.
        minimum_length = 0,
      
        -- If set, the letters for each buffer in buffer-pick mode will be
        -- assigned based on their name. Otherwise or in case all letters are
        -- already assigned, the behavior is to assign letters in order of
        -- usability (see order below)
        semantic_letters = true,
      
        -- Set the filetypes which barbar will offset itself for
        sidebar_filetypes = {
          -- Use the default values: {event = 'BufWinLeave', text = '', align = 'left'}
          NvimTree = true,
          -- Or, specify the text used for the offset:
          undotree = {
            text = 'undotree',
            align = 'center', -- *optionally* specify an alignment (either 'left', 'center', or 'right')
          },
          -- Or, specify the event which the sidebar executes when leaving:
          ['neo-tree'] = {event = 'BufWipeout'},
          -- Or, specify all three
          Outline = {event = 'BufWinLeave', text = 'symbols-outline', align = 'right'},
        },
      
        -- New buffer letters are assigned in this order. This order is
        -- optimal for the qwerty keyboard layout but might need adjustment
        -- for other layouts.
        letters = 'asdfjkl;ghnmxcvbziowerutyqpASDFJKLGHNMXCVBZIOWERUTYQP',
      
        -- Sets the name of unnamed buffers. By default format is "[Buffer X]"
        -- where X is the buffer number. But only a static string is accepted here.
        no_name_title = nil,
      
        -- sorting options
        sort = {
          -- tells barbar to ignore case differences while sorting buffers
          ignore_case = true,
        },
      }
      
      
      require('scope').setup {
        hooks = {
          pre_tab_leave = function()
            vim.api.nvim_exec_autocmds('User', {pattern = 'ScopeTabLeavePre'})
            -- [other statements]
          end,
      
          post_tab_enter = function()
            vim.api.nvim_exec_autocmds('User', {pattern = 'ScopeTabEnterPost'})
            -- [other statements]
          end,
      
          -- [other hooks]
        },
      
        -- [other options]
      }
      
      
      vim.opt.sessionoptions:append 'globals'
      require'mini.sessions'.setup {
        hooks = {
          pre = {
            write = function() vim.api.nvim_exec_autocmds('User', {pattern = 'SessionSavePre'}) end,
          },
        },
      }
      
      
      require'persistence'.setup {
        options = {--[[<other options>,]] 'globals'},
        pre_save = function() vim.api.nvim_exec_autocmds('User', {pattern = 'SessionSavePre'}) end,
      }
      
      
      vim.opt.sessionoptions:append 'globals'
      vim.api.nvim_create_autocmd({ 'User' }, {
        pattern = 'PersistedSavePre',
        group = vim.api.nvim_create_augroup('PersistedHooks', {}),
        callback = function()
          vim.api.nvim_exec_autocmds('User', { pattern = 'SessionSavePre' })
        end,
      })
      
      
      extensions = {
        barbar = {},
      }
      
      
      vim.opt.sessionoptions:append 'globals'
      vim.api.nvim_create_user_command(
        'Mksession',
        function(attr)
          vim.api.nvim_exec_autocmds('User', {pattern = 'SessionSavePre'})
      
          -- Neovim 0.8+
          vim.cmd.mksession {bang = attr.bang, args = attr.fargs}
      
          -- Neovim 0.7
          vim.api.nvim_command('mksession ' .. (attr.bang and '!' or '') .. attr.args)
        end,
        {bang = true, complete = 'file', desc = 'Save barbar with :mksession', nargs = '?'}
      )
      
    end,
  },
  {
    "akinsho/bufferline.nvim",
    config = function()
      
      -- using packer.nvim
      use {'akinsho/bufferline.nvim', tag = "*", requires = 'nvim-tree/nvim-web-devicons'}
      
      -- using lazy.nvim
      {'akinsho/bufferline.nvim', version = "*", dependencies = 'nvim-tree/nvim-web-devicons'}
      
      
      vim.opt.termguicolors = true
      require("bufferline").setup{}
      
      
      -- rest of config ...
      
      --- count is an integer representing total count of errors
      --- level is a string "error" | "warning"
      --- diagnostics_dict is a dictionary from error level ("error", "warning" or "info")to number of errors for each level.
      --- this should return a string
      --- Don't get too fancy as this function will be executed a lot
      diagnostics_indicator = function(count, level, diagnostics_dict, context)
        local icon = level:match("error") and " " or " "
        return " " .. icon .. count
      end
      
      
      
      
      diagnostics_indicator = function(count, level, diagnostics_dict, context)
        local s = " "
        for e, n in pairs(diagnostics_dict) do
          local sym = e == "error" and " "
            or (e == "warning" and " " or " ")
          s = s .. n .. sym
        end
        return s
      end
      
      
      diagnostics_indicator = function(count, level, diagnostics_dict, context)
        if context.buffer:current() then
          return ''
        end
      
        return ''
      end
      
    end,
  },
  {
    "crispgm/nvim-tabline",
    config = function()
      
      {
          'crispgm/nvim-tabline',
          dependencies = { 'nvim-tree/nvim-web-devicons' }, -- optional
          config = true,
      }
      
      
      require('tabline').setup({opts})
      
      
      require('tabline').setup({
          show_index = true,           -- show tab index
          show_modify = true,          -- show buffer modification indicator
          show_icon = false,           -- show file extension icon
          fnamemodify = ':t',          -- file name modifier string
                                       -- can be a function to modify buffer name
          modify_indicator = '[+]',    -- modify indicator
          no_name = 'No name',         -- no name buffer name
          brackets = { '[', ']' },     -- file name brackets surrounding
          inactive_tab_max_length = 0  -- max length of inactive tab titles, 0 to ignore
      })
      
      
      " Only if there are at least two tabs (default)
      vim.opt.showtabline = 1
      
      " Always
      vim.opt.showtabline = 2
      
      " Never
      vim.opt.showtabline = 0
      
    end,
  },
  {
    "alvarosevilla95/luatab.nvim",
    config = function()
      
      use { 'alvarosevilla95/luatab.nvim', requires='nvim-tree/nvim-web-devicons' }
      
      
      { 'alvarosevilla95/luatab.nvim', dependencies = { 'nvim-tree/nvim-web-devicons' } }
      
      
      require('luatab').setup{}
      
    end,
  },
  {
    "johann2357/nvim-smartbufs",
  },
  {
    "willothy/nvim-cokeline",
    config = function()
      
      local get_hex = require('cokeline.hlgroups').get_hl_attr
      
      require('cokeline').setup({
        default_hl = {
          fg = function(buffer)
            return
              buffer.is_focused
              and get_hex('ColorColumn', 'bg')
               or get_hex('Normal', 'fg')
          end,
          bg = function(buffer)
            return
              buffer.is_focused
              and get_hex('Normal', 'fg')
               or get_hex('ColorColumn', 'bg')
          end,
        },
      
        components = {
          {
            text = function(buffer) return ' ' .. buffer.devicon.icon end,
            fg = function(buffer) return buffer.devicon.color end,
          },
          {
            text = function(buffer) return buffer.unique_prefix end,
            fg = get_hex('Comment', 'fg'),
            italic = true
          },
          {
            text = function(buffer) return buffer.filename .. ' ' end,
            underline = function(buffer)
              return buffer.is_hovered and not buffer.is_focused
            end
          },
          {
            text = '',
            on_click = function(_, _, _, _, buffer)
              buffer:delete()
            end
          },
          {
            text = ' ',
          }
        },
      })
      
      
      local get_hex = require('cokeline.hlgroups').get_hl_attr
      
      local green = vim.g.terminal_color_2
      local yellow = vim.g.terminal_color_3
      
      require('cokeline').setup({
        default_hl = {
          fg = function(buffer)
            return
              buffer.is_focused
              and get_hex('Normal', 'fg')
               or get_hex('Comment', 'fg')
          end,
          bg = get_hex('ColorColumn', 'bg'),
        },
      
        components = {
          {
            text = '｜',
            fg = function(buffer)
              return
                buffer.is_modified and yellow or green
            end
          },
          {
            text = function(buffer) return buffer.devicon.icon .. ' ' end,
            fg = function(buffer) return buffer.devicon.color end,
          },
          {
            text = function(buffer) return buffer.index .. ': ' end,
          },
          {
            text = function(buffer) return buffer.unique_prefix end,
            fg = get_hex('Comment', 'fg'),
            italic = true,
          },
          {
            text = function(buffer) return buffer.filename .. ' ' end,
            bold = function(buffer) return buffer.is_focused end,
          },
          {
            text = ' ',
          },
        },
      })
      
      
      local get_hex = require('cokeline.hlgroups').get_hl_attr
      
      require('cokeline').setup({
        default_hl = {
          fg = function(buffer)
            return
              buffer.is_focused
              and get_hex('Normal', 'fg')
               or get_hex('Comment', 'fg')
          end,
          bg = 'NONE',
        },
        components = {
          {
            text = function(buffer) return (buffer.index ~= 1) and '▏' or '' end,
            fg = function() return get_hex('Normal', 'fg') end
          },
          {
            text = function(buffer) return '    ' .. buffer.devicon.icon end,
            fg = function(buffer) return buffer.devicon.color end,
          },
          {
            text = function(buffer) return buffer.filename .. '    ' end,
            bold = function(buffer) return buffer.is_focused end
          },
          {
            text = '󰖭',
            on_click = function(_, _, _, _, buffer)
              buffer:delete()
            end
          },
          {
            text = '  ',
          },
        },
      })
      
      
      local is_picking_focus = require('cokeline.mappings').is_picking_focus
      local is_picking_close = require('cokeline.mappings').is_picking_close
      local get_hex = require('cokeline.hlgroups').get_hl_attr
      
      local red = vim.g.terminal_color_1
      local yellow = vim.g.terminal_color_3
      
      require('cokeline').setup({
        default_hl = {
          fg = function(buffer)
            return
              buffer.is_focused
              and get_hex('Normal', 'fg')
               or get_hex('Comment', 'fg')
          end,
          bg = function() return get_hex('ColorColumn', 'bg') end,
        },
      
        components = {
          {
            text = function(buffer) return (buffer.index ~= 1) and '▏' or '' end,
          },
          {
            text = '  ',
          },
          {
            text = function(buffer)
              return
                (is_picking_focus() or is_picking_close())
                and buffer.pick_letter .. ' '
                 or buffer.devicon.icon
            end,
            fg = function(buffer)
              return
                (is_picking_focus() and yellow)
                or (is_picking_close() and red)
                or buffer.devicon.color
            end,
            italic = function()
              return
                (is_picking_focus() or is_picking_close())
            end,
            bold = function()
              return
                (is_picking_focus() or is_picking_close())
            end
          },
          {
            text = ' ',
          },
          {
            text = function(buffer) return buffer.filename .. '  ' end,
            bold = function(buffer) return buffer.is_focused end,
          },
          {
            text = '',
            on_click = function(_, _, _, _, buffer)
              buffer:delete()
            end,
          },
          {
            text = '  ',
          },
        },
      })
      
      
      local get_hex = require('cokeline.hlgroups').get_hl_attr
      
      local yellow = vim.g.terminal_color_3
      
      require('cokeline').setup({
        default_hl = {
          fg = function(buffer)
            return
              buffer.is_focused
              and get_hex('Normal', 'fg')
               or get_hex('Comment', 'fg')
          end,
          bg = function() return get_hex('ColorColumn', 'bg') end,
        },
      
        sidebar = {
          filetype = {'NvimTree', 'neo-tree'},
          components = {
            {
              text = function(buf)
                return buf.filetype
              end,
              fg = yellow,
              bg = function() return get_hex('NvimTreeNormal', 'bg') end,
              bold = true,
            },
          }
        },
      
        components = {
          {
            text = function(buffer) return (buffer.index ~= 1) and '▏' or '' end,
          },
          {
            text = '  ',
          },
          {
            text = function(buffer)
              return buffer.devicon.icon
            end,
            fg = function(buffer)
              return buffer.devicon.color
            end,
          },
          {
            text = ' ',
          },
          {
            text = function(buffer) return buffer.filename .. '  ' end,
            bold = function(buffer)
              return buffer.is_focused
            end,
          },
          {
            text = '',
            on_click = function(_, _, _, _, buffer)
              buffer:delete()
            end,
          },
          {
            text = '  ',
          },
        },
      })
      
      
      require("cokeline.history"):last():focus()
      
      
      require("lazy").setup({
        {
        "willothy/nvim-cokeline",
        dependencies = {
          "nvim-lua/plenary.nvim",        -- Required for v0.4.0+
          "nvim-tree/nvim-web-devicons", -- If you want devicons
          "stevearc/resession.nvim"       -- Optional, for persistent history
        },
        config = true
      }
      })
      
      
      require('cokeline').setup({
        -- Only show the bufferline when there are at least this many visible buffers.
        -- default: `1`.
        ---@type integer
        show_if_buffers_are_at_least = 1,
      
        buffers = {
          -- A function to filter out unwanted buffers. Takes a buffer table as a
          -- parameter (see the following section for more infos) and has to return
          -- either `true` or `false`.
          -- default: `false`.
          ---@type false | fun(buf: Buffer):boolean
          filter_valid = false,
      
          -- A looser version of `filter_valid`, use this function if you still
          -- want the `cokeline-{switch,focus}-{prev,next}` mappings to work for
          -- these buffers without displaying them in your bufferline.
          -- default: `false`.
          ---@type false | fun(buf: Buffer):boolean
          filter_visible = false,
      
          -- Which buffer to focus when a buffer is deleted, `prev` focuses the
          -- buffer to the left of the deleted one while `next` focuses the one the
          -- right.
          -- default: 'next'.
          focus_on_delete = 'prev' | 'next',
      
          -- If set to `last` new buffers are added to the end of the bufferline,
          -- if `next` they are added next to the current buffer.
          -- if set to `directory` buffers are sorted by their full path.
          -- if set to `number` buffers are sorted by bufnr, as in default Neovim
          -- default: 'last'.
          ---@type 'last' | 'next' | 'directory' | 'number' | fun(a: Buffer, b: Buffer):boolean
          new_buffers_position = 'last',
      
          -- If true, right clicking a buffer will close it
          -- The close button will still work normally
          -- Default: true
          ---@type boolean
          delete_on_right_click = true,
        },
      
        mappings = {
          -- Controls what happens when the first (last) buffer is focused and you
          -- try to focus/switch the previous (next) buffer. If `true` the last
          -- (first) buffers gets focused/switched, if `false` nothing happens.
          -- default: `true`.
          ---@type boolean
          cycle_prev_next = true,
      
          -- Disables mouse mappings
          -- default: `false`.
          ---@type boolean
          disable_mouse = false,
        },
      
        -- Maintains a history of focused buffers using a ringbuffer
        history = {
          ---@type boolean
          enabled = true,
          ---The number of buffers to save in the history
          ---@type integer
          size = 2
        },
      
        rendering = {
          -- The maximum number of characters a rendered buffer is allowed to take
          -- up. The buffer will be truncated if its width is bigger than this
          -- value.
          -- default: `999`.
          ---@type integer
          max_buffer_width = 999,
        },
      
        pick = {
          -- Whether to use the filename's first letter first before
          -- picking a letter from the valid letters list in order.
          -- default: `true`
          ---@type boolean
          use_filename = true,
      
          -- The list of letters that are valid as pick letters. Sorted by
          -- keyboard reachability by default, but may require tweaking for
          -- non-QWERTY keyboard layouts.
          -- default: `'asdfjkl;ghnmxcvbziowerutyqpASDFJKLGHNMXCVBZIOWERTYQP'`
          ---@type string
          letters = 'asdfjkl;ghnmxcvbziowerutyqpASDFJKLGHNMXCVBZIOWERTYQP',
        },
      
        -- The default highlight group values.
        -- The `fg`, `bg`, and `sp` keys are either colors in hexadecimal format or
        -- functions taking a `buffer` parameter and returning a color in
        -- hexadecimal format. Style attributes work the same way, but functions
        -- should return boolean values.
        default_hl = {
          -- default: `ColorColumn`'s background color for focused buffers,
          -- `Normal`'s foreground color for unfocused ones.
          ---@type nil | string | fun(buffer: Buffer): string
          fg = function(buffer)
            local hlgroups = require("cokeline.hlgroups")
            return buffer.is_focused and hlgroups.get_hl_attr("ColorColumn", "bg")
              or hlgroups.get_hl_attr("Normal", "fg")
          end,
      
          -- default: `Normal`'s foreground color for focused buffers,
          -- `ColorColumn`'s background color for unfocused ones.
          -- default: `Normal`'s foreground color.
          ---@type nil | string | function(buffer: Buffer): string,
          bg = function(buffer)
            local hlgroups = require("cokeline.hlgroups")
            return buffer.is_focused and hlgroups.get_hl_attr("Normal", "fg")
              or hlgroups.get_hl_attr("ColorColumn", "bg")
          end,
      
          -- default: unset.
          ---@type nil | string | function(buffer): string,
          sp = nil,
      
          ---@type nil | boolean | fun(buf: Buffer):boolean
          bold = nil,
          ---@type nil | boolean | fun(buf: Buffer):boolean
          italic = nil,
          ---@type nil | boolean | fun(buf: Buffer):boolean
          underline = nil,
          ---@type nil | boolean | fun(buf: Buffer):boolean
          undercurl = nil,
          ---@type nil | boolean | fun(buf: Buffer):boolean
          strikethrough = nil,
        },
      
        -- The highlight group used to fill the tabline space
        fill_hl = 'TabLineFill',
      
        -- A list of components to be rendered for each buffer. Check out the section
        -- below explaining what this value can be set to.
        -- default: see `/lua/cokeline/config.lua`
        ---@type Component[]
        components = {},
      
        -- Custom areas can be displayed on the right hand side of the bufferline.
        -- They act identically to buffer components, except their methods don't take a Buffer object.
        -- If you want a rhs component to be stateful, you can wrap it in a closure containing state.
        ---@type Component[] | false
        rhs = {},
      
        -- Tabpages can be displayed on either the left or right of the bufferline.
        -- They act the same as other components, except they are passed TabPage objects instead of
        -- buffer objects.
        ---@type table | false
        tabs = {
          placement = "left" | "right",
          ---@type Component[]
          components = {}
        },
      
        -- Left sidebar to integrate nicely with file explorer plugins.
        -- This is a table containing a `filetype` key and a list of `components` to
        -- be rendered in the sidebar.
        -- The last component will be automatically space padded if necessary
        -- to ensure the sidebar and the window below it have the same width.
        ---@type table | false
        sidebar = {
          ---@type string | string[]
          filetype = { "NvimTree", "neo-tree", "SidebarNvim" },
          ---@type Component[]
          components = {},
        },
      })
      
      
      Buffer = {
        -- The buffer's order in the bufferline (1 for the first buffer, 2 for the
        -- second one, etc.).
        index = int,
      
        -- The buffer's internal number as reported by `:ls`.
        number = int,
      
        ---@type boolean
        is_focused = false,
      
        ---@type boolean
        is_modified = false,
      
        ---@type boolean
        is_readonly = false,
      
        -- The buffer is the first visible buffer in the tab bar
        ---@type boolean
        is_first    = false,
      
        -- The buffer is the last visible buffer in the tab bar
        ---@type boolean
        is_last     = false,
      
        -- The mouse is hovering over the current component in the buffer
        -- This is a special variable in that it will only be true for the hovered *component*
        -- on render. This is to allow components to respond to hover events individually without managing
        -- component state.
        ---@type boolean
        is_hovered  = false,
      
        -- The mouse is hovering over the buffer (true for all components)
        ---@type boolean
        buf_hovered = false,
      
        -- The buffer's type as reported by `:echo &buftype`.
        ---@type string
        ---@type string
        type = '',
      
        -- The buffer's filetype as reported by `:echo &filetype`.
        ---@type string
        filetype = '',
      
        -- The buffer's full path.
        ---@type string
        path = '',
      
        -- The buffer's filename.
        ---@type string
        filename = 'string',
      
        -- A unique prefix used to distinguish buffers with the same filename
        -- stored in different directories. For example, if we have two files
        -- `bar/foo.md` and `baz/foo.md`, then the first will have `bar/` as its
        -- unique prefix and the second one will have `baz/`.
        ---@type string
        unique_prefix = '',
      
        -- The letter that is displayed when picking a buffer to either focus or
        -- close it.
        ---@type string
        pick_letter = 'char',
      
        -- This needs the `nvim-tree/nvim-web-devicons` plugin to be installed.
        devicon = {
          -- An icon representing the buffer's filetype.
          ---@type string
          icon = 'string',
      
          -- The colors of the devicon in hexadecimal format (useful to be passed
          -- to a component's `fg` field (see the `Components` section).
          color = '#rrggbb',
        },
      
        -- The values in this table are the ones reported by Neovim's built in
        -- LSP interface.
        diagnostics = {
          ---@type integer
          errors = 0,
          ---@type integer
          warnings = 0,
          ---@type integer
          infos = 0,
          ---@type integer
          hints = 0,
        },
      }
      
      
      ---@param self Buffer
      ---Deletes the buffer
      function Buffer:delete() end
      
      ---@param self Buffer
      ---Focuses the buffer
      function Buffer:focus() end
      
      ---@param self Buffer
      ---@return number
      ---Returns the number of lines in the buffer
      function Buffer:lines() end
      
      ---@param self Buffer
      ---@return string[]
      ---Returns the buffer's lines
      function Buffer:text() end
      
      ---@param buf Buffer
      ---@return boolean
      ---Returns true if the buffer is valid
      function Buffer:is_valid() end
      
      
      TabPage = {
        -- The tabpage number, as reported by `nvim_list_tabpages`
        ---@type integer
        number = 0,
        -- A list of Window objects contained in the TabPage (see wiki for more info)
        ---@type Window[]
        windows = {},
        -- The currently focused window in the TabPage
        ---@type Window
        focused = nil,
        -- True if the TabPage is the current TabPage
        ---@type boolean
        is_active = true,
        -- True if the TabPage is first in the list
        ---@type boolean
        is_first = false,
        -- True if the TabPage is last in the list
        ---@type boolean
        is_last = false
      }
      
      
      require('cokeline').setup({
        -- ...
        components = {
          {
            text = function(buffer) return ' ' .. buffer.index end,
          },
          {
            text = function(buffer) return ' ' .. buffer.filename .. ' ' end,
          },
          {
            text = '󰅖',
            on_click = function(_, _, _, _, buffer)
              buffer:delete()
            end
          },
          {
            text = ' ',
          }
        }
      })
      
      
      {
      
        ---@type string | fun(buffer: Buffer): string
        text = "",
      
        -- The foreground, backgrond and style of the component
        ---@type nil | string | fun(buffer: Buffer): string
        fg = '#rrggbb',
        ---@type nil | string | fun(buffer: Buffer): string
        bg = '#rrggbb',
        ---@type nil | string | fun(buffer: Buffer): string
        sp = '#rrggbb',
        ---@type nil | boolean | fun(buffer: Buffer): boolean
        bold = false,
        ---@type nil | boolean | fun(buffer: Buffer): boolean
        italic = false,
        ---@type nil | boolean | fun(buffer: Buffer): boolean
        underline = false,
        ---@type nil | boolean | fun(buffer: Buffer): boolean
        undercurl = false,
        ---@type nil | boolean | fun(buffer: Buffer): boolean
        strikethrough = false,
      
        -- Or, alternatively, the name of the highlight group
        ---@type nil | string | fun(buffer: Buffer): string
        highlight = nil,
      
        -- If `true` the buffer will be deleted when this component is
        -- left-clicked (usually used to implement close buttons, overrides `on_click`).
        -- deprecated, it is recommended to use the Buffer:delete() method in an on_click event
        -- to implement close buttons instead.
        ---@type boolean
        delete_buffer_on_left_click = false,
      
        -- Handles click event for a component
        -- If not set, component will have the default click behavior
        -- buffer is a Buffer object, not a bufnr
        ---@type nil | fun(idx: integer, clicks: integer, button: string, mods: string, buffer: Buffer)
        on_click = nil,
      
        -- Called on a component when hovered
        ---@type nil | function(buffer: Buffer, mouse_col: integer)
        on_mouse_enter = nil,
      
        -- Called on a component when unhovered
        ---@type nil | function(buffer: Buffer, mouse_col: integer)
        on_mouse_leave = nil,
      
        truncation = {
          -- default: index of the component in the `components` table (1 for the
          -- first component, 2 for the second, etc.).
          ---@type integer
          priority = 1,
      
          -- default: `right`.
          ---@type 'left' | 'middle' | 'right'
          direction = 'left' | 'middle' | 'right',
        },
      }
      
      
      History = {}
      
      ---Adds a Buffer object to the history
      ---@type bufnr integer
      function History:push(bufnr)
      end
      
      ---Removes and returns the oldest Buffer object in the history
      ---@return Buffer?
      function History:pop()
      end
      
      ---Returns a list of Buffer objects in the history,
      ---ordered from oldest to newest
      ---@return Buffer[]
      function History:list()
      end
      
      ---Returns an iterator of Buffer objects in the history,
      ---ordered from oldest to newest
      ---@return fun(): Buffer?
      function History:iter()
      end
      
      ---Get a Buffer object by history index
      ---@param idx integer
      ---@return Buffer?
      function History:get(idx)
      end
      
      ---Get a Buffer object representing the last-accessed buffer (before the current one)
      ---@return Buffer?
      function History:last()
      end
      
      ---Returns true if the history is empty
      ---@return boolean
      function History:is_empty()
      end
      
      ---Returns the maximum number of buffers that can be stored in the history
      ---@return integer
      function History:capacity()
      end
      
      ---Returns true if the history contains the given buffer
      ---@param bufnr integer
      ---@return boolean
      function History:contains(bufnr)
      end
      
      ---Returns the number of buffers in the history
      ---@return integer
      function History:len()
      end
      
      
      vim.keymap.set("n", "<leader>bp", function()
          require('cokeline.mappings').pick("focus")
      end, { desc = "Pick a buffer to focus" })
      
      
      local map = vim.api.nvim_set_keymap
      
      map("n", "<S-Tab>", "<Plug>(cokeline-focus-prev)", { silent = true })
      map("n", "<Tab>", "<Plug>(cokeline-focus-next)", { silent = true })
      map("n", "<Leader>p", "<Plug>(cokeline-switch-prev)", { silent = true })
      map("n", "<Leader>n", "<Plug>(cokeline-switch-next)", { silent = true })
      
      for i = 1, 9 do
        map(
          "n",
          ("<F%s>"):format(i),
          ("<Plug>(cokeline-focus-%s)"):format(i),
          { silent = true }
        )
        map(
          "n",
          ("<Leader>%s"):format(i),
          ("<Plug>(cokeline-switch-%s)"):format(i),
          { silent = true }
        )
      end
      
      
    end,
  },
  {
    "tomiis4/BufferTabs.nvim",
    config = function()
      
      use 'tomiis4/BufferTabs.nvim'
      
      
      {
          'tomiis4/BufferTabs.nvim',
          dependencies = {
              'nvim-tree/nvim-web-devicons', -- optional
          },
          lazy = false,
          config = function()
              require('buffertabs').setup({
                  -- config
              })
          end
      },
      
      
      -- 1) lua code
      require('buffertabs').toggle()
      
      -- 2) command
      :BufferTabsToggle
      
      
      require('buffertabs').setup()
      
      
      require('buffertabs').setup({
          ---@type 'none'|'single'|'double'|'rounded'|'solid'|'shadow'|table
          border = 'rounded',
      
          ---@type integer
          padding = 1,
      
          ---@type boolean
          icons = true,
      
          ---@type string
          modified = " ",
      
          ---@type string use hl Group or hex color
          hl_group = 'Keyword',
      
          ---@type string use hl Group or hex color
          hl_group_inactive = 'Comment',
      
          ---@type boolean
          show_all = false,
      
          ---@type boolean
          show_single_buffer = true,
      
          ---@type 'row'|'column'
          display = 'row',
      
          ---@type 'left'|'right'|'center'
          horizontal = 'center',
      
          ---@type 'top'|'bottom'|'center'
          vertical = 'top',
      
          ---@type number in ms (recommend 2000)
          timeout = 0,
      
          ---@type boolean
          show_id = false
      
          ---@type integer
          max_buffers = 0
      
          ---@type integer
          surround_active_buffer = 0
      })
      
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-tabline.md",
  },
  {
    "rafcamlet/tabline-framework.nvim",
    config = function()
      
      local render = function(f)
        f.add '   '
      
        f.make_tabs(function(info)
          f.add(' ' .. info.index .. ' ')
          f.add(info.filename or '[no name]')
          f.add(info.modified and '+')
          f.add ' '
        end)
      end
      
      
      use { "rafcamlet/tabline-framework.nvim",  requires = "kyazdani42/nvim-web-devicons" }
      
      
      require('tabline_framework').setup {
        -- Render function is resposible for generating content of tabline
        -- This is the place where you do your magic!
        render = function(f)
          f.add 'This is my tabline!'
        end,
        -- Default color of tabline items: tabs/bufs
        -- if not set TF uses TabLine highlight group colors
        hl = { fg = "#abb2bf" bg ="#31353f" }
        -- Default color of selected item
        -- if not set TF uses TabLineSel highlight group colors
        hl_sel = { fg = "#282c34" bg ="#abb2bf" gui = "bold,underline" }
        -- Default color of everything except items
        -- if not set TF uses TabLineFill highlight group colors
        hl_fill = { fg = "#282c34" bg ="#abb2bf" }
      }
      
      
      
      local render = function(f)
        f.add { ' ', fg = "#bb0000" }
        f.add ' '
      end
      
      require('tabline_framework').setup { render = render }
      
      
      local render = function(f)
        f.add { '   ', fg = "#bb0000" }
      
        f.make_tabs(function(info)
          f.add(' ' .. info.index .. ' ')
          f.add(info.filename or '[no name]')
          f.add ' '
        end)
      end
      
      
      local render = function(f)
        f.add { '   ', fg = "#bb0000" }
      
        f.make_tabs(function(info)
          f.add( ' ' .. info.index .. ' ')
      
          if info.filename then
            -- let's add + sign if the buffer is modified
            f.add(info.modified and '+')
            f.add(info.filename)
          else
            -- Why waste space for [no name] ?
            -- Let's use [-] if the buffer has no name
            -- or [+] if it is also modified
            f.add(info.modified and '[+]' or '[-]')
          end
      
          f.add ' '
        end)
      end
      
      
      local render = function(f)
        f.add { '   ', fg = "#bb0000" }
      
        f.make_tabs(function(info)
          -- With the help of kyazdani42/nvim-web-devicons we can fetch color
          -- associated with the filetype
          local icon_color = f.icon_color(info.filename)
      
          -- If this is the current tab then highlight it
          if info.current then
            -- We can use set_fg to change default fg color
            -- so you won't need to specify it every time
            f.set_fg(icon_color)
          end
      
          f.add( ' ' .. info.index .. ' ')
      
          if info.filename then
            f.add(info.modified and '+')
            f.add(info.filename)
      
            -- The icon function returns a filetype icon based on the filename
            f.add(' ' .. f.icon(info.filename))
          else
            f.add(info.modified and '[+]' or '[-]')
          end
          f.add ' '
        end)
      end
      
      
      local render = function(f)
        f.add { '   ', fg = "#bb0000" }
      
        f.make_tabs(function(info)
          -- ...
        end)
      
        -- Let's add a spacer wich will justify the rest of the tabline to the right
        f.add_spacer()
      
        -- get some info from lsp
        local errors = #vim.diagnostic.get(0, { severity = vim.diagnostic.severity.ERROR })
        local warnings = #vim.diagnostic.get(0, { severity = vim.diagnostic.severity.WARN })
      
        -- and display it
        f.add { '  ' .. errors, fg = "#e86671" }
        f.add { '  ' .. warnings, fg = "#e5c07b"}
        f.add ' '
      end
      
      
      -- Try it:
      require('tabline_framework').setup {
        render = require('tabline_framework.examples.simple'),
      }
      
      
      
      local render = function(f)
        f.add '   '
      
        f.make_tabs(function(info)
          f.add(' ' .. info.index .. ' ')
          f.add(info.filename or '[no name]')
          f.add(info.modified and '+')
          f.add ' '
        end)
      end
      
      
      -- Try it:
      require('tabline_framework').setup {
        render = require('tabline_framework.examples.diagonal_tiles'),
        hl = { fg = '#abb2bf', bg = '#181A1F' },
        hl_sel = { fg = '#abb2bf', bg = '#282c34'},
        hl_fill = { fg = '#ffffff', bg = '#000000'},
      }
      
      
      
      local colors = {
        black = '#000000',
        white = '#ffffff',
        bg = '#181A1F',
        bg_sel = '#282c34',
        fg = '#696969'
      }
      
      local render = function(f)
        f.add { '  ' }
      
        f.make_tabs(function(info)
          f.add {  ' ', fg = colors.black }
          f.set_fg(not info.current and colors.fg or nil)
      
          f.add( info.index .. ' ')
      
          if info.filename then
            f.add(info.modified and '+')
            f.add(info.filename)
            f.add {
              ' ' .. f.icon(info.filename),
              fg = info.current and f.icon_color(info.filename) or nil
            }
          else
            f.add(info.modified and '[+]' or '[-]')
          end
      
          f.add {
            ' ',
            fg = info.current and colors.bg_sel or colors.bg,
            bg = colors.black
          }
        end)
      
        f.add_spacer()
      
        local errors = #vim.diagnostic.get(0, { severity = vim.diagnostic.severity.ERROR })
        local warnings = #vim.diagnostic.get(0, { severity = vim.diagnostic.severity.WARN })
      
        f.add { '  ' .. errors, fg = "#e86671" }
        f.add { '  ' .. warnings, fg = "#e5c07b"}
        f.add ' '
      end
      
      
      -- Try it:
      require('tabline_framework').setup {
        render = require('tabline_framework.examples.fancy_indexes'),
        hl = { fg = '#abb2bf', bg = '#181A1F' },
        hl_sel = { fg = '#abb2bf', bg = '#282c34'},
        hl_fill = { fg = '#ffffff', bg = '#000000'},
      }
      
      
      local inactive = {
        black = '#000000',
        white = '#ffffff',
        fg = '#696969',
        bg_1 = '#181A1F',
        bg_2 = '#202728',
        index = '#61afef',
      }
      
      local active = vim.tbl_extend('force', inactive, {
        fg = '#abb2bf',
        bg_2 = '#282c34',
        index = '#d19a66',
      })
      
      local render = function(f)
        f.add '  '
        f.make_tabs(function(info)
          local colors = info.current and active or inactive
      
          f.add {
            ' ' .. info.index .. ' ',
            fg = colors.index,
            bg = colors.bg_1
          }
      
          f.set_colors { fg = colors.fg, bg = colors.bg_2 }
      
          f.add ' '
          if info.filename then
            f.add(info.modified and '+')
            f.add(info.filename)
            f.add {
              ' ' .. f.icon(info.filename),
              fg = info.current and f.icon_color(info.filename) or nil
            }
          else
            f.add(info.modified and '[+]' or '[-]')
          end
          f.add ' '
          f.add { ' ', bg = colors.black }
        end)
      
        f.add_spacer()
      
        local errors = #vim.diagnostic.get(0, { severity = vim.diagnostic.severity.ERROR })
        local warnings = #vim.diagnostic.get(0, { severity = vim.diagnostic.severity.WARN })
      
        f.add { '  ' .. errors, fg = "#e86671" }
        f.add { '  ' .. warnings, fg = "#e5c07b"}
        f.add ' '
      end
      
      
      -- Try it:
      require('tabline_framework').setup {
        render = require('tabline_framework.examples.tabs_and_buffers'),
      }
      
      
      local toys = require 'tabline_framework.toys'
      
      toys.setup_tab_buffers()
      
      local render = function(f)
        f.add '  '
      
        f.make_bufs(function(info)
          f.add(' ' .. info.buf .. ' ')
          f.add(info.filename or '[no name]')
          f.add(info.modified and '+')
          f.add ' '
        end, toys.get_tab_buffers(0))
      
        f.add_spacer()
      
        f.make_tabs(function(info)
          f.add(' ' .. info.index .. ' ')
        end)
      end
      
    end,
  },
  {
    "nanozuki/tabby.nvim",
    config = function()
      
      tab.in_jump_mode() and tab.jump_key() or tab.number()
      
      
      {
        'nanozuki/tabby.nvim',
        config = function()
          -- configs...
        end,
      }
      
      
      {
        'nanozuki/tabby.nvim',
        ---@type TabbyConfig
        opts = {
          -- configs...
        },
      }
      
      
      vim.o.showtabline = 2
      
      
      vim.opt.sessionoptions = 'curdir,folds,globals,help,tabpages,terminal,winsize'
      
      
      local theme = {
        fill = 'TabLineFill',
        -- Also you can do this: fill = { fg='#f2e9de', bg='#907aa9', style='italic' }
        head = 'TabLine',
        current_tab = 'TabLineSel',
        tab = 'TabLine',
        win = 'TabLine',
        tail = 'TabLine',
      }
      require('tabby').setup({
        line = function(line)
          return {
            {
              { '  ', hl = theme.head },
              line.sep('', theme.head, theme.fill),
            },
            line.tabs().foreach(function(tab)
              local hl = tab.is_current() and theme.current_tab or theme.tab
              return {
                line.sep('', hl, theme.fill),
                tab.is_current() and '' or '󰆣',
                tab.number(),
                tab.name(),
                tab.close_btn(''),
                line.sep('', hl, theme.fill),
                hl = hl,
                margin = ' ',
              }
            end),
            line.spacer(),
            line.wins_in_tab(line.api.get_current_tab()).foreach(function(win)
              return {
                line.sep('', theme.win, theme.fill),
                win.is_current() and '' or '',
                win.buf_name(),
                line.sep('', theme.win, theme.fill),
                hl = theme.win,
                margin = ' ',
              }
            end),
            {
              line.sep('', theme.tail, theme.fill),
              { '  ', hl = theme.tail },
            },
            hl = theme.fill,
          }
        end,
        -- option = {}, -- setup modules' option,
      })
      
      
      vim.api.nvim_set_keymap("n", "<leader>ta", ":$tabnew<CR>", { noremap = true })
      vim.api.nvim_set_keymap("n", "<leader>tc", ":tabclose<CR>", { noremap = true })
      vim.api.nvim_set_keymap("n", "<leader>to", ":tabonly<CR>", { noremap = true })
      vim.api.nvim_set_keymap("n", "<leader>tn", ":tabn<CR>", { noremap = true })
      vim.api.nvim_set_keymap("n", "<leader>tp", ":tabp<CR>", { noremap = true })
      -- move current tab to previous position
      vim.api.nvim_set_keymap("n", "<leader>tmp", ":-tabmove<CR>", { noremap = true })
      -- move current tab to next position
      vim.api.nvim_set_keymap("n", "<leader>tmn", ":+tabmove<CR>", { noremap = true })
      
      
      require('tabby').setup({
        line = function(line)
          local cwd = ' ' .. vim.fn.fnamemodify(vim.fn.getcwd(), ':t') .. ' '
          return {
              {
                  { cwd, hl = theme.head },
                  line.sep('', theme.head, theme.line),
              },
              ".....",
          }
        end,
        option = {},
      })
      
      
      {
        tab_name = {
          name_fallback = function(tabid)
            return "fallback name"
            end,
          override = nil,
        },
        buf_name = {
          mode = 'unique', -- or 'relative', 'tail', 'shorten'
            name_fallback = function(bufid)
            return '[No Name]'
            end,
          override = nil,
        }
      }
      
      
        -- node 1
        {
          "tab1", 100
          hl = "TabLineSel"
        }
        -- node 2
        {
          "text 1"
          {
              "text 2",
              hl = "Info",
          },
          "text3",
          hl = "Fill",
        }
        
      
      require('tabby').setup({
        preset = 'active_wins_at_tail',
        option = {
          theme = {
            fill = 'TabLineFill',       -- tabline background
            head = 'TabLine',           -- head element highlight
            current_tab = 'TabLineSel', -- current tab label highlight
            tab = 'TabLine',            -- other tab label highlight
            win = 'TabLine',            -- window highlight
            tail = 'TabLine',           -- tail element highlight
          },
          nerdfont = true,              -- whether use nerdfont
          lualine_theme = nil,          -- lualine theme name
          tab_name = {
            name_fallback = function(tabid)
              return tabid
            end,
          },
          buf_name = {
            mode = 'unique', -- or 'relative', 'tail', 'shorten'
          },
        },
      })
      
    end,
  },
  {
    "roobert/bufferline-cycle-windowless.nvim",
    config = function()
      
      {
        "roobert/bufferline-cycle-windowless.nvim",
        dependencies = {
          { "akinsho/bufferline.nvim" },
        },
        config = function()
          require("bufferline-cycle-windowless").setup({
            -- whether to start in enabled or disabled mode
            default_enabled = true,
          })
        end,
      },
      
      
      use {
        "roobert/bufferline-cycle-windowless.nvim",
        requires = {
          { "akinsho/bufferline.nvim" },
        },
        setup = function()
          require("bufferline-cycle-windowless").setup({
           -- whether to start in enabled or disabled mode
           default_enabled = true,
         })
        end,
      }
      
    end,
  },
  {
    "ya2s/nvim-cursorline",
    config = function()
      
      require('nvim-cursorline').setup {
        cursorline = {
          enable = true,
          timeout = 1000,
          number = false,
        },
        cursorword = {
          enable = true,
          min_length = 3,
          hl = { underline = true },
        }
      }
      
    end,
  },
  {
    "xiyaowong/nvim-cursorword",
  },
  {
    "sontungexpt/stcursorword",
    config = function()
      
          -- lazy
          {
              "sontungexpt/stcursorword",
              event = "VeryLazy",
              config = true,
          },
      
      
          -- default configuration
          require("stcursorword").setup({
              max_word_length = 100, -- if cursorword length > max_word_length then not highlight
              min_word_length = 2, -- if cursorword length < min_word_length then not highlight
              excluded = {
                  filetypes = {
                      "TelescopePrompt",
                  },
                  buftypes = {
                      -- "nofile",
                      -- "terminal",
                  },
                  patterns = { -- the pattern to match with the file path
                      -- "%.png$",
                      -- "%.jpg$",
                      -- "%.jpeg$",
                      -- "%.pdf$",
                      -- "%.zip$",
                      -- "%.tar$",
                      -- "%.tar%.gz$",
                      -- "%.tar%.xz$",
                      -- "%.tar%.bz2$",
                      -- "%.rar$",
                      -- "%.7z$",
                      -- "%.mp3$",
                      -- "%.mp4$",
                  },
              },
              highlight = {
                  underline = true,
                  fg = nil,
                  bg = nil,
              },
          })
      
    end,
  },
  {
    "RRethy/vim-illuminate",
    config = function()
      
      -- default configuration
      require('illuminate').configure({
          -- providers: provider used to get references in the buffer, ordered by priority
          providers = {
              'lsp',
              'treesitter',
              'regex',
          },
          -- delay: delay in milliseconds
          delay = 100,
          -- filetype_overrides: filetype specific overrides.
          -- The keys are strings to represent the filetype while the values are tables that
          -- supports the same keys passed to .configure except for filetypes_denylist and filetypes_allowlist
          filetype_overrides = {},
          -- filetypes_denylist: filetypes to not illuminate, this overrides filetypes_allowlist
          filetypes_denylist = {
              'dirbuf',
              'dirvish',
              'fugitive',
          },
          -- filetypes_allowlist: filetypes to illuminate, this is overridden by filetypes_denylist
          -- You must set filetypes_denylist = {} to override the defaults to allow filetypes_allowlist to take effect
          filetypes_allowlist = {},
          -- modes_denylist: modes to not illuminate, this overrides modes_allowlist
          -- See `:help mode()` for possible values
          modes_denylist = {},
          -- modes_allowlist: modes to illuminate, this is overridden by modes_denylist
          -- See `:help mode()` for possible values
          modes_allowlist = {},
          -- providers_regex_syntax_denylist: syntax to not illuminate, this overrides providers_regex_syntax_allowlist
          -- Only applies to the 'regex' provider
          -- Use :echom synIDattr(synIDtrans(synID(line('.'), col('.'), 1)), 'name')
          providers_regex_syntax_denylist = {},
          -- providers_regex_syntax_allowlist: syntax to illuminate, this is overridden by providers_regex_syntax_denylist
          -- Only applies to the 'regex' provider
          -- Use :echom synIDattr(synIDtrans(synID(line('.'), col('.'), 1)), 'name')
          providers_regex_syntax_allowlist = {},
          -- under_cursor: whether or not to illuminate under the cursor
          under_cursor = true,
          -- large_file_cutoff: number of lines at which to use large_file_config
          -- The `under_cursor` option is disabled when this cutoff is hit
          large_file_cutoff = 10000,
          -- large_file_config: config to use for large files (based on large_file_cutoff).
          -- Supports the same keys passed to .configure
          -- If nil, vim-illuminate will be disabled for large files.
          large_file_overrides = nil,
          -- min_count_to_highlight: minimum number of matches required to perform highlighting
          min_count_to_highlight = 1,
          -- should_enable: a callback that overrides all other settings to
          -- enable/disable illumination. This will be called a lot so don't do
          -- anything expensive in it.
          should_enable = function(bufnr) return true end,
          -- case_insensitive_regex: sets regex case sensitivity
          case_insensitive_regex = false,
          -- disable_keymaps: disable default keymaps
          disable_keymaps = false,
      })
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-cursorword.md",
  },
  {
    "mawkler/modicator.nvim",
    config = function()
      
      require('modicator').setup()
      
      
      vim.o.termguicolors = true
      vim.o.cursorline = true
      vim.o.number = true
      
      
      {
        'mawkler/modicator.nvim',
        dependencies = 'mawkler/onedark.nvim', -- Add your colorscheme plugin here
        init = function()
          -- These are required for Modicator to work
          vim.o.cursorline = true
          vim.o.number = true
          vim.o.termguicolors = true
        end,
        opts = {
          -- Warn if any required option above is missing. May emit false positives
          -- if some other plugin modifies them, which in that case you can just
          -- ignore. Feel free to remove this line after you've gotten Modicator to
          -- work properly.
          show_warnings = true,
        }
      }
      
      
      use {
        'mawkler/modicator.nvim',
        after = 'onedark.nvim', -- Add your colorscheme plugin here
        setup = function()
          -- These are required for Modicator to work
          vim.o.cursorline = true
          vim.o.number = true
          vim.o.termguicolors = true
        end,
        config = function()
          require('modicator').setup({
          -- Warn if any required option above is missing. May emit false positives
          -- if some other plugin modifies them, which in that case you can just
          -- ignore. Feel free to remove this line after you've gotten Modicator to
          -- work properly.
          show_warnings = true,
        })
        end
      }
      
      
      require('modicator').setup({
        -- Warn if any required option is missing. May emit false positives if some
        -- other plugin modifies them, which in that case you can just ignore
        show_warnings = false,
        highlights = {
          -- Default options for bold/italic
          defaults = {
            bold = false,
            italic = false,
          },
          -- Use `CursorLine`'s background color for `CursorLineNr`'s background
          use_cursorline_background = false,
        },
        integration = {
          lualine = {
            enabled = true,
            -- Letter of lualine section to use (if `nil`, gets detected automatically)
            mode_section = nil,
            -- Whether to use lualine's mode highlight's foreground or background
            highlight = 'bg',
          },
        },
      })
      
      
      local marks_fix_group = vim.api.nvim_create_augroup('marks-fix-hl', {})
      vim.api.nvim_create_autocmd({ 'VimEnter' }, {
        group = marks_fix_group,
        callback = function()
          vim.api.nvim_set_hl(0, 'MarkSignNumHL', {})
        end,
      })
      
    end,
  },
  {
    "nyngwang/murmur.lua",
    config = function()
      
      local FOO = 'your_augroup_name'
      vim.api.nvim_create_augroup(FOO, { clear = true })
      
      use {
        'nyngwang/murmur.lua',
        config = function ()
          require('murmur').setup {
            -- cursor_rgb = {
            --  guibg = '#393939',
            -- },
            -- cursor_rgb_always_use_config = false, -- if set to `true`, then always use `cursor_rgb`.
            -- yank_blink = {
            --   enabled = true,
            --   on_yank = nil, -- Can be customized. See `:h on_yank`.
            -- },
            max_len = 80,
            min_len = 3, -- this is recommended since I prefer no cursorword highlighting on `if`.
            exclude_filetypes = {},
            callbacks = {
              -- to trigger the close_events of vim.diagnostic.open_float.
              function ()
                -- Close floating diag. and make it triggerable again.
                vim.api.nvim_exec_autocmds("User", { pattern = "MurmurDiagnostics" })
                vim.w.diag_shown = false
              end,
            }
          }
      
          -- To create IDE-like no blinking diagnostic message with `cursor` scope. (should be paired with the callback above)
          vim.api.nvim_create_autocmd('CursorHold', {
            group = FOO,
            pattern = '*',
            callback = function ()
              -- skip when a float-win already exists.
              if vim.w.diag_shown then return end
      
              -- open float-win when hovering on a cursor-word.
              if vim.w.cursor_word ~= "" then
                local buf = vim.diagnostic.open_float({
                  scope = "cursor",
                  -- Only close the window on InsertEnter and the explicit diagnostic close event
                  close_events = { "InsertEnter", "User MurmurDiagnostics" },
                })
                -- If the window closes for any reason *other* than it being closed by a callback,
                -- make it triggerable again
                vim.api.nvim_create_autocmd("WinClosed", {
                  group = FOO,
                  buffer = buf,
                  once = true,
                  callback = function() vim.w.diag_shown = false end,
                })
                vim.w.diag_shown = true
              else
                vim.w.diag_shown = false
              end
            end
          })
      
          -- To create special cursorword coloring for the colortheme `typewriter-night`.
          -- remember to change it to the name of yours.
          vim.api.nvim_create_autocmd({ 'ColorScheme' }, {
            group = FOO,
            pattern = 'typewriter-night',
            callback = function ()
              vim.api.nvim_set_hl(0, "murmur_cursor_rgb", { fg = "#0a100d", bg = "#ffee32" })
            end
          })
        end
      }
      
    end,
  },
  {
    "nvimdev/dashboard-nvim",
    config = function()
      
      {
        'nvimdev/dashboard-nvim',
        event = 'VimEnter',
        config = function()
          require('dashboard').setup {
            -- config
          }
        end,
        dependencies = { {'nvim-tree/nvim-web-devicons'}}
      }
      
      
      use {
        'nvimdev/dashboard-nvim',
        event = 'VimEnter',
        config = function()
          require('dashboard').setup {
            -- config
          }
        end,
        requires = {'nvim-tree/nvim-web-devicons'}
      }
      
      
      theme = 'hyper'    -- theme is doom and hyper default is hyper
      disable_move       -- default is false disable move keymap for hyper
      shortcut_type      -- shortcut type 'letter' or 'number'
      shuffle_letter     -- default is false, shortcut 'letter' will be randomize, set to false to have ordered letter
      letter_list        -- default is a-z, excluding j and k
      change_to_vcs_root -- default is false,for open file in hyper mru. it will change to the root of vcs
      config = {},       -- config used for theme
      hide = {
        statusline       -- hide statusline default is true
        tabline          -- hide the tabline
        winbar           -- hide winbar
      },
      preview = {
        command          -- preview command
        file_path        -- preview file path
        file_height      -- preview file height
        file_width       -- preview file width
      },
      
      
      config = {
        header -- type is table def
        week_header = {
          enable  --boolean use a week header
          concat  --concat string after time string line
          append  --table append after time string line
        },
        disable_move  -- boolean default is false disable move key
      }
      
      
      config = {
        shortcut = {
          -- action can be a function type
          { desc = string, group = 'highlight group', key = 'shortcut key', action = 'action when you press key' },
        },
        packages = { enable = true }, -- show how many plugins neovim loaded
        -- limit how many projects list, action when you press key or enter it will run this action.
        -- action can be a function type, e.g.
        -- action = func(path) vim.cmd('Telescope find_files cwd=' .. path) end
        project = { enable = true, limit = 8, icon = 'your icon', label = '', action = 'Telescope find_files cwd=' },
        mru = { enable = true, limit = 10, icon = 'your icon', label = '', cwd_only = false },
        footer = {}, -- footer
      }
      
      
      config = {
        center = {
          {
            icon = '',
            icon_hl = 'group',
            desc = 'description',
            desc_hl = 'group',
            key = 'shortcut key in dashboard buffer not keymap !!',
            key_hl = 'group',
            key_format = ' [%s]', -- `%s` will be substituted with value of `key`
            action = '',
          },
        },
        footer = {},
        vertical_center = false, -- Center the Dashboard on the vertical (from top to bottom)
      }
      
      
        db.setup({
          theme = 'hyper',
          config = {
            week_header = {
             enable = true,
            },
            shortcut = {
              { desc = '󰊳 Update', group = '@property', action = 'Lazy update', key = 'u' },
              {
                icon = ' ',
                icon_hl = '@variable',
                desc = 'Files',
                group = 'Label',
                action = 'Telescope find_files',
                key = 'f',
              },
              {
                desc = ' Apps',
                group = 'DiagnosticHint',
                action = 'Telescope app',
                key = 'a',
              },
              {
                desc = ' dotfiles',
                group = 'Number',
                action = 'Telescope dotfiles',
                key = 'd',
              },
            },
          },
        })
      
      
      db.setup({
        theme = 'doom',
        config = {
          header = {}, --your header
          center = {
            {
              icon = ' ',
              icon_hl = 'Title',
              desc = 'Find File           ',
              desc_hl = 'String',
              key = 'b',
              keymap = 'SPC f f',
              key_hl = 'Number',
              key_format = ' %s', -- remove default surrounding `[]`
              action = 'lua print(2)'
            },
            {
              icon = ' ',
              desc = 'Find Dotfiles',
              key = 'f',
              keymap = 'SPC f d',
              key_format = ' %s', -- remove default surrounding `[]`
              action = 'lua print(3)'
            },
          },
          footer = {}  --your footer
        }
      })
      
    end,
  },
  {
    "goolord/alpha-nvim",
    config = function()
      
      {
          'goolord/alpha-nvim',
          dependencies = { 'echasnovski/mini.icons' },
          config = function ()
              require'alpha'.setup(require'alpha.themes.startify'.config)
          end
      };
      
      
      use {
          'goolord/alpha-nvim',
          requires = { 'echasnovski/mini.icons' },
          config = function ()
              require'alpha'.setup(require'alpha.themes.startify'.config)
          end
      }
      
      
      require "paq" {
          "goolord/alpha-nvim";
          "echasnovski/mini.icons";
      }
      require'alpha'.setup(require'alpha.themes.startify'.config)
      
      
      {
          'goolord/alpha-nvim',
          config = function ()
              require'alpha'.setup(require'alpha.themes.dashboard'.config)
          end
      };
      
      
      use {
          'goolord/alpha-nvim',
          config = function ()
              require'alpha'.setup(require'alpha.themes.dashboard'.config)
          end
      }
      
      
      require "paq" {
          "goolord/alpha-nvim";
          "echasnovski/mini.icons";
      }
      require'alpha'.setup(require'alpha.themes.dashboard'.config)
      
      
      {
          'goolord/alpha-nvim',
          dependencies = {
              'echasnovski/mini.icons',
              'nvim-lua/plenary.nvim'
          },
          config = function ()
              require'alpha'.setup(require'alpha.themes.theta'.config)
          end
      };
      
      
      use {
          'goolord/alpha-nvim',
          requires = {
              'echasnovski/mini.icons',
              'nvim-lua/plenary.nvim'
          },
          config = function ()
              require'alpha'.setup(require'alpha.themes.dashboard'.config)
          end
      }
      
      
      require "paq" {
          "goolord/alpha-nvim";
          "echasnovski/mini.icons";
          'nvim-lua/plenary.nvim';
      }
      require'alpha'.setup(require'alpha.themes.dashboard'.config)
      
      
        {
          "goolord/alpha-nvim",
          -- dependencies = { 'echasnovski/mini.icons' },
          dependencies = { 'nvim-tree/nvim-web-devicons' },
          config = function()
            local startify = require("alpha.themes.startify")
            -- available: devicons, mini, default is mini
            -- if provider not loaded and enabled is true, it will try to use another provider
            startify.file_icons.provider = "devicons"
            require("alpha").setup(
              startify.config
            )
          end,
        },
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-starter.md",
  },
  {
    "max397574/startup.nvim",
  },
  {
    "willothy/veil.nvim",
    config = function()
      
      {
        'willothy/veil.nvim',
        lazy = true,
        dependencies = {
          -- All optional, only required for the default setup.
          -- If you customize your config, these aren't necessary.
          "nvim-telescope/telescope.nvim",
          "nvim-lua/plenary.nvim",
          "nvim-telescope/telescope-file-browser.nvim"
        }
        config = true,
        -- or configure with:
        -- opts = { ... }
      }
      
      
      local builtin = require("veil.builtin")
      
      local default = {
        sections = {
          builtin.sections.animated(builtin.headers.frames_nvim, {
            hl = { fg = "#5de4c7" },
          }),
          builtin.sections.buttons({
            {
              icon = "",
              text = "Find Files",
              shortcut = "f",
              callback = function()
                  require("telescope.builtin").find_files()
              end,
            },
            {
              icon = "",
              text = "Find Word",
              shortcut = "w",
              callback = function()
                  require("telescope.builtin").live_grep()
              end,
            },
            {
              icon = "",
              text = "Buffers",
              shortcut = "b",
              callback = function()
                  require("telescope.builtin").buffers()
              end,
            },
            {
              icon = "",
              text = "Config",
              shortcut = "c",
              callback = function()
                require("telescope").extensions.file_browser.file_browser({
                  path = vim.fn.stdpath("config"),
                })
              end,
            },
          }),
          builtin.sections.oldfiles(),
        },
        mappings = {},
        startup = true,
        listed = false
      }
      
      
      
      -- in your config:
      
      local current_day = os.date("%A")
      
      require('veil').setup({
        sections = {
          builtin.sections.animated(builtin.headers.frames_days_of_week[current_day], {
            hl = { fg = "#5de4c7" },
          }),
          -- other sections
          -- ...
        }
      }
      
      
    end,
  },
  {
    "TobinPalmer/Tip.nvim",
    config = function()
      
      -- Lazy.nvim
      return {
        "TobinPalmer/Tip.nvim",
        event = "VimEnter",
        init = function()
          -- Default config
          --- @type Tip.config
          require("tip").setup({
            seconds = 2,
            title = "Tip!",
            url = "https://vtip.43z.one", -- Or https://vimiscool.tech/neotip
          })
        end,
      }
      
    end,
  },
  {
    "CWood-sdf/spaceport.nvim",
    config = function()
      
      {
          'CWood-sdf/spaceport.nvim',
          opts = {
      
          },
          lazy = false, -- load spaceport immediately
      }
      
      
      {
      
          -- This prevents the same directory from being repeated multiple times in the recents section
          -- For example, I have replaceDirs set to { {"~/projects", "_" } } so that ~/projects is not repeated a ton
          -- Note every element is applied to the directory in order,
          --   so if you have { {"~/projects", "_"} } and you also want to replace
          --   ~/projects/foo with @, then you would need
          --   { {"~/projects/foo", "@"}, {"~/projects", "_"} }
          --   or { {"~/projects", "_"}, {"_/foo", "@"} }
          replaceDirs = {},
      
          -- turn /home/user/ into ~/ (also works on windows for C:\Users\user\)
          replaceHome = true,
      
          -- What to do when entering a directory, personally I use "Oil .", but Ex is preinstalled with neovim
          projectEntry = "Ex",
      
          -- The farthest back in time that directories should be shown
          -- I personally use "yesterday" so that there aren't millions of directories on the screen.
          -- the possible values are: "pin", "today", "yesterday", "pastWeek", "pastMonth", and "later"
          lastViewTime = "later",
      
          -- The maximum number of directories to show in the recents section (0 means show all of them)
          maxRecentFiles = 0,
      
          -- The sections to show on the screen (see `Customization` for more info)
          sections = {
              "_global_remaps",
              "name",
              "remaps",
              "recents",
          },
      
          -- toggle or set file and directory icons.
          --  For example, the following can be used to set different icons `{ file = " ", dir = " ", remaps = " ", pinned = " ", today = " ", yesterday = " ", week = " ", month = " ", long = " ", news = "󱀄 " }`
          icons = true
      
          -- For true speed, it has the type string[][],
          --  each element of the shortcuts array contains two strings, the first is the key, the second is a match string to a directory
          --   for example, I have ~/.config/nvim as shortcut f, so I can type `f` to go to my neovim dotfiles, this is set with { { "f", ".config/nvim" } }
          shortcuts = {
              { "f", ".config/nvim" },
          },
      
          --- Set to true to have more verbose logging
          debug = false,
      
          -- The path to the log file
          logPath = vim.fn.stdpath("log") .. "/spaceport.log",
          -- How many hours to preserve each log entry for
          logPreserveHours = 24,
      
      }
      
      
      {
          "_global_remaps",
          "name",
          "remaps",
          "recents",
      }
      
      
      sections = {
          {
              "remaps",
              title = "REMAPS (or something)",
          },
      
      },
      
      
      sections = {
          {
              "recents",
              remaps = {
                  {
                      -- override the remap with this key
                      ogkey = "p",
                      -- change the key
                      key = "s",
                  },
              },
          },
      },
      
      
      
      sections = {
          {
              "name",
              config = {
                  style = "lite",
                  gradient = "blue_green",
              },
          },
      }
      
      
      sections = {
          {
              "name",
              config = {
                  style = "lite",
                  gradient = {
                      { start = "#ff0000", stop = "#990000", dir = "left" },
                  },
              },
          },
      }
      
      
      vim.api.nvim_set_hl(0, "SpaceportRecentsTitle", {
          fg = "red",
      })
      
      
      local i = 0
      
      ---...
      sections = {
      {
          -- can either be a string or `SpaceportWord[]`
          title = "count",
          lines = function()
              return {
                  -- lines can be strings
                  "Count: ",
                  -- or lines can be arrays of `SpaceportWord`s, this allows the words to have highlights
                  {
      
                      -- Spaceport words are tables with the following fields:
                      -- [1] = the text to display
                      -- colorOpts = the options to pass to `vim.api.nvim_set_hl`
                      -- See [nvim_set_hl docs](https://neovim.io/doc/user/api.html#nvim_set_hl())
      
                      -- Alternatively, if you want the value to be customizable, you can set the
                      --   _name field to the name of a global highlight group along with all the other values
                      --   If spaceport detects that the global highlight group exists, it will use that, otherwise it will create the highlight group with the given values
                      {
                          i .. "",
                          colorOpts = {
                              fg = "red",
                          },
                      },
                  },
              }
          end,
          -- The number of empty lines to put between this section and the previous section
          topBuffer = 0,
          remaps = {
              {
                  key = "w",
                  mode = "n",
                  --- Spaceport passes two parameters to action():
                  --- 1. The line that the cursor is on (relative to the start of the screen)
                  --- 2. vim.v.count
                  action = function(line, count)
                      i = i + 1
                      -- This will cause the screen to be re-rendered
                      require('spaceport.screen').render()
                  end,
                  description = "Increment count",
                  -- Setting this to false will make the remap not be shown in the 'remaps' section
                  visible = true,
                  -- Setting this to false will make it so that the action will only be called when the cursor is on the lines of the screen
                  callOutside = true,
              },
          },
          -- if this is nil, the screen will be centered
          position = {
              -- Positive values are from the top, negative values are from the bottom
              row = -1,
              -- Positive values are from the left, negative values are from the right
              col = 1,
          },
          onExit = function()
              -- This function will be called when spaceport is exited
              i = 0
          end,
      }
      }
      
      
      require('telescope').load_extension('spaceport')
      
      
      require('telescope').extensions.spaceport.projects()
      
      
      require('telecope').extensions.spaceport.tmux_windows()
      
      require('telecope').extensions.spaceport.tmux_sessions()
      
      
      require('telescope').extensions.spaceport.find()
      
    end,
  },
  {
    "mong8se/actually.nvim",
  },
  {
    "Kurama622/profile.nvim",
    config = function()
      
      {
        "Kurama622/profile.nvim",
        dependencies = { "3rd/image.nvim" },
        config = function()
          require("profile").setup({
            avatar_path = "<your avatar path>", -- default: profile.nvim/resources/profile.png
            user = "<your github username>",
          })
          vim.api.nvim_set_keymap("n", "<leader>p", "<cmd>Profile<cr>", { silent = true })
        end
      }
      
      
        {
          "Kurama622/profile.nvim",
          dependencies = { "3rd/image.nvim" },
          config = function()
            local comp = require("profile.components")
            local win_width = vim.o.columns
            require("profile").setup({
              avatar_path = "/home/arch/Github/profile.nvim/resources/profile.png",
              -- avatar position options
              avatar_opts = {
                avatar_width = 20,
                avatar_height = 20,
                avatar_x = math.floor((win_width - 20) / 2),
                avatar_y = 7,
                force_blank = true,   -- if true, will create some blank lines (avatar_height + avatar_y)
              },
      
              -- git user
              user = "Kurama622",
              git_contributions = {
                start_week = 1, -- The minimum is 1
                end_week = 53, -- The maximum is 53
                empty_char = " ",
                full_char = { "", "󰧞", "", "", "" },
                fake_contributions = nil,
                cache_path = "/tmp/profile.nvim/", -- Cache the data of git contributions locally.
                cache_duration = 24 * 60 * 60, -- seconds, The cache validity period is 1 day.
      
                --[[
                -- If you want to fake git's contribution information,
                -- you can pass a function to fake_contributions.
                fake_contributions = function()
                  local ret = {}
                  for i = 1, 53 do
                    ret[tostring(i)] = {}
                    for j = 1, 7 do
                      ret[tostring(i)][j] = math.random(0, 5)
                    end
                  end
                  return ret
                end,
                ]]
      
                -- if you want to use a third-party API to fetch git contributions
                -- non_official_api_cmd = [[ curl -s "https://github-contributions-api.jogruber.de/v4/%s?y=$(date -d "1 year ago" +%%Y)&y=$(date +%%Y)" \
                --    | jq --arg start $(date -d "1 year ago" +%%Y-%%m-%%d) --arg end $(date +%%Y-%%m-%%d) \
                --    '.contributions | [ .[] | select((.date >= $start) and (.date <= $end)) ] | sort_by(.date) | (.[0].date | strptime("%%Y-%%m-%%d") | strftime("%%w") | tonumber) as $wd | map(.count) | ([range(0, $wd) ] | map(0)) + . | . as $array | reduce range(0; length; 7) as $i ({}; . + {($i/7+1 | tostring): $array[$i:$i+7] })' ]],
              },
              hide = {
                statusline = true,
                tabline = true,
              },
      
              disable_keys = { "h", "j", "k", "<Left>", "<Right>", "<Up>", "<Down>", "<C-f>" }, -- disable some mappings. (You can use it to disable cursor movement)
              cursor_pos = { 0, 0 },  -- set cursor position
      
              -- Customize the content to render
              format = function()
                -- render avatar
                comp:avatar()
                -- customize text component
                comp:text_component_render({
                  comp:text_component("git@github.com:Kurama622/profile.nvim", "center", "ProfileRed"),
                  comp:text_component("──── By Kurama622", "right", "ProfileBlue"),
                })
                comp:separator_render()
      
                -- Custom card component, render git repository by default
                comp:card_component_render({
                  type = "table",
                  content = function()
                    return {
                      {
                        title = "kurama622/llm.nvim",
                        description = [[LLM Neovim Plugin: Effortless Natural
      Language Generation with LLM's API]],
                      },
                      {
                        title = "kurama622/profile.nvim",
                        description = [[A Neovim plugin: Your Personal Homepage]],
                      },
                    }
                  end,
                  hl = {
                    border = "ProfileYellow",
                    text = "ProfileYellow",
                  },
                })
                comp:separator_render()
      
                -- git contributions, Considering network latency, the module will render asynchronously.
                -- you can also configure `fake_contributions`, so it won't fetch data from the Github
                comp:git_contributions_render("ProfileGreen")
              end,
            })
            vim.api.nvim_set_keymap("n", "<leader>p", "<cmd>Profile<cr>", { silent = true })
          end,
        },
      
      
        {
          "3rd/image.nvim",
          dependencies = {
            "leafo/magick",
          },
          config = function()
            require("image").setup({
              backend = "ueberzug",
              -- backend = "kitty",
              kitty_method = "normal",
              integrations = {
                markdown = {
                  enabled = true,
                  clear_in_insert_mode = true,
                  download_remote_images = true,
                  only_render_image_at_cursor = true,
                  filetypes = { "markdown", "vimwiki" }, -- markdown extensions (ie. quarto) can go here
                },
                html = {
                  enabled = false,
                },
                css = {
                  enabled = false,
                },
              },
              max_width = nil,
              max_height = nil,
              max_width_window_percentage = nil,
              max_height_window_percentage = 50,
              window_overlap_clear_enabled = true, -- toggles images when windows are overlapped
              -- window_overlap_clear_ft_ignore = { "cmp_menu", "cmp_docs", "" },
              editor_only_render_when_focused = true, -- auto show/hide images when the editor gains/looses focus
              tmux_show_only_in_active_window = true, -- auto show/hide images in the correct Tmux window (needs visual-activity off)
              hijack_file_patterns = { "*.png", "*.jpg", "*.jpeg", "*.gif", "*.webp", "*.avif" }, -- render image files as images when opened
            })
          end,
        },
      
      
      local user_mappings = {
        n = {
          ["r"] = "<cmd>lua require('telescope.builtin').oldfiles()<cr>",
          ["f"] = "<cmd>lua require('telescope.builtin').find_files()<cr>",
          ["c"] = "<cmd>lua require('telescope.builtin').find_files({ cwd = '$HOME/.config/nvim' })<cr>",
          ["/"] = "<cmd>lua require('telescope.builtin').live_grep()<cr>",
          ["n"] = "<cmd>enew<cr>",
          ["l"] = "<cmd>Lazy<cr>",
        },
      }
      vim.api.nvim_create_autocmd("FileType", {
        pattern = "profile",
        callback = function()
          for mode, mapping in pairs(user_mappings) do
            for key, cmd in pairs(mapping) do
              vim.api.nvim_buf_set_keymap(0, mode, key, cmd, { noremap = true, silent = true })
            end
          end
        end,
      })
      
      
      --[[
      full_char = { "█", "█", "█", "█", "█" },
      full_char = { "■", "■", "■", "■", "■" },
      full_char = { "▄", "▅", "▆", "▇", "█" },
      full_char = { "", "󰧞", "", "", "" },
      ]]
      
      
      return {
        {
          "Kurama622/profile.nvim",
          config = function()
            local comp = require("profile.components")
            require("profile").setup({
              avatar_opts = {
                force_blank = false,
              },
              user = "Kurama622",
              git_contributions = {
                start_week = 1,
                end_week = 53,
                empty_char = " ",
                full_char = { "", "󰧞", "", "", "" },
                fake_contributions = nil,
              },
              hide = {
                statusline = true,
                tabline = true,
              },
              disable_keys = { "h", "j", "k", "<Left>", "<Right>", "<Up>", "<Down>", "<C-f>" },
              cursor_pos = { 17, 48 },
              format = function()
                local header = {
                  [[                                                                       ]],
                  [[                                                                       ]],
                  [[                                                                       ]],
                  [[                                                                       ]],
                  [[                                                                       ]],
                  [[                                                                       ]],
                  [[                                                                     ]],
                  [[       ████ ██████           █████      ██                     ]],
                  [[      ███████████             █████                             ]],
                  [[      █████████ ███████████████████ ███   ███████████   ]],
                  [[     █████████  ███    █████████████ █████ ██████████████   ]],
                  [[    █████████ ██████████ █████████ █████ █████ ████ █████   ]],
                  [[  ███████████ ███    ███ █████████ █████ █████ ████ █████  ]],
                  [[ ██████  █████████████████████ ████ █████ █████ ████ ██████ ]],
                  [[                                                                       ]],
                }
                for _, line in ipairs(header) do
                  comp:text_component_render({ comp:text_component(line, "center", "ProfileBlue") })
                end
      
                comp:text_component_render({
                  comp:text_component("git@github.com:Kurama622/profile.nvim", "center", "ProfileRed"),
                  comp:text_component("──── By Kurama622", "right", "ProfileBlue"),
                })
                comp:separator_render()
                comp:card_component_render({
                  type = "table",
                  content = function()
                    return {
                      {
                        title = "kurama622/llm.nvim",
                        description = [[LLM Neovim Plugin: Effortless Natural
      Language Generation with LLM's API]],
                      },
                      {
                        title = "kurama622/profile.nvim",
                        description = [[A Neovim plugin: Your Personal Homepage]],
                      },
                    }
                  end,
                  hl = {
                    border = "ProfileYellow",
                    text = "ProfileYellow",
                  },
                })
                comp:separator_render()
                comp:git_contributions_render("ProfileGreen")
              end,
            })
            vim.api.nvim_set_keymap("n", "<leader>p", "<cmd>Profile<cr>", { silent = true })
      
            local user_mappings = {
              n = {
                ["r"] = "<cmd>FzfLua oldfiles<cr>",
                ["f"] = "<cmd>FzfLua files<cr>",
                ["c"] = "<cmd>FzfLua files cwd=$HOME/.config/nvim<cr>",
                ["/"] = "<cmd>FzfLua live_grep<cr>",
                ["n"] = "<cmd>enew<cr>",
                ["l"] = "<cmd>Lazy<cr>",
              },
            }
            vim.api.nvim_create_autocmd("FileType", {
              pattern = "profile",
              callback = function()
                for mode, mapping in pairs(user_mappings) do
                  for key, cmd in pairs(mapping) do
                    vim.api.nvim_buf_set_keymap(0, mode, key, cmd, { noremap = true, silent = true })
                  end
                end
              end,
            })
          end,
        },
      }
      
    end,
  },
  {
    "nvim-tree/nvim-web-devicons",
    config = function()
      
      use 'nvim-tree/nvim-web-devicons'
      
      
      { "nvim-tree/nvim-web-devicons", opts = {} },
      
      
      require'nvim-web-devicons'.setup {
       -- your personal icons can go here (to override)
       -- you can specify color or cterm_color instead of specifying both of them
       -- DevIcon will be appended to `name`
       override = {
        zsh = {
          icon = "",
          color = "#428850",
          cterm_color = "65",
          name = "Zsh"
        }
       };
       -- globally enable different highlight colors per icon (default to true)
       -- if set to false all icons will have the default icon's color
       color_icons = true;
       -- globally enable default icons (default to false)
       -- will get overriden by `get_icons` option
       default = true;
       -- globally enable "strict" selection of icons - icon will be looked up in
       -- different tables, first by filename, and if not found by extension; this
       -- prevents cases when file doesn't have any extension but still gets some icon
       -- because its name happened to match some extension (default to false)
       strict = true;
       -- set the light or dark variant manually, instead of relying on `background`
       -- (default to nil)
       variant = "light|dark";
       -- override blend value for all highlight groups :h highlight-blend.
       -- setting this value to `0` will make all icons opaque. in practice this means
       -- that icons width will not be affected by pumblend option (see issue #608)
       -- (default to nil)
       blend = 0;
       -- same as `override` but specifically for overrides by filename
       -- takes effect when `strict` is true
       override_by_filename = {
        [".gitignore"] = {
          icon = "",
          color = "#f1502f",
          name = "Gitignore"
        }
       };
       -- same as `override` but specifically for overrides by extension
       -- takes effect when `strict` is true
       override_by_extension = {
        ["log"] = {
          icon = "",
          color = "#81e043",
          name = "Log"
        }
       };
       -- same as `override` but specifically for operating system
       -- takes effect when `strict` is true
       override_by_operating_system = {
        ["apple"] = {
          icon = "",
          color = "#A2AAAD",
          cterm_color = "248",
          name = "Apple",
        },
       };
      }
      
      
      require'nvim-web-devicons'.get_icon(filename, extension, options)
      
      
      require'nvim-web-devicons'.get_icon(filename, extension, { default = true })
      
      
      require'nvim-web-devicons'.has_loaded()
      
      
      local icon, color = require'nvim-web-devicons'.get_icon_color("init.lua", "lua")
      assert(icon == "")
      assert(color == "#51a0cf")
      
      
      require'nvim-web-devicons'.get_icons()
      
      
      require'nvim-web-devicons'.get_icons_by_filename()
      require'nvim-web-devicons'.get_icons_by_extension()
      require'nvim-web-devicons'.get_icons_by_operating_system()
      require'nvim-web-devicons'.get_icons_by_desktop_environment()
      require'nvim-web-devicons'.get_icons_by_window_manager()
      
      
      require("nvim-web-devicons").set_icon {
        zsh = {
          icon = "",
          color = "#428850",
          cterm_color = "65",
          name = "Zsh"
        }
      }
      
      
      require("nvim-web-devicons").set_default_icon('', '#6d8086', 65)
      
      
      require("nvim-web-devicons").get_icon_by_filetype(filetype, opts)
      require("nvim-web-devicons").get_icon_colors_by_filetype(filetype, opts)
      require("nvim-web-devicons").get_icon_color_by_filetype(filetype, opts)
      require("nvim-web-devicons").get_icon_cterm_color_by_filetype(filetype, opts)
      
      
      require("nvim-web-devicons").set_icon_by_filetype { cpp = "c", pandoc = "md", }
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-icons.md",
  },
  {
    "ya2s/nvim-nonicons",
    config = function()
      
      use 'yamatsum/nvim-nonicons'
      
      -- if use nvim-web-devicons
      use {
        'yamatsum/nvim-nonicons',
        requires = {'kyazdani42/nvim-web-devicons'}
      }
      
      
      require('nvim-nonicons').setup {}
      
      
      local icons = require "nvim-nonicons"
      
      icons.get("file")
      
      
      local icons = require("nvim-nonicons")
      
      require("telescope").setup({
        defaults = {
          prompt_prefix = "  " .. icons.get("telescope") .. "  ",
          selection_caret = " ❯ ",
          entry_prefix = "   ",
        },
      })
      
      
      local nonicons_extention = require("nvim-nonicons.extentions.nvim-tree")
      
      require("nvim-tree").setup({
        renderer = {
          icons = {
            glyphs = nonicons_extention.glyphs,
          },
        },
      })
      
      
      local icons = require("nvim-nonicons")
      local nonicons_extention = require("nvim-nonicons.extentions.lualine")
      
      require("lualine").setup({
        sections = {
          lualine_a = { nonicons_extention.mode },
          lualine_z = {
            {
              "branch",
              icon = icons.get("git-branch"),
            },
          },
        }
      })
      
      
      local nonicons_extention = require("nvim-nonicons.extentions.nvim-lsp-installer")
      
      require("nvim-lsp-installer").setup({
        ui = {
          icons = nonicons_extention.icons,
        },
      })
      
      
      local nonicons_extention = require("nvim-nonicons.extentions.nvim-notify")
      
      require("notify").setup({
        icons = nonicons_extention.icons,
      })
      
    end,
  },
  {
    "ziontee113/icon-picker.nvim",
    config = function()
      
      {
          "ziontee113/icon-picker.nvim",
          config = function()
              require("icon-picker").setup({ disable_legacy_commands = true })
      
              local opts = { noremap = true, silent = true }
      
              vim.keymap.set("n", "<Leader><Leader>i", "<cmd>IconPickerNormal<cr>", opts)
              vim.keymap.set("n", "<Leader><Leader>y", "<cmd>IconPickerYank<cr>", opts) --> Yank the selected icon into register
              vim.keymap.set("i", "<C-i>", "<cmd>IconPickerInsert<cr>", opts)
          end
      }
      
      
      use "stevearc/dressing.nvim"
      use({
        "ziontee113/icon-picker.nvim",
        config = function()
          require("icon-picker").setup({
            disable_legacy_commands = true
          })
        end,
      })
      
      
      local opts = { noremap = true, silent = true }
      
      vim.keymap.set("n", "<Leader><Leader>i", "<cmd>IconPickerNormal<cr>", opts)
      vim.keymap.set("n", "<Leader><Leader>y", "<cmd>IconPickerYank<cr>", opts) --> Yank the selected icon into register
      vim.keymap.set("i", "<C-i>", "<cmd>IconPickerInsert<cr>", opts)
      
      
      local opts = { noremap = true, silent = true }
      
      vim.keymap.set("n", "<Leader><Leader>i", "<cmd>PickEverything<cr>", opts)
      vim.keymap.set("n", "<Leader><Leader>y", "<cmd>PickEverythingYank<cr>", opts)
      vim.keymap.set("i", "<C-i>", "<cmd>PickEverythingInsert<cr>", opts)
      
    end,
  },
  {
    "2KAbhishek/nerdy.nvim/",
  },
  {
    "pandasoli/nekovim",
    config = function()
      
      ---@type func(PresenceMakers, WorkPropsMakers)
      require 'nekovim'.setup {}
      
    end,
  },
  {
    "edluffy/hologram.nvim",
    config = function()
      
      use {'edluffy/hologram.nvim'}
      
      
      require('hologram').setup{
          auto_display = true -- WIP automatic markdown image display, may be prone to breaking
      }
      
      
      local source = '/Users/.../Documents/my-image.png'
      local buf = vim.api.nvim_get_current_buf()
      local image = require('hologram.image'):new(source, {})
      
      -- Image should appear below this line, then disappear after 5 seconds
      
      image:display(5, 0, buf, {})
      
      vim.defer_fn(function()
          image:delete(0, {free = true})
      end, 5000)
      
      
      Image:new(source, {
          format = 100, -- format in which image data is sent
          transmission_type = 'f', -- transmission medium used
          data_width = nil, -- px. width of image
          data_height = nil, -- px. height of image
          data_size = nil, -- size of data to read from file
          data_offset = nil, -- offset from which to read file data
          image_number = nil, -- image number
          compressed = nil, -- whether data is compressed or not
          image_id = nil, -- image id
          placement_id = 1, -- placement id
      })
      
      
      Image:display(row, col, buf, {
          x_offset = nil, -- left edge of image area to start displaying from (px.)
          y_offset = nil, -- top edge of image area to start displaying from (px.)
          width = nil, -- width of image area to display
          height = nil, -- height of image area to display
          cell_x = nil, -- x-offset within first cell to start displaying from (px.)
          cell_y = nil, -- y-offset within first cell to start displaying from (px.)
          cols = nil, -- number of columns to display over
          rows = nil, -- number of rows to display over
          z_index = 0, -- vertical stacking order of image
          placement_id = 1, -- placement id
      })
      
      
      Image:delete(id, {
          free = false -- when deleting image, free stored image data and also extmark of image. (default: false)
      })
      
    end,
  },
  {
    "HakonHarnes/img-clip.nvim",
    config = function()
      
      return {
        "HakonHarnes/img-clip.nvim",
        event = "VeryLazy",
        opts = {
          -- add options here
          -- or leave it empty to use the default settings
        },
        keys = {
          -- suggested keymap
          { "<leader>p", "<cmd>PasteImage<cr>", desc = "Paste image from system clipboard" },
        },
      }
      
      
      require("img-clip").paste_image(opts?, input?) -- input is optional and can be a file path or URL
      
      
      require("img-clip").paste_image({ use_absolute_path = false, file_name = "image.png" }, "/path/to/file.png")
      
      
      {
        default = {
          -- file and directory options
          dir_path = "assets", ---@type string | fun(): string
          extension = "png", ---@type string | fun(): string
          file_name = "%Y-%m-%d-%H-%M-%S", ---@type string | fun(): string
          use_absolute_path = false, ---@type boolean | fun(): boolean
          relative_to_current_file = false, ---@type boolean | fun(): boolean
      
          -- logging options
          verbose = true, ---@type boolean | fun(): boolean
      
          -- template options
          template = "$FILE_PATH", ---@type string | fun(context: table): string
          url_encode_path = false, ---@type boolean | fun(): boolean
          relative_template_path = true, ---@type boolean | fun(): boolean
          use_cursor_in_template = true, ---@type boolean | fun(): boolean
          insert_mode_after_paste = true, ---@type boolean | fun(): boolean
          insert_template_after_cursor = true, ---@type boolean | fun(): boolean
      
          -- prompt options
          prompt_for_file_name = true, ---@type boolean | fun(): boolean
          show_dir_path_in_prompt = false, ---@type boolean | fun(): boolean
      
          -- base64 options
          max_base64_size = 10, ---@type number | fun(): number
          embed_image_as_base64 = false, ---@type boolean | fun(): boolean
      
          -- image options
          process_cmd = "", ---@type string | fun(): string
          copy_images = false, ---@type boolean | fun(): boolean
          download_images = true, ---@type boolean | fun(): boolean
      
          -- drag and drop options
          drag_and_drop = {
            enabled = true, ---@type boolean | fun(): boolean
            insert_mode = false, ---@type boolean | fun(): boolean
          },
        },
      
        -- filetype specific options
        filetypes = {
          markdown = {
            url_encode_path = true, ---@type boolean | fun(): boolean
            template = "![$CURSOR]($FILE_PATH)", ---@type string | fun(context: table): string
            download_images = false, ---@type boolean | fun(): boolean
          },
      
          vimwiki = {
            url_encode_path = true, ---@type boolean | fun(): boolean
            template = "![$CURSOR]($FILE_PATH)", ---@type string | fun(context: table): string
            download_images = false, ---@type boolean | fun(): boolean
          },
      
          html = {
            template = '<img src="$FILE_PATH" alt="$CURSOR">', ---@type string | fun(context: table): string
          },
      
          tex = {
            relative_template_path = false, ---@type boolean | fun(): boolean
            template = [[
      \begin{figure}[h]
        \centering
        \includegraphics[width=0.8\textwidth]{$FILE_PATH}
        \caption{$CURSOR}
        \label{fig:$LABEL}
      \end{figure}
          ]], ---@type string | fun(context: table): string
          },
      
          typst = {
            template = [[
      #figure(
        image("$FILE_PATH", width: 80%),
        caption: [$CURSOR],
      ) <fig-$LABEL>
          ]], ---@type string | fun(context: table): string
          },
      
          rst = {
            template = [[
      .. image:: $FILE_PATH
         :alt: $CURSOR
         :width: 80%
          ]], ---@type string | fun(context: table): string
          },
      
          asciidoc = {
            template = 'image::$FILE_PATH[width=80%, alt="$CURSOR"]', ---@type string | fun(context: table): string
          },
      
          org = {
            template = [=[
      #+BEGIN_FIGURE
      [[file:$FILE_PATH]]
      #+CAPTION: $CURSOR
      #+NAME: fig:$LABEL
      #+END_FIGURE
          ]=], ---@type string | fun(context: table): string
          },
        },
      
        -- file, directory, and custom triggered options
        files = {}, ---@type table | fun(): table
        dirs = {}, ---@type table | fun(): table
        custom = {}, ---@type table | fun(): table
      }
      
      
      dir_path = function()
        return vim.fn.expand("%:t:r")
      end,
      
      
      filetypes = {
        <filetype> = { -- obtained from "set filetype?"
          -- add options here
        }
      }
      
      
      filetypes = {
        tex = {
          use_absolute_path = true
        }
      }
      
      
      -- file specific options
      files = {
        ["/path/to/specific/file.md"] = {
          template = "Custom template for this file",
        },
        ["README.md"] = {
          template = "Custom template for README.md files",
        },
      },
      
      -- directory specific options
      dirs = {
        ["/path/to/project"] = {
          template = "Project specific template",
        },
      },
      
      -- custom options
      custom = {
        {
          trigger = function() -- returns true to enable
            return vim.fn.strftime("%A") == "Monday"
          end,
          template = "Template for Mondays only",
        },
      }
      
      
      dirs = {
        ["/home/user/markdown"] = {
          template = "template for this project",
      
          filetypes = { -- filetype options nested inside dirs
            markdown = {
              template = "markdown template"
            }
          },
      
          files = { -- file options nested inside dirs
            ["readme.md"] = {
              dir_path = "images"
            },
          },
        },
      }
      
      
      return {
        -- add options here
      }
      
      
      return {
        default = {
          template = "default template"
        },
      
        filetypes = {
          markdown = {
            template = "markdown template"
          }
        },
      }
      
      
      template = function(context)
        return "![" .. context.cursor .. "](" .. context.file_path .. ")"
      end
      
      
      function()
        local telescope = require("telescope.builtin")
        local actions = require("telescope.actions")
        local action_state = require("telescope.actions.state")
      
        telescope.find_files({
          attach_mappings = function(_, map)
            local function embed_image(prompt_bufnr)
              local entry = action_state.get_selected_entry()
              local filepath = entry[1]
              actions.close(prompt_bufnr)
      
              local img_clip = require("img-clip")
              img_clip.paste_image(nil, filepath)
            end
      
            map("i", "<CR>", embed_image)
            map("n", "<CR>", embed_image)
      
            return true
          end,
        })
      end
      
      
      function()
          Snacks.picker.files {
          	ft = { "jpg", "jpeg", "png", "webp" },
          	confirm = function(self, item, _)
          	    self:close()
          	    require("img-clip").paste_image({}, "./" .. item.file) -- ./ is necessary for img-clip to recognize it as path
          	end,
          }
      end()
      
      
      function()
        local oil = require("oil")
        local filename = oil.get_cursor_entry().name
        local dir = oil.get_current_dir()
        oil.close()
      
        local img_clip = require("img-clip")
        img_clip.paste_image({}, dir .. filename)
      end
      
      
      keymaps = {
        ["<leader>p"] = function()
          local oil = require("oil")
          local filename = oil.get_cursor_entry().name
          local dir = oil.get_current_dir()
          oil.close()
      
          local img_clip = require("img-clip")
          img_clip.paste_image({}, dir .. filename)
        end,
      }
      
    end,
  },
  {
    "ekickx/clipboard-image.nvim",
    config = function()
      
      require'clipboard-image'.setup {
        -- Default configuration for all filetype
        default = {
          img_dir = "images",
          img_name = function() return os.date('%Y-%m-%d-%H-%M-%S') end, -- Example result: "2021-04-13-10-04-18"
          affix = "<\n  %s\n>" -- Multi lines affix
        },
        -- You can create configuration for ceartain filetype by creating another field (markdown, in this case)
        -- If you're uncertain what to name your field to, you can run `lua print(vim.bo.filetype)`
        -- Missing options from `markdown` field will be replaced by options from `default` field
        markdown = {
          img_dir = {"src", "assets", "img"}, -- Use table for nested dir (New feature form PR #20)
          img_dir_txt = "/assets/img",
          img_handler = function(img) -- New feature from PR #22
            local script = string.format('./image_compressor.sh "%s"', img.path)
            os.execute(script)
          end,
        }
      }
      
      
      {
        default = {
          <options>
        },
        <filetype> = {
          <options>
        },
      }
      
    end,
  },
  {
    "niuiic/cp-image.nvim",
    config = function()
      
      require("cp-image").setup(
      	-- default config
      	{
      		-- how to generate the image from clipboard and place it
      		-- image_type is the suffix of file name
      		cmd = function(path, image_type)
      			return string.format("xclip -selection clipboard -t image/%s -o > %s", image_type, path)
      		end,
      		---@diagnostic disable-next-line:unused-local
      		-- text to insert
      		-- relative_path is relative to the root path of the project
      		text = function(relative_path, file_name, file_type, full_path)
      			return string.format("![%s](%s)", file_name, relative_path)
      		end,
      		-- default directory path to store image
      		path = function(project_root)
      			return project_root
      		end,
      		-- used to search root path of the project
      		-- if .git does not exist, current directory path would be used
      		root_pattern = ".git",
      	}
      )
      
    end,
  },
  {
    "askfiy/nvim-picgo",
  },
  {
    "madskjeldgaard/reaper-nvim",
    config = function()
      
      -- Which fuzzy finder to use with reaper-nvim: Can be either "fzf" or "skim"
      vim.g.reaper_fuzzy_command = "fzf"
      
      -- Target port of the Reaper session receiving these osc messages
      vim.g.reaper_target_port = 1234
      
      -- Target ip
      vim.g.reaper_target_ip = "127.0.0.1"
      
      -- Browser command used for opening links
      vim.g.reaper_browser_command = "firefox"
      
    end,
  },
  {
    "davidgranstrom/scnvim",
    config = function()
      
      return {
        'davidgranstrom/scnvim',
        ft = 'supercollider',
        config = function()
          local scnvim = require 'scnvim'
          local map = scnvim.map
          local map_expr = scnvim.map_expr
          scnvim.setup {
            -- your config here
          }
        end
      }
      
      
      use { 'davidgranstrom/scnvim' }
      
      
      local scnvim = require 'scnvim'
      local map = scnvim.map
      local map_expr = scnvim.map_expr
      
      scnvim.setup({
        keymaps = {
          ['<M-e>'] = map('editor.send_line', {'i', 'n'}),
          ['<C-e>'] = {
            map('editor.send_block', {'i', 'n'}),
            map('editor.send_selection', 'x'),
          },
          ['<CR>'] = map('postwin.toggle'),
          ['<M-CR>'] = map('postwin.toggle', 'i'),
          ['<M-L>'] = map('postwin.clear', {'n', 'i'}),
          ['<C-k>'] = map('signature.show', {'n', 'i'}),
          ['<F12>'] = map('sclang.hard_stop', {'n', 'x', 'i'}),
          ['<leader>st'] = map('sclang.start'),
          ['<leader>sk'] = map('sclang.recompile'),
          ['<F1>'] = map_expr('s.boot'),
          ['<F2>'] = map_expr('s.meter'),
        },
        editor = {
          highlight = {
            color = 'IncSearch',
          },
        },
        postwin = {
          float = {
            enabled = true,
          },
        },
      })
      
      
      local scnvim = require('scnvim')
      scnvim.setup({
        sclang = {
          cmd = 'C:/Program Files/SuperCollider-3.12.2/sclang.exe'
        },
      })
      
    end,
  },
  {
    "andweeb/presence.nvim",
    config = function()
      
      -- The setup config table shows all available config options with their default values:
      require("presence").setup({
          -- General options
          auto_update         = true,                       -- Update activity based on autocmd events (if `false`, map or manually execute `:lua package.loaded.presence:update()`)
          neovim_image_text   = "The One True Text Editor", -- Text displayed when hovered over the Neovim image
          main_image          = "neovim",                   -- Main image display (either "neovim" or "file")
          client_id           = "793271441293967371",       -- Use your own Discord application client id (not recommended)
          log_level           = nil,                        -- Log messages at or above this level (one of the following: "debug", "info", "warn", "error")
          debounce_timeout    = 10,                         -- Number of seconds to debounce events (or calls to `:lua package.loaded.presence:update(<filename>, true)`)
          enable_line_number  = false,                      -- Displays the current line number instead of the current project
          blacklist           = {},                         -- A list of strings or Lua patterns that disable Rich Presence if the current file name, path, or workspace matches
          buttons             = true,                       -- Configure Rich Presence button(s), either a boolean to enable/disable, a static table (`{{ label = "<label>", url = "<url>" }, ...}`, or a function(buffer: string, repo_url: string|nil): table)
          file_assets         = {},                         -- Custom file asset definitions keyed by file names and extensions (see default config at `lua/presence/file_assets.lua` for reference)
          show_time           = true,                       -- Show the timer
      
          -- Rich Presence text options
          editing_text        = "Editing %s",               -- Format string rendered when an editable file is loaded in the buffer (either string or function(filename: string): string)
          file_explorer_text  = "Browsing %s",              -- Format string rendered when browsing a file explorer (either string or function(file_explorer_name: string): string)
          git_commit_text     = "Committing changes",       -- Format string rendered when committing changes in git (either string or function(filename: string): string)
          plugin_manager_text = "Managing plugins",         -- Format string rendered when managing plugins (either string or function(plugin_manager_name: string): string)
          reading_text        = "Reading %s",               -- Format string rendered when a read-only or unmodifiable file is loaded in the buffer (either string or function(filename: string): string)
          workspace_text      = "Working on %s",            -- Format string rendered when in a git repository (either string or function(project_name: string|nil, filename: string): string)
          line_number_text    = "Line %s out of %s",        -- Format string rendered when `enable_line_number` is set to true (either string or function(line_number: number, line_count: number): string)
      })
      
    end,
  },
  {
    "Chaitanyabsprip/present.nvim",
  },
  {
    "krady21/compiler-explorer.nvim",
    config = function()
      
      require('packer').startup(function()
        use {'krady21/compiler-explorer.nvim'}
      end
      
      
      require("paq") {
        {'krady21/compiler-explorer.nvim'};
      }
      
      
      require("compiler-explorer").setup({
        url = "https://godbolt.org",
        infer_lang = true, -- Try to infer possible language based on file extension.
        line_match = {
          highlight = false, -- highlight the matching line(s) in the other buffer.
          jump = false, -- move the cursor in the other buffer to the first matching line.
        },
        open_qflist = false, --  Open qflist after compilation if there are diagnostics.
        split = "split", -- How to split the window after the second compile (split/vsplit).
        compiler_flags = "", -- Default flags passed to the compiler.
        job_timeout_ms = 25000, -- Timeout for libuv job in milliseconds.
        languages = { -- Language specific default compiler/flags
          --c = {
          --  compiler = "g121",
          --  compiler_flags = "-O2 -Wall",
          --},
        },
      })
      
    end,
  },
  {
    "3rd/image.nvim",
    config = function()
      
      {
          "3rd/image.nvim",
          build = false, -- so that it doesn't build the rock https://github.com/3rd/image.nvim/issues/91#issuecomment-2453430239
          opts = {
              processor = "magick_cli",
          }
      }
      
      
      require("lazy").setup({
          rocks = {
              hererocks = true,  -- recommended if you do not have global installation of Lua 5.1.
          },
          spec = {
              {
                  "3rd/image.nvim",
                  opts = {}
              },
          }
      })
      
      
      {
          "vhyrro/luarocks.nvim",
          priority = 1001, -- this plugin needs to run before anything else
          opts = {
              rocks = { "magick" },
          },
      },
      {
          "3rd/image.nvim",
          dependencies = { "luarocks.nvim" },
          opts = {}
      }
      
      
      -- Example for configuring Neovim to load user-installed installed Lua rocks:
      package.path = package.path .. ";" .. vim.fn.expand("$HOME") .. "/.luarocks/share/lua/5.1/?/init.lua"
      package.path = package.path .. ";" .. vim.fn.expand("$HOME") .. "/.luarocks/share/lua/5.1/?.lua"
      
      {
          "3rd/image.nvim",
          opts = {}
      }
      
      
      require("image").setup({
        backend = "kitty", -- or "ueberzug" or "sixel"
        processor = "magick_cli", -- or "magick_rock"
        integrations = {
          markdown = {
            enabled = true,
            clear_in_insert_mode = false,
            download_remote_images = true,
            only_render_image_at_cursor = false,
            only_render_image_at_cursor_mode = "popup", -- or "inline"
            floating_windows = false, -- if true, images will be rendered in floating markdown windows
            filetypes = { "markdown", "vimwiki" }, -- markdown extensions (ie. quarto) can go here
          },
          neorg = {
            enabled = true,
            filetypes = { "norg" },
          },
          typst = {
            enabled = true,
            filetypes = { "typst" },
          },
          html = {
            enabled = false,
          },
          css = {
            enabled = false,
          },
        },
        max_width = nil,
        max_height = nil,
        max_width_window_percentage = nil,
        max_height_window_percentage = 50,
        scale_factor = 1.0,
        window_overlap_clear_enabled = false, -- toggles images when windows are overlapped
        window_overlap_clear_ft_ignore = { "cmp_menu", "cmp_docs", "snacks_notif", "scrollview", "scrollview_sign" },
        editor_only_render_when_focused = false, -- auto show/hide images when the editor gains/looses focus
        tmux_show_only_in_active_window = false, -- auto show/hide images in the correct Tmux window (needs visual-activity off)
        hijack_file_patterns = { "*.png", "*.jpg", "*.jpeg", "*.gif", "*.webp", "*.avif" }, -- render image files as images when opened
      })
      
      
      require('image').setup({
        integrations = {
          markdown = {
            resolve_image_path = function(document_path, image_path, fallback)
              -- document_path is the path to the file that contains the image
              -- image_path is the potentially relative path to the image. for
              -- markdown it's `![](this text)`
      
              -- you can call the fallback function to get the default behavior
              return fallback(document_path, image_path)
            end,
          }
        }
      })
      
      
      require("image").enable() -- enable the plugin
      require("image").disable() -- disable the plugin
      print(require("image").is_enabled()) -- bool
      
      
      require("image").setup({
        integrations = {
          markdown = {
              only_render_image_at_cursor = true, -- defaults to false
              only_render_image_at_cursor_mode = "popup", -- "popup" or "inline", defaults to "popup"
          }
      })
      
      
      local api = require("image")
      
      -- from a file (absolute path)
      local image = api.from_file("/path/to/image.png", {
        id = "my_image_id", -- optional, defaults to a random string
        window = 1000, -- optional, binds image to a window and its bounds
        buffer = 1000, -- optional, binds image to a buffer (paired with window binding)
        with_virtual_padding = true, -- optional, pads vertically with extmarks, defaults to false
      
        -- optional, binds image to an extmark which it follows. Forced to be true when
        -- `with_virtual_padding` is true. defaults to false.
        inline = true,
      
        -- geometry (optional)
        x = 1,
        y = 1,
        width = 10,
        height = 10
      })
      
      -- from a URL
      api.from_url("https://gist.ro/s/remote.png", {
          -- all the same options from above
      }, function(img)
          -- do stuff with the image
      end
      )
      
      image:render() -- render image
      image:render(geometry) -- update image geometry and render it
      image:clear()
      
      image:move(x, y) -- move image
      image:brightness(value) -- change brightness
      image:saturation(value) -- change saturation
      image:hue(value) -- change hue
      
      -- create a report, also available as :ImageReport
      require("image").create_report()
      
    end,
  },
  {
    "adelarsq/image_preview.nvim",
    config = function()
      
      {
          'adelarsq/image_preview.nvim',
          event = 'VeryLazy',
          config = function()
              require("image_preview").setup()
          end
      },
      
      
      require("image_preview").setup({})
      
      
      require("neo-tree").setup({
        filesystem = {
          window = {
            mappings = {
              ["<leader>p"] = "image_wezterm", -- " or another map
            },
          },
          commands = {
            image_wezterm = function(state)
              local node = state.tree:get_node()
              if node.type == "file" then
                require("image_preview").PreviewImage(node.path)
              end
            end,
          },
        },
      }
      
    end,
  },
  {
    "niuiic/code-shot.nvim",
    config = function()
      
      ---@class code-shot.Context
      ---@field file_path string
      ---@field file_type string
      ---@field selected_area omega.Area
      ---@field selection string
      
      ---@class omega.Area
      ---@field start_lnum number
      ---@field start_col number
      ---@field end_lnum number
      ---@field end_col number
      
      
      local function shot_file_to_clipboard()
      	require("code-shot").shot(function(context)
      		vim.system(
      			{
      				"silicon",
      				"--to-clipboard",
      				context.file_path,
      			},
      			nil,
      			function(result)
      				if result.code == 0 then
      					vim.notify("Shot code successfully", vim.log.levels.INFO)
      				else
      					vim.notify("Shot code failed", vim.log.levels.ERROR)
      				end
      			end
      		)
      	end)
      end
      
      
      local function shot_file_to_file()
      	require("code-shot").shot(function(context)
      		vim.system(
      			{
      				"silicon",
      				"-o",
      				string.format("%s.png", os.date("%Y-%m-%d_%H:%M:%S")),
      				context.file_path,
      			},
      			nil,
      			function(result)
      				if result.code == 0 then
      					vim.notify("Shot code successfully", vim.log.levels.INFO)
      				else
      					vim.notify("Shot code failed", vim.log.levels.ERROR)
      				end
      			end
      		)
      	end)
      end
      
      
      
      local function shot_selection_to_clipboard()
      	require("code-shot").shot(function(context)
      		vim.system({
      			"silicon",
      			"--to-clipboard",
      			"--language",
      			context.file_type,
      		}, { stdin = context.selection }, function(result)
      			if result.code == 0 then
      				vim.notify("Shot code successfully", vim.log.levels.INFO)
      			else
      				vim.notify("Shot code failed", vim.log.levels.ERROR)
      			end
      		end)
      	end)
      end
      
      
      local shot_selection_to_file = function()
      	require("code-shot").shot(function(context)
      		require("omega").to_normal_mode()
      
      		vim.system({
      			"silicon",
      			"-o",
      			string.format("%s.png", os.date("%Y-%m-%d_%H:%M:%S")),
      			"--language",
      			context.file_type,
      		}, {
      			stdin = context.selection,
      		}, function(result)
      			if result.code == 0 then
      				vim.notify("Shot code successfully", vim.log.levels.INFO)
      			else
      				vim.notify("Shot code failed", vim.log.levels.ERROR)
      			end
      		end)
      	end)
      end
      
    end,
  },
  {
    "AntonVanAssche/music-controls.nvim",
    config = function()
      
      {
        'AntonVanAssche/music-controls.nvim',
      }
      
      
      {
        'AntonVanAssche/music-controls.nvim',
        opts = {
          default_player = 'spotify'
        }
      }
      
      
      require('lualine').setup {
        sections = {
          lualine_x = {
            require("music-controls")._statusline,
          }
        }
      }
      
    end,
  },
  {
    "Rits1272/riff.nvim",
    config = function()
      
      {
        "rits1272/riff.nvim",
        dependencies = { "nvim-telescope/telescope.nvim" },
        opts = {
            ytdlp_cmd = "yt-dlp",
            status_echo_delay_ms = 10,
        },
      }
      
      
      use {
        "rits1272/riff.nvim",
        requires = { "nvim-telescope/telescope.nvim" },
        config = function()
          require("riff").setup({
            ytdlp_cmd = "yt-dlp",
            status_echo_delay_ms = 10,
          })
        end,
      }
      
    end,
  },
  {
    "neo451/feed.nvim",
    config = function()
      
      return {
         "neo451/feed.nvim",
         cmd = "Feed",
         ---@module 'feed'
         ---@type feed.config
         opts = {},
      }
      
    end,
  },
  {
    "vyfor/cord.nvim",
    config = function()
      
      {
        'vyfor/cord.nvim',
        build = ':Cord update',
        -- opts = {}
      }
      
      
      use {
        'vyfor/cord.nvim',
        run = ':Cord update',
        -- config = function()
        --   require('cord').setup {}
        -- end
      }
      
      
      vim.pack.add { 'https://github.com/vyfor/cord.nvim' }
      vim.api.nvim_create_autocmd('PackChanged', {
        callback = function(opts)
          if opts.data.spec.name == 'cord.nvim' and opts.data.kind == 'update' then 
            vim.cmd 'Cord update'
          end
        end
      })
      
    end,
  },
  {
    "iamt4nk/smm.nvim",
    config = function()
      
      {
         'iamt4nk/smm.nvim',
         dependencies = {
           'nvim-lua/plenary.nvim',
           'nvim-telescope/telescope.nvim',
         },
         config = {
            premium = true,
            icons = true,                       -- Whether to use nerdfonts
            
            -- debug = true,                    -- These can be used in case there are any issues and you need to debug.
            -- file = '/tmp/smm_debug.log'
      
            playback = {
               timer_update_interval = 250,     -- How often the timer itself is  updated in ms
               timer_sync_interval = 5000,      -- How often sync requests are sent to the server in ms
               playback_pos = 'BottomRight',    -- Options { 'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight' }
               playback_width = 40,             -- Width of the playback window
               progress_bar_width = 35,         -- Width of the progress bar
            },
      
            spotify = {
               api_retry_max = 3,               -- The number of times to retry before failing out.
               api_retry_backoff = 2000,
               auth = {                         -- These are the only absolutely required configurations.
                  client_id = '<your client id>',
                  callback_url = '<your callback URL>',
                  callback_port = '<your callback port>',
               },
            },
         },
      },
      
    end,
  },
  {
    "jameswolensky/marker-groups.nvim",
    config = function()
      
      {
        "jameswolensky/marker-groups.nvim",
        dependencies = {
          "nvim-lua/plenary.nvim", -- Required
          "ibhagwan/fzf-lua", -- Optional: fzf-lua picker
          "folke/snacks.nvim", -- Optional: Snacks picker
          "nvim-telescope/telescope.nvim", -- Optional: Telescope picker
          -- mini.pick is part of mini.nvim; this plugin vendors mini.nvim for tests,
          -- but you can also install mini.nvim explicitly to use mini.pick system-wide
          -- "nvim-mini/mini.nvim",
        },
        config = function()
          require("marker-groups").setup({
            -- Default picker is 'vim' (built-in vim.ui)
            -- Accepted values: 'vim' | 'snacks' | 'fzf-lua' | 'mini.pick' | 'telescope'
            picker = 'vim',
          })
        end,
      }
      
      
      use {
        "jameswolensky/marker-groups.nvim",
        requires = {
          "nvim-lua/plenary.nvim", -- Required
          "ibhagwan/fzf-lua", -- Optional
          "folke/snacks.nvim", -- Optional
          "nvim-telescope/telescope.nvim", -- Optional
          -- "nvim-mini/mini.nvim", -- Optional
        },
        config = function()
          require("marker-groups").setup()
        end,
      }
      
      
      -- Basic setup with defaults
      require("marker-groups").setup()
      
      -- Create a new group
      :MarkerGroupsCreate feature-auth
      
      -- Add a marker at current line
      :MarkerAdd Implement JWT token validation
      
      -- View all markers in drawer viewer
      :MarkerGroupsView
      
      -- List all groups
      :MarkerGroupsList
      
      
      require("marker-groups").setup({
        -- Persistence
        data_dir = vim.fn.stdpath("data") .. "/marker-groups",
      
        -- Logging
        debug = false,
        log_level = "info", -- "debug" | "info" | "warn" | "error"
      
        -- Drawer viewer
        drawer_config = {
          width = 60,        -- 30..120
          side = "right",    -- "left" | "right"
          border = "rounded",
          title_pos = "center",
        },
      
        -- Context shown around markers in viewer/preview
        context_lines = 2,
      
        -- Virtual text display & highlight groups
        max_annotation_display = 50, -- truncate long annotations
        highlight_groups = {
          marker = "MarkerGroupsMarker",
          annotation = "MarkerGroupsAnnotation",
          context = "MarkerGroupsContext",
          multiline_start = "MarkerGroupsMultilineStart",
          multiline_end = "MarkerGroupsMultilineEnd",
        },
      
        -- Keybindings (declarative; override per entry or disable by setting to false)
        keymaps = {
          enabled = true,
          prefix = "<leader>m",
          mappings = {
            marker = {
              add = { suffix = "a", mode = { "n", "v" }, desc = "Add marker" },
              edit = { suffix = "e", desc = "Edit marker at cursor" },
              delete = { suffix = "d", desc = "Delete marker at cursor" },
              list = { suffix = "l", desc = "List markers in buffer" },
              info = { suffix = "i", desc = "Show marker at cursor" },
            },
            group = {
              create = { suffix = "gc", desc = "Create marker group" },
              select = { suffix = "gs", desc = "Select marker group" },
              list = { suffix = "gl", desc = "List marker groups" },
              rename = { suffix = "gr", desc = "Rename marker group" },
              delete = { suffix = "gd", desc = "Delete marker group" },
              info = { suffix = "gi", desc = "Show active group info" },
              from_branch = { suffix = "gb", desc = "Create group from git branch" },
            },
            view = { toggle = { suffix = "v", desc = "Toggle drawer marker viewer" } },
            
          },
        },
      
        -- Picker backend (default: 'vim')
        -- Accepted values: 'vim' | 'snacks' | 'fzf-lua' | 'mini.pick' | 'telescope'
        -- Invalid values fall back to 'vim'.
        picker = 'vim',
      })
      
      
      -- Create a group for review comments
      :MarkerGroupsCreate code-review
      
      -- Add markers for issues found
      :MarkerAdd TODO: Extract this function
      :MarkerAdd FIXME: Handle edge case for empty array
      :MarkerAdd NOTE: Consider performance optimization
      
      
      -- Organize by feature branches
      :MarkerGroupsCreate feature-user-auth
      :MarkerAdd Implement login endpoint
      :MarkerAdd Add password validation
      :MarkerAdd Create user session management
      
      
      -- Track bugs and fixes
      :MarkerGroupsCreate bug-fixes
      :MarkerAdd BUG: Memory leak in data processing
      :MarkerAdd FIX: Null pointer exception handling
      
    end,
  },
  {
    "bngarren/checkmate.nvim",
    config = function()
      
      {
          "bngarren/checkmate.nvim",
          ft = "markdown", -- Lazy loads for Markdown files matching patterns in 'files'
          opts = {
              -- your configuration here
              -- or leave empty to use defaults
          },
      
      }
      
      
      files = { "tasks", "*.plan", "project/**/todo.md" }
      
      
      -----------------------------------------------------
      ---Checkmate configuration
      ---@class checkmate.Config
      ---
      ---Whether the plugin is enabled
      ---@field enabled boolean
      ---
      ---Whether to show notifications
      ---@field notify boolean
      ---
      --- Filenames or patterns to activate Checkmate on when the filetype is 'markdown'
      ---
      --- Uses Unix-style glob patterns with the following rules:
      --- - Patterns are CASE-SENSITIVE (e.g., "TODO" won't match "todo")
      --- - Basename patterns (no slash): Match against filename only
      ---   - "TODO" matches any file named "TODO" regardless of path
      ---   - "*.md" matches any markdown file in any directory
      ---   - "*todo*" matches any file with "todo" in the name
      --- - Path patterns (has slash):
      ---   - "docs/*.md" matches markdown files in any "docs" directory
      ---   - "/home/user/*.md" matches only in that specific directory (absolute)
      ---   - Both "docs/*.md" and "**/docs/*.md" behave the same (match at any depth)
      --- - Glob syntax (refer to `h: vim.glob`):
      ---   - `*` matches any characters except /
      ---   - `**` matches any characters including / (recursive)
      ---   - `?` matches any single character
      ---   - `[abc]` matches any character in the set
      ---   - `{foo,bar}` matches either "foo" or "bar"
      ---
      --- Examples:
      --- - {"TODO", "todo"} - files named TODO (case variations)
      --- - {"*.md"} - all markdown files
      --- - {"*todo*", "*TODO*"} - files with "todo" in the name
      --- - {"docs/*.md", "notes/*.md"} - markdown in specific directories
      --- - {"project/**/todo.md"} - todo.md under any project directory
      ---@field files string[]
      ---
      ---Logging settings
      ---@field log checkmate.LogSettings
      ---
      ---Define the keymap as a dict-style table or a sequence of { rhs, desc, { modes } }
      ---See `h: vim.set.keymap` for how 'rhs' is treated, including being able to pass a Lua function directly
      ---Default modes is {"n"}
      ---@alias checkmate.KeymapConfig {rhs: string|function, desc?: string, modes?: string[]} | table<integer, any>
      ---
      ---Keymappings (false to disable)
      ---
      ---Setting `keys` to false will not register any keymaps. Setting a specific key to false will not register that default mapping.
      ---Note: mappings for metadata are set separately in the `metadata` table
      ---@field keys ( table<string, checkmate.KeymapConfig|false>| false )
      ---
      ---Characters for todo markers (checked and unchecked)
      ---@deprecated use todo_states
      ---@field todo_markers? checkmate.TodoMarkers
      ---
      ---The states that a todo item may have
      ---Default: "unchecked" and "checked"
      ---Note that Github-flavored Markdown specification only includes "checked" and "unchecked".
      ---
      ---If you add additional states here, they may not work in other Markdown apps without special configuration.
      ---@field todo_states table<string, checkmate.TodoStateDefinition>
      ---
      ---Default list item marker to be used when creating new Todo items
      ---@field default_list_marker "-" | "*" | "+"
      ---
      ---@field ui? checkmate.UISettings
      ---
      ---Highlight settings (merges with defaults, user config takes precedence)
      ---Default style will attempt to integrate with current colorscheme (experimental)
      ---May need to tweak some colors to your liking
      ---@field style checkmate.StyleSettings?
      ---
      ---Enter insert mode after `:Checkmate create`, require("checkmate").create()
      ---Default: true
      ---@field enter_insert_after_new boolean
      ---
      ---List continuation refers to the automatic creation of new todo lines when insert mode keymaps are fired, i.e., typically <CR>
      ---To offer optimal configurability and integration with other plugins, you can set the exact keymaps and their functions via the `keys` option. The list continuation functionality can also be toggled via the `enabled` option.
      --- - When enabled and keymap calls `create()`, it will create a new todo line, using the origin/current row with reasonable defaults
      --- - Works for both raw Markdown (e.g. `- [ ]`) and Unicode style (e.g. `- ☐`) todos.
      ---@field list_continuation checkmate.ListContinuationSettings
      ---
      ---Smart toggle provides intelligent parent-child todo state propagation
      ---
      ---When you change a todo's state, it can automatically update related todos based on their
      ---hierarchical relationship. Only "checked" and "unchecked" states are propagated - custom
      ---states remain unchanged but influence the propagation logic based on their type.
      ---@field smart_toggle checkmate.SmartToggleSettings
      ---
      ---Enable/disable the todo count indicator (shows number of child todo items incomplete vs complete)
      ---@field show_todo_count boolean
      ---
      ---Options for todo count indicator position
      ---@alias checkmate.TodoCountPosition "eol" | "inline"
      ---
      ---Position to show the todo count indicator (if enabled)
      --- `eol` = End of the todo item line
      --- `inline` = After the todo marker, before the todo item text
      ---@field todo_count_position checkmate.TodoCountPosition
      ---
      ---Formatter function for displaying the todo count indicator
      ---@field todo_count_formatter? fun(completed: integer, total: integer): string
      ---
      ---Whether to count child todo items recursively in the todo_count
      ---If true, all nested todo items will count towards the parent todo's count
      ---@field todo_count_recursive boolean
      ---
      ---Whether to register keymappings defined in each metadata definition.
      ---When false, default metadata keymaps are not created; you can still call require('checkmate').toggle_metadata() or bind keys manually.
      ---@field use_metadata_keymaps boolean
      ---
      ---Custom @tag(value) fields that can be toggled on todo items
      ---To add custom metadata tag, add a new field to this table with the metadata properties
      ---
      ---Note: When setting metadata in config, entire metadata entries are replaced,
      ---not deep-merged. To modify only specific fields of default metadata,
      ---you will need to manually merge the default implementation.
      ---@field metadata checkmate.Metadata
      ---
      ---Settings for the archived todos section
      ---@field archive checkmate.ArchiveSettings?
      ---
      ---Config for the linter
      ---@field linter checkmate.LinterConfig?
      ---
      ---Turn off treesitter highlights (on by default)
      ---Buffer local
      ---See `:h treesitter-highlight`
      ---@field disable_ts_highlights? boolean
      
      -----------------------------------------------------
      
      ---@class checkmate.LogSettings
      --- Any messages above this level will be logged
      ---@field level ("trace" | "debug" | "info" | "warn" | "error" | "fatal" | vim.log.levels.DEBUG | vim.log.levels.ERROR | vim.log.levels.INFO | vim.log.levels.TRACE | vim.log.levels.WARN)?
      ---
      --- Should print log output to a file
      --- Default: true
      ---@field use_file boolean
      ---
      --- The default path on-disk where log files will be written to.
      --- Defaults to `vim.fn.stdpath("log") .. "checkmate.log"`
      ---@field file_path string?
      ---
      --- Max file size (kilobytes)
      --- When file size exceeds max, a new file will be overwritten
      --- Default: 5120 kb (5 mb)
      ---@field max_file_size? number
      
      -----------------------------------------------------
      
      ---The broad categories used internally that give semantic meaning to each todo state
      ---@alias checkmate.TodoStateType "incomplete" | "complete" | "inactive"
      
      ---@class checkmate.TodoStateDefinition
      ---
      --- The glyph or text string used for a todo marker is expected to be 1 character length.
      --- Multiple characters _may_ work but are not currently supported and could lead to unexpected results.
      ---@field marker string
      ---
      --- Markdown checkbox representation (custom states only)
      --- For custom states, this determines how the todo state is written to file in Markdown syntax.
      --- Important:
      ---   - Must be unique among all todo states. If two states share the same Markdown representation, there will
      ---   be unpredictable behavior when parsing the Markdown into the Checkmate buffer
      ---   - Not guaranteed to work in other apps/plugins as custom `[.]`, `[/]`, etc. are not standard Github-flavored Markdown
      ---   - This field is ignored for default `checked` and `unchecked` states as these are always represented per Github-flavored
      --- Markdown spec, e.g. `[ ]` and `[x]`
      ---@field markdown string | string[]
      ---
      --- Defines how a custom todo state relates to an intended task (custom states only)
      ---
      --- The helps the custom state integrate with plugin behaviors like `smart toggle` and `todo count indicator`.
      ---
      --- Options:
      --- - "incomplete" - active/ongoing task (like unchecked)
      --- - "complete"   - finished task (like checked)
      --- - "inactive"   - paused/deferred task (neither)
      ---
      --- Defaults:
      ---  - the "checked" state is always "complete" and the "unchecked" state is always "incomplete"
      ---  - custom states without a defined `type` will default to "inactive"
      ---@field type? checkmate.TodoStateType
      ---
      --- The order in which this state is cycled (lower = first)
      ---@field order? number
      
      -----------------------------------------------------
      
      --- DEPRECATED v0.10
      ---@deprecated use `todo_states`
      ---@class checkmate.TodoMarkers
      ---
      ---Character used for unchecked items
      ---@field unchecked string
      ---
      ---Character used for checked items
      ---@field checked string
      
      -----------------------------------------------------
      
      ---@class checkmate.UISettings
      ---
      ---@alias checkmate.Picker "telescope" | "snacks" | "mini" | false | fun(items: string[], opts: {on_choice: function})
      ---Default behavior: attempt to use an installed plugin, if found
      ---If false, will default to vim.ui.select
      ---If a function is passed, will use this picker implementation
      ---@field picker? checkmate.Picker
      
      -----------------------------------------------------
      
      ---@class checkmate.ListContinuationSettings
      ---
      --- Whether to enable list continuation behavior
      ---
      --- Default: true
      ---@field enabled? boolean
      ---
      --- Control behavior when cursor is mid-line (not at the end).
      ---
      --- When `true` (default):
      ---   - Text after cursor moves to the new todo line
      ---   - Original line is truncated at cursor position
      ---   - Example: "- ☐ Buy |milk and eggs" → "- ☐ Buy" + "- ☐ milk and eggs"
      ---
      --- When `false`:
      ---   - List continuation only works when cursor is at end of line
      ---
      --- Default: true
      ---@field split_line? boolean
      ---
      --- Define which keys trigger list continuation and their behavior.
      ---
      --- Each key can map to either:
      ---   - A function that creates the new todo
      ---   - A table with `rhs` (function) and optional `desc` (description)
      ---
      --- Default keys:
      ---   - `<CR>`: Create sibling todo (same indentation)
      ---   - `<S-CR>`: Create nested todo (indented as child)
      ---
      --- **Important**: This field completely replaces the default keys (no merging).
      --- To keep some defaults while adding custom keys, explicitly include them in your config.
      ---@field keys? table<string, {rhs: function, desc?: string}|function>
      ---
      -----------------------------------------------------
      
      ---@class checkmate.SmartToggleSettings
      ---
      ---Whether to enable smart toggle behavior
      ---
      ---What is 'smart toggle'?
      --- - Attempts to propagate a change in state (i.e. checked ←→ unchecked) up and down the hierarchy in a sensible manner
      --- - In this mode, changing the state of a todo maybe also affect nearby todos
      ---Default: true
      ---@field enabled boolean?
      ---
      ---Whether to use smart toggle behavior with `cycle` commands/API
      ---
      ---If enabled, this may inadvertently toggle nearby todos as you cycle through, depending on `smart_toggle` rules.
      ---If you would like to cascade/propagate when setting a custom state, use the `toggle(target_state)` api.
      ---
      ---Default: false (cycling through states won't trigger propagation)
      ---@field include_cycle boolean?
      ---
      ---How checking a parent affects its children
      ---  - "all_children": Check all descendants, including nested
      ---  - "direct_children": Only check immediate unchecked children (default)
      ---  - "none": Don't propagate down
      ---@field check_down "all_children"|"direct_children"|"none"?
      ---
      ---How unchecking a parent affects its children
      ---  - "all_children": Uncheck all descendants, including nested
      ---  - "direct_children": Only uncheck immediate checked children
      ---  - "none": Don't propagate down (default)
      ---@field uncheck_down "all_children"|"direct_children"|"none"?
      ---
      ---When a parent should become checked
      ---i.e, how a checked child affects its parent
      ---
      ---Note: Custom states with "complete" type count as done, "incomplete" as not done,
      ---and "inactive" states are ignored (as if they don't exist for completion purposes).
      ---
      ---  - "all_children": When ALL descendants are complete or inactive, including nested
      ---  - "direct_children": When all immediate children are complete/inactive (default)
      ---  - "none": Never auto-check parents
      ---@field check_up "all_children"|"direct_children"|"none"?
      ---
      ---When a parent should become unchecked
      ---i.e, how a unchecked child affects its parent
      ---  - "all_children": When ANY descendant is incomplete
      ---  - "direct_children": When any immediate child is incomplete (default)
      ---  - "none": Never auto-uncheck parents
      ---@field uncheck_up "all_children"|"direct_children"|"none"?
      
      -----------------------------------------------------
      
      --- Style
      
      ---@alias checkmate.HighlightGroup
      ---| "CheckmateListMarkerUnordered" -- unordered list markers (-,+,*)
      ---| "CheckmateListMarkerOrdered" -- ordered (numerical) list markers (1.,2.)
      ---| "CheckmateUncheckedMarker" -- unchecked markers (□)
      ---| "CheckmateUncheckedMainContent" -- main content of unchecked todo items (typically 1st paragraph)
      ---| "CheckmateUncheckedAdditionalContent" -- additional content of unchecked todo items (subsequent paragraphs or list items)
      ---| "CheckmateCheckedMarker" -- checked markers (✔)
      ---| "CheckmateCheckedMainContent" -- main content of checked todo items (typically 1st paragraph)
      ---| "CheckmateCheckedAdditionalContent" -- additional content of checked todo items (subsequent paragraphs or list items)
      ---| "CheckmateTodoCountIndicator" -- the todo count indicator (e.g. x/x)
      
      ---Customize the style of markers and content
      ---@alias checkmate.StyleSettings table<checkmate.HighlightGroup, vim.api.keyset.highlight>
      
      -----------------------------------------------------
      
      --- Metadata
      
      ---A table of canonical metadata tag names and associated properties that define the look and function of the tag
      ---
      ---A 'canonical' name is the main lookup name for a metadata tag; additional 'aliases' can be used that point to this name
      ---@alias checkmate.Metadata table<string, checkmate.MetadataProps>
      
      ---@class checkmate.MetadataProps
      ---
      ---Additional string values that can be used interchangably with the canonical tag name.
      ---E.g. @started could have aliases of `{"initiated", "began"}` so that @initiated and @began could
      ---also be used and have the same styling/functionality
      ---@field aliases? string[]
      ---
      ---@alias checkmate.StyleFn fun(context?: checkmate.MetadataContext):vim.api.keyset.highlight
      ---
      ---Highlight settings table, or a function that returns highlight settings (being passed metadata context)
      ---@field style? vim.api.keyset.highlight|checkmate.StyleFn
      ---
      ---@alias checkmate.GetValueFn fun(context?: checkmate.MetadataContext):string
      ---
      ---Function that returns the default value for this metadata tag
      ---i.e. what is used after insertion
      ---@field get_value? checkmate.GetValueFn
      ---
      ---@alias checkmate.ChoicesFn fun(context?: checkmate.MetadataContext, cb?: fun(items: string[])): string[]|nil
      ---
      ---Values that are populated during completion or select pickers
      ---Can be either:
      --- - An array of items (string[])
      --- - A function that returns items
      ---@field choices? string[]|checkmate.ChoicesFn
      ---
      ---Keymapping for toggling (adding/removing) this metadata tag
      ---Can also pass a tuple (key, desc) to include a description
      ---@field key? string|string[]
      ---
      ---Used for displaying metadata in a consistent order
      ---@field sort_order? integer
      ---
      ---Moves the cursor to the metadata after it is inserted
      ---  - "tag" - moves to the beginning of the tag
      ---  - "value" - moves to the beginning of the value
      ---  - false - disables jump (default)
      ---@field jump_to_on_insert? "tag" | "value" | false
      ---
      ---Selects metadata text in visual mode after metadata is inserted
      ---The `jump_to_on_insert` field must be set (not false)
      ---The selected text will be the tag or value, based on jump_to_on_insert setting
      ---Default (false) - off
      ---@field select_on_insert? boolean
      ---
      ---Callback to run when this metadata tag is added to a todo item
      ---E.g. can be used to change the todo item state
      ---@field on_add? fun(todo_item: checkmate.TodoItem)
      ---
      ---Callback to run when this metadata tag is removed from a todo item
      ---E.g. can be used to change the todo item state
      ---@field on_remove? fun(todo_item: checkmate.TodoItem)
      ---
      ---Callback to run when this metadata tag's value is changed (not on initial add or removal)
      ---Receives the todo item, old value, and new value
      ---@field on_change? fun(todo_item: checkmate.TodoItem, old_value: string, new_value: string)
      
      -----------------------------------------------------
      
      ---@class checkmate.ArchiveSettings
      ---
      ---Defines the header section for the archived todos
      ---@field heading checkmate.ArchiveHeading
      ---
      ---Number of blank lines between archived todo items (root only)
      ---@field parent_spacing integer?
      ---
      ---How to arrange newly added archived todos
      ---If true, newly added todos will be added to the top of the archive section
      ---Default: true
      ---@field newest_first boolean?
      
      ---@class checkmate.ArchiveHeading
      ---
      ---Name for the archived todos section
      ---Default: "Archived"
      ---@field title string?
      ---
      ---The heading level (e.g. #, ##, ###, ####)
      ---Integers 1 to 6
      ---Default: 2 (##)
      ---@field level integer?
      
      -----------------------------------------------------
      
      ---@class checkmate.LinterConfig
      ---
      ---Whether to enable the linter (vim.diagnostics)
      ---Default: true
      ---@field enabled boolean
      ---
      ---Map of issues to diagnostic severity level
      ---@field severity table<string, vim.diagnostic.Severity>?
      ---
      ---Whether to use verbose linter/diagnostic messages
      ---Default: false
      ---@field verbose boolean?
      
      
      ---@type checkmate.Config
      return {
        enabled = true,
        notify = true,
        -- Default file matching:
        --  - Any `todo` or `TODO` file, including with `.md` extension
        --  - Any `.todo` extension (can be ".todo" or ".todo.md")
        -- To activate Checkmate, the filename must match AND the filetype must be "markdown"
        files = {
          "todo",
          "TODO",
          "todo.md",
          "TODO.md",
          "*.todo",
          "*.todo.md",
        },
        log = {
          level = "warn",
          use_file = true,
        },
        -- Default keymappings
        keys = {
          ["<leader>Tt"] = {
            rhs = "<cmd>Checkmate toggle<CR>",
            desc = "Toggle todo item",
            modes = { "n", "v" },
          },
          ["<leader>Tc"] = {
            rhs = "<cmd>Checkmate check<CR>",
            desc = "Set todo item as checked (done)",
            modes = { "n", "v" },
          },
          ["<leader>Tu"] = {
            rhs = "<cmd>Checkmate uncheck<CR>",
            desc = "Set todo item as unchecked (not done)",
            modes = { "n", "v" },
          },
          ["<leader>T="] = {
            rhs = "<cmd>Checkmate cycle_next<CR>",
            desc = "Cycle todo item(s) to the next state",
            modes = { "n", "v" },
          },
          ["<leader>T-"] = {
            rhs = "<cmd>Checkmate cycle_previous<CR>",
            desc = "Cycle todo item(s) to the previous state",
            modes = { "n", "v" },
          },
          ["<leader>Tn"] = {
            rhs = "<cmd>Checkmate create<CR>",
            desc = "Create todo item",
            modes = { "n", "v" },
          },
          ["<leader>Tr"] = {
            rhs = "<cmd>Checkmate remove<CR>",
            desc = "Remove todo marker (convert to text)",
            modes = { "n", "v" },
          },
          ["<leader>TR"] = {
            rhs = "<cmd>Checkmate remove_all_metadata<CR>",
            desc = "Remove all metadata from a todo item",
            modes = { "n", "v" },
          },
          ["<leader>Ta"] = {
            rhs = "<cmd>Checkmate archive<CR>",
            desc = "Archive checked/completed todo items (move to bottom section)",
            modes = { "n" },
          },
          ["<leader>Tv"] = {
            rhs = "<cmd>Checkmate metadata select_value<CR>",
            desc = "Update the value of a metadata tag under the cursor",
            modes = { "n" },
          },
          ["<leader>T]"] = {
            rhs = "<cmd>Checkmate metadata jump_next<CR>",
            desc = "Move cursor to next metadata tag",
            modes = { "n" },
          },
          ["<leader>T["] = {
            rhs = "<cmd>Checkmate metadata jump_previous<CR>",
            desc = "Move cursor to previous metadata tag",
            modes = { "n" },
          },
        },
        default_list_marker = "-",
        todo_states = {
          -- we don't need to set the `markdown` field for `unchecked` and `checked` as these can't be overriden
          ---@diagnostic disable-next-line: missing-fields
          unchecked = {
            marker = "□",
            order = 1,
          },
          ---@diagnostic disable-next-line: missing-fields
          checked = {
            marker = "✔",
            order = 2,
          },
        },
        style = {}, -- override defaults
        enter_insert_after_new = true, -- Should enter INSERT mode after `:Checkmate create` (new todo)
        list_continuation = {
          enabled = true,
          split_line = true,
          keys = {
            ["<CR>"] = function()
              require("checkmate").create({
                position = "below",
                indent = false,
              })
            end,
            ["<S-CR>"] = function()
              require("checkmate").create({
                position = "below",
                indent = true,
              })
            end,
          },
        },
        smart_toggle = {
          enabled = true,
          include_cycle = false,
          check_down = "direct_children",
          uncheck_down = "none",
          check_up = "direct_children",
          uncheck_up = "direct_children",
        },
        show_todo_count = true,
        todo_count_position = "eol",
        todo_count_recursive = true,
        use_metadata_keymaps = true,
        metadata = {
          -- Example: A @priority tag that has dynamic color based on the priority value
          priority = {
            style = function(context)
              local value = context.value:lower()
              if value == "high" then
                return { fg = "#ff5555", bold = true }
              elseif value == "medium" then
                return { fg = "#ffb86c" }
              elseif value == "low" then
                return { fg = "#8be9fd" }
              else -- fallback
                return { fg = "#8be9fd" }
              end
            end,
            get_value = function()
              return "medium" -- Default priority
            end,
            choices = function()
              return { "low", "medium", "high" }
            end,
            key = "<leader>Tp",
            sort_order = 10,
            jump_to_on_insert = "value",
            select_on_insert = true,
          },
          -- Example: A @started tag that uses a default date/time string when added
          started = {
            aliases = { "init" },
            style = { fg = "#9fd6d5" },
            get_value = function()
              return tostring(os.date("%m/%d/%y %H:%M"))
            end,
            key = "<leader>Ts",
            sort_order = 20,
          },
          -- Example: A @done tag that also sets the todo item state when it is added and removed
          done = {
            aliases = { "completed", "finished" },
            style = { fg = "#96de7a" },
            get_value = function()
              return tostring(os.date("%m/%d/%y %H:%M"))
            end,
            key = "<leader>Td",
            on_add = function(todo_item)
              require("checkmate").set_todo_item(todo_item, "checked")
            end,
            on_remove = function(todo_item)
              require("checkmate").set_todo_item(todo_item, "unchecked")
            end,
            sort_order = 30,
          },
        },
        archive = {
          heading = {
            title = "Archive",
            level = 2, -- e.g. ##
          },
          parent_spacing = 0, -- no extra lines between archived todos
          newest_first = true,
        },
        linter = {
          enabled = true,
        },
      }
      
      
      keys = {
        ["<leader>Ta"] = {
            rhs = "<cmd>Checkmate archive<CR>",
            desc = "Archive todos",
            modes = { "n" },
        },
      }
      
      
      keys = {
        ["<leader>Ta"] = {"<cmd>Checkmate archive<CR>", "Archive todos", {"n"} }
      }
      
      
      opts = {
          style = {
              CheckmateCheckedMarker = { fg = "#7bff4f", bold = true}
          }
      }
      
      
      todo_states = {
        partial = {
          -- ...
        }
      }
      
      
      styles = {
        CheckmatePartialMarker = { fg = "#f0fc03" }
        CheckmatePartialMainContent = { fg = "#faffa1" }
      }
      
      
      todo_states = {
        checked = {
          marker = "☒" -- how it appears in Neovim
        },
        unchecked = {
          marker = "☐" -- how it appears in Neovim
        }
      }
      
      
      todo_states = {
        -- Built-in states (cannot change markdown or type)
        unchecked = { marker = "□" },
        checked = { marker = "✔" },
        
        -- Custom states
        in_progress = {
          marker = "◐",
          markdown = ".",     -- Saved as `- [.]`
          type = "incomplete", -- Counts as "not done"
          order = 50,
        },
        cancelled = {
          marker = "✗",
          markdown = "c",     -- Saved as `- [c]` 
          type = "complete",   -- Counts as "done"
          order = 2,
        },
        on_hold = {
          marker = "⏸",
          markdown = "/",     -- Saved as `- [/]`
          type = "inactive",   -- Ignored in counts
          order = 100,
        }
      }
      
      
      require("checkmate").cycle()        -- Next state
      require("checkmate").cycle(true)    -- Previous state
      
      -- or to toggle to a specific state
      require("checkmate").toggle("on_hold")
      
      
      -- Custom formatter that returns the % completed
      todo_count_formatter = function(completed, total)
        return string.format("[%.0f%%]", completed / total * 100)
      end,
      style = {
        CheckmateTodoCountIndicator = { fg = "#faef89" },
      },
      
      
      opts = {
        smart_toggle = {
          enabled = true,
          check_down = "direct",        -- How checking a parent affects children
          uncheck_down = "none",        -- How unchecking a parent affects children
          check_up = "direct_children", -- When to auto-check parents
          uncheck_up = "direct_children", -- When to auto-uncheck parents
        }
      }
      
      
      opts = {
        archive = {
          heading = {
            title = "Completed",
            level = 4
          }
        }
      }
      
      
      ## Archive
      
      - ✔ Update the dependencies 
      - ✔ Refactor the User api
      - ✔ Add additional tests 
      
      
      ## Archive
      
      - ✔ Update the dependencies 
      
      - ✔ Refactor the User api
      
      - ✔ Add additional tests 
      
      
      {
        linter = {
          enabled = false
        }
      }
      
    end,
  },
  {
    "lfilho/note2cal.nvim",
    config = function()
      
      {
        'lfilho/note2cal.nvim',
        config = function()
          require("note2cal").setup({
            debug = false, -- if true, prints a debug message an return early (won't schedule events)
            calendar_name = "Work", -- the name of the calendar as it appear on Calendar.app
            highlights = {
              at_symbol = "WarningMsg", -- the highlight group for the "@" symbol
              at_text = "Number", -- the highlight group for the date-time part
            },
            keymaps = {
                normal = "<Leader>se", -- mnemonic: Schedule Event
                visual = "<Leader>se", -- mnemonic: Schedule Event
            },
          })
        end,
        ft = "markdown",
      },
      
      
    end,
  },
  {
    "0styx0/abbreinder.nvim",
    config = function()
      
      use {
          '0styx0/abbreinder.nvim',
          requires = {
              {
                  '0styx0/abbremand.nvim',
                  module = 'abbremand' -- if want to lazy load
              }
          },
          config = function()
              -- config can be empty to stay with defaults
              -- or anything can be changed, with anything unspecified
              -- retaining the default values
              require'abbreinder'.setup()
          end,
          event = 'BufRead', -- if want lazy load
      }
      
      
      local config_defaults = {
          value_highlight = {
              enabled = true,
              group = 'Special', -- highlight to use
              time = 4000 -- -1 for permanent
          },
          tooltip = {
              enabled = true,
              time = 4000, -- time before tooltip closes
              opts = {}, -- see :help nvim_open_win
              highlight = {
                  enabled = true,
                  group = 'Special', -- highlight to use
              },
              format = function(trigger, value) -- format to print reminder in
                  return 'abbrev: "' .. trigger .. '"->' .. '"' .. value .. '"'
              end,
          },
      }
      
    end,
  },
  {
    "jakewvincent/mkdnflow.nvim",
    config = function()
      
      new_file_template = {
          template = [[
      # {{ title }}
      Date: {{ date }}
      Filename: {{ filename }}
      ]],
          placeholders = {
              before = {
                  date = function()
                      return os.date("%A, %B %d, %Y") -- Wednesday, March 1, 2023
                  end
              },
              after = {
                  filename = function()
                      return vim.api.nvim_buf_get_name(0)
                  end
              }
          }
      }
      
      
      require('mkdnflow').setup({
          links = {
              transform_explicit = function(text)
                  -- Make lowercase, remove spaces, and reverse the string
                  return string.lower(text:gsub(' ', ''))
              end
          }
      })
      
      
      cmp.setup({
      	sources = cmp.config.sources({
      		-- Other cmp sources
      		{ name = 'mkdnflow' },  -- Add this
      		-- Other cmp sources
      	}),
      })
      
      
      require('mkdnflow').setup({
          mappings = {
              MkdnEnter = {{'i', 'n', 'v'}, '<CR>'} -- This monolithic command has the aforementioned
                  -- insert-mode-specific behavior and also will trigger row jumping in tables. Outside
                  -- of lists and tables, it behaves as <CR> normally does.
              -- MkdnNewListItem = {'i', '<CR>'} -- Use this command instead if you only want <CR> in
                  -- insert mode to add a new list item (and behave as usual outside of lists).
          }
      })
      
      
      require('lazy').setup({
          -- Your other plugins
          {
              'jakewvincent/mkdnflow.nvim',
              config = function()
                  require('mkdnflow').setup({
                      -- Config goes here; leave blank for defaults
                  })
              end
          }
          -- Your other plugins
      })
      
      
      require('pckr').add({
          -- Your other plugins
          {
              'jakewvincent/mkdnflow.nvim',
              config = function()
                  require('mkdnflow').setup({
                      -- Config goes here; leave blank for defaults
                  })
              end
          }
          -- Your other plugins
      })
      
      
      require('paq')({
          -- Your other plugins
          'jakewvincent/mkdnflow.nvim',
          -- Your other plugins
      })
      
      -- Include the setup function somewhere else in your init.lua/vim file, or the
      -- plugin won't activate itself:
      
      require('mkdnflow').setup({
          -- Config goes here; leave blank for defaults
      })
      
      
      use({'jakewvincent/mkdnflow.nvim',
           config = function()
              require('mkdnflow').setup({
                  -- Config goes here; leave blank for defaults
              })
           end
      })
      
      
      -- ** DEFAULT SETTINGS; TO USE THESE, PASS NO ARGUMENTS TO THE SETUP FUNCTION **
      require('mkdnflow').setup({
          modules = {
              bib = true,
              buffers = true,
              conceal = true,
              cursor = true,
              folds = true,
              foldtext = true,
              links = true,
              lists = true,
              maps = true,
              paths = true,
              tables = true,
              yaml = false,
              cmp = false
          },
          filetypes = {md = true, rmd = true, markdown = true},
          create_dirs = true,
          perspective = {
              priority = 'first',
              fallback = 'current',
              root_tell = false,
              nvim_wd_heel = false,
              update = false
          },
          wrap = false,
          bib = {
              default_path = nil,
              find_in_root = true
          },
          silent = false,
          cursor = {
              jump_patterns = nil
          },
          links = {
              style = 'markdown',
              name_is_source = false,
              conceal = false,
              context = 0,
              implicit_extension = nil,
              transform_implicit = false,
              transform_explicit = function(text)
                  text = text:gsub(" ", "-")
                  text = text:lower()
                  text = os.date('%Y-%m-%d_')..text
                  return(text)
              end,
              create_on_follow_failure = true
          },
          new_file_template = {
              use_template = false,
              placeholders = {
                  before = {
                      title = "link_title",
                      date = "os_date"
                  },
                  after = {}
              },
              template = "# {{ title }}"
          },
          to_do = {
              symbols = {' ', '-', 'X'},
              update_parents = true,
              not_started = ' ',
              in_progress = '-',
              complete = 'X'
          },
          foldtext = {
              object_count = true,
              object_count_icons = 'emoji',
              object_count_opts = function()
                  return require('mkdnflow').foldtext.default_count_opts()
              end,
              line_count = true,
              line_percentage = true,
              word_count = false,
              title_transformer = nil,
              separator = ' · ',
              fill_chars = {
                  left_edge = '⢾',
                  right_edge = '⡷',
                  left_inside = ' ⣹',
                  right_inside = '⣏ ',
                  middle = '⣿',
              },
          },
          tables = {
              trim_whitespace = true,
              format_on_move = true,
              auto_extend_rows = false,
              auto_extend_cols = false,
              style = {
                  cell_padding = 1,
                  separator_padding = 1,
                  outer_pipes = true,
                  mimic_alignment = true
              }
          },
          yaml = {
              bib = { override = false }
          },
          mappings = {
              MkdnEnter = {{'n', 'v'}, '<CR>'},
              MkdnTab = false,
              MkdnSTab = false,
              MkdnNextLink = {'n', '<Tab>'},
              MkdnPrevLink = {'n', '<S-Tab>'},
              MkdnNextHeading = {'n', ']]'},
              MkdnPrevHeading = {'n', '[['},
              MkdnGoBack = {'n', '<BS>'},
              MkdnGoForward = {'n', '<Del>'},
              MkdnCreateLink = false, -- see MkdnEnter
              MkdnCreateLinkFromClipboard = {{'n', 'v'}, '<leader>p'}, -- see MkdnEnter
              MkdnFollowLink = false, -- see MkdnEnter
              MkdnDestroyLink = {'n', '<M-CR>'},
              MkdnTagSpan = {'v', '<M-CR>'},
              MkdnMoveSource = {'n', '<F2>'},
              MkdnYankAnchorLink = {'n', 'yaa'},
              MkdnYankFileAnchorLink = {'n', 'yfa'},
              MkdnIncreaseHeading = {'n', '+'},
              MkdnDecreaseHeading = {'n', '-'},
              MkdnToggleToDo = {{'n', 'v'}, '<C-Space>'},
              MkdnNewListItem = false,
              MkdnNewListItemBelowInsert = {'n', 'o'},
              MkdnNewListItemAboveInsert = {'n', 'O'},
              MkdnExtendList = false,
              MkdnUpdateNumbering = {'n', '<leader>nn'},
              MkdnTableNextCell = {'i', '<Tab>'},
              MkdnTablePrevCell = {'i', '<S-Tab>'},
              MkdnTableNextRow = false,
              MkdnTablePrevRow = {'i', '<M-CR>'},
              MkdnTableNewRowBelow = {'n', '<leader>ir'},
              MkdnTableNewRowAbove = {'n', '<leader>iR'},
              MkdnTableNewColAfter = {'n', '<leader>ic'},
              MkdnTableNewColBefore = {'n', '<leader>iC'},
              MkdnFoldSection = {'n', '<leader>f'},
              MkdnUnfoldSection = {'n', '<leader>F'}
          }
      })
      
      
      function(input)
          return(string.upper(os.date('%Y-')..input))
      end
      
      
      function(input)
          if input:match('%d%d%d%d%-%d%d%-%d%d') then
              return('journals/'..input)
          else
              return('pages/'..input)
          end
      end
      
      
      -- SAMPLE FOLDTEXT CONFIGURATION RECIPE WITH COMMENTS
      require('mkdnflow').setup({
          -- Other config options
          foldtext = {
              title_transformer = function()
                  local function my_title_transformer(text)
                      local updated_title = text:gsub('%b{}', '')
                      updated_title = updated_title:gsub('^%s*', '')
                      updated_title = updated_title:gsub('%s*$', '')
                      updated_title = updated_title:gsub('^######', '░░░░░▓')
                      updated_title = updated_title:gsub('^#####', '░░░░▓▓')
                      updated_title = updated_title:gsub('^####', '░░░▓▓▓')
                      updated_title = updated_title:gsub('^###', '░░▓▓▓▓')
                      updated_title = updated_title:gsub('^##', '░▓▓▓▓▓')
                      updated_title = updated_title:gsub('^#', '▓▓▓▓▓▓')
                      return updated_title
                  end
                  return my_title_transformer
              end,
              object_count_icon_set = 'nerdfont', -- Use/fall back on the nerdfont icon set
              object_count_opts = function()
                  local opts = {
                      link = false, -- Prevent links from being counted
                      blockquote = { -- Count block quotes (these aren't counted by default)
                          icon = ' ',
                          count_method = {
                              pattern = { '^>.+$' },
                              tally = 'blocks',
                          }
                      },
                      fncblk = {
                          -- Override the icon for fenced code blocks with 
                          icon = ' '
                      }
                  }
                  return opts
              end,
              line_count = false, -- Prevent lines from being counted
              word_count = true, -- Count the words in the section
              fill_chars = {
                  left_edge = '╾─🖿 ─',
                  right_edge = '──╼',
                  item_separator = ' · ',
                  section_separator = ' // ',
                  left_inside = ' ┝',
                  right_inside = '┥ ',
                  middle = '─',
              },
          },
          -- Other config options
      })
      
      
      -- If you have an init.lua
      vim.api.nvim_create_autocmd("FileType", {pattern = "markdown", command = "set awa"})
      -- Use the following if your buffer is set to become hidden
      --vim.api.nvim_create_autocmd("BufLeave", {pattern = "*.md", command = "silent! wall"})
      
      
      if not require('mkdnflow').buffers.goBack() then
        vim.cmd('Dirvish %:p')
      end
      
    end,
  },
  {
    "jbyuki/nabla.nvim",
    config = function()
      
          {
              "williamboman/mason.nvim",
              opts = { ensure_installed = { "tree-sitter-cli" } },
          },
      
          {
              "jbyuki/nabla.nvim",
              dependencies = {
                  "nvim-neo-tree/neo-tree.nvim",
                  "williamboman/mason.nvim",
              },
              lazy = true,
      
              config = function()
                  require("nvim-treesitter.configs").setup({
                      ensure_installed = { "latex" },
                      auto_install = true,
                      sync_install = false,
                  })
              end,
      
              keys = function()
                  return {
                      {
                          "<leader>p",
                          ':lua require("nabla").popup()<cr>',
                          desc = "NablaPopUp",
                      },
                  }
              end,
          },
      
        
      
          vim.o.packpath = vim.o.packpath .. ",<path to where pack/ is located>"
          
    end,
  },
  {
    "nvim-neorg/neorg",
    config = function()
      
        require("neorg").setup()
        
      
        require("nvim-treesitter.configs").setup({
          highlight = {
            enable = true,
          },
        })
        
      
      {
          "nvim-neorg/neorg",
          lazy = false, -- Disable lazy loading as some `lazy.nvim` distributions set `lazy = true` by default
          version = "*", -- Pin Neorg to the latest stable release
          config = true,
      }
      
      
      use {
        "nvim-neorg/neorg",
        rocks = { "lua-utils.nvim", "nvim-nio", "nui.nvim", "plenary.nvim", "pathlib.nvim", "nvim-treesitter-legacy-api" },
        tag = "*", -- Pin Neorg to the latest stable release
        config = function()
            require("neorg").setup()
        end,
      }
      
    end,
  },
  {
    "nvim-orgmode/orgmode",
  },
  {
    "nfrid/due.nvim",
    config = function()
      
      use {
        'NFrid/due.nvim',
        config = function()
          require('due_nvim').setup {}
        end
      }
      
      
      require('due_nvim').setup {
        prescript = 'due: ',             -- prescript to due data
        prescript_hi = 'Comment',        -- highlight group of it
        due_hi = 'String',               -- highlight group of the data itself
        ft = '*.md',                     -- filename template to apply aucmds :)
        today = 'TODAY',                 -- text for today's due
        today_hi = 'Character',          -- highlight group of today's due
        overdue = 'OVERDUE',             -- text for overdued
        overdue_hi = 'Error',            -- highlight group of overdued
        date_hi = 'Conceal',             -- highlight group of date string
      
        pattern_start = '<',             -- start for a date string pattern
        pattern_end = '>',               -- end for a date string pattern
        -- lua patterns: in brackets are 'groups of data', their order is described
        -- accordingly. More about lua patterns: https://www.lua.org/pil/20.2.html
        date_pattern = '(%d%d)%-(%d%d)', -- m, d
        datetime_pattern = date_pattern .. ' (%d+):(%d%d)', -- m, d, h, min
        datetime12_pattern = datetime_pattern .. ' (%a%a)', -- m, d, h, min, am/pm
        fulldate_pattern = '(%d%d%d%d)%-' .. date_pattern, -- y, m, d
        fulldatetime_pattern = '(%d%d%d%d)%-' .. datetime_pattern, -- y, m, d, h, min
        fulldatetime12_pattern = fulldatetime_pattern .. ' (%a%a)', -- y, m, d, h, min, am/pm
        -- idk how to allow to define the order by config yet,
        -- but you can help me figure it out...
      
        regex_hi = "\\d*-*\\d\\+-\\d\\+\\( \\d*:\\d*\\( \\a\\a\\)\\?\\)\\?",
                                        -- vim regex for highlighting, notice double
                                           -- backslashes cuz lua strings escaping
      
        update_rate = use_clock_time and (use_seconds and 1000 or 60000) or 0,
                                        -- selects the rate due clocks will update in
                                           -- milliseconds. 0 or less disables it
      
        use_clock_time = false,         -- display also hours and minutes
        use_clock_today = false,        -- do it instead of TODAY
        use_seconds = false,            -- if use_clock_time == true, display seconds
                                           -- as well
        default_due_time = "midnight"   -- if use_clock_time == true, calculate time
                                           -- until option on specified date. Accepts
                                           -- "midnight", for 23:59:59, or noon, for
                                           -- 12:00:00
      }
      
      
      require("due_nvim").draw(0)   -- Draws it for a buffer (0 to current)
      require("due_nvim").clean(0)  -- Cleans the array from it
      require("due_nvim").redraw(0) -- Cleans, then draws
      require("due_nvim").async_update(0) -- Runs the async update function (needs update_rate > 0)
      
    end,
  },
  {
    "jbyuki/venn.nvim",
    config = function()
      
      use "jbyuki/venn.nvim"
      
      
      -- venn.nvim: enable or disable keymappings
      function _G.Toggle_venn()
          local venn_enabled = vim.inspect(vim.b.venn_enabled)
          if venn_enabled == "nil" then
              vim.b.venn_enabled = true
              vim.cmd[[setlocal ve=all]]
              -- draw a line on HJKL keystokes
              vim.api.nvim_buf_set_keymap(0, "n", "J", "<C-v>j:VBox<CR>", {noremap = true})
              vim.api.nvim_buf_set_keymap(0, "n", "K", "<C-v>k:VBox<CR>", {noremap = true})
              vim.api.nvim_buf_set_keymap(0, "n", "L", "<C-v>l:VBox<CR>", {noremap = true})
              vim.api.nvim_buf_set_keymap(0, "n", "H", "<C-v>h:VBox<CR>", {noremap = true})
              -- draw a box by pressing "f" with visual selection
              vim.api.nvim_buf_set_keymap(0, "v", "f", ":VBox<CR>", {noremap = true})
          else
              vim.cmd[[setlocal ve=]]
              vim.api.nvim_buf_del_keymap(0, "n", "J")
              vim.api.nvim_buf_del_keymap(0, "n", "K")
              vim.api.nvim_buf_del_keymap(0, "n", "L")
              vim.api.nvim_buf_del_keymap(0, "n", "H")
              vim.api.nvim_buf_del_keymap(0, "v", "f")
              vim.b.venn_enabled = nil
          end
      end
      -- toggle keymappings for venn using <leader>v
      vim.api.nvim_set_keymap('n', '<leader>v', ":lua Toggle_venn()<CR>", { noremap = true})
      
    end,
  },
  {
    "nvim-telekasten/telekasten.nvim",
    config = function()
      
        use {
          'renerocksai/telekasten.nvim',
          requires = {'nvim-telescope/telescope.nvim'}
        }
      
      
        {
          'renerocksai/telekasten.nvim',
          dependencies = {'nvim-telescope/telescope.nvim'}
        },
      
      
      require('telekasten').setup({
        home = vim.fn.expand("~/zettelkasten"), -- Put the name of your notes directory here
      })
      
      
      -- Launch panel if nothing is typed after <leader>z
      vim.keymap.set("n", "<leader>z", "<cmd>Telekasten panel<CR>")
      
      -- Most used functions
      vim.keymap.set("n", "<leader>zf", "<cmd>Telekasten find_notes<CR>")
      vim.keymap.set("n", "<leader>zg", "<cmd>Telekasten search_notes<CR>")
      vim.keymap.set("n", "<leader>zd", "<cmd>Telekasten goto_today<CR>")
      vim.keymap.set("n", "<leader>zz", "<cmd>Telekasten follow_link<CR>")
      vim.keymap.set("n", "<leader>zn", "<cmd>Telekasten new_note<CR>")
      vim.keymap.set("n", "<leader>zc", "<cmd>Telekasten show_calendar<CR>")
      vim.keymap.set("n", "<leader>zb", "<cmd>Telekasten show_backlinks<CR>")
      vim.keymap.set("n", "<leader>zI", "<cmd>Telekasten insert_img_link<CR>")
      
      -- Call insert link automatically when we start typing a link
      vim.keymap.set("i", "[[", "<cmd>Telekasten insert_link<CR>")
      
      
    end,
  },
  {
    "zk-org/zk-nvim",
    config = function()
      
      use("zk-org/zk-nvim")
      
      
      {
        "zk-org/zk-nvim",
        config = function()
          require("zk").setup({
            -- See Setup section below
          })
        end
      }
      
      
      return {
        "zk-org/zk-nvim",
        config = function()
          require("zk").setup({
            -- Can be "telescope", "fzf", "fzf_lua", "minipick", "snacks_picker",
            -- or select" (`vim.ui.select`).
            picker = "select",
      
            lsp = {
              -- `config` is passed to `vim.lsp.start(config)`
              config = {
                name = "zk",
                cmd = { "zk", "lsp" },
                filetypes = { "markdown" },
                -- on_attach = ...
                -- etc, see `:h vim.lsp.start()`
              },
      
              -- automatically attach buffers in a zk notebook that match the given filetypes
              auto_attach = {
                enabled = true,
              },
            },
          })
        end,
      }
      
      
      require("zk").setup({
          picker_options = {
              telescope = require("telescope.themes").get_ivy(),
      
              -- or if you use snacks picker
      
              snacks_picker = {
                  layout = {
                      preset = "ivy",
                  }
              },
          },
          ...
      })
      
      
      require("zk.commands").get("ZkNew")({ dir = "daily" })
      require("zk.commands").get("ZkNotes")({ createdAfter = "3 days ago", tags = { "work" } })
      require("zk.commands").get("ZkNewFromTitleSelection")()
      
      
      ---A thin wrapper around `vim.api.nvim_add_user_command` which parses the `params.args` of the command as a Lua table and passes it on to `fn`.
      ---@param name string
      ---@param fn function
      ---@param opts? table {needs_selection} makes sure the command is called with a range
      ---@see vim.api.nvim_add_user_command
      require("zk.commands").add(name, fn, opts)
      
      
      local zk = require("zk")
      local commands = require("zk.commands")
      
      commands.add("ZkOrphans", function(options)
        options = vim.tbl_extend("force", { orphan = true }, options or {})
        zk.edit(options, { title = "Zk Orphans" })
      end)
      
      
      local zk = require("zk")
      local commands = require("zk.commands")
      
      local function make_edit_fn(defaults, picker_options)
        return function(options)
          options = vim.tbl_extend("force", defaults, options or {})
          zk.edit(options, picker_options)
        end
      end
      
      commands.add("ZkOrphans", make_edit_fn({ orphan = true }, { title = "Zk Orphans" }))
      commands.add("ZkRecents", make_edit_fn({ createdAfter = "2 weeks ago" }, { title = "Zk Recents" }))
      
      
      ---Cd into the notebook root
      --
      ---@param options? table
      require("zk").cd(options)
      
      
      ---Creates and edits a new note
      --
      ---@param options? table additional options
      ---@see https://github.com/zk-org/zk/blob/main/docs/tips/editors-integration.md#zknew
      require("zk").new(options)
      
      
      ---Indexes the notebook
      --
      ---@param options? table additional options
      ---@see https://github.com/zk-org/zk/blob/main/docs/tips/editors-integration.md#zkindex
      require("zk").index(options)
      
      
      ---Opens a notes picker, and calls the callback with the selection
      --
      ---@param options? table additional options
      ---@param picker_options? table options for the picker
      ---@param cb function
      ---@see https://github.com/zk-org/zk/blob/main/docs/tips/editors-integration.md#zklist
      ---@see zk.ui.pick_notes
      require("zk").pick_notes(options, picker_options, cb)
      
      
      ---Opens a tags picker, and calls the callback with the selection
      --
      ---@param options? table additional options
      ---@param picker_options? table options for the picker
      ---@param cb function
      ---@see https://github.com/zk-org/zk/blob/main/docs/tips/editors-integration.md#zktaglist
      ---@see zk.ui.pick_tags
      require("zk").pick_tags(options, picker_options, cb)
      
      
      ---Opens a notes picker, and edits the selected notes
      --
      ---@param options? table additional options
      ---@param picker_options? table options for the picker
      ---@see https://github.com/zk-org/zk/blob/main/docs/tips/editors-integration.md#zklist
      ---@see zk.ui.pick_notes
      require("zk").edit(options, picker_options)
      
      
      ---@param path? string path to explicitly specify the notebook
      ---@param options? table additional options
      ---@param cb function callback function
      ---@see https://github.com/zk-org/zk/blob/main/docs/tips/editors-integration.md#zkindex
      require("zk.api").index(path, options, function(err, stats)
        -- do something with the stats
      end)
      
      
      ---@param path? string path to explicitly specify the notebook
      ---@param options? table additional options
      ---@param cb function callback function
      ---@see https://github.com/zk-org/zk/blob/main/docs/tips/editors-integration.md#zknew
      require("zk.api").new(path, options, function(err, res)
        file_path = res.path
        -- do something with the new file path
      end)
      
      
      ---@param path? string path to explicitly specify the notebook
      ---@param options table additional options
      ---@param cb function callback function
      ---@see https://github.com/zk-org/zk/blob/main/docs/tips/editors-integration.md#zklist
      require("zk.api").list(path, options, function(err, notes)
        -- do something with the notes
      end)
      
      
      ---@param path? string path to explicitly specify the notebook
      ---@param options? table additional options
      ---@param cb function callback function
      ---@see https://github.com/zk-org/zk/blob/main/docs/tips/editors-integration.md#zktaglist
      require("zk.api").tag.list(path, options, function(err, tags)
        -- do something with the tags
      end)
      
      
      ---Opens a notes picker
      --
      ---@param notes list
      ---@param options? table containing {picker}, {title}, {multi_select} keys
      ---@param cb function
      require("zk.ui").pick_notes(notes, options, cb)
      
      
      ---Opens a tags picker
      --
      ---@param tags list
      ---@param options? table containing {picker}, {title}, {multi_select} keys
      ---@param cb function
      require("zk.ui").pick_tags(tags, options, cb)
      
      
      ---To be used in zk.api.list as the `selection` in the additional options table
      --
      ---@param options table the same options that are use for pick_notes
      ---@return table api selection
      require("zk.ui").get_pick_notes_list_api_selection(options)
      
      
      local opts = { noremap=true, silent=false }
      
      -- Create a new note after asking for its title.
      vim.api.nvim_set_keymap("n", "<leader>zn", "<Cmd>ZkNew { title = vim.fn.input('Title: ') }<CR>", opts)
      
      -- Open notes.
      vim.api.nvim_set_keymap("n", "<leader>zo", "<Cmd>ZkNotes { sort = { 'modified' } }<CR>", opts)
      -- Open notes associated with the selected tags.
      vim.api.nvim_set_keymap("n", "<leader>zt", "<Cmd>ZkTags<CR>", opts)
      
      -- Search for the notes matching a given query.
      vim.api.nvim_set_keymap("n", "<leader>zf", "<Cmd>ZkNotes { sort = { 'modified' }, match = { vim.fn.input('Search: ') } }<CR>", opts)
      -- Search for the notes matching the current visual selection.
      vim.api.nvim_set_keymap("v", "<leader>zf", ":'<,'>ZkMatch<CR>", opts)
      
      
      -- Add the key mappings only for Markdown files in a zk notebook.
      if require("zk.util").notebook_root(vim.fn.expand('%:p')) ~= nil then
        local function map(...) vim.api.nvim_buf_set_keymap(0, ...) end
        local opts = { noremap=true, silent=false }
      
        -- Open the link under the caret.
        map("n", "<CR>", "<Cmd>lua vim.lsp.buf.definition()<CR>", opts)
      
        -- Create a new note after asking for its title.
        -- This overrides the global `<leader>zn` mapping to create the note in the same directory as the current buffer.
        map("n", "<leader>zn", "<Cmd>ZkNew { dir = vim.fn.expand('%:p:h'), title = vim.fn.input('Title: ') }<CR>", opts)
        -- Create a new note in the same directory as the current buffer, using the current selection for title.
        map("v", "<leader>znt", ":'<,'>ZkNewFromTitleSelection { dir = vim.fn.expand('%:p:h') }<CR>", opts)
        -- Create a new note in the same directory as the current buffer, using the current selection for note content and asking for its title.
        map("v", "<leader>znc", ":'<,'>ZkNewFromContentSelection { dir = vim.fn.expand('%:p:h'), title = vim.fn.input('Title: ') }<CR>", opts)
      
        -- Open notes linking to the current buffer.
        map("n", "<leader>zb", "<Cmd>ZkBacklinks<CR>", opts)
        -- Alternative for backlinks using pure LSP and showing the source context.
        --map('n', '<leader>zb', '<Cmd>lua vim.lsp.buf.references()<CR>', opts)
        -- Open notes linked by the current buffer.
        map("n", "<leader>zl", "<Cmd>ZkLinks<CR>", opts)
      
        -- Preview a linked note.
        map("n", "K", "<Cmd>lua vim.lsp.buf.hover()<CR>", opts)
        -- Open the code actions for a visual selection.
        map("v", "<leader>za", ":'<,'>lua vim.lsp.buf.range_code_action()<CR>", opts)
      end
      
      
      require("nvim-treesitter.configs").setup({
        -- ...
        highlight = {
          -- ...
          additional_vim_regex_highlighting = { "markdown" }
        },
      })
      
      
      -- Redirect Neovim runtime paths to /tmp
      vim.env.XDG_CONFIG_HOME = "/tmp/nvim/config"
      vim.env.XDG_DATA_HOME = "/tmp/nvim/data"
      vim.env.XDG_STATE_HOME = "/tmp/nvim/state"
      vim.env.XDG_CACHE_HOME = "/tmp/nvim/cache"
      
      -- Bootstrap lazy.nvim
      local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
      if not (vim.uv or vim.loop).fs_stat(lazypath) then
        local lazyrepo = "https://github.com/folke/lazy.nvim.git"
        local out = vim.fn.system({ "git", "clone", "--filter=blob:none", "--branch=stable", lazyrepo, lazypath })
        if vim.v.shell_error ~= 0 then
          vim.api.nvim_echo({
            { "Failed to clone lazy.nvim:\n", "ErrorMsg" },
            { out, "WarningMsg" },
            { "\nPress any key to exit..." },
          }, true, {})
          vim.fn.getchar()
          os.exit(1)
        end
      end
      vim.opt.rtp:prepend(lazypath)
      
      -- Make sure to setup `mapleader` and `maplocalleader` before
      -- loading lazy.nvim so that mappings are correct.
      -- This is also a good place to setup other settings (vim.opt)
      vim.g.mapleader = " "
      vim.g.maplocalleader = "\\"
      
      -- Setup lazy.nvim
      require("lazy").setup({
      	{
      		"neovim/nvim-lspconfig",
      	},
      	{
      		"zk-org/zk-nvim",
      		config = function()
      			require("zk").setup()
      		end,
      	},
      	-- automatically check for plugin updates
      	checker = { enabled = true },
      })
      
      
      require("telescope").load_extension("zk")
      
    end,
  },
  {
    "chrsm/impulse.nvim",
    config = function()
      
      packer.startup(function(use)
        use {
          "chrsm/impulse.nvim",
          config = function()
            require("impulse").setup({})
          end,
          requires = { "nvim-lua/plenary.nvim", "nvim-telescope/telescope.nvim" },
        }
      end)
      
    end,
  },
  {
    "obsidian-nvim/obsidian.nvim",
    config = function()
      
      return {
        "obsidian-nvim/obsidian.nvim",
        version = "*", -- recommended, use latest release instead of latest commit
        ft = "markdown",
        -- Replace the above line with this if you only want to load obsidian.nvim for markdown files in your vault:
        -- event = {
        --   -- If you want to use the home shortcut '~' here you need to call 'vim.fn.expand'.
        --   -- E.g. "BufReadPre " .. vim.fn.expand "~" .. "/my-vault/*.md"
        --   -- refer to `:h file-pattern` for more examples
        --   "BufReadPre path/to/my-vault/*.md",
        --   "BufNewFile path/to/my-vault/*.md",
        -- },
        ---@module 'obsidian'
        ---@type obsidian.config
        opts = {
          workspaces = {
            {
              name = "personal",
              path = "~/vaults/personal",
            },
            {
              name = "work",
              path = "~/vaults/work",
            },
          },
      
          -- see below for full list of options 👇
        },
      }
      
    end,
  },
  {
    "IlyasYOY/obs.nvim",
    config = function()
      
      return {
          {
              "IlyasYOY/obs.nvim",
              dependencies = {
                  "nvim-lua/plenary.nvim",
                  "nvim-telescope/telescope.nvim",
              },
              dev = true,
              config = function()
                  local obs = require "obs"
      
                  obs.setup {
                      vault_home = "~/Notes",
                      vault_name = "Notes",
                      journal = {
                          template_name = "daily",
                      },
                  }
      
                  vim.keymap.set("n", "<leader>nn", "<cmd>ObsNvimFollowLink<cr>")
                  vim.keymap.set("n", "<leader>nr", "<cmd>ObsNvimRandomNote<cr>")
                  vim.keymap.set("n", "<leader>nN", "<cmd>ObsNvimNewNote<cr>")
                  vim.keymap.set("n", "<leader>ny", "<cmd>ObsNvimCopyObsidianLinkToNote<cr>")
                  vim.keymap.set("n", "<leader>no", "<cmd>ObsNvimOpenInObsidian<cr>")
                  vim.keymap.set("n", "<leader>nd", "<cmd>ObsNvimDailyNote<cr>")
                  vim.keymap.set("n", "<leader>nw", "<cmd>ObsNvimWeeklyNote<cr>")
                  vim.keymap.set("n", "<leader>nrn", "<cmd>ObsNvimRename<cr>")
                  vim.keymap.set("n", "<leader>nT", "<cmd>ObsNvimTemplate<cr>")
                  vim.keymap.set("n", "<leader>nM", "<cmd>ObsNvimMove<cr>")
                  vim.keymap.set("n", "<leader>nb", "<cmd>ObsNvimBacklinks<cr>")
                  vim.keymap.set("n", "<leader>nfj", "<cmd>ObsNvimFindInJournal<cr>")
                  vim.keymap.set("n", "<leader>nff", "<cmd>ObsNvimFindNote<cr>")
                  vim.keymap.set("n", "<leader>nfg", "<cmd>ObsNvimFindInNotes<cr>")
              end,
          },
      }
      
       
      obs.setup {
          journal = {
              -- setting for daily note template name
              daily_template_name = "daily",
          },
      }
      
      
      -- config for nvim-cmp
      local cmp_source = require "obs.cmp-source"
      cmp.register_source("obs", cmp_source.new())
      
      -- config for obs.nvim
      local group = vim.api.nvim_create_augroup(
          "ObsNvim",
          { clear = true }
      )
      
      vim.api.nvim_create_autocmd({ "BufEnter" }, {
          group = group,
          pattern = "*.md",
          desc = "Setup notes nvim-cmp source",
          callback = function()
              if obs.vault:is_current_buffer_in_vault() then
                  require("cmp").setup.buffer {
                      sources = {
                          { name = "obs" },
                          { name = "luasnip" },
                      },
                  }
              end
          end,
      })
      
    end,
  },
  {
    "jghauser/papis.nvim",
    config = function()
      
      {
        "jghauser/papis.nvim",
        dependencies = {
          "kkharji/sqlite.lua",
          "MunifTanjim/nui.nvim",
          -- If not already installed, you may also want one of:
          -- "hrsh7th/nvim-cmp",
          -- "saghen/blink.cmp",
      
          -- Choose one of the following two if not already installed:
          -- "nvim-telescope/telescope.nvim",
          -- "folke/snacks.nvim",
      
        },
        config = function()
          require("papis").setup({
          -- Your configuration goes here
          })
        end,
      }
      
      
      use({
        "jghauser/papis.nvim",
        after = { "telescope.nvim", "nvim-cmp" }, -- Amend if you're using snacks.nvim
        requires = {
          "kkharji/sqlite.lua",
          "MunifTanjim/nui.nvim",
          "pysan3/pathlib.nvim",
          -- If not already installed, you may also want one of:
          -- "hrsh7th/nvim-cmp",
          -- "saghen/blink.cmp",
      
          -- Choose one of the following two if not already installed:
          -- "nvim-telescope/telescope.nvim",
          -- "folke/snacks.nvim",
        },
        config = function()
          require("papis").setup(
          -- Your configuration goes here
          )
        end,
      })
      
      
      require("papis").setup({
        -- Enable the default keymaps (defaults to `false`)
        enable_keymaps = true,
      
        -- You might want to change the filetypes activating papis.nvim
        -- init_filetypes = { "markdown", "norg", "yaml", "typst" },
      
        -- If you don't have an appropriate font (like Nerd Font), you
        -- may want to disable icons. This may require a `:Papis reload data`.
        -- to take effect.
        -- enable_icons = false,
      
        -- You can enable disabled modules (e.g. the 'ask' module) like so:
        -- ["ask"] = {
        --   enable = true,
        -- },
      })
      
      
      -- Defines citation formats for various filetypes. They define how citation strings
      -- are parsed and formatted when inserted. For each filetype, we may define:
      -- - `start_str`: Precedes the citation.
      -- - `start_pattern`: Alternative lua pattern for more complex parsing.
      -- - `end_str`: Appended after the citation.
      -- - `ref_prefix`: Precedes each `ref` in a citation.
      -- - `separator_str`: Gets added between `ref`s if there are multiple in a citation.
      -- For example, for the `org` filetype if we insert a citation with `Ref1` and `Ref2`,
      -- we end up with `[cite:@Ref1;@Ref2]`.
      cite_formats = {
        tex = {
          start_str = [[\cite{]],
          start_pattern = [[\cite[pt]?%[?[^%{]*]],
          end_str = "}",
          separator_str = ", ",
        },
        markdown = {
          ref_prefix = "@",
          separator_str = "; "
        },
        rmd = {
          ref_prefix = "@",
          separator_str = "; "
        },
        plain = {
          separator_str = ", "
        },
        org = {
          start_str = "[cite:",
          end_str = "]",
          ref_prefix = "@",
          separator_str = ";",
        },
        norg = {
          start_str = "{= ",
          end_str = "}",
          separator_str = "; ",
        },
        typst = {
          ref_prefix = "@",
          separator_str = " ",
        },
      },
      
      -- What citation format to use when none is defined for the current filetype.
      cite_formats_fallback = "plain",
      
      -- Enable default keymaps.
      enable_keymaps = false,
      
      -- Whether to enable the file system event watcher. When disabled, the database
      -- is only updated on startup.
      enable_fs_watcher = true,
      
      -- The sqlite schema of the main `data` table. Only the "text" and "luatable"
      -- types are allowed.
      data_tbl_schema = {
        id = { "integer", pk = true },
        papis_id = { "text", required = true, unique = true },
        ref = { "text", required = true, unique = true },
        author = "text",
        editor = "text",
        year = "text",
        title = "text",
        shorttitle = "text",
        type = "text",
        abstract = "text",
        time_added = "text",
        notes = "luatable",
        journal = "text",
        volume = "text",
        number = "text",
        author_list = "luatable",
        tags = "luatable",
        files = "luatable",
        related_to = "luatable",
      },
      
      -- Path to the papis.nvim database.
      db_path = vim.fn.stdpath("data") .. "/papis/papis-nvim.sqlite3",
      
      -- Name of the `yq` executable.
      yq_bin = "yq",
      
      -- Base papis command (can for example be used to change the config file used).
      papis_cmd_base = { "papis" },
      
      -- Filetypes that start papis.nvim.
      init_filetypes = { "markdown", "norg", "yaml", "typst" },
      
      -- Papis options to import into papis.nvim.
      papis_conf_keys = { "info-name", "notes-name", "dir", "opentool" },
      
      -- Whether to enable pretty icons (requires something like Nerd Fonts)
      enable_icons = true,
      
      -- Configuration of the search module.
      ["search"] = {
      
        -- Whether to enable this module.
        enable = true,
      
        -- Picker provider
        provider = "auto", ---@type "auto" | "snacks" | "telescope"
      
        -- Picker keymaps
        picker_keymaps = {
          ["<CR>"] = { "ref_insert", mode = { "n", "i" }, desc = "(Papis) Insert ref" },
          ["r"] = { "ref_insert_formatted", mode = "n", desc = "(Papis) Insert formatted ref" },
          ["<c-r>"] = { "ref_insert_formatted", mode = "i", desc = "(Papis) Insert formatted ref" },
          ["f"] = { "open_file", mode = "n", desc = "(Papis) Open file" },
          ["<c-f>"] = { "open_file", mode = "i", desc = "(Papis) Open file" },
          ["n"] = { "open_note", mode = "n", desc = "(Papis) Open note" },
          ["<c-n>"] = { "open_note", mode = "i", desc = "(Papis) Open note" },
          ["e"] = { "open_info", mode = "n", desc = "(Papis) Open info.yaml file" },
          ["<c-e>"] = { "open_info", mode = "i", desc = "(Papis) Open info.yaml file" },
        },
      
        -- Whether to enable line wrap in picker previewer.
        wrap = true,
      
        -- Whether to initially sort entries by time-added.
        initial_sort_by_time_added = true,
      
        -- What keys to search for matches.
        search_keys = { "author", "editor", "year", "title", "tags" },
      
        -- Papis.nvim uses a common configuration format for defining the formatting
        -- of strings. Sometimes -- as for instance in the below `preview_format` option --
        -- we define a set of lines. At other times -- as for instance in the `results_format`
        -- option -- we define a single line. Sets of lines are composed of single lines.
        -- A line can be composed of either a single element or multiple elements. The below
        -- `preview_format` shows an example where each line is defined by a table with just
        -- one element. The `results_format` and `popup_format` are examples where (some) of
        -- the lines contain multiple elements (and are represented by a table of tables).
        -- Each element contains:
        --   1. The key whose value is shown
        --   2. How it is formatted (here, each is just given as is)
        --   3. The highlight group
        --   4. (Optionally), `show_key` causes the key's name to be displayed in addition
        --      to the value. When used, there are then another two items defining the
        --      formatting of the key and its highlight group. The key is shown *before*
        --      the value in the preview (even though it is defined after it in this
        --      configuration (e.g. `title = Critique of Pure Reason`)).
        -- An element may also just contain `empty_line`. This is used to insert an empty line.
        -- Strings that define the formatting (such as in 2. and 4. above) can optionally
        -- be a table mapping strings onto tables that define first, an icon, and second, a
        -- non-icon version. So, a field `some_string = { "󱀁  ", "%s: " }` would mean that if
        -- the value is `some_string` it will get replaced with the defined icon (or non-icon
        -- version). The special key `fallback` is used to define how to handle strings that
        -- aren't explicitly configured. The `enable_icons` option determines whether the
        -- icon or non-icon version is used.
        preview_format = {
          { "author", "%s", "PapisPreviewAuthor" },
          { "year", "%s", "PapisPreviewYear" },
          { "title", "%s", "PapisPreviewTitle" },
          { "empty_line" },
          { "journal", "%s", "PapisPreviewValue", "show_key", { fallback = { "󱀁  ", "%s: " } }, "PapisPreviewKey" },
          { "type", "%s", "PapisPreviewValue", "show_key", { fallback = { "󰀼  ", "%s: " } }, "PapisPreviewKey" },
          { "ref", "%s", "PapisPreviewValue", "show_key", { fallback = { "󰌋  ", "%s: " } }, "PapisPreviewKey" },
          { "tags", "%s", "PapisPreviewValue", "show_key", { fallback = { "󰓹  ", "%s: " } }, "PapisPreviewKey" },
          { "abstract", "%s", "PapisPreviewValue", "show_key", { fallback = { "󰭷  ", "%s: " } }, "PapisPreviewKey" },
        },
      
        -- The format of each line in the the results window. Here, everything is show on
        -- one line (otherwise equivalent to points 1-3 of `preview_format`). The `force_space`
        -- value is used to force whitespace for icons (so that if e.g. a file is absent, it will
        -- show "  ", ensuring that columns are aligned.)
        results_format = {
          { "files", { fallback = { "󰈙 ", "F " } }, "PapisResultsFiles", "force_space" },
          { "notes", { fallback = { "󰆈 ", "N " } }, "PapisResultsNotes", "force_space" },
          { "author", "%s ", "PapisResultsAuthor" },
          { "year", "(%s) ", "PapisResultsYear" },
          { "title", "%s", "PapisResultsTitle" },
        },
      },
      
      -- Configuration of the completion module.
      ["completion"] = {
      
        -- Whether to enable this module.
        enable = true,
      
        -- Set the completion provider.
        provider = "auto", ---@type "auto" | "cmp" | "blink"
      },
      
      -- Configuration of the at-cursor module.
      ["at-cursor"] = {
      
        -- Whether to enable this module.
        enable = true,
      
        -- The format of the popup shown on `:Papis at-cursor show-popup` (equivalent to points 1-3
        -- of `preview_format`). Note that one of the lines is composed of multiple elements. Note
        -- also the `{ "vspace", "vspace" },` line which is exclusive to `popup_format` and which tells
        -- papis.nvim to fill the space between the previous and next element with whitespace (and
        -- in effect make whatever comes after right-aligned). It can only occur once in a line.
        popup_format = {
          {
            { "author", "%s", "PapisPopupAuthor" },
            { "vspace", "vspace" },
            { "files", { fallback = { "󰈙 ", "F " } }, "PapisResultsFiles" },
            { "notes", { fallback = { "󰆈 ", "N " } }, "PapisResultsNotes" },
          },
          { "year",  "%s", "PapisPopupYear" },
          { "title", "%s", "PapisPopupTitle" },
        },
      },
      
      -- Configuration of formatter module.
      ["formatter"] = {
      
        -- Whether to enable this module.
        enable = true,
      
        -- This function runs when first opening a new note. The `entry` arg is a table
        -- containing all the information about the entry (see above `data_tbl_schema`).
        -- This example is meant to be used with the `markdown` filetype. The function
        -- must return a set of lines, specifying the lines to be added to the note.
        format_notes = function(entry)
          -- Some string formatting templates (see above `results_format` option for
          -- more details)
          local title_format = {
            { "author", "%s ", "" },
            { "year", "(%s) ", "" },
            { "title", "%s", "" },
          }
          -- Format the strings with information in the entry
          local title = require("papis.utils"):format_display_strings(entry, title_format, true)
          -- Grab only the strings (and disregard highlight groups)
          for k, v in ipairs(title) do
            title[k] = v[1]
          end
          -- Define all the lines to be inserted
          local lines = {
            "---",
            'title: "Notes -- ' .. table.concat(title) .. '"',
            "---",
            "",
          }
          return lines
        end,
        -- This function runs when inserting a formatted reference (currently by `f/c-f` in
        -- the picker). It works similarly to the `format_notes` above, except that the set
        -- of lines should only contain one line (references using multiple lines aren't
        -- currently supported).
        format_references = function(entry)
          local reference_format = {
            { "author",  "%s ",   "" },
            { "year",    "(%s). ", "" },
            { "title",   "%s. ",  "" },
            { "journal", "%s. ",    "" },
            { "volume",  "%s",    "" },
            { "number",  "(%s)",  "" },
          }
          local reference_data = require("papis.utils"):format_display_strings(entry, reference_format)
          for k, v in ipairs(reference_data) do
            reference_data[k] = v[1]
          end
          local lines = { table.concat(reference_data) }
          return lines
        end,
      },
      
      -- Configuration of the at-cursor module.
      ["ask"] = {
      
        -- Whether to enable this module.
        enable = false,
      
        -- Picker provider
        provider = "auto", ---@type "auto" | "snacks" | "telescope"
      
        -- Defines the arguments for available slash commands (they get added to `papis_cmd_base`).
        -- You can call them with e.g. `/ask`. The {input} value gets replaced with the your input
        -- (e.g. /ask MY INPUT).
        slash_command_args = {
          ask = { "ask", "--output", "json", "{input}" },
          shortask = { "ask", "--output", "json", "--evidence-k", "5", "--max-sources", "3", "{input}" },
          longask = { "ask", "--output", "json", "--evidence-k", "20", "--max-sources", "10", "{input}" },
          index = { "ask", "index" },
        },
      
        -- Whether to initially sort entries by time-added.
        initial_sort_by_time_added = true,
      
        -- Picker keymaps
        picker_keymaps = {
          ["<CR>"] = { "open_answer", mode = { "n", "i" }, desc = "(Papis) Open answer" },
          ["d"] = { "delete_answer", mode = "n", desc = "(Papis) Delete answer" },
          ["<c-d>"] = { "delete_answer", mode = "i", desc = "(Papis) Delete answer" },
        },
      
        -- The format of the picker preview (see above for details).
        preview_format = {
          { "question", "%s", "PapisPreviewQuestion", "show_key", { fallback = { "󰍉  ", "Question: " } }, "PapisPreviewKey" },
          { "empty_line" },
          { "answer", "%s", "PapisPreviewAnswer", "show_key", { fallback = { "󱆀  ", "Answer: " } }, "PapisPreviewKey" },
        },
      
        -- The format of each line in the the picker results (see above for details).
        results_format = {
          { "slash", {
            ask = { "󰪡  ", "M " },
            shortask = { "󰄰  ", "S" },
            longask = { "󰪥  ", "L " },
          }, "PapisResultsCommand", "force_space" },
          { "question",   "%s ",   "PapisResultsQuestion" },
          { "time_added", "(%s) ", "PapisResultsTimeAdded" },
        },
      },
      
      -- Configurations relevant for parsing `info.yaml` files.
      ["papis-storage"] = {
      
        -- Whether to enable this module.
        enable = true,
      
        -- As lua doesn't deal well with '-', we define conversions between the format
        -- in the `info.yaml` and the format in papis.nvim's internal database.
        key_name_conversions = {
          time_added = "time-added",
        },
      
        -- The keys which `.yaml` files are expected to always define. Files that are
        -- missing these keys will cause an error message and will not be added to
        -- the database.
        required_keys = { "papis_id", "ref" },
      },
      
      -- Configuration of custom HL groups
      ["colors"] = {
      
        -- Whether to enable this module.
        enable = true,
      },
      
      -- Configuration of the debug module
      ["debug"] = {
      
        -- Whether to enable this module.
        enable = false,
      },
      
      
      require("blink.cmp").setup({
        sources = {
          -- add 'papis' to the list of sources for the yaml filetype
          per_filetype = {
            yaml = { "papis" }
          },
      })
      
      
      require("cmp").setup({
        sources = cmp.config.sources({
        -- your other source
        { name = "papis" },
        })
      })
      
    end,
  },
  {
    "Ostralyan/scribe.nvim",
    config = function()
      
      return require('packer').startup(function(use)
        use 'nvim-telescope/telescope.nvim', tag = '0.1.0',
        use 'Ostralyan/scribe.nvim'
      end)
      
      
      -- Default values
      -- {
      --   directory = '~/notes',
      --   file_ext = 'md',
      --   default_file = 'scribe'
      -- }
      require('scribe').setup{}
      
      
      require('scribe').setup{
        directory = './notes',
        file_ext = '.txt',
        default_file = 'scribe'
      }
      
    end,
  },
  {
    "RutaTang/quicknote.nvim",
    config = function()
      
      require("lazy").setup({
        { "RutaTang/quicknote.nvim", config=function()
              -- you must call setup to let quicknote.nvim works correctly
              require("quicknote").setup({})
        end
        , dependencies = { "nvim-lua/plenary.nvim"} },
      })
      
      
      require("lazy").setup({
        { "RutaTang/quicknote.nvim", config=function()
              require("quicknote").setup({
                  mode = "portable", -- "portable" | "resident", default to "portable"
                  sign = "N", -- This is used for the signs on the left side (refer to ShowNoteSigns() api).
                             -- You can change it to whatever you want (eg. some nerd fonts icon), 'N' is default
                  filetype = "md",
                  git_branch_recognizable = true, -- If true, quicknote will separate notes by git branch 
                                                  -- But it should only be used with resident mode,  it has not effect used with portable mode
              })
        end
        , dependencies = { "nvim-lua/plenary.nvim"} },
      })
      
      
      require("telescope").setup({
          extensions = {
              quicknote = {
                  defaultScope = "CWD",
              }
          }
      })
      
      require("telescope").load_extension("quicknote")
      
      
      vim.api.nvim_set_keymap("n", "<leader>p", "<cmd>:lua require('quicknote').NewNoteAtCurrentLine()<cr>",{})
      
    end,
  },
  {
    "serenevoid/kiwi.nvim",
    config = function()
      
      
      use {
          'serenevoid/kiwi.nvim'
      }
      
      
      
      
      -- init.lua:
      {
          'serenevoid/kiwi.nvim'
      }
      
      -- plugins/kiwi.lua:
      return {
          'serenevoid/kiwi.nvim'
      }
      
      
      
      {
          'serenevoid/kiwi.nvim',
          opts = {
              {
                  name = "work",
                  path = "work-wiki"
              },
              {
                  name = "personal",
                  path = "personal-wiki"
              }
          },
          keys = {
              { "<leader>ww", ":lua require(\"kiwi\").open_wiki_index()<cr>", desc = "Open Wiki index" },
              { "<leader>wp", ":lua require(\"kiwi\").open_wiki_index(\"personal\")<cr>", desc = "Open index of personal wiki" },
              { "T", ":lua require(\"kiwi\").todo.toggle()<cr>", desc = "Toggle Markdown Task" }
          },
          lazy = true
      }
      
      
      -- Setup Custom wiki path if required
      require('kiwi').setup({
          {
              name = "work",
              path = "work-wiki"
          },
          {
              name = "personal",
              path = "personal-wiki"
          }
      })
      -- Note: The path will be created in user home directory
      
      -- Use default path (i.e. ~/wiki/)
      local kiwi = require('kiwi')
      
      -- Necessary keybindings
      vim.keymap.set('n', '<leader>ww', kiwi.open_wiki_index, {})
      vim.keymap.set('n', 'T', kiwi.todo.toggle, {})
      
    end,
  },
  {
    "ada0l/obsidian",
    config = function()
      
      {
        'ada0l/obsidian',
        lazy = 'VeryLazy',
        keys = {
          { '<leader>ov', '<cmd>lua require("obsidian").vault_prompt()<cr>', desc = 'Vault prompt' },
          { '<leader>oc', '<cmd>lua require("obsidian").cd_vault()<cr>', desc = 'Cd vault' },
          { '<leader>on', '<cmd>lua require("obsidian").new_note_prompt()<cr>', desc = 'New note' },
          { '<leader>ot', '<cmd>lua require("obsidian").open_today()<cr>', desc = 'Open today' },
          { '<leader>oT', '<cmd>lua require("obsidian").open_today_prompt()<cr>', desc = 'Open today (shift)' },
          { '<leader>oi', '<cmd>lua require("obsidian").template_picker()<cr>', desc = 'Template picker' },
          { '<leader>of', '<cmd>lua require("obsidian").note_picker()<cr>', desc = 'Note picker' },
          { '<leader>ob', '<cmd>lua require("obsidian").backlinks_picker()<cr>', desc = 'Backlinks picker' },
          { '<leader>or', '<cmd>lua require("obsidian").rename_prompt()<cr>', desc = 'Rename prompt' },
          {
            'gf',
            function()
              if require('obsidian').found_wikilink_under_cursor() ~= nil then
                return '<cmd>lua require("obsidian").go_to()<CR>'
              else
                return 'gf'
              end
            end,
            noremap = false,
            expr = true,
          },
        },
        ---@type ObsidianOptions
        opts = {
          extra_fd_opts = '--exclude assets --exclude journals --exclude _debug_remotely_save',
          vaults = {
            {
              dir = '~/Knowledge/',
              daily = {
                dir = 'journals',
                format = '%Y-%m-%d',
              },
              note = {
                dir = '.',
                transformator = function(filename)
                  if filename ~= nil and filename ~= '' then
                    return filename
                  end
                  return string.format('%d', os.time())
                end,
              },
              templates = {
                dir = 'templates',
                date = '%Y-%d-%m',
                time = '%Y-%d-%m',
              },
            },
          },
        },
      }
      
      
      {
        'hrsh7th/nvim-cmp',
        dependencies = {
          'ada0l/obsidian',
        },
        ---@param opts cmp.ConfigSchema
        opts = function(_, opts)
          local cmp = require('cmp')
          local obsidian = require('obsidian')
          cmp.register_source('obsidian', obsidian.get_cmp_source().new())
          table.insert(opts.sources, { name = 'obsidian' })
        end,
      },
      
    end,
  },
  {
    "gsuuon/note.nvim",
    config = function()
      
      use 'gsuuon/note.nvim'
      
      
        {
          'gsuuon/note.nvim',
          opts = {
            -- opts.spaces are note workspace parent directories.
            -- These directories contain a `notes` directory which will be created if missing.
            -- `<space path>/notes` acts as the note root, so for space '~' the note root is `~/notes`.
            -- Defaults to { '~' }.
            spaces = {
              '~',
              -- '~/projects/foo'
            },
      
            -- Set keymap = false to disable keymapping
            -- keymap = { 
            --   prefix = '<leader>n'
            -- }
          },
          cmd = 'Note',
          ft = 'note',
          keys = {
            -- You can use telescope to search the current note space:
            {'<leader>tn', -- [t]elescope [n]ote
              function()
                require('telescope.builtin').live_grep({
                  cwd = require('note.api').current_note_root()
                })
              end,
              mode = 'n'
            }
          }
        }
      
      
      require('note').setup({
        spaces = { '~', '~/myproject' }
      })
      
    end,
  },
  {
    "backdround/global-note.nvim",
    config = function()
      
      local global_note = require("global-note")
      global_note.setup()
      
      vim.keymap.set("n", "<leader>n", global_note.toggle_note, {
        desc = "Toggle global note",
      })
      
      
      {
        -- Filename to use for default note (preset).
        -- string or fun(): string
        filename = "global.md",
      
        -- Directory to keep default note (preset).
        -- string or fun(): string
        directory = vim.fn.stdpath("data") .. "/global-note/",
      
        -- Floating window title.
        -- string or fun(): string
        title = "Global note",
      
        -- Ex command name.
        -- string
        command_name = "GlobalNote",
      
        -- A nvim_open_win config to show float window.
        -- table or fun(): table
        window_config = function()
          local window_height = vim.api.nvim_list_uis()[1].height
          local window_width = vim.api.nvim_list_uis()[1].width
          return {
            relative = "editor",
            border = "single",
            title = "Note",
            title_pos = "center",
            width = math.floor(0.7 * window_width),
            height = math.floor(0.85 * window_height),
            row = math.floor(0.05 * window_height),
            col = math.floor(0.15 * window_width),
          }
        end,
      
        -- It's called after the window creation.
        -- fun(buffer_id: number, window_id: number)
        post_open = function(_, _) end,
      
        -- Whether to use autosave. Autosave saves buffer on closing window
        -- or exiting Neovim.
        -- boolean
        autosave = true,
      
        -- Additional presets to create other global, project local, file local
        -- and other notes.
        -- { [name]: table } - tables there have the same fields as the current table.
        additional_presets = {},
      }
      
      
      require("global-note").setup({
        filename = "global.md",
        directory = "~/notes/",
      
        additional_presets = {
          projects = {
            filename = "projects-to-do.md",
            title = "List of projects",
            command_name = "ProjectsNote",
            -- All not specified options are used from the root.
          },
      
          food = {
            filename = "want-to-eat.md",
            title = "List of food",
            command_name = "FoodNote",
            -- All not specified options are used from the root.
          },
        },
      })
      
      -- Functions to toggle notes:
      require("global-note").toggle_note()
      require("global-note").toggle_note("projects")
      require("global-note").toggle_note("food")
      
      -- Commands to toggle notes (they are generated by command_name field):
      -- :GlobalNote -- by default
      -- :ProjectsNote
      -- :FoodNote
      
      
      local global_note = require("global-note")
      global_note.setup({
        additional_presets = {
          project_local = {
            command_name = "ProjectNote",
      
            filename = function()
              return get_project_name() .. ".md"
            end,
      
            title = "Project note",
          },
        }
      })
      
      vim.keymap.set("n", "<leader>n", function()
        global_note.toggle_note("project_local")
      end, {
        desc = "Toggle project note",
      })
      
      
      local global_note = require("global-note")
      global_note.setup({
        additional_presets = {
          git_branch_local = {
            command_name = "GitBranchNote",
      
            directory = function()
              return vim.fn.stdpath("data") .. "/global-note/" .. get_project_name()
            end,
      
            filename = function()
              local git_branch = get_git_branch()
              if git_branch == nil then
                return nil
              end
              return get_git_branch():gsub("[^%w-]", "-") .. ".md"
            end,
      
            title = get_git_branch,
          },
        }
      })
      
      vim.keymap.set("n", "<leader>n", function()
        global_note.toggle_note("git_branch_local")
      end, {
        desc = "Toggle git branch note",
      })
      
      
      local get_project_name = function()
        local project_directory, err = vim.loop.cwd()
        if project_directory == nil then
          vim.notify(err, vim.log.levels.WARN)
          return nil
        end
      
        local project_name = vim.fs.basename(project_directory)
        if project_name == nil then
          vim.notify("Unable to get the project name", vim.log.levels.WARN)
          return nil
        end
      
        return project_name
      end
      
      
      local get_project_name = function()
        local result = vim.system({
          "git",
          "rev-parse",
          "--show-toplevel",
        }, {
          text = true,
        }):wait()
      
        if result.stderr ~= "" then
          vim.notify(result.stderr, vim.log.levels.WARN)
          return nil
        end
      
        local project_directory = result.stdout:gsub("\n", "")
      
        local project_name = vim.fs.basename(project_directory)
        if project_name == nil then
          vim.notify("Unable to get the project name", vim.log.levels.WARN)
          return nil
        end
      
        return project_name
      end
      
      
      local get_project_name = function()
        local result = vim.system({
          "git",
          "symbolic-ref",
          "--short",
          "HEAD",
        }, {
          text = true,
        }):wait()
      
        if result.stderr ~= "" then
          vim.notify(result.stderr, vim.log.levels.WARN)
          return nil
        end
      
        return result.stdout:gsub("\n", "")
      end
      
    end,
  },
  {
    "2KAbhishek/tdo.nvim",
    config = function()
      
          -- Lazy
          {
              '2kabhishek/tdo.nvim',
              dependencies =  '2kabhishek/pickme.nvim',
              cmd = { 'Tdo' },
              keys = { '<leader>nn', '<leader>nt', '<leader>nx', '[t', ']t' }, -- Add more keybindings you need for lazy loading
          },
      
      
      local tdo = require('tdo')
      
      tdo.setup({
          add_default_keybindings = true, -- Add default keybindings for the plugin
          completion = {
              offsets = {},               -- Custom offsets / date expressions for completion
              ignored_files = { 'README.md', 'templates' }, -- Files/directories to ignore in completions
          },
          cache = {                       -- You don't really need to change these
              timeout = 5000,             -- Completion cache timeout in milliseconds
              max_entries = 100,          -- Maximum number of cached completion entries
          },
          lualine = {                     -- Only used for lualine integration
              update_frequency = 300,     -- How frequently to update the pending todo count in lualine
              only_show_in_notes = false, -- Whether to show the lualine component only in notes buffers
          }
      })
      
      
      require('lualine').setup({
          sections = {
              lualine_x = { require('tdo.lualine'), 'fileformat', 'filetype' },
          }
      })
      
    end,
  },
  {
    "y3owk1n/dotmd.nvim",
    config = function()
      
      -- dotmd.lua
      return {
       "y3owk1n/dotmd.nvim",
       version = "*", -- remove this if you want to use the `main` branch
       opts = {
        -- your configuration comes here
        -- or leave it empty to use the default settings
        -- refer to the configuration section below
       }
      }
      
      
      require("dotmd").setup({
        -- your configuration
      })
      
      
      ---@alias DotMd.Split "vertical" | "horizontal" | "float" | "none" Split direction
      ---@alias DotMd.PickerType "telescope" | "fzf" | "snacks" | "mini" Picker type
      
      ---@class DotMd.Config
      ---@field root_dir? string Root directory of dotmd, default is `~/dotmd`
      ---@field default_split? DotMd.Split Split direction for new or existing files, default is `none`
      ---@field picker? DotMd.PickerType Picker type, default is `nil`
      ---@field rollover_todo? DotMd.Config.RolloverTodo
      ---@field dir_names? DotMd.Config.DirNames
      ---@field templates? Dotmd.Config.Templates
      
      ---@class DotMd.Config.RolloverTodo
      ---@field enabled? boolean Rollover the nearest previous unchecked todos to today's date, default is `false`
      ---@field headings? string[] H2 Headings to search for in your todos template to rollover, default is { "Tasks" }
      
      ---@class DotMd.Config.DirNames
      ---@field notes? string Directory name for notes, default is "notes"
      ---@field todos? string Todo directory name, default is "todos"
      ---@field journals? string Journal directory name, default is "journals"
      
      ---@class Dotmd.Config.Templates
      ---@field notes? fun(name: string): string[]
      ---@field todos? fun(date: string): string[]
      ---@field journals? fun(date: string): string[]
      ---@field inbox? fun(date: string): string[]
      {
       root_dir = "~/dotmd",
       default_split = "none",
       rollover_todo = {
        enabled = false,
        heading = { "Tasks" },
       },
       picker = nil,
       dir_names = {
        notes = "notes",
        todos = "todos",
        journals = "journals",
       },
       templates = {
        notes = function(title)
         return {
          "---",
          "title: " .. title,
          "created: " .. os.date("%Y-%m-%d %H:%M"),
          "---",
          "",
          "# " .. title,
          "",
         }
        end,
        todos = function(date)
         return {
          "---",
          "type: todo",
          "date: " .. date,
          "---",
          "",
          "# Todo for " .. date,
          "",
          "## Tasks",
          "",
         }
        end,
        journals = function(date)
         return {
          "---",
          "type: journal",
          "date: " .. date,
          "---",
          "",
          "# Journal Entry for " .. date,
          "",
          "## Highlights",
          "",
          "## Thoughts",
          "",
          "## Tasks",
          "",
         }
        end,
        inbox = function()
         return {
          "---",
          "type: inbox",
          "---",
          "",
          "# Inbox",
          "",
          "## Quick Notes",
          "",
          "## Tasks",
          "",
          "## References",
          "",
         }
        end,
       },
      }
      
      
      {
       "y3owk1n/dotmd.nvim",
       cmd = {
        "DotMdCreateNote",
        "DotMdCreateTodoToday",
        "DotMdCreateJournal",
        "DotMdInbox",
        "DotMdNavigate",
        "DotMdPick",
        "DotMdOpen",
       },
       event = "VeryLazy",
       ---@type DotMd.Config
       opts = {
        root_dir = "~/dotmd" -- set it to your desired directory or remain at it is
        default_split = "float" -- or "vertical" or "horizontal" or "none" based on your preference
        rollover_todo = {
         enabled = true, -- enable rollover
        },
        picker = "snacks" -- or "fzf" or "telescope" or "mini" based on your preference
       },
       keys = {
        {
         "<leader>nc",
         function()
          require("dotmd").create_note()
         end,
         desc = "[DotMd] Create new note",
        },
        {
         "<leader>nt",
         function()
          require("dotmd").create_todo_today()
         end,
         desc = "[DotMd] Create todo for today",
        },
        {
         "<leader>ni",
         function()
          require("dotmd").inbox()
         end,
         desc = "[DotMd] Inbox",
        },
        {
         "<leader>nj",
         function()
          require("dotmd").create_journal()
         end,
         desc = "[DotMd] Create journal",
        },
        {
         "<leader>np",
         function()
          require("dotmd").navigate("previous")
         end,
         desc = "[DotMd] Navigate to previous todo",
        },
        {
         "<leader>nn",
         function()
          require("dotmd").navigate("next")
         end,
         desc = "[DotMd] Navigate to next todo",
        },
        {
         "<leader>no",
         function()
          require("dotmd").open({
           pluralise_query = true, -- recommended
          })
         end,
         desc = "[DotMd] Open",
        },
        {
         "<leader>sna",
         function()
          require("dotmd").pick()
         end,
         desc = "[DotMd] Everything",
        },
        {
         "<leader>snA",
         function()
          require("dotmd").pick({
           grep = true,
          })
         end,
         desc = "[DotMd] Search everything grep",
        },
        {
         "<leader>snn",
         function()
          require("dotmd").pick({
           type = "notes",
          })
         end,
         desc = "[DotMd] Search notes",
        },
        {
         "<leader>snN",
         function()
          require("dotmd").pick({
           type = "notes",
           grep = true,
          })
         end,
         desc = "[DotMd] Search notes grep",
        },
        {
         "<leader>snt",
         function()
          require("dotmd").pick({
           type = "todos",
          })
         end,
         desc = "[DotMd] Search todos",
        },
        {
         "<leader>snT",
         function()
          require("dotmd").pick({
           type = "todos",
           grep = true,
          })
         end,
         desc = "[DotMd] Search todos grep",
        },
        {
         "<leader>snj",
         function()
          require("dotmd").pick({
           type = "journals",
          })
         end,
         desc = "[DotMd] Search journal",
        },
        {
         "<leader>snJ",
         function()
          require("dotmd").pick({
           type = "journals",
           grep = true,
          })
         end,
         desc = "[DotMd] Search journal grep",
        },
       },
      },
      
      
      journals = function(date)
        return {
          "---",
          "type: journal",
          "date: " .. date,
          "---",
          "# " .. date,
          "",
          "## What happened today?",
          "## Reflections",
          "## TODOs",
        }
      end
      
      
      ---@alias DotMd.Split "vertical" | "horizontal" | "float" | "none" Split direction
      
      ---@class DotMd.CreateFileOpts
      ---@field split? DotMd.Split Split direction for new or existing files, default is based on `default_split` in config
      
      ---@param opts? DotMd.CreateFileOpts
      require("dotmd").create_note(opts) # or :DotMdCreateNote
      
      
      ---@alias DotMd.Split "vertical" | "horizontal" | "float" | "none" Split direction
      
      ---@class DotMd.CreateFileOpts
      ---@field split? DotMd.Split Split direction for new or existing files, default is based on `default_split` in config
      
      ---@param opts? DotMd.CreateFileOpts
      require("dotmd").create_todo_today(opts) # or :DotMdCreateTodoToday
      
      
      ---@alias DotMd.Split "vertical" | "horizontal" | "float" | "none" Split direction
      
      ---@class DotMd.CreateFileOpts
      ---@field split? DotMd.Split Split direction for new or existing files, default is based on `default_split` in config
      
      ---@param opts? DotMd.CreateFileOpts
      require("dotmd").create_journal(opts) # or :DotMdCreateJournal
      
      
      ---@alias DotMd.Split "vertical" | "horizontal" | "float" | "none" Split direction
      
      ---@class DotMd.CreateFileOpts
      ---@field split? DotMd.Split Split direction for new or existing files, default is based on `default_split` in config
      
      ---@param opts? DotMd.CreateFileOpts
      require("dotmd").create_journal(opts) # or :DotMdInbox
      
      
      ---@alias DotMd.PickType "notes" | "todos" | "journals" | "all" Pick type
      ---@alias DotMd.PickerType "telescope" | "fzf" | "snacks" | "mini" Picker type
      
      ---@class DotMd.PickOpts
      ---@field picker? DotMd.PickerType Picker type, default is based on `picker` in config
      ---@field type? DotMd.PickType Pick type, default is `all`
      ---@field grep? boolean Grep the selected type directory for a string, default is false
      
      ---@param opts? DotMd.PickOpts
      require("dotmd").pick(opts) # or :DotMdPick
      
      
      ---@param direction "previous"|"next"
      require("dotmd").navigate(direction) # or :DotMdNavigate
      
      
      ---@alias DotMd.PickType "notes" | "todos" | "journals" | "all" Pick type
      
      ---@class DotMd.OpenOpts
      ---@field type? DotMd.PickType Open type, default is `all`
      ---@field query? string Query to filter the files
      ---@field split? DotMd.Split Split direction for new or existing files, default is based on `default_split` in config
      ---@field pluralise_query? boolean Pluralise the query, default is `false`
      
      ---@param opts? DotMd.OpenOpts Options for opening the file
      require("dotmd").open(opts) # or :DotMdOpen
      
    end,
  },
  {
    "athar-qadri/scratchpad.nvim",
    config = function()
      
      {
        "athar-qadri/scratchpad.nvim",
        event = "VeryLazy",
        dependencies = { "nvim-lua/plenary.nvim" }, -- don't forget to add this one if you don't have it yet!
        config = function()
          require("scratchpad"):setup()
        end,
      }
      
      
      use {
        "athar-qadri/scratchpad.nvim",
        requires = { "nvim-lua/plenary.nvim" },
        config = function()
          require("scratchpad"):setup()
        end,
      }
      
      
      local scratchpad = require("scratchpad")
      
      -- Default setup
      scratchpad:setup()
      --or
      -- Custom setup
      scratchpad:setup({
        settings = {
          sync_on_ui_close = true,
          title = "My Scratch Pad"
        },
        default = {
        --here you specify project root identifiers (Cargo.toml, package.json, blah-blah-blah)
        --or let your man do the job
          root_patterns = { ".git", "package.json", "README.md" },
        },
      })
      
      
      {
        keys = {
          {
            "<Leader>es",
            function()
              local scratchpad = require("scratchpad")
              scratchpad.ui:new_scratchpad()
            end,
            desc = "open scratchpad",
          },
        },
      }
      
      
      return {
        "athar-qadri/scratchpad.nvim",
        event = "VeryLazy",
        opts = {},
        dependencies = {
          "nvim-lua/plenary.nvim",
        },
        config = function()
          local scratchpad = require("scratchpad")
          scratchpad:setup({ settings = { sync_on_ui_close = true } })
        end,
        keys = {
          {
            "<Leader>es",
            function()
              local scratchpad = require("scratchpad")
              scratchpad.ui:new_scratchpad()
            end,
            desc = "show scratch pad",
          
            vim.keymap.set({ "n", "v" }, "<leader>ps", function()
              local scratchpad = require("scratchpad")
              scratchpad.ui:sync()
            end, { desc = "Push selection / current line to scratchpad" }),
          },
        },
      }
      
    end,
  },
  {
    "echaya/neowiki.nvim",
    config = function()
      
      {
        "echaya/neowiki.nvim",
        opts = {
          wiki_dirs = {
            -- neowiki.nvim supports both absolute and tilde-expanded paths
            { name = "Work", path = "~/work/wiki" },
            { name = "Personal", path = "personal/wiki" },
          },
        },
        keys = {
          { "<leader>ww", "<cmd>lua require('neowiki').open_wiki()<cr>", desc = "Open Wiki" },
          { "<leader>wW", "<cmd>lua require('neowiki').open_wiki_floating()<cr>", desc = "Open Wiki in Floating Window" },
          { "<leader>wT", "<cmd>lua require('neowiki').open_wiki_new_tab()<cr>", desc = "Open Wiki in Tab" },
        },
      }
      
      
      require("mini.deps").add("echaya/neowiki.nvim")
      require("neowiki").setup()
      vim.keymap.set("n", "<leader>ww", require("neowiki").open_wiki, { desc = "Open Wiki" })
      vim.keymap.set("n", "<leader>wW", require("neowiki").open_wiki_floating, { desc = "Open Floating Wiki" })
      vim.keymap.set("n", "<leader>wT", require("neowiki").open_wiki_new_tab, { desc = "Open Wiki in Tab" })
      
      
      require("neowiki").setup({
        -- A list of tables, where each table defines a wiki.
        -- Both absolute and tilde-expanded paths are supported.
        -- If this is nil, the plugin defaults to `~/wiki`.
        -- Example:
        -- wiki_dirs = {
        --   { name = "Work", path = "~/Documents/work-wiki" },
        --   { name = "Personal", path = "personal-wiki" },
        -- }
        wiki_dirs = nil,
      
        -- The filename for a wiki's index page (e.g., "index.md").
        index_file = "index.md",
      
        -- Automatically discover and register nested wiki roots.
        discover_nested_roots = false,
      
        -- Defines the keymaps used by neowiki.
        -- Setting a keymap to `false` or an empty string will disable it.
        keymaps = {
          -- In Normal mode, follows the link under the cursor.
          -- In Visual mode, creates a link from the selection.
          action_link = "<CR>",
          action_link_vsplit = "<S-CR>",
          action_link_split = "<C-CR>",
      
          -- Jumps to the next link in the buffer.
          next_link = "<Tab>",
          -- Jumps to the previous link in the buffer.
          prev_link = "<S-Tab>",
          -- Navigate back and forth in history.
          navigate_back = "[[",
          navigate_forward = "]]",
          -- Jumps to the index page of the current wiki.
          jump_to_index = "<Backspace>",
      
          -- Renames the current wiki page and updates backlinks.
          rename_page = "<leader>wr",
          -- Deletes the current wiki page and updates backlinks.
          delete_page = "<leader>wd",
          -- Inserts a link to another wiki page.
          insert_link = "<leader>wi",
          -- Removes all links in the current file that point to non-existent pages.
          cleanup_links = "<leader>wc",
      
          -- Toggles the status of a gtd item.
          -- Works on the current line in Normal mode and on the selection in Visual mode.
          toggle_task = "<leader>wt",
      
          -- Closes the floating window.
          close_float = "q",
        },
      
        -- Configuration for the GTD functionality.
        gtd = {
          -- Set to false to disable the progress percentage virtual text.
          show_gtd_progress = true,
          -- The highlight group to use for the progress virtual text.
          gtd_progress_hl_group = "Comment",
        },
      
        -- Configuration for opening wiki in floating window.
        floating_wiki = {
          -- Config for nvim_open_win(). Defines the window's structure,
          -- position, and border.
          open = {
            relative = "editor",
            width = 0.9,
            height = 0.9,
            border = "rounded",
          },
      
          -- Options for nvim_win_set_option(). Defines the style
          -- within the window after it's created.
          style = {},
        },
      })
      
      
      -- Open a specific wiki defined in wiki_dirs without a prompt
      vim.keymap.set("n", "<leader>wk", function()
        require("neowiki").open_wiki("Work")
      end, { desc = "Open Work Wiki" })
      
    end,
  },
  {
    "phrmendes/todotxt.nvim",
    config = function()
      
      MiniDeps.now(function()
        MiniDeps.add({ source = "phrmendes/todotxt.nvim" })
      
        require("todotxt").setup({
          todotxt = vim.env.HOME .. "/Documents/notes/todo.txt",
          donetxt = vim.env.HOME .. "/Documents/notes/done.txt",
          ghost_text = {
            enable = true,
            mappings = {
              ["(A)"] = "now",
              ["(B)"] = "next",
              ["(C)"] = "today",
            },
          },
        })
      end)
      
      
      return {
        "phrmendes/todotxt.nvim",
        cmd = { "TodoTxt", "DoneTxt" },
        opts = {
          todotxt = "path/to/the/todo.txt",
          donetxt = "path/to/the/done.txt",
          ghost_text = {
            enable = true,
            mappings = {
              ["(A)"] = "now",
              ["(B)"] = "next",
              ["(C)"] = "today",
            },
          },
        },
      }
      
      
      vim.filetype.add({
        filename = {
          ["todo.txt"] = "todotxt",
          ["done.txt"] = "todotxt",
        },
      })
      
      
      vim.keymap.set("n", "<leader>tn", "<cmd>TodoTxt new<cr>", { desc = "New todo entry" })
      vim.keymap.set("n", "<leader>tt", "<cmd>TodoTxt<cr>", { desc = "Toggle todo.txt" })
      vim.keymap.set("n", "<leader>td", "<cmd>DoneTxt<cr>", { desc = "Toggle done.txt" })
      vim.keymap.set("n", "<leader>tg", "<cmd>TodoTxt ghost<cr>", { desc = "Toggle ghost text" })
      vim.keymap.set("n", "<cr>", "<Plug>(TodoTxtToggleState)", { desc = "Toggle task state" })
      vim.keymap.set("n", "<c-c>n", "<Plug>(TodoTxtCyclePriority)", { desc = "Cycle priority" })
      vim.keymap.set("n", "<leader>tm", "<Plug>(TodoTxtMoveDone)", { desc = "Move done tasks" })
      vim.keymap.set("n", "<leader>tss", "<Plug>(TodoTxtSortTasks)", { desc = "Sort tasks (default)" })
      vim.keymap.set("n", "<leader>tsp", "<Plug>(TodoTxtSortByPriority)", { desc = "Sort by priority" })
      vim.keymap.set("n", "<leader>tsc", "<Plug>(TodoTxtSortByContext)", { desc = "Sort by context" })
      vim.keymap.set("n", "<leader>tsP", "<Plug>(TodoTxtSortByProject)", { desc = "Sort by project" })
      vim.keymap.set("n", "<leader>tsd", "<Plug>(TodoTxtSortByDueDate)", { desc = "Sort by due date" })
      
      
      require("nvim-treesitter.configs").setup({
        ensure_installed = { "todotxt" },
        highlight = { enable = true },
      })
      
      
      ghost_text = {
        enable = true,
        mappings = {
          ["(A)"] = "now",      -- High priority tasks
          ["(B)"] = "next",     -- Medium priority tasks
          ["(C)"] = "today",    -- Lower priority tasks
          ["(D)"] = "tomorrow", -- Even lower priority
          ["(E)"] = "this week",
          ["(F)"] = "next week",
        },
        prefix = " ",           -- Text prefix
        highlight = "Comment",  -- Highlight group
      }
      
    end,
  },
  {
    "happyeric77/joplin.nvim",
    config = function()
      
      {
        "happyeric77/joplin.nvim",
        dependencies = {
          "nvim-telescope/telescope.nvim",
          "nvim-lua/plenary.nvim",
        },
        config = function()
          require("joplin").setup({
            -- Your configuration options here
          })
        end,
      },
      
      
      use {
        "happyeric77/joplin.nvim",
        requires = {
          "nvim-telescope/telescope.nvim",
          "nvim-lua/plenary.nvim",
        },
        config = function()
          require("joplin").setup({
            -- Your configuration options here
          })
        end,
      }
      
      
      -- Basic setup (using environment variable JOPLIN_TOKEN)
      require("joplin").setup()
      
      -- Custom configuration
      require("joplin").setup({
        -- API Configuration (flat structure, NOT nested under 'api')
        token_env = "JOPLIN_TOKEN",    -- Environment variable for token
        token = nil,                   -- Or directly specify token (overrides env var)
        port = 41184,
        host = "localhost",
        
        -- Tree view settings
        tree = {
          height = 12,
          position = "botright",
          focus_after_open = false,
          auto_sync = true,
        },
        
        -- Keymap settings
        keymaps = {
          enter = "replace",           -- Enter behavior: replace/vsplit
          o = "vsplit",               -- o behavior: vsplit/replace
          search = "<leader>js",
          search_notebook = "<leader>jsnb",
          toggle_tree = "<leader>jt",
        },
        
        -- Startup validation settings
        startup = {
          validate_on_load = true,     -- Validate requirements on startup
          show_warnings = true,        -- Show warning messages
          async_validation = true,     -- Async validation to avoid blocking
          validation_delay = 100,      -- Delay before validation starts
        },
      })
      
      
         require("joplin").setup({
           token = "your_token_here"
         })
         
      
         require("joplin").setup({
           port = 41185, -- Your custom port
         })
         
      
      require("joplin").setup({
        startup = {
          validate_on_load = false, -- Disable validation
          show_warnings = false,    -- Disable warning messages
        }
      })
      
    end,
  },
  {
    "Cih2001/pikchr.nvim",
    config = function()
      
      {
          "Cih2001/pikchr.nvim",
          lazy = false, -- or set true for lazy loading
          cmd = "Pikchr",
          config = function()
              require("pikchr").setup({
                  server_port = 1234,
              })
          end,
      },
      
    end,
  },
  {
    "gaborvecsei/usage-tracker.nvim",
    config = function()
      
      Plug 'gaborvecsei/usage-tracker.nvim'
      
      
      require('usage-tracker').setup({
          keep_eventlog_days = 14,
          cleanup_freq_days = 7,
          event_wait_period_in_sec = 5,
          inactivity_threshold_in_min = 5,
          inactivity_check_freq_in_sec = 5,
          verbose = 0,
          telemetry_endpoint = "" -- you'll need to start the restapi for this feature
      })
      
    end,
  },
  {
    "mateuszwieloch/automkdir.nvim",
    config = function()
      
      {
        ---@type string[] Array of regexes to try to match filepaths against.
        blacklist = { "oil:.*" },
      }
      
    end,
  },
  {
    "jghauser/mkdir.nvim",
    config = function()
      
      -- mkdir
      use {
        'jghauser/mkdir.nvim'
      }
      
    end,
  },
  {
    "matbme/JABS.nvim",
    config = function()
      
      use 'matbme/JABS.nvim'
      
      
      require 'jabs'.setup {}
      
      
      require 'jabs'.setup {
          -- Options for the main window
          position = {'center', 'top'}, -- position = {'<position_x>', '<position_y>'} | <position_x> left, center, right,
                                        --                                             <position_y> top, center, bottom
                                        -- Default {'right', 'bottom'}
      
          relative = 'editor', -- win, editor, cursor. Default win
          clip_popup_size = false, -- clips the popup size to the win (or editor) size. Default true
      
          width = 80, -- default 50
          height = 20, -- default 10
          border = 'single', -- none, single, double, rounded, solid, shadow, (or an array or chars). Default shadow
      
          offset = { -- window position offset
              top = 2, -- default 0
              bottom = 2, -- default 0
              left = 2, -- default 0
              right = 2, -- default 0
          },
      
          sort_mru = true -- Sort buffers by most recently used (true or false). Default false
          split_filename = true -- Split filename into separate components for name and path. Default false
          split_filename_path_width = 20 -- If split_filename is true, how wide the column for the path is supposed to be, Default 0 (don't show path)
      
          -- Options for preview window
          preview_position = 'left', -- top, bottom, left, right. Default top
          preview = {
              width = 40, -- default 70
              height = 60, -- default 30
              border = 'single', -- none, single, double, rounded, solid, shadow, (or an array or chars). Default double
          },
      
          -- Default highlights (must be a valid :highlight)
          highlight = {
              current = "Title", -- default StatusLine
              hidden = "StatusLineNC", -- default ModeMsg
              split = "WarningMsg", -- default StatusLine
              alternate = "StatusLine" -- default WarningMsg
          },
      
          -- Default symbols
          symbols = {
              current = "C", -- default 
              split = "S", -- default 
              alternate = "A", -- default 
              hidden = "H", -- default ﬘
              locked = "L", -- default 
              ro = "R", -- default 
              edited = "E", -- default 
              terminal = "T", -- default 
              default_file = "D", -- Filetype icon if not present in nvim-web-devicons. Default 
              terminal_symbol = ">_" -- Filetype icon for a terminal split. Default 
          },
      
          -- Keymaps
          keymap = {
              close = "<c-d>", -- Close buffer. Default D
              jump = "<space>", -- Jump to buffer. Default <cr>
              h_split = "h", -- Horizontally split buffer. Default s
              v_split = "v", -- Vertically split buffer. Default v
              preview = "p", -- Open buffer preview. Default P
          },
      
          -- Whether to use nvim-web-devicons next to filenames
          use_devicons = false -- true or false. Default true
      }
      
    end,
  },
  {
    "j-morano/buffer_manager.nvim",
    config = function()
      
      use 'nvim-lua/plenary.nvim'  -- basic dependency
      use 'j-morano/buffer_manager.nvim'
      
      
      :lua require("buffer_manager.ui").toggle_quick_menu()
      
      
      :lua require("buffer_manager.ui").nav_next()
      :lua require("buffer_manager.ui").nav_prev()
      
      
      :lua require'buffer_manager.ui'.save_menu_to_file()
      :lua require'buffer_manager.ui'.load_menu_from_file()
      
      
      :lua require'buffer_manager.ui'.save_menu_to_file('bm')
      :lua require'buffer_manager.ui'.load_menu_from_file('bm')
      
      
      require("buffer_manager").setup({ })
      
      
      vim.api.nvim_set_hl(0, "BufferManagerModified", { fg = "#0000af" })
      
      
        {
          line_keys = "1234567890",
          select_menu_item_commands = {
            edit = {
              key = "<CR>",
              command = "edit"
            }
          },
          focus_alternate_buffer = false,
          width = nil,
          height = nil,
          short_file_names = false,
          show_depth = true,
          short_term_names = false,
          loop_nav = true,
          highlight = "",
          win_extra_options = {},
          borderchars = { "─", "│", "─", "│", "╭", "╮", "╯", "╰" },
          format_function = nil,
          order_buffers = nil,
          show_indicators = nil,
          toggle_key_bindings = { "q", "<ESC>" },
        }
      
      
      local opts = {noremap = true}
      local map = vim.keymap.set
      -- Setup
      require("buffer_manager").setup({
        select_menu_item_commands = {
          v = {
            key = "<C-v>",
            command = "vsplit"
          },
          h = {
            key = "<C-h>",
            command = "split"
          }
        },
        focus_alternate_buffer = false,
        short_file_names = true,
        short_term_names = true,
        loop_nav = false,
        highlight = 'Normal:BufferManagerBorder',
        win_extra_options = {
          winhighlight = 'Normal:BufferManagerNormal',
        },
      })
      -- Navigate buffers bypassing the menu
      local bmui = require("buffer_manager.ui")
      local keys = '1234567890'
      for i = 1, #keys do
        local key = keys:sub(i,i)
        map(
          'n',
          string.format('<leader>%s', key),
          function () bmui.nav_file(i) end,
          opts
        )
      end
      -- Just the menu
      map({ 't', 'n' }, '<M-Space>', bmui.toggle_quick_menu, opts)
      -- Open menu and search
      map({ 't', 'n' }, '<M-m>', function ()
        bmui.toggle_quick_menu()
        -- wait for the menu to open
        vim.defer_fn(function ()
          vim.fn.feedkeys('/')
        end, 50)
      end, opts)
      -- Next/Prev
      map('n', '<M-j>', bmui.nav_next, opts)
      map('n', '<M-k>', bmui.nav_prev, opts)
      
      
      vim.api.nvim_command([[
      autocmd FileType buffer_manager vnoremap J :m '>+1<CR>gv=gv
      autocmd FileType buffer_manager vnoremap K :m '<-2<CR>gv=gv
      ]])
      
    end,
  },
  {
    "clojure-vim/jazz.nvim",
  },
  {
    "doctorfree/cheatsheet.nvim",
    config = function()
      
      use {
        'doctorfree/cheatsheet.nvim',
      
        requires = {
          {'nvim-telescope/telescope.nvim'},
          {'nvim-lua/popup.nvim'},
          {'nvim-lua/plenary.nvim'},
        }
      }
      
      
      {
        "doctorfree/cheatsheet.nvim",
        event = "VeryLazy",
        dependencies = {
          { "nvim-telescope/telescope.nvim" },
          { "nvim-lua/popup.nvim" },
          { "nvim-lua/plenary.nvim" },
        },
        config = function()
          local ctactions = require("cheatsheet.telescope.actions")
          require("cheatsheet").setup({
            bundled_cheetsheets = {
              enabled = { "default", "lua", "markdown", "regex", "netrw", "unicode" },
              disabled = { "nerd-fonts" },
            },
            bundled_plugin_cheatsheets = {
              enabled = {
                "auto-session",
                "goto-preview",
                "octo.nvim",
                "telescope.nvim",
                "vim-easy-align",
                "vim-sandwich",
              },
              disabled = { "gitsigns" },
            },
            include_only_installed_plugins = true,
            telescope_mappings = {
              ["<CR>"] = ctactions.select_or_fill_commandline,
              ["<A-CR>"] = ctactions.select_or_execute,
              ["<C-Y>"] = ctactions.copy_cheat_value,
              ["<C-E>"] = ctactions.edit_user_cheatsheet,
            },
          })
        end,
      }
      
      
      require("cheatsheet").setup({
          -- Whether to show bundled cheatsheets
      
          -- For generic cheatsheets like default, unicode, nerd-fonts, etc
          -- bundled_cheatsheets = {
          --     enabled = {},
          --     disabled = {},
          -- },
          bundled_cheatsheets = true,
      
          -- For plugin specific cheatsheets
          -- bundled_plugin_cheatsheets = {
          --     enabled = {},
          --     disabled = {},
          -- }
          bundled_plugin_cheatsheets = true,
      
          -- For bundled plugin cheatsheets, do not show a sheet if you
          -- don't have the plugin installed (searches runtimepath for
          -- same directory name)
          include_only_installed_plugins = true,
      
          -- Key mappings bound inside the telescope window
          telescope_mappings = {
              ['<CR>'] = require('cheatsheet.telescope.actions').select_or_fill_commandline,
              ['<A-CR>'] = require('cheatsheet.telescope.actions').select_or_execute,
              ['<C-Y>'] = require('cheatsheet.telescope.actions').copy_cheat_value,
              ['<C-E>'] = require('cheatsheet.telescope.actions').edit_user_cheatsheet,
          }
      })
      
      
      require('cheatsheet').setup({
          telescope_mappings = {
              ['<CR>'] = require('cheatsheet.telescope.actions').select_or_execute,
              ['<A-CR>'] = require('cheatsheet.telescope.actions').select_or_fill_commandline,
          }
      })
      
      
      require("cheatsheet").setup({
          bundled_cheatsheets = {
              -- only show the default cheatsheet
              enabled = { "default" },
          },
          bundled_plugin_cheatsheets = {
              -- show cheatsheets for all plugins except gitsigns
              disabled = { "gitsigns.nvim" },
          }
      })
      
    end,
  },
  {
    "hat0uma/prelive.nvim",
    config = function()
      
      {
        "hat0uma/prelive.nvim",
        opts = {},
        cmd = {
          "PreLiveGo",
          "PreLiveStatus",
          "PreLiveClose",
          "PreLiveCloseAll",
          "PreLiveLog",
        },
      }
      
      
      require('prelive').setup {
        server = {
          --- The host to bind the server to.
          --- It is strongly recommended not to expose it to the external network.
          host = "127.0.0.1",
      
          --- The port to bind the server to.
          --- If the value is 0, the server will bind to a random port.
          port = 2255,
        },
      
        http = {
          --- maximum number of pending connections.
          --- If the number of pending connections is greater than this value, the client will receive ECONNREFUSED.
          --- @type integer
          tcp_max_backlog = 16,
      
          --- tcp recv buffer size.
          --- The size of the buffer used to receive data from the client.
          --- This value is used for `vim.uv.recv_buffer_size()`.
          --- @type integer
          tcp_recv_buffer_size = 1024,
      
          --- http keep-alive timeout in milliseconds.
          --- If the client does not send a new request within this time, the server will close the connection.
          --- @type integer
          keep_alive_timeout = 60 * 1000,
      
          --- request body size limit
          --- If the request body size exceeds this value, the server will return 413 Payload Too Large.
          --- @type integer
          max_body_size = 1024 * 1024 * 1,
      
          --- request line size limit
          --- The request line consists of the request method, request URI, and HTTP version.
          --- If the request line size exceeds this value, the server will return 414 URI Too Long.
          --- @type integer
          max_request_line_size = 1024 * 4,
      
          --- header field size limit (key + value)
          --- If the size of a header field exceeds this value, the server will return 431 Request Header Fields Too Large.
          --- @type integer
          max_header_field_size = 1024 * 4,
      
          --- max header count.
          --- If the number of header fields exceeds this value, the server will return 431 Request Header Fields Too Large.
          --- @type integer
          max_header_num = 100,
      
          --- max chunk-ext size limit for chunked body
          --- If the size of a chunk-ext exceeds this value, the server will return 400 Bad Request.
          --- @type integer
          max_chunk_ext_size = 1024 * 1,
        },
      
        log = {
          --- The log levels to print. see `vim.log.levels`.
          print_level = vim.log.levels.WARN,
      
          --- The log levels to write to the log file. see `vim.log.levels`.
          file_level = vim.log.levels.DEBUG,
      
          --- The maximum size of the log file in bytes.
          --- If 0, it does not output.
          max_file_size = 1 * 1024 * 1024,
      
          --- The maximum number of log files to keep.
          max_backups = 3,
        },
      }
      
      
      local prelive = require('prelive')
      
      -- Start the server and open the specified file in the browser.
      -- If { watch = false }, the server will not watch the file for changes. in this case, you need to call `prelive.reload` manually.
      local opts = { watch = true }
      prelive.go(dir, file, opts)
      
      -- Show the status of the served directories and open one in the browser.
      prelive.status()
      
      -- Select a directory to stop serving. (using `vim.ui.select`)
      prelive.select_close()
      
      -- Stop serving the specified directory.If no arguments are provided, It stops all.
      prelive.close()
      
      -- Open the log file in a new tab.
      prelive.open_log()
      
      -- Force reload the served directory.
      prelive.reload(dir)
      
    end,
  },
  {
    "code-biscuits/nvim-biscuits",
    config = function()
      
      call plug#begin()
      Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}
      Plug 'code-biscuits/nvim-biscuits'
      call plug#end()
      
      
      use {
        'code-biscuits/nvim-biscuits',
        requires = {
          'nvim-treesitter/nvim-treesitter',
           run = ':TSUpdate'
        },
      }
      
      
      
      lua <<EOF
      require'nvim-treesitter.configs'.setup {
        ensure_installed = "maintained",
        ...
      }
      EOF
      
      
      lua require('nvim-biscuits').setup({})
      
      
      lua <<EOF
      require('nvim-biscuits').setup({
        default_config = {
          max_length = 12,
          min_distance = 5,
          prefix_string = " 📎 "
        },
        language_config = {
          html = {
            prefix_string = " 🌐 "
          },
          javascript = {
            prefix_string = " ✨ ",
            max_length = 80
          },
          python = {
            disabled = true
          }
        }
      })
      EOF
      
      
      lua <<EOF
      require('nvim-biscuits').setup({
        on_events = { 'InsertLeave', 'CursorHoldI' }
      })
      EOF
      
      
      
      " global color
      highlight BiscuitColor ctermfg=cyan
      
      " language specific color
      highlight BiscuitColorRust ctermfg=red
      
      
      
      lua <<EOF
      require('nvim-biscuits').setup({
        max_length = 2,
        trim_by_words = true,
      })
      EOF
      
      
      lua <<EOF
      require('nvim-biscuits').setup({
        toggle_keybind = "<leader>cb",
        show_on_start = true -- defaults to false
      })
      EOF
      
      
      lua <<EOF
      require('nvim-biscuits').setup({
        language_config = {
          rust = {
            toggle_keybind = "<leader>cb"
          }
        }
      })
      EOF
      
      
      require('nvim-biscuits').toggle_biscuits()
      
      
      lua <<EOF
      require('nvim-biscuits').setup({
        cursor_line_only = true
      })
      EOF
      
      
      lua <<EOF
      require('nvim-biscuits').setup({
        max_file_size = '100kb'
      })
      EOF
      
      
      keys = {
        {
          "<leader>bb",
          function()
            require("nvim-biscuits").BufferAttach()
          end,
          mode = "n",
          desc = "Enable Biscuits",
        },
      },
      
      
      keys = {
        {
          "<leader>bb",
          function()
            local nvim_biscuits =
            require("nvim-biscuits")
            nvim_biscuits.BufferAttach()
            nvim_biscuits.toggle_biscuits()
          end,
          mode = "n",
          desc = "Enable Biscuits",
        },
      },
      
    end,
  },
  {
    "kazhala/close-buffers.nvim",
    config = function()
      
      require('close_buffers').setup({
        filetype_ignore = {},  -- Filetype to ignore when running deletions
        file_glob_ignore = {},  -- File name glob pattern to ignore when running deletions (e.g. '*.md')
        file_regex_ignore = {}, -- File name regex pattern to ignore when running deletions (e.g. '.*[.]md')
        preserve_window_layout = { 'this', 'nameless' },  -- Types of deletion that should preserve the window layout
        next_buffer_cmd = nil,  -- Custom function to retrieve the next buffer when preserving window layout
      })
      
      
      require('close_buffers').setup({
        preserve_window_layout = { 'this' },
        next_buffer_cmd = function(windows)
          require('bufferline').cycle(1)
          local bufnr = vim.api.nvim_get_current_buf()
      
          for _, window in ipairs(windows) do
            vim.api.nvim_win_set_buf(window, bufnr)
          end
        end,
      })
      
      vim.api.nvim_set_keymap(
        'n',
        '<leader>th',
        [[<CMD>lua require('close_buffers').delete({type = 'hidden'})<CR>]],
        { noremap = true, silent = true }
      )
      vim.api.nvim_set_keymap(
        'n',
        '<leader>tu',
        [[<CMD>lua require('close_buffers').delete({type = 'nameless'})<CR>]],
        { noremap = true, silent = true }
      )
      vim.api.nvim_set_keymap(
        'n',
        '<leader>tc',
        [[<CMD>lua require('close_buffers').delete({type = 'this'})<CR>]],
        { noremap = true, silent = true }
      )
      
      
      -- bdelete
      require('close_buffers').delete({ type = 'hidden', force = true }) -- Delete all non-visible buffers
      require('close_buffers').delete({ type = 'nameless' }) -- Delete all buffers without name
      require('close_buffers').delete({ type = 'this' }) -- Delete the current buffer
      require('close_buffers').delete({ type = 1 }) -- Delete the specified buffer number
      require('close_buffers').delete({ regex = '.*[.]md' }) -- Delete all buffers matching the regex
      
      -- bwipeout
      require('close_buffers').wipe({ type = 'all', force = true }) -- Wipe all buffers
      require('close_buffers').wipe({ type = 'other' }) -- Wipe all buffers except the current focused
      require('close_buffers').wipe({ type = 'hidden', glob = '*.lua' }) -- Wipe all buffers matching the glob
      
      
      require('close_buffers').delete({ type = 1 }) -- Delete buffer with number 1
      
      
      require('close_buffers').this({ type = 'this', force = true })
      
      
      require('close_buffers').delete({ regex = '.*[.]md', force = true }) -- Delete all markdown buffers
      require('close_buffers').delete({ type = 'hidden', regex = '.*[.]lua' }) -- Delete all hidden lua buffers
      
      
      require('close_buffers').delete({ glob = '*.md', force = true }) -- Delele all markdown buffers
      require('close_buffers').delete({ type = 'hidden', glob = '*.lua' }) -- Delete all hidden lua buffers
      
    end,
  },
  {
    "rktjmp/paperplanes.nvim",
    config = function()
      
      -- options shown with default values
      require("paperplanes").setup({
        register = "+",
        provider = "0x0.st",
        provider_options = {},
        notifier = vim.notify or print,
        save_history = true
      })
      
    end,
  },
  {
    "rcarriga/nvim-notify",
    config = function()
      
      vim.opt.termguicolors = true
      
      
      use 'rcarriga/nvim-notify'
      
      
      require("notify")("My super important message")
      
      
      vim.notify = require("notify")
      
      
      vim.notify("This is an error message", "error")
      
      
      local plugin = "My Awesome Plugin"
      
      vim.notify("This is an error message.\nSomething went wrong!", "error", {
        title = plugin,
        on_open = function()
          vim.notify("Attempting recovery.", vim.log.levels.WARN, {
            title = plugin,
          })
          local timer = vim.loop.new_timer()
          timer:start(2000, 0, function()
            vim.notify({ "Fixing problem.", "Please wait..." }, "info", {
              title = plugin,
              timeout = 3000,
              on_close = function()
                vim.notify("Problem solved", nil, { title = plugin })
                vim.notify("Error code 0x0395AF", 1, { title = plugin })
              end,
            })
          end)
        end,
      })
      
      
      local async = require("plenary.async")
      local notify = require("notify").async
      
      async.run(function()
        notify("Let's wait for this to close").events.close()
        notify("It closed!")
      end)
      
      
      vim.notify(text, "info", {
        title = "My Awesome Plugin",
        on_open = function(win)
          local buf = vim.api.nvim_win_get_buf(win)
          vim.api.nvim_buf_set_option(buf, "filetype", "markdown")
        end,
      })
      
      
      require('telescope').extensions.notify.notify(<opts>)
      
      
      require("notify").history()
      
      
      require("notify").clear_history()
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-notify.md",
  },
  {
    "folke/noice.nvim",
    config = function()
      
      -- lazy.nvim
      {
        "folke/noice.nvim",
        event = "VeryLazy",
        opts = {
          -- add any options here
        },
        dependencies = {
          -- if you lazy-load any plugin below, make sure to add proper `module="..."` entries
          "MunifTanjim/nui.nvim",
          -- OPTIONAL:
          --   `nvim-notify` is only needed, if you want to use the notification view.
          --   If not available, we use `mini` as the fallback
          "rcarriga/nvim-notify",
          }
      }
      
      
      require("noice").setup({
        lsp = {
          -- override markdown rendering so that **cmp** and other plugins use **Treesitter**
          override = {
            ["vim.lsp.util.convert_input_to_markdown_lines"] = true,
            ["vim.lsp.util.stylize_markdown"] = true,
            ["cmp.entry.get_documentation"] = true, -- requires hrsh7th/nvim-cmp
          },
        },
        -- you can enable a preset for easier configuration
        presets = {
          bottom_search = true, -- use a classic bottom cmdline for search
          command_palette = true, -- position the cmdline and popupmenu together
          long_message_to_split = true, -- long messages will be sent to a split
          inc_rename = false, -- enables an input dialog for inc-rename.nvim
          lsp_doc_border = false, -- add a border to hover docs and signature help
        },
      })
      
      
      {
        cmdline = {
          enabled = true, -- enables the Noice cmdline UI
          view = "cmdline_popup", -- view for rendering the cmdline. Change to `cmdline` to get a classic cmdline at the bottom
          opts = {}, -- global options for the cmdline. See section on views
          ---@type table<string, CmdlineFormat>
          format = {
            -- conceal: (default=true) This will hide the text in the cmdline that matches the pattern.
            -- view: (default is cmdline view)
            -- opts: any options passed to the view
            -- icon_hl_group: optional hl_group for the icon
            -- title: set to anything or empty string to hide
            cmdline = { pattern = "^:", icon = "", lang = "vim" },
            search_down = { kind = "search", pattern = "^/", icon = " ", lang = "regex" },
            search_up = { kind = "search", pattern = "^%?", icon = " ", lang = "regex" },
            filter = { pattern = "^:%s*!", icon = "$", lang = "bash" },
            lua = { pattern = { "^:%s*lua%s+", "^:%s*lua%s*=%s*", "^:%s*=%s*" }, icon = "", lang = "lua" },
            help = { pattern = "^:%s*he?l?p?%s+", icon = "" },
            input = { view = "cmdline_input", icon = "󰥻 " }, -- Used by input()
            -- lua = false, -- to disable a format, set to `false`
          },
        },
        messages = {
          -- NOTE: If you enable messages, then the cmdline is enabled automatically.
          -- This is a current Neovim limitation.
          enabled = true, -- enables the Noice messages UI
          view = "notify", -- default view for messages
          view_error = "notify", -- view for errors
          view_warn = "notify", -- view for warnings
          view_history = "messages", -- view for :messages
          view_search = "virtualtext", -- view for search count messages. Set to `false` to disable
        },
        popupmenu = {
          enabled = true, -- enables the Noice popupmenu UI
          ---@type 'nui'|'cmp'
          backend = "nui", -- backend to use to show regular cmdline completions
          ---@type NoicePopupmenuItemKind|false
          -- Icons for completion item kinds (see defaults at noice.config.icons.kinds)
          kind_icons = {}, -- set to `false` to disable icons
        },
        -- default options for require('noice').redirect
        -- see the section on Command Redirection
        ---@type NoiceRouteConfig
        redirect = {
          view = "popup",
          filter = { event = "msg_show" },
        },
        -- You can add any custom commands below that will be available with `:Noice command`
        ---@type table<string, NoiceCommand>
        commands = {
          history = {
            -- options for the message history that you get with `:Noice`
            view = "split",
            opts = { enter = true, format = "details" },
            filter = {
              any = {
                { event = "notify" },
                { error = true },
                { warning = true },
                { event = "msg_show", kind = { "" } },
                { event = "lsp", kind = "message" },
              },
            },
          },
          -- :Noice last
          last = {
            view = "popup",
            opts = { enter = true, format = "details" },
            filter = {
              any = {
                { event = "notify" },
                { error = true },
                { warning = true },
                { event = "msg_show", kind = { "" } },
                { event = "lsp", kind = "message" },
              },
            },
            filter_opts = { count = 1 },
          },
          -- :Noice errors
          errors = {
            -- options for the message history that you get with `:Noice`
            view = "popup",
            opts = { enter = true, format = "details" },
            filter = { error = true },
            filter_opts = { reverse = true },
          },
          all = {
            -- options for the message history that you get with `:Noice`
            view = "split",
            opts = { enter = true, format = "details" },
            filter = {},
          },
        },
        notify = {
          -- Noice can be used as `vim.notify` so you can route any notification like other messages
          -- Notification messages have their level and other properties set.
          -- event is always "notify" and kind can be any log level as a string
          -- The default routes will forward notifications to nvim-notify
          -- Benefit of using Noice for this is the routing and consistent history view
          enabled = true,
          view = "notify",
        },
        lsp = {
          progress = {
            enabled = true,
            -- Lsp Progress is formatted using the builtins for lsp_progress. See config.format.builtin
            -- See the section on formatting for more details on how to customize.
            --- @type NoiceFormat|string
            format = "lsp_progress",
            --- @type NoiceFormat|string
            format_done = "lsp_progress_done",
            throttle = 1000 / 30, -- frequency to update lsp progress message
            view = "mini",
          },
          override = {
            -- override the default lsp markdown formatter with Noice
            ["vim.lsp.util.convert_input_to_markdown_lines"] = false,
            -- override the lsp markdown formatter with Noice
            ["vim.lsp.util.stylize_markdown"] = false,
            -- override cmp documentation with Noice (needs the other options to work)
            ["cmp.entry.get_documentation"] = false,
          },
          hover = {
            enabled = true,
            silent = false, -- set to true to not show a message if hover is not available
            view = nil, -- when nil, use defaults from documentation
            ---@type NoiceViewOptions
            opts = {}, -- merged with defaults from documentation
          },
          signature = {
            enabled = true,
            auto_open = {
              enabled = true,
              trigger = true, -- Automatically show signature help when typing a trigger character from the LSP
              luasnip = true, -- Will open signature help when jumping to Luasnip insert nodes
              throttle = 50, -- Debounce lsp signature help request by 50ms
            },
            view = nil, -- when nil, use defaults from documentation
            ---@type NoiceViewOptions
            opts = {}, -- merged with defaults from documentation
          },
          message = {
            -- Messages shown by lsp servers
            enabled = true,
            view = "notify",
            opts = {},
          },
          -- defaults for hover and signature help
          documentation = {
            view = "hover",
            ---@type NoiceViewOptions
            opts = {
              lang = "markdown",
              replace = true,
              render = "plain",
              format = { "{message}" },
              win_options = { concealcursor = "n", conceallevel = 3 },
            },
          },
        },
        markdown = {
          hover = {
            ["|(%S-)|"] = vim.cmd.help, -- vim help links
            ["%[.-%]%((%S-)%)"] = require("noice.util").open, -- markdown links
          },
          highlights = {
            ["|%S-|"] = "@text.reference",
            ["@%S+"] = "@parameter",
            ["^%s*(Parameters:)"] = "@text.title",
            ["^%s*(Return:)"] = "@text.title",
            ["^%s*(See also:)"] = "@text.title",
            ["{%S-}"] = "@parameter",
          },
        },
        health = {
          checker = true, -- Disable if you don't want health checks to run
        },
        ---@type NoicePresets
        presets = {
          -- you can enable a preset by setting it to true, or a table that will override the preset config
          -- you can also add custom presets that you can enable/disable with enabled=true
          bottom_search = false, -- use a classic bottom cmdline for search
          command_palette = false, -- position the cmdline and popupmenu together
          long_message_to_split = false, -- long messages will be sent to a split
          inc_rename = false, -- enables an input dialog for inc-rename.nvim
          lsp_doc_border = false, -- add a border to hover docs and signature help
        },
        throttle = 1000 / 30, -- how frequently does Noice need to check for ui updates? This has no effect when in blocking mode.
        ---@type NoiceConfigViews
        views = {}, ---@see section on views
        ---@type NoiceRouteConfig[]
        routes = {}, --- @see section on routes
        ---@type table<string, NoiceFilter>
        status = {}, --- @see section on statusline components
        ---@type NoiceFormatOptions
        format = {}, --- @see section on formatting
      }
      
      
        require("noice").setup({
          cmdline = {
            format = {
              cmdline = { icon = ">" },
              search_down = { icon = "🔍⌄" },
              search_up = { icon = "🔍⌃" },
              filter = { icon = "$" },
              lua = { icon = "☾" },
              help = { icon = "?" },
            },
          },
          format = {
            level = {
              icons = {
                error = "✖",
                warn = "▼",
                info = "●",
              },
            },
          },
          popupmenu = {
            kind_icons = false,
          },
          inc_rename = {
            cmdline = {
              format = {
                IncRename = { icon = "⟳" },
              },
            },
          },
        })
      
      
      -- all messages over 10 lines, excluding echo and search_count
      local filter = {
        event = "msg_show",
        min_height = 10,
        ["not"] = { kind = { "search_count", "echo" } },
      }
      
      
      -- override the default split view to always enter the split when it opens
      require("noice").setup({
        views = {
          split = {
            enter = true,
          },
        },
      })
      
      
      {
        win_options = {
          winhighlight = {
            Normal = "NormalFloat",
            FloatBorder = "FloatBorder"
          },
        }
      }
      
      
      {
        -- default format
        default = { "{level} ", "{title} ", "{message}" },
        -- default format for vim.notify views
        notify = { "{message}" },
        -- default format for the history
        details = {
          "{level} ",
          "{date} ",
          "{event}",
          { "{kind}", before = { ".", hl_group = "NoiceFormatKind" } },
          " ",
          "{title} ",
          "{cmdline} ",
          "{message}",
        },
        telescope = ..., -- formatter used to display telescope results
        telescope_preview = ..., -- formatter used to preview telescope results
        fzf = ..., -- formatter used to display fzf results
        fzf_preview = ..., -- formatter used to preview fzf results
        lsp_progress = ..., -- formatter used by lsp progress
        lsp_progress_done = ..., -- formatter used by lsp progress
      }
      
      
      -- skip search_count messages instead of showing them as virtual text
      require("noice").setup({
        routes = {
          {
            filter = { event = "msg_show", kind = "search_count" },
            opts = { skip = true },
          },
        },
      })
      
      -- always route any messages with more than 20 lines to the split view
      require("noice").setup({
        routes = {
          {
            view = "split",
            filter = { event = "msg_show", min_height = 20 },
          },
        },
      })
      
      
      require("lualine").setup({
        sections = {
          lualine_x = {
            {
              require("noice").api.status.message.get_hl,
              cond = require("noice").api.status.message.has,
            },
            {
              require("noice").api.status.command.get,
              cond = require("noice").api.status.command.has,
              color = { fg = "#ff9e64" },
            },
            {
              require("noice").api.status.mode.get,
              cond = require("noice").api.status.mode.has,
              color = { fg = "#ff9e64" },
            },
            {
              require("noice").api.status.search.get,
              cond = require("noice").api.status.search.has,
              color = { fg = "#ff9e64" },
            },
          },
        },
      })
      
      
      require("telescope").load_extension("noice")
      
      
      vim.keymap.set("n", "<leader>nl", function()
        require("noice").cmd("last")
      end)
      
      vim.keymap.set("n", "<leader>nh", function()
        require("noice").cmd("history")
      end)
      
      
      -- redirect ":hi"
      require("noice").redirect("hi")
      
      -- redirect some function
      require("noice").redirect(function()
        print("test")
      end)
      
      
      vim.keymap.set("c", "<S-Enter>", function()
        require("noice").redirect(vim.fn.getcmdline())
      end, { desc = "Redirect Cmdline" })
      
      
      vim.keymap.set({ "n", "i", "s" }, "<c-f>", function()
        if not require("noice.lsp").scroll(4) then
          return "<c-f>"
        end
      end, { silent = true, expr = true })
      
      vim.keymap.set({ "n", "i", "s" }, "<c-b>", function()
        if not require("noice.lsp").scroll(-4) then
          return "<c-b>"
        end
      end, { silent = true, expr = true })
      
    end,
  },
  {
    "sQVe/bufignore.nvim",
    config = function()
      
      {
        'sQVe/bufignore.nvim',
        dependencies = { 'nvim-lua/plenary.nvim' },
        opts = {
          -- Input configuration here.
          -- Refer to the configuration section below for options.
        }
      },
      
      
      use({
        'sQVe/bufignore.nvim',
        requires = { 'nvim-lua/plenary.nvim' },
        config = function()
          require("bufignore").setup({
            -- Input configuration here.
            -- Refer to the configuration section below for options.
          })
        end
      })
      
      
      {
        auto_start = true,
        ignore_sources = {
          git = true,
          patterns = { '/%.git/' },
          symlink = true,
          ignore_cwd_only = true,
        },
        pre_unlist = nil,
      }
      
    end,
  },
  {
    "saifulapm/commasemi.nvim",
    config = function()
      
      {
        "saifulapm/commasemi.nvim",
        lazy = false,
        opts = {
          leader = "<localleader>",
          keymaps = true,
          commands = true
        }
      }
      
      
      {
        "saifulapm/commasemi.nvim",
        lazy = false,
        init = function()
          vim.g.commasemi_disable_commands = true  -- disable commands before plugin loads
        end,
        opts = {
          keymaps = true,
          commands = false
        }
      }
      
      
      {
        "saifulapm/commasemi.nvim",
        cmd = { "CommaToggle", "SemiToggle" },
        opts = {
          keymaps = false,
          commands = true
        }
      }
      
      
      {
        "saifulapm/commasemi.nvim",
        keys = {
          { "<localleader>,", desc = "Toggle comma" },
          { "<localleader>;", desc = "Toggle semicolon" },
        },
        opts = {
          leader = "<localleader>",
          keymaps = true,
          commands = true
        }
      }
      
      
      require('commasemi').setup({
        leader = '<localleader>', -- optional, defaults to <localleader>
        keymaps = true,          -- optional, set to false to disable keymaps
        commands = true          -- optional, set to false to disable commands
      })
      
    end,
  },
  {
    "stevearc/dressing.nvim",
    config = function()
      
      {
        'stevearc/dressing.nvim',
        opts = {},
      }
      
      
      require('packer').startup(function()
          use {'stevearc/dressing.nvim'}
      end)
      
      
      require "paq" {
          {'stevearc/dressing.nvim'};
      }
      
      
      require("dressing").setup({
        input = {
          -- Set to false to disable the vim.ui.input implementation
          enabled = true,
      
          -- Default prompt string
          default_prompt = "Input",
      
          -- Trim trailing `:` from prompt
          trim_prompt = true,
      
          -- Can be 'left', 'right', or 'center'
          title_pos = "left",
      
          -- The initial mode when the window opens (insert|normal|visual|select).
          start_mode = "insert",
      
          -- These are passed to nvim_open_win
          border = "rounded",
          -- 'editor' and 'win' will default to being centered
          relative = "cursor",
      
          -- These can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
          prefer_width = 40,
          width = nil,
          -- min_width and max_width can be a list of mixed types.
          -- min_width = {20, 0.2} means "the greater of 20 columns or 20% of total"
          max_width = { 140, 0.9 },
          min_width = { 20, 0.2 },
      
          buf_options = {},
          win_options = {
            -- Disable line wrapping
            wrap = false,
            -- Indicator for when text exceeds window
            list = true,
            listchars = "precedes:…,extends:…",
            -- Increase this for more context when text scrolls off the window
            sidescrolloff = 0,
          },
      
          -- Set to `false` to disable
          mappings = {
            n = {
              ["<Esc>"] = "Close",
              ["<CR>"] = "Confirm",
            },
            i = {
              ["<C-c>"] = "Close",
              ["<CR>"] = "Confirm",
              ["<Up>"] = "HistoryPrev",
              ["<Down>"] = "HistoryNext",
            },
          },
      
          override = function(conf)
            -- This is the config that will be passed to nvim_open_win.
            -- Change values here to customize the layout
            return conf
          end,
      
          -- see :help dressing_get_config
          get_config = nil,
        },
        select = {
          -- Set to false to disable the vim.ui.select implementation
          enabled = true,
      
          -- Priority list of preferred vim.select implementations
          backend = { "telescope", "fzf_lua", "fzf", "builtin", "nui" },
      
          -- Trim trailing `:` from prompt
          trim_prompt = true,
      
          -- Options for telescope selector
          -- These are passed into the telescope picker directly. Can be used like:
          -- telescope = require('telescope.themes').get_ivy({...})
          telescope = nil,
      
          -- Options for fzf selector
          fzf = {
            window = {
              width = 0.5,
              height = 0.4,
            },
          },
      
          -- Options for fzf-lua
          fzf_lua = {
            -- winopts = {
            --   height = 0.5,
            --   width = 0.5,
            -- },
          },
      
          -- Options for nui Menu
          nui = {
            position = "50%",
            size = nil,
            relative = "editor",
            border = {
              style = "rounded",
            },
            buf_options = {
              swapfile = false,
              filetype = "DressingSelect",
            },
            win_options = {
              winblend = 0,
            },
            max_width = 80,
            max_height = 40,
            min_width = 40,
            min_height = 10,
          },
      
          -- Options for built-in selector
          builtin = {
            -- Display numbers for options and set up keymaps
            show_numbers = true,
            -- These are passed to nvim_open_win
            border = "rounded",
            -- 'editor' and 'win' will default to being centered
            relative = "editor",
      
            buf_options = {},
            win_options = {
              cursorline = true,
              cursorlineopt = "both",
              -- disable highlighting for the brackets around the numbers
              winhighlight = "MatchParen:",
              -- adds padding at the left border
              statuscolumn = " ",
            },
      
            -- These can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
            -- the min_ and max_ options can be a list of mixed types.
            -- max_width = {140, 0.8} means "the lesser of 140 columns or 80% of total"
            width = nil,
            max_width = { 140, 0.8 },
            min_width = { 40, 0.2 },
            height = nil,
            max_height = 0.9,
            min_height = { 10, 0.2 },
      
            -- Set to `false` to disable
            mappings = {
              ["<Esc>"] = "Close",
              ["<C-c>"] = "Close",
              ["<CR>"] = "Confirm",
            },
      
            override = function(conf)
              -- This is the config that will be passed to nvim_open_win.
              -- Change values here to customize the layout
              return conf
            end,
          },
      
          -- Used to override format_item. See :help dressing-format
          format_item_override = {},
      
          -- see :help dressing_get_config
          get_config = nil,
        },
      })
      
      
      require('dressing').setup({
        input = {
          win_options = {
            winhighlight = 'NormalFloat:DiagnosticError'
          }
        }
      })
      
      
      require('dressing').setup({
        select = {
          get_config = function(opts)
            if opts.kind == 'codeaction' then
              return {
                backend = 'nui',
                nui = {
                  relative = 'cursor',
                  max_width = 40,
                }
              }
            end
          end
        }
      })
      
      
      
      vim.ui.select({'apple', 'banana', 'mango'}, {
        prompt = "Title",
        telescope = require("telescope.themes").get_cursor(),
      }, function(selected) end)
      
    end,
  },
  {
    "gaborvecsei/cryptoprice.nvim",
    config = function()
      
      Plug 'nvim-lua/plenary.nvim' -- if you already have this you don't need to include it
      Plug 'gaborvecsei/cryptoprice.nvim'
      
      
      :lua require("cryptoprice").toggle()
      
      
      nnoremap <leader>cy <cmd>lua require('cryptoprice').toggle()<cr>
      
      
      let g:cryptoprice_base_currency = "usd"
      let g:cryptoprice_crypto_list = ["bitcoin", "ethereum"]
      let g:cryptoprice_window_width = 60
      let g:cryptoprice_window_height = 10
      
      
      vim.g.cryptoprice_base_currency = "usd"
      vim.g.cryptoprice_crypto_list = {"bitcoin", "ethereum"} 
      vim.g.cryptoprice_window_width = 60
      vim.g.cryptoprice_window_height = 10
      
      
      lua << EOF
      require("cryptoprice").setup{
          base_currency="usd",
          crypto_list={"bitcoin", "ethereum"},
          window_height=10,
          window_width=60
      }
      EOF
      
    end,
  },
  {
    "jghauser/fold-cycle.nvim",
    config = function()
      
      use {
        'jghauser/fold-cycle.nvim',
        config = function()
          require('fold-cycle').setup()
        end
      }
      
      
      require('fold-cycle').setup({
        open_if_max_closed = true,    -- closing a fully closed fold will open it
        close_if_max_opened = true,   -- opening a fully open fold will close it
      })
      
      
      vim.keymap.set('n', '<tab>',
        function() return require('fold-cycle').open() end,
        {silent = true, desc = 'Fold-cycle: open folds'})
      vim.keymap.set('n', '<s-tab>',
        function() return require('fold-cycle').close() end,
        {silent = true, desc = 'Fold-cycle: close folds'})
      vim.keymap.set('n', 'zC',
        function() return require('fold-cycle').close_all() end,
        {remap = true, silent = true, desc = 'Fold-cycle: close all folds'})
      
    end,
  },
  {
    "rgroli/other.nvim",
    config = function()
      
      require("other-nvim").setup({
          mappings = {
              -- builtin mappings
              "livewire",
              "angular",
              "laravel",
              "rails",
              "golang",
              "python",
              "react",
              "rust",
              "elixir",
              "clojure",
              -- custom mapping
              {
                  pattern = "/path/to/file/src/app/(.*)/.*.ext$",
                  target = "/path/to/file/src/view/%1/",
                  transformer = "lowercase"
              }
          },
          transformers = {
              -- defining a custom transformer
              lowercase = function (inputString)
                  return inputString:lower()
              end
          },
          style = {
              -- How the plugin paints its window borders
              -- Allowed values are none, single, double, rounded, solid and shadow
              border = "solid",
      
              -- Column seperator for the window
              seperator = "|",
      
      	-- width of the window in percent. e.g. 0.5 is 50%, 1.0 is 100%
      	width = 0.7,
      
      	-- min height in rows.
      	-- when more columns are needed this value is extended automatically
      	minHeight = 2
          },
      })
      
      
      require("other-nvim").setup({
      	mappings = {
      		"livewire",
      		"angular",
      		"laravel",
      		"rails",
      		"golang",
      		"python",
              "react",
      		"rust",
              "elixir",
      		"clojure",
      	},
      })
      
      vim.api.nvim_set_keymap("n", "<leader>ll", "<cmd>:Other<CR>", { noremap = true, silent = true })
      vim.api.nvim_set_keymap("n", "<leader>ltn", "<cmd>:OtherTabNew<CR>", { noremap = true, silent = true })
      vim.api.nvim_set_keymap("n", "<leader>lp", "<cmd>:OtherSplit<CR>", { noremap = true, silent = true })
      vim.api.nvim_set_keymap("n", "<leader>lv", "<cmd>:OtherVSplit<CR>", { noremap = true, silent = true })
      vim.api.nvim_set_keymap("n", "<leader>lc", "<cmd>:OtherClear<CR>", { noremap = true, silent = true })
      
      -- Context specific bindings
      vim.api.nvim_set_keymap("n", "<leader>lt", "<cmd>:Other test<CR>", { noremap = true, silent = true })
      vim.api.nvim_set_keymap("n", "<leader>ls", "<cmd>:Other scss<CR>", { noremap = true, silent = true })
      
      
      -- default settings
      local defaults = {
      
      	-- by default there are no mappings enabled
      	mappings = {},
      
      	-- default transformers
      	transformers = {
      		camelToKebap = transformers.camelToKebap,
      		kebapToCamel = transformers.kebapToCamel,
      		pluralize = transformers.pluralize,
      		singularize = transformers.singularize,
      	},
      
      	-- Should the window show files which do not exist yet based on
      	-- pattern matching. Selecting the files will create the file.
      	showMissingFiles = true,
      
      	-- When a mapping requires an initial selection of the other file, this setting controls,
      	-- wether the selection should be remembered for the current user session.
      	-- When this option is set to false reference between the two buffers are never saved.
      	-- Existing references can be removed on the buffer with :OtherClear
      	rememberBuffers = true,
      
      	keybindings = {
      		["<cr>"] = "open_file_by_command()",
      		["<esc>"] = "close_window()",
      		t = "open_file_tabnew()",
      		o = "open_file()",
      		q = "close_window()",
      		v = "open_file_vs()",
      		s = "open_file_sp()",
      	},
      
      	hooks = {
      		-- This hook which is executed when the file-picker is shown.
      		-- It could be used to filter or reorder the files in the filepicker.
      		-- The function must return a lua table with the same structure as the input parameter.
      		--
      		-- The input parameter "files" is a lua table with each entry containing:
      		-- @param table (filename (string), context (string), exists (boolean))
      		-- @return table | boolean When an empty table or false is returned the filepicker is not openend.
      		filePickerBeforeShow = function(files)
      			return files
      		end,
      
      		-- This hook is called whenever a file is about to be opened.
      		-- One example how this can be used: a non existing file needs to be opened by another plugin, which provides a template.
      		--
      		-- @param filename (string) the full-path of the file
      		-- @param exists (boolean) doess the file already exist
      		-- @return (boolean) When true (default) the plugin takes care of opening the file, when the function returns false this indicated that opening of the file is done in the hook.
      		onOpenFile = function(filename, exists)
      			return true
      		end,
      
              	-- This hook is called whenever the plugin tries to find other files.
      		-- It returns the matches found by the plugin. It can be used to filter or reorder the files or use the matches with another plugin.
      		--
      		-- @param matches (table) lua table with each entry containing: (filename (string), context (string), exists (boolean))
      		-- @return (matches) Make sure to return the matches, otherwise the plugin will not work as expected.
      		onFindOtherFiles = function(matches)
      			return matches
      		end,
      
      	},
      
      	style = {
      		-- How the plugin paints its window borders
      		-- Allowed values are none, single, double, rounded, solid and shadow
      		border = "solid",
      
      		-- Column seperator for the window
      		seperator = "|",
      
      		-- Indicator showing that the file does not yet exist
      		newFileIndicator = "(* new *)",
      
      		-- width of the window in percent. e.g. 0.5 is 50%, 1 is 100%
      		width = 0.7,
      
      		-- min height in rows.
      		-- when more columns are needed this value is extended automatically
      		minHeight = 2,
      	},
      
      }
      
      
      require("other-nvim").setup({
          mappings = {
      		{
      			pattern = "/src/app/(.*)/.*.ts$",
      			target = "/src/app/%1/%1.component.html",
                  		context = "component" -- optional
      		},
      		{
      			pattern = "/src/app/(.*)/.*.html$",
      			target = "/src/app/%1/%1.component.ts",
                  		context = "view"
      		}
      	}
      })
      
      
      require("other-nvim").setup({
          mappings = {
              	{
              		pattern = "/app/Http/Controllers/(.*)Controller.php$",
              		target = "/resources/views/%1/",
                      	context = "controller"
              		transformer = "camelToKebap",
              	},
              	{
              		pattern = "/resources/views/(.*)/.*",
              		target = "/app/Http/Controllers/%1Controller.php",
                      	context = "view"
              		transformer = "kebapToCamel",
              	},
      	}
      })
      
      
      require("other-nvim").setup({
          mappings = {
      		{
      			pattern = "/src/app/(.*)/.*.ts$",
      			target = "/src/app/%1/%1.component.html",
                  		context = "component"
      		},
      		{
      			pattern = "/src/app/(.*)/.*.html$",
      			target = "/src/app/%1/%1.component.ts",
                  		context = "view"
      		},
      		{
      			pattern = "/src/app/(.*)/.*.ts$",
      			target = "/src/app/%1/%1.component.html",
                  		context = "component"
      		},
      		{
      			pattern = "/src/app/(.*)/.*.spec.ts$",
      			target = "/src/app/%1/%1.component.html",
                  		context = "test"
      		},
      	}
      })
      
      
      require("other-nvim").setup({
          mappings = {
          	{
                  pattern = "/(.*)/(.*)/.*.ts$",
                  target = {
                      {
                          target = "/%1/%2/%2.component.html",
                          context = "html"
                      },
                      {
                          target = "/%1/%2/%2.component.spec.ts",
                          context = "test"
                      }
                  }
              }
      	},
      })
      
      
      require("other-nvim").setup({
          mappings = {
      		--- [...]
      		{
      		    pattern = "/src/(.*)/.*.js$",
      		    target = "/src/%1/\\(*.css\\|*.scss\\)",
      		},
      })
      
      
      require("other-nvim").setup({
          mappings = {
              {
                  -- Function receives the current file path and should return
                  -- captures to use in the target pattern, or nil if no match
                  pattern = function(file)
                      local match = file:match("/src/components/(.*)/index.tsx$")
                      if match then
                          return {match, "component"}  -- Returns captures as table
                      end
                      return nil  -- No match
                  end,
                  target = "/src/tests/%1/%2.test.tsx",
                  context = "test"
              }
          }
      })
      
      
      function (inputString)
         -- transforming here
         return transformedValue;
      end
      
      
      require("other-nvim").setup({
          -- [...]
          mappings = {
              -- custom mapping
              {
                  pattern = "/path/to/file/src/app/(.*)/.*.ext$",
                  target = "/path/to/file/src/view/%1/",
                  transformer = "lowercase"
              }
          },
          transformers = {
              lowercase = function (inputString)
                  return inputString:lower()
              end
          },
          -- [...]
      })
      
    end,
  },
  {
    "toppair/reach.nvim",
    config = function()
      
      use 'toppair/reach.nvim'
      
      
      -- default config
      require('reach').setup({
        notifications = true
      })
      
      
      -- default
      local options = {
        handle = 'auto',              -- 'bufnr' or 'dynamic' or 'auto'
        show_icons = true,
        show_current = false,         -- Include current buffer in the list
        show_modified = true,         -- Show buffer modified indicator
        modified_icon = '⬤',          -- Character to use as modified indicator
        grayout_current = true,       -- Wheter to gray out current buffer entry
        force_delete = {},            -- List of filetypes / buftypes to use
                                      -- 'bdelete!' on, e.g. { 'terminal' }
        filter = nil,                 -- Function taking bufnr as parameter,
                                      -- returning true or false
        sort = nil,                   -- Comparator function (bufnr, bufnr) -> bool
        terminal_char = '\\',         -- Character to use for terminal buffer handles
                                      -- when options.handle is 'dynamic'
        grayout = true,               -- Gray out non matching entries
      
        -- A list of characters to use as handles when options.handle == 'auto'
        auto_handles = require('reach.buffers.constant').auto_handles,
        auto_exclude_handles = {},    -- A list of characters not to use as handles when
                                      -- options.handle == 'auto', e.g. { '8', '9', 'j', 'k' }
        previous = {
          enable = true,              -- Mark last used buffers with specified chars and colors
          depth = 2,                  -- Maximum number of buffers to mark
          chars = { '•' },            -- Characters to use as markers,
                                      -- last one is used when depth > #chars
          groups = {                  -- Highlight groups for markers,
            'String',                 -- last one is used when depth > #groups
            'Comment',
          },
        },
        -- A map of action to key that should be used to invoke it
        actions = {
          split = '-',
          vertsplit = '|',
          tabsplit = ']',
          delete = '<Space>',
          priority = '=',
        },
      }
      
      require('reach').buffers(options)
      
      -- Example keymapping
      vim.keymap.set('n', '<leader>rb', function() require('reach').buffers(buffer_options) end, {})
      
      
      -- default
      local options = {
        filter = function(mark)
          return mark:match('[a-zA-Z]') -- return true to disable
        end,
        -- A map of action to key that should be used to invoke it
        actions = {
          split = '-',
          vertsplit = '|',
          tabsplit = ']',
          delete = '<Space>',
        },
      }
      
      require('reach').marks(options)
      
      
      -- default
      local options = {
        show_icons = true,
        show_current = false,
        -- A map of action to key that should be used to invoke it
        actions = {
          delete = '<Space>',
        },
      }
      
      require('reach').tabpages(options)
      
      
      -- default
      local options = {
        filter = (function()
          local default = {
            'blue', 'darkblue', 'default', 'delek', 'desert', 'elflord', 'evening', 'industry', 'koehler',
            'morning', 'murphy', 'pablo', 'peachpuff', 'ron', 'shine', 'slate', 'torte', 'zellner',
          }
      
          return function(name)
            return not vim.tbl_contains(default, name) -- return true to disable
          end
        end)(),
      }
      
      require('reach').colorschemes(options)
      
      
      -- options as in require('reach').buffers(options)
      require('reach').switch_to_buffer(n, options)
      
    end,
  },
  {
    "axieax/urlview.nvim",
    config = function()
      
        vim.keymap.set("n", "\\u", "<Cmd>UrlView<CR>", { desc = "View buffer URLs" })
        vim.keymap.set("n", "\\U", "<Cmd>UrlView packer<CR>", { desc = "View Packer plugin URLs" })
        
      
      use("axieax/urlview.nvim")
      
      
      "axieax/urlview.nvim"
      
      
      require("urlview").setup({
        -- custom configuration options --
      })
      
    end,
  },
  {
    "cxwx/lazyUrlUpdate.nvim",
    config = function()
      
      {
          "cxwx/lazyUrlUpdate.nvim",
          ft = "lua",
          opts = {},
          keys = {
              {"<leader>up", "<cmd>LazyUrlUpdate<CR>", desc = "Update plugin under cursor"},
              {"<leader>bp", "<cmd>LazyUrlBuild<CR>", desc = "Build plugin under cursor"},
          }
      },
      
    end,
  },
  {
    "nkakouros-original/numbers.nvim",
    config = function()
      
      lua require('numbers').setup()
      
      
      {
        excluded_filetypes = {
          'nerdtree',
          'unite',
          -- etc
        }
      }
      
    end,
  },
  {
    "ghillb/cybu.nvim",
    config = function()
      
      use({
        "ghillb/cybu.nvim",
        branch = "main", -- timely updates
        -- branch = "v1.x", -- won't receive breaking changes
        requires = { "nvim-tree/nvim-web-devicons", "nvim-lua/plenary.nvim"}, -- optional for icon support
        config = function()
          local ok, cybu = pcall(require, "cybu")
          if not ok then
            return
          end
          cybu.setup()
          vim.keymap.set("n", "K", "<Plug>(CybuPrev)")
          vim.keymap.set("n", "J", "<Plug>(CybuNext)")
          vim.keymap.set({"n", "v"}, "<c-s-tab>", "<plug>(CybuLastusedPrev)")
          vim.keymap.set({"n", "v"}, "<c-tab>", "<plug>(CybuLastusedNext)")
        end,
      })
      
      
      require("cybu").setup()
      vim.keymap.set("n", "[b", "<Plug>(CybuPrev)")
      vim.keymap.set("n", "]b", "<Plug>(CybuNext)")
      vim.keymap.set("n", "<s-tab>", "<plug>(CybuLastusedPrev)")
      vim.keymap.set("n", "<tab>", "<plug>(CybuLastusedNext)")
      
      
      require("cybu").setup({
        position = {
          relative_to = "win",          -- win, editor, cursor
          anchor = "topcenter",         -- topleft, topcenter, topright,
                                          -- centerleft, center, centerright,
                                          -- bottomleft, bottomcenter, bottomright
          vertical_offset = 10,         -- vertical offset from anchor in lines
          horizontal_offset = 0,        -- vertical offset from anchor in columns
          max_win_height = 5,           -- height of cybu window in lines
          max_win_width = 0.5,          -- integer for absolute in columns
                                          -- float for relative to win/editor width
        },
        style = {
          path = "relative",            -- absolute, relative, tail (filename only),
                                          -- tail_dir (filename & parent dir)
          path_abbreviation = "none",   -- none, shortened
          border = "rounded",           -- single, double, rounded, none
          separator = " ",              -- string used as separator
          prefix = "…",                 -- string used as prefix for truncated paths
          padding = 1,                  -- left & right padding in number of spaces
          hide_buffer_id = true,        -- hide buffer IDs in window
          devicons = {
            enabled = true,             -- enable or disable web dev icons
            colored = true,             -- enable color for web dev icons
            truncate = true,            -- truncate wide icons to one char width
          },
          highlights = {                -- see highlights via :highlight
            current_buffer = "CybuFocus",       -- current / selected buffer
            adjacent_buffers = "CybuAdjacent",  -- buffers not in focus
            background = "CybuBackground",      -- window background
            border = "CybuBorder",              -- border of the window
          },
        },
        behavior = {                    -- set behavior for different modes
          mode = {
            default = {
              switch = "immediate",     -- immediate, on_close
              view = "rolling",         -- paging, rolling
            },
            last_used = {
              switch = "on_close",      -- immediate, on_close
              view = "paging",          -- paging, rolling
              update_on = "buf_enter",  -- buf_enter, cursor_moved
            },
            auto = {
              view = "rolling",         -- paging, rolling
            },
          },
          show_on_autocmd = false,      -- event to trigger cybu (eg. "BufEnter")
        },
        display_time = 750,             -- time the cybu window is displayed
        exclude = {                     -- filetypes, cybu will not be active
          "neo-tree",
          "fugitive",
          "qf",
        },
        filter = {
          unlisted = true,              -- filter & fallback for unlisted buffers
        },
        fallback = function() end,      -- arbitrary fallback function
                                          -- used in excluded filetypes
      })
      
      
      require("cybu").setup({
        behavior = {
          mode = {
            last_used = {
              update_on = "text_changed",
            }
          }
        }
      })
      
      
      require("cybu").setup({
        experimental = {
          buffer_provider = function()
            -- Return table of buffer objects: {{bufnr=1, filename="file.lua"}, ...}
            -- Logic to fetch buffers from your preferred source
            return custom_buffer_list
          end
        }
      })
      
    end,
  },
  {
    "sontungexpt/url-open",
    config = function()
      
      -- lazy.nvim
      {
          "sontungexpt/url-open",
          event = "VeryLazy",
          cmd = "URLOpenUnderCursor",
          config = function()
              local status_ok, url_open = pcall(require, "url-open")
              if not status_ok then
                  return
              end
              url_open.setup ({})
          end,
      },
      
      
      -- lazy.nvim
      {
          "sontungexpt/url-open",
          branch = "mini",
          event = "VeryLazy",
          cmd = "URLOpenUnderCursor",
          config = function()
              local status_ok, url_open = pcall(require, "url-open")
              if not status_ok then
                  return
              end
              url_open.setup ({})
          end,
      },
      
      
      -- default values
      require("url-open").setup({
          -- default will open url with default browser of your system or you can choose your browser like this
          -- open_app = "micorsoft-edge-stable",
          -- google-chrome, firefox, micorsoft-edge-stable, opera, brave, vivaldi
          open_app = "default",
          -- If true, only open the URL when the cursor is in the middle of the URL.
          -- If false, open the next URL found from the cursor position,
          -- which means you can open a URL even when the cursor is in front of the URL or in the middle of the URL.
          open_only_when_cursor_on_url = false,
          highlight_url = {
              all_urls = {
                  enabled = false,
                  fg = "#21d5ff", -- "text" or "#rrggbb"
                  -- fg = "text", -- text will set underline same color with text
                  bg = nil, -- nil or "#rrggbb"
                  underline = true,
              },
              cursor_move = {
                  enabled = true,
                  fg = "#199eff", -- "text" or "#rrggbb"
                  -- fg = "text", -- text will set underline same color with text
                  bg = nil, -- nil or "#rrggbb"
                  underline = true,
              },
          },
          deep_pattern = false,
          -- a list of patterns to open url under cursor
          extra_patterns = {
              -- {
              -- 	  pattern = '["]([^%s]*)["]:%s*"[^"]*%d[%d%.]*"',
              -- 	  prefix = "https://www.npmjs.com/package/",
              -- 	  suffix = "",
              -- 	  file_patterns = { "package%.json" },
              -- 	  excluded_file_patterns = nil,
              -- 	  extra_condition = function(pattern_found)
              -- 	    return not vim.tbl_contains({ "version", "proxy" }, pattern_found)
              -- 	  end,
              -- },
      		-- so the url will be https://www.npmjs.com/package/[pattern_found]
      
      
              -- {
              -- 	  pattern = '["]([^%s]*)["]:%s*"[^"]*%d[%d%.]*"',
              -- 	  prefix = "https://www.npmjs.com/package/",
              -- 	  suffix = "/issues",
              -- 	  file_patterns = { "package%.json" },
              -- 	  excluded_file_patterns = nil,
              -- 	  extra_condition = function(pattern_found)
              -- 	    return not vim.tbl_contains({ "version", "proxy" }, pattern_found)
              -- 	  end,
              -- },
      		--
      		-- so the url will be https://www.npmjs.com/package/[pattern_found]/issues
          },
      })
      
      
      vim.keymap.set("n", "gx", "<esc>:URLOpenUnderCursor<cr>")
      
    end,
  },
  {
    "crusj/bookmarks.nvim",
    config = function()
      
      require("bookmarks.list").load{
          filename = '/Users/crusj/Project/bookmarks.nvim/README.md',
          description = 'readme',
          fre = 3,
          id = '429b65925c650553dfcc8576231837a2',
          line = 2,
          updated_at = 1651588531,
      }
      require("bookmarks.list").load{
          filename = '/Users/crusj/Project/bookmarks.nvim/lua/bookmarks/config.lua',
          description = 'keymap',
          fre = 11,
          id = 'a22afa41979db45c6a8215cb7df6304f',
          line = 6,
          updated_at = 1651588572,
      }
      require("bookmarks.list").load{
          filename = '/Users/crusj/Project/bookmarks.nvim/lua/bookmarks/event.lua',
          description = 'add keymap',
          fre = 5,
          id = 'a2e79c4b86b533f43fe3aa5a545a5073',
          line = 10,
          updated_at = 1651580490,
      }
      
      
      {
          'crusj/bookmarks.nvim',
          branch = 'main',
          requires = { 'kyazdani42/nvim-web-devicons' },
          config = function()
              require("bookmarks").setup()
             	require("telescope").load_extension("bookmarks")
          end
      }
      
      
      {
          'crusj/bookmarks.nvim',
          keys = {
              { "<tab><tab>", mode = { "n" } },
          },
          branch = 'main',
          dependencies = { 'nvim-web-devicons' },
          config = function()
              require("bookmarks").setup()
              require("telescope").load_extension("bookmarks")
          end
      }
      
      
      
      
      require("bookmarks").setup({
          storage_dir = "",  -- Default path: vim.fn.stdpath("data").."/bookmarks,  if not the default directory, should be absolute path",
          mappings_enabled = true, -- If the value is false, only valid for global keymaps: toggle、add、delete_on_virt、show_desc
          keymap = {
              toggle = "<tab><tab>", -- Toggle bookmarks(global keymap)
              close = "q", -- close bookmarks (buf keymap)
              add = "\\z", -- Add bookmarks(global keymap)
              add_global = "\\g" -- Add global bookmarks(global keymap), global bookmarks will appear in all projects. Identified with the symbol '󰯾'
              jump = "<CR>", -- Jump from bookmarks(buf keymap)
              delete = "dd", -- Delete bookmarks(buf keymap)
              order = "<space><space>", -- Order bookmarks by frequency or updated_time(buf keymap)
              delete_on_virt = "\\dd", -- Delete bookmark at virt text line(global keymap)
              show_desc = "\\sd", -- show bookmark desc(global keymap)
              focus_tags = "<c-j>",      -- focus tags window
              focus_bookmarks = "<c-k>", -- focus bookmarks window
              toogle_focus = "<S-Tab>", -- toggle window focus (tags-window <-> bookmarks-window)
          },
          width = 0.8, -- Bookmarks window width:  (0, 1]
          height = 0.7, -- Bookmarks window height: (0, 1]
          preview_ratio = 0.45, -- Bookmarks preview window ratio (0, 1]
          tags_ratio = 0.1, -- Bookmarks tags window ratio
          fix_enable = false, -- If true, when saving the current file, if the bookmark line number of the current file changes, try to fix it.
      
          virt_text = "", -- Show virt text at the end of bookmarked lines, if it is empty, use the description of bookmarks instead.
          sign_icon = "󰃃",                                           -- if it is not empty, show icon in signColumn.
          virt_pattern = { "*.go", "*.lua", "*.sh", "*.php", "*.rs" }, -- Show virt text only on matched pattern
          virt_ignore_pattern = {}, -- Ignore showing virt text on matched pattern, this works after virt_pattern
          border_style = "single", -- border style: "single", "double", "rounded" 
          hl = {
              border = "TelescopeBorder", -- border highlight
              cursorline = "guibg=Gray guifg=White", -- cursorline highlight
          },
          datetime_format = "%Y-%m-%d %H:%M:%S", -- os.date
          -- •	%Y: Four-digit year
          -- •	%m: Two-digit month (01 to 12)
          -- •	%d: Two-digit day (01 to 31)
          -- •	%H: Hour in 24-hour format (00 to 23)
          -- •	%I: Hour in 12-hour format (01 to 12)
          -- •	%M: Two-digit minute (00 to 59)
          -- •	%S: Two-digit second (00 to 59)
          -- •	%p: AM/PM indicator
      })
      
    end,
  },
  {
    "xiyaowong/virtcolumn.nvim",
    config = function()
      
      vim.g.virtcolumn_char = '▕' -- char to display the line
      vim.g.virtcolumn_priority = 10 -- priority of extmark
      
    end,
  },
  {
    "m-demare/attempt.nvim",
    config = function()
      
      return {
          'm-demare/attempt.nvim', -- No need to specify plenary as dependency
      }
      
      
      use {
        'm-demare/attempt.nvim',
        requires = 'nvim-lua/plenary.nvim',
      }
      
      -- Optional
      use {
        { 'nvim-telescope/telescope.nvim' },
        { 'nvim-telescope/telescope-ui-select.nvim' }
      }
      
      
      require('attempt').setup()
      
      
      require('attempt').setup{
        dir = (unix and '/tmp/' or vim.fn.expand '$TEMP\\') .. 'attempt.nvim' .. path_separator,
        autosave = false,
        list_buffers = false,     -- This will make them show on other pickers (like :Telescope buffers)
        initial_content = {
          py = initial_content_fn, -- Either string or function that returns the initial content
          c = initial_content_fn,
          cpp = initial_content_fn,
          java = initial_content_fn,
          rs = initial_content_fn,
          go = initial_content_fn,
          sh = initial_content_fn
        },
        ext_options = { 'lua', 'js', 'py', 'cpp', 'c', '' },  -- Options to choose from
        format_opts = { [''] = '[None]' },                    -- How they'll look
        run = {
          py = { 'w !python' },      -- Either table of strings or lua functions
          js = { 'w !node' },
          ts = { 'w !deno run -' },
          lua = { 'w' , 'luafile %' },
          sh = { 'w !bash' },
          pl = { 'w !perl' },
          cpp = { 'w' , '!'.. cpp_compiler ..' %:p -o %:p:r.out && echo "" && %:p:r.out && rm %:p:r.out '},
          c = { 'w' , '!'.. c_compiler ..' %:p -o %:p:r.out && echo "" && %:p:r.out && rm %:p:r.out'},
        }
      }
      -- (You may omit the settings whose defaults you're ok with)
      
      
      require('telescope').load_extension 'attempt'
      
      
      vim.keymap.set('n', '<leader>al', require('attempt.snacks').picker)
      
      
      local attempt = require('attempt')
      local map = vim.keymap.set
      
      map('n', '<leader>an', attempt.new_select)        -- new attempt, selecting extension
      map('n', '<leader>ai', attempt.new_input_ext)     -- new attempt, inputing extension
      map('n', '<leader>ar', attempt.run)               -- run attempt
      map('n', '<leader>ad', attempt.delete_buf)        -- delete attempt from current buffer
      map('n', '<leader>ac', attempt.rename_buf)        -- rename attempt from current buffer
      map('n', '<leader>al', 'Telescope attempt')       -- search through attempts
      --or: map('n', '<leader>al', require('attempt.snacks').picker)
      --or: map('n', '<leader>al', attempt.open_select) -- use ui.select instead of telescope/snacks.nvim
      
    end,
  },
  {
    "kevinhwang91/nvim-ufo",
    config = function()
      
      use {'kevinhwang91/nvim-ufo', requires = 'kevinhwang91/promise-async'}
      
      
      use {'kevinhwang91/nvim-ufo', requires = 'kevinhwang91/promise-async'}
      
      vim.o.foldcolumn = '1' -- '0' is not bad
      vim.o.foldlevel = 99 -- Using ufo provider need a large value, feel free to decrease the value
      vim.o.foldlevelstart = 99
      vim.o.foldenable = true
      
      -- Using ufo provider need remap `zR` and `zM`. If Neovim is 0.6.1, remap yourself
      vim.keymap.set('n', 'zR', require('ufo').openAllFolds)
      vim.keymap.set('n', 'zM', require('ufo').closeAllFolds)
      
      -- Option 1: coc.nvim as LSP client
      use {'neoclide/coc.nvim', branch = 'master', run = 'yarn install --frozen-lockfile'}
      require('ufo').setup()
      --
      
      -- Option 2: nvim lsp as LSP client
      -- Tell the server the capability of foldingRange,
      -- Neovim hasn't added foldingRange to default capabilities, users must add it manually
      local capabilities = vim.lsp.protocol.make_client_capabilities()
      capabilities.textDocument.foldingRange = {
          dynamicRegistration = false,
          lineFoldingOnly = true
      }
      local language_servers = vim.lsp.get_clients() -- or list servers manually like {'gopls', 'clangd'}
      for _, ls in ipairs(language_servers) do
          require('lspconfig')[ls].setup({
              capabilities = capabilities
              -- you can add other fields for setting up lsp server in this table
          })
      end
      require('ufo').setup()
      --
      
      -- Option 3: treesitter as a main provider instead
      -- (Note: the `nvim-treesitter` plugin is *not* needed.)
      -- ufo uses the same query files for folding (queries/<lang>/folds.scm)
      -- performance and stability are better than `foldmethod=nvim_treesitter#foldexpr()`
      require('ufo').setup({
          provider_selector = function(bufnr, filetype, buftype)
              return {'treesitter', 'indent'}
          end
      })
      --
      
      -- Option 4: disable all providers for all buffers
      -- Not recommend, AFAIK, the ufo's providers are the best performance in Neovim
      require('ufo').setup({
          provider_selector = function(bufnr, filetype, buftype)
              return ''
          end
      })
      
      
      {
          open_fold_hl_timeout = {
              description = [[Time in millisecond between the range to be highlgihted and to be cleared
                          while opening the folded line, `0` value will disable the highlight]],
              default = 400
          },
          provider_selector = {
              description = [[A function as a selector for fold providers. For now, there are
                          'lsp' and 'treesitter' as main provider, 'indent' as fallback provider]],
              default = nil
          },
          close_fold_kinds_for_ft = {
              description = [[After the buffer is displayed (opened for the first time), close the
                          folds whose range with `kind` field is included in this option. For now,
                          'lsp' provider's standardized kinds are 'comment', 'imports' and 'region',
                          and the 'treesitter' provider exposes the underlying node types.
                          This option is a table with filetype as key and fold kinds as value. Use a
                          default value if value of filetype is absent.
                          Run `UfoInspect` for details if your provider has extended the kinds.]],
              default = {default = {}}
          },
          close_fold_current_line_for_ft = {
              description = [[Whether to close folds on the current line when the buffer is first
                          displayed.
                          This option is a table with filetype as key and boolean as value. Use a
                          default value if value of filetype is absent.
                          ]],
              default = {default = false}
          },
          fold_virt_text_handler = {
              description = [[A function customize fold virt text, see ### Customize fold text]],
              default = nil
          },
          enable_get_fold_virt_text = {
              description = [[Enable a function with `lnum` as a parameter to capture the virtual text
                          for the folded lines and export the function to `get_fold_virt_text` field of
                          ctx table as 6th parameter in `fold_virt_text_handler`]],
              default = false
          },
          preview = {
              description = [[Configure the options for preview window and remap the keys for current
                          buffer and preview buffer if the preview window is displayed.
                          Never worry about the users's keymaps are overridden by ufo, ufo will save
                          them and restore them if preview window is closed.]],
              win_config = {
                  border = {
                      description = [[The border for preview window,
                          `:h nvim_open_win() | call search('border:')`]],
                      default = 'rounded',
                  },
                  winblend = {
                      description = [[The winblend for preview window, `:h winblend`]],
                      default = 12,
                  },
                  winhighlight = {
                      description = [[The winhighlight for preview window, `:h winhighlight`]],
                      default = 'Normal:Normal',
                  },
                  maxheight = {
                      description = [[The max height of preview window]],
                      default = 20,
                  }
              },
              mappings = {
                  description = [[The table for {function = key}]],
                  default = [[see ###Preview function table for detail]],
              }
          }
      }
      
      
      local ftMap = {
          vim = 'indent',
          python = {'indent'},
          git = ''
      }
      require('ufo').setup({
          open_fold_hl_timeout = 150,
          close_fold_kinds_for_ft = {
              default = {'imports', 'comment'},
              json = {'array'},
              c = {'comment', 'region'}
          },
          close_fold_current_line_for_ft = {
              default = true,
              c = false
          },
          preview = {
              win_config = {
                  border = {'', '─', '', '', '', '─', '', ''},
                  winhighlight = 'Normal:Folded',
                  winblend = 0
              },
              mappings = {
                  scrollU = '<C-u>',
                  scrollD = '<C-d>',
                  jumpTop = '[',
                  jumpBot = ']'
              }
          },
          provider_selector = function(bufnr, filetype, buftype)
              -- if you prefer treesitter provider rather than lsp,
              -- return ftMap[filetype] or {'treesitter', 'indent'}
              return ftMap[filetype]
      
              -- refer to ./doc/example.lua for detail
          end
      })
      vim.keymap.set('n', 'zR', require('ufo').openAllFolds)
      vim.keymap.set('n', 'zM', require('ufo').closeAllFolds)
      vim.keymap.set('n', 'zr', require('ufo').openFoldsExceptKinds)
      vim.keymap.set('n', 'zm', require('ufo').closeFoldsWith) -- closeAllFolds == closeFoldsWith(0)
      vim.keymap.set('n', 'K', function()
          local winid = require('ufo').peekFoldedLinesUnderCursor()
          if not winid then
              -- choose one of coc.nvim and nvim lsp
              vim.fn.CocActionAsync('definitionHover') -- coc.nvim
              vim.lsp.buf.hover()
          end
      end)
      
      
      local handler = function(virtText, lnum, endLnum, width, truncate)
          local newVirtText = {}
          local suffix = (' 󰁂 %d '):format(endLnum - lnum)
          local sufWidth = vim.fn.strdisplaywidth(suffix)
          local targetWidth = width - sufWidth
          local curWidth = 0
          for _, chunk in ipairs(virtText) do
              local chunkText = chunk[1]
              local chunkWidth = vim.fn.strdisplaywidth(chunkText)
              if targetWidth > curWidth + chunkWidth then
                  table.insert(newVirtText, chunk)
              else
                  chunkText = truncate(chunkText, targetWidth - curWidth)
                  local hlGroup = chunk[2]
                  table.insert(newVirtText, {chunkText, hlGroup})
                  chunkWidth = vim.fn.strdisplaywidth(chunkText)
                  -- str width returned from truncate() may less than 2nd argument, need padding
                  if curWidth + chunkWidth < targetWidth then
                      suffix = suffix .. (' '):rep(targetWidth - curWidth - chunkWidth)
                  end
                  break
              end
              curWidth = curWidth + chunkWidth
          end
          table.insert(newVirtText, {suffix, 'MoreMsg'})
          return newVirtText
      end
      
      -- global handler
      -- `handler` is the 2nd parameter of `setFoldVirtTextHandler`,
      -- check out `./lua/ufo.lua` and search `setFoldVirtTextHandler` for detail.
      require('ufo').setup({
          fold_virt_text_handler = handler
      })
      
      -- buffer scope handler
      -- will override global handler if it is existed
      -- local bufnr = vim.api.nvim_get_current_buf()
      -- require('ufo').setFoldVirtTextHandler(bufnr, handler)
      
    end,
  },
  {
    "xiyaowong/link-visitor.nvim",
    config = function()
      
      require("link-visitor").setup({
        open_cmd = nil,
        --[[
        1. cmd to open url
          defaults:
            win or wsl: cmd.exe /c start
            mac: open
            linux: xdg-open
        2. a function to handle the link
          the function signature: func(link: string)
        --]]
        silent = true, -- disable all prints, `false` by defaults skip_confirmation
        skip_confirmation = false, -- Skip the confirmation step, default: false
        border = "rounded" -- none, single, double, rounded, solid, shadow see `:h nvim_open_win()`
      })
      
      
      local lv = require 'link-visitor'
      
      lv.links_in_buffer(bufnr?) -- Open links in the buffer, current buffer by default
      lv.link_under_cursor() -- Open link under the cursor(search in current line)
      lv.link_near_cursor() -- Open link near the cursor(search in current line)
      lv.link_nearest() -- Open the nearest link to the current position(Search in the whole buffer)
      lv.visit(url) -- Open the url
      
      
      vim.api.nvim_create_autocmd("User", {
      	callback = function()
      		local ok, buf = pcall(vim.api.nvim_win_get_buf, vim.g.coc_last_float_win)
      		if ok then
      			vim.keymap.set("n", "K", function()
      				require("link-visitor").link_under_cursor()
      			end, { buffer = buf })
      			vim.keymap.set("n", "L", function()
      				require("link-visitor").link_near_cursor()
      			end, { buffer = buf })
      		end
      	end,
      	pattern = "CocOpenFloat",
      })
      
    end,
  },
  {
    "sitiom/nvim-numbertoggle",
    config = function()
      
      use { "sitiom/nvim-numbertoggle" }
      
    end,
  },
  {
    "anuvyklack/fold-preview.nvim",
    config = function()
      
      use { 'anuvyklack/fold-preview.nvim',
         requires = 'anuvyklack/keymap-amend.nvim',
         config = function()
            require('fold-preview').setup({
               -- Your configuration goes here.
            })
         end
      }
      
      
      require('fold-preview').mapping
      
      
      local keymap = vim.keymap
      keymap.amend = require('keymap-amend')
      local map = require('fold-preview').mapping
      
      keymap.amend('n', 'h',  map.show_close_preview_open_fold)
      keymap.amend('n', 'l',  map.close_preview_open_fold)
      keymap.amend('n', 'zo', map.close_preview)
      keymap.amend('n', 'zO', map.close_preview)
      keymap.amend('n', 'zc', map.close_preview_without_defer)
      keymap.amend('n', 'zR', map.close_preview)
      keymap.amend('n', 'zM', map.close_preview_without_defer)
      
      
      use { 'anuvyklack/fold-preview.nvim',
         requires = 'anuvyklack/keymap-amend.nvim',
         config = function()
            local fp = require('fold-preview')
            local map = require('fold-preview').mapping
            local keymap = vim.keymap
            keymap.amend = require('keymap-amend')
      
            fp.setup({ 
               default_keybindings = false
               -- another settings
            })
      
            keymap.amend('n', 'K', function(original)
               if not fp.show_preview() then original() end
               -- or
               -- if not fp.toggle_preview() then original() end
               -- to close preview on second press on K.
            end)
            keymap.amend('n', 'h',  map.close_preview_open_fold)
            keymap.amend('n', 'l',  map.close_preview_open_fold)
            keymap.amend('n', 'zo', map.close_preview)
            keymap.amend('n', 'zO', map.close_preview)
            keymap.amend('n', 'zc', map.close_preview_without_defer)
            keymap.amend('n', 'zR', map.close_preview)
            keymap.amend('n', 'zM', map.close_preview_without_defer)
         end
      }
      
    end,
  },
  {
    "nguyenvukhang/nvim-toggler",
    config = function()
      
      use { 'nguyenvukhang/nvim-toggler' }
      
      
      -- init.lua
      require('nvim-toggler').setup()
      
      
      -- init.lua
      require('nvim-toggler').setup({
        -- your own inverses
        inverses = {
          ['vim'] = 'emacs'
        },
        -- removes the default <leader>i keymap
        remove_default_keybinds = true,
        -- removes the default set of inverses
        remove_default_inverses = true,
        -- auto-selects the longest match when there are multiple matches
        autoselect_longest_match = false
      })
      
      
      -- init.lua
      vim.keymap.set({ 'n', 'v' }, '<leader>cl', require('nvim-toggler').toggle)
      
    end,
  },
  {
    "CosmicNvim/cosmic-ui",
  },
  {
    "AckslD/messages.nvim",
    config = function()
      
      use {
        'AckslD/messages.nvim',
        config = 'require("messages").setup()',
      }
      
      
      Msg = function(...)
        require('messages.api').capture_thing(...)
      end
      
      
      require('messages').setup({
        command_name = 'Messages',
        -- should prepare a new buffer and return the winid
        -- by default opens a floating window
        -- provide a different callback to change this behaviour
        -- @param opts: the return value from float_opts
        prepare_buffer = function(opts)
          local buf = vim.api.nvim_create_buf(false, true)
          return vim.api.nvim_open_win(buf, true, opts)
        end,
        -- should return options passed to prepare_buffer
        -- @param lines: a list of the lines of text
        buffer_opts = function(lines)
          local gheight = vim.api.nvim_list_uis()[1].height
          local gwidth = vim.api.nvim_list_uis()[1].width
          return {
            relative = 'editor',
            width = gwidth - 2,
            height = clip_val(1, #lines, gheight * 0.5),
            anchor = 'SW',
            row = gheight - 1,
            col = 0,
            style = 'minimal',
            border = 'rounded',
            zindex = 1,
          }
        end,
        -- what to do after opening the float
        post_open_float = function(winnr)
        end
      })
      
    end,
  },
  {
    "jbyuki/instant.nvim",
  },
  {
    "numToStr/BufOnly.nvim",
    config = function()
      
      use { "numtostr/BufOnly.nvim", "cmd": "BufOnly" }
      
      
      vim.g.bufonly_delete_non_modifiable = true
      
      
      vim.fn.nvim_set_keymap('n', '<leader>x', ':BufOnly<CR>', { noremap = true, silent = true })
      
    end,
  },
  {
    "zbirenbaum/neodim",
    config = function()
      
      {
        "zbirenbaum/neodim",
        event = "LspAttach",
        config = function()
          require("neodim").setup()
        end,
      }
      
      
      require("neodim").setup({
        alpha = 0.75,
        blend_color = nil,
        hide = {
          underline = true,
          virtual_text = true,
          signs = true,
        },
        regex = {
          "[uU]nused",
          "[nN]ever [rR]ead",
          "[nN]ot [rR]ead",
        },
        priority = 128,
        disable = {},
      })
      
      
      require("neodim").setup({
        alpha = 0.5 -- make the dimmed text even dimmer
      })
      
      
      require("neodim").setup({
        blend_color = "#10171f"
      })
      
      
        require("neodim").setup({
          regex = {
            "[Uu]nused",
            cs = {
              "CS8019",
            },
            -- disable `regex` option when filetype is "rust"
            rust = {},
          }
        })
      
      
      -- re-enable only sign decorations for 'unused' diagnostics
      require("neodim").setup({
        hide = { signs = false }
      })
      
      
      -- re-enable all decorations for 'unused' diagnostics
      require("neodim").setup({
        hide = {
          virtual_text = false,
          signs = false,
          underline = false,
        }
      })
      
    end,
  },
  {
    "bfredl/nvim-miniyank",
  },
  {
    "chrisgrieser/nvim-genghis",
    config = function()
      
      -- lazy.nvim
      { "chrisgrieser/nvim-genghis" }
      
      -- packer
      use { "chrisgrieser/nvim-genghis" }
      
      
      -- default config
      require("genghis").setup {
      	trashCmd = function() ---@type fun(): string|string[]
      		if jit.os == "OSX" then return "trash" end -- builtin since macOS 14
      		if jit.os == "Windows" then return "trash" end
      		if jit.os == "Linux" then return { "gio", "trash" } end
      		return "trash-cli"
      	end,
      
      	fileOperations = {
      		-- automatically keep the extension when no file extension is given
      		-- (everything after the first non-leading dot is treated as the extension)
      		autoAddExt = true,
      	},
      
      	navigation = {
      		onlySameExtAsCurrentFile = false,
      		ignoreDotfiles = true,
      		ignoreExt = { "png", "svg", "webp", "jpg", "jpeg", "gif", "pdf", "zip" },
      		ignoreFilesWithName = { ".DS_Store" },
      	},
      
      	successNotifications = true,
      
      	icons = { -- set an icon to empty string to disable it
      		chmodx = "󰒃",
      		copyFile = "󱉥",
      		copyPath = "󰅍",
      		duplicate = "",
      		file = "󰈔",
      		move = "󰪹",
      		new = "󰝒",
      		nextFile = "󰖽",
      		prevFile = "󰖿",
      		rename = "󰑕",
      		trash = "󰩹",
      	},
      }
      
      
      require("genghis").createNewFile()
      
    end,
  },
  {
    "chrisgrieser/nvim-recorder",
    config = function()
      
      -- lazy.nvim
      {
      	"chrisgrieser/nvim-recorder",
      	dependencies = "rcarriga/nvim-notify", -- optional
      	opts = {}, -- required even with default settings, since it calls `setup()`
      },
      
      -- packer
      use {
      	"chrisgrieser/nvim-recorder",
      	requires = "rcarriga/nvim-notify", -- optional
      	config = function() require("recorder").setup() end,
      }
      
      
      -- default values
      require("recorder").setup {
      	-- Named registers where macros are saved (single lowercase letters only).
      	-- The first register is the default register used as macro-slot after
      	-- startup.
      	slots = { "a", "b" },
      
          -- specify one of options: 
          -- [static]   -> use static slots, this is default behaviour
          -- [rotate]   -> rotates through letters specified in slots[]
          dynamicSlots = "static",
      
      	mapping = {
      		startStopRecording = "q",
      		playMacro = "Q",
      		switchSlot = "<C-q>",
      		editMacro = "cq",
      		deleteAllMacros = "dq",
      		yankMacro = "yq",
      		-- ⚠️ this should be a string you don't use in insert mode during a macro
      		addBreakPoint = "##",
      	},
      
      	-- Clears all macros-slots on startup.
      	clear = false,
      
      	-- Log level used for non-critical notifications; mostly relevant for nvim-notify.
      	-- (Note that by default, nvim-notify does not show the levels `trace` & `debug`.)
      	logLevel = vim.log.levels.INFO, -- :help vim.log.levels
      
      	-- If enabled, only essential notifications are sent.
      	-- If you do not use a plugin like nvim-notify, set this to `true`
      	-- to remove otherwise annoying messages.
      	lessNotifications = false,
      
      	-- Use nerdfont icons in the status bar components and keymap descriptions
      	useNerdfontIcons = true,
      
      	-- Performance optimizations for macros with high count. When `playMacro` is
      	-- triggered with a count higher than the threshold, nvim-recorder
      	-- temporarily changes changes some settings for the duration of the macro.
      	performanceOpts = {
      		countThreshold = 100,
      		lazyredraw = true, -- enable lazyredraw (see `:h lazyredraw`)
      		noSystemClipboard = true, -- remove `+`/`*` from clipboard option
      		autocmdEventsIgnore = { -- temporarily ignore these autocmd events
      			"TextChangedI",
      			"TextChanged",
      			"InsertLeave",
      			"InsertEnter",
      			"InsertCharPre",
      		},
      	},
      
      	-- [experimental] partially share keymaps with nvim-dap.
      	-- (See README for further explanations.)
      	dapSharedKeymaps = false,
      }
      
      
      -- Indicates whether you are currently recording. Useful if you are using
      -- `cmdheight=0`, where recording-status is not visible.
      require("recorder").recordingStatus()
      
      -- Displays non-empty macro-slots (registers) and indicates the selected ones.
      -- Only displayed when *not* recording. Slots with breakpoints get an extra `#`.
      require("recorder").displaySlots()
      
      
      lualine_y = {
      	{ require("recorder").displaySlots },
      },
      lualine_z = {
      	{ require("recorder").recordingStatus },
      },
      
      
      -- minimal config for lazy-loading with lazy.nvim
      {
      	"chrisgrieser/nvim-recorder",
      	dependencies = "rcarriga/nvim-notify",
      	keys = {
      		-- these must match the keys in the mapping config below
      		{ "q", desc = " Start Recording" },
      		{ "Q", desc = " Play Recording" },
      	},
      	config = function()
      		require("recorder").setup({
      			mapping = {
      				startStopRecording = "q",
      				playMacro = "Q",
      			},
      		})
      
      			local lualineZ = require("lualine").get_config().sections.lualine_z or {}
      			local lualineY = require("lualine").get_config().sections.lualine_y or {}
      			table.insert(lualineZ, { require("recorder").recordingStatus })
      			table.insert(lualineY, { require("recorder").displaySlots })
      
      			require("lualine").setup {
      				tabline = {
      					lualine_y = lualineY,
      					lualine_z = lualineZ,
      				},
      			}
      	end,
      },
      
    end,
  },
  {
    "figsoda/nix-develop.nvim",
  },
  {
    "yaocccc/nvim-foldsign",
    config = function()
      
          require('nvim-foldsign').setup({
              offset = -2,
              foldsigns = {
                  open = '-',          -- mark the beginning of a fold
                  close = '+',         -- show a closed fold
                  seps = { '│', '┃' }, -- open fold middle marker
              },
              enabled = true,
          })
      
      
      vim.keymap.set('n', '<leader>tf', require('nvim-foldsign').toggle_foldsign )
      
    end,
  },
  {
    "tenxsoydev/nx.nvim",
    config = function()
      
      vim.keymap.set('n', ';w', "<Cmd>w<CR>")
      vim.keymap.set('n', ';q', "<Cmd>w<CR>", { desc = "Close Current Window" })
      vim.keymap.set('', "j", "&wrap ? 'gj' : 'j'", { expr = true, silent = true })
      vim.keymap.set('', "<Down>", "&wrap ? 'gj' : 'j'", { expr = true, silent = true })
      
      -- Can be written as
      nx.map({
         { ";w", "<Cmd>w<CR>" },
         { ";q", "<Cmd>confirm quit<CR>", desc = "Close Current Window" },
         { { "j", "<Down>" }, "&wrap ? 'gj' : 'j'", "", expr = true, silent = true },
      })
      
      
      -- Options like filetype and wk_label are not directly supported by vim.keymap.set
      nx.map({
         { "<leader>ts", "<Cmd>set spell!<CR>", desc = "Toggle Spellcheck", wk_label = "Spellcheck" },
         { "<leader>tp", "<Cmd>MarkdownPreviewToggle<CR>", ft = "markdown", desc = "Toggle Markdown Preview" },
      })
      -- Wrapper options
      nx.map({
         -- Line Navigation
         { { "j", "<Down>" }, "&wrap ? 'gj' : 'j'", "" },
         { { "k", "<Up>" }, "&wrap ? 'gk' : 'k'", "" },
         { "$", "&wrap ? 'g$' : '$'", "" },
         { "^", "&wrap ? 'g^' : '^'", "" },
         -- Enter insert mode at indentation level on empty lines
         { "i", "len(getline('.')) == 0 ? '\"_cc' : 'i'"  },
         }, { expr = true, silent = true })
      })
      
      
        nx.map({ ";q", "<Cmd>confirm quit<CR>", desc = "Close Current Window" })
        ---@ ╰── set a single keymap
        ---@ ╭── or lists of keymaps
        nx.map({
           -- Line Navigation
           ---@    ╭── multiple lhs
           { { "j", "<Up>" }, "&wrap ? 'gj' : 'j'", "" },
           { { "k", "<Down>" }, "&wrap ? 'gk' : 'k'", "" },
           { "$", "&wrap ? 'g$' : '$'", "" },
           { "^", "&wrap ? 'g^' : '^'", "" },
           -- Indentation
           { "i", function() return smart_indent "i" end },
           { "a", function() return smart_indent "a" end },
           { "A", function() return smart_indent "A" end },
           }, { expr = true, silent = true })
        ---@      ╰── wrapper opts apply options to all entries
      
        nx.map({
           { "<Esc>", "<Esc>", "i" },
           { "<C-c>", "<Cmd>close<CR>", { "i", "x" } },
           { "q", "<Cmd>close<CR>", "x" },
           ---@ set filetype keymaps ──╮ (in {wrapper_opts} or for single keymaps)
        }, { buffer = 0, ft = "DressingInput" })
        
      
        nx.map({
        { "<kEnter>", "<CR>", { "", "!" }, desc = "Enter" }
        ---@ ^=                      ╰── or  ──╮
        { "<kEnter>", "<CR>", desc = "Enter", mode = { "", "!" } }
        }, { mode = { "", "!" }) -- or in wrapper_opts (here it has to be the `mode` key)
        
      
        ---@ reference using the default vim.keymap.set
      
        local opts = { noremap=true, silent=true }
        vim.keymap.set('n', '<space>e', vim.diagnostic.open_float, opts)
        vim.keymap.set('n', '[d', vim.diagnostic.goto_prev, opts)
        vim.keymap.set('n', ']d', vim.diagnostic.goto_next, opts)
        vim.keymap.set('n', '<space>q', vim.diagnostic.setloclist, opts)
      
        local on_attach = function(client, bufnr)
           local bufopts = { noremap=true, silent=true, buffer=bufnr }
           vim.keymap.set('n', 'gD', vim.lsp.buf.declaration, bufopts)
           vim.keymap.set('n', 'gd', vim.lsp.buf.definition, bufopts)
           vim.keymap.set('n', 'K', vim.lsp.buf.hover, bufopts)
           vim.keymap.set('n', 'gi', vim.lsp.buf.implementation, bufopts)
           vim.keymap.set('n', '<C-k>', vim.lsp.buf.signature_help, bufopts)
           vim.keymap.set('n', '<space>wa', vim.lsp.buf.add_workspace_folder, bufopts)
           vim.keymap.set('n', '<space>wr', vim.lsp.buf.remove_workspace_folder, bufopts)
           vim.keymap.set('n', '<space>wl', function()
              print(vim.inspect(vim.lsp.buf.list_workspace_folders()))
           end, bufopts)
           vim.keymap.set('n', '<space>D', vim.lsp.buf.type_definition, bufopts)
           vim.keymap.set('n', '<space>rn', vim.lsp.buf.rename, bufopts)
           vim.keymap.set('n', '<space>ca', vim.lsp.buf.code_action, bufopts)
           vim.keymap.set('n', 'gr', vim.lsp.buf.references, bufopts)
           vim.keymap.set('n', '<space>f', function() vim.lsp.buf.format { async = true } end, bufopts)
        end
        
      
        ---@ nx.map
      
        nx.map({
           { "<space>e", vim.diagnostic.open_float },
           { "[d", vim.diagnostic.goto_prev },
           { "]d", vim.diagnostic.goto_next },
           { "<space>q", vim.diagnostic.setloclist },
        }, { noremap = true, silent = true })
      
        local on_attach = function(client, bufnr)
           nx.map({
              { "gD", vim.lsp.buf.declaration },
              { "gd", vim.lsp.buf.definition },
              { "K", vim.lsp.buf.hover },
              { "gi", vim.lsp.buf.implementation },
              { "<C-k>", vim.lsp.buf.signature_help },
              { "<space>wa", vim.lsp.buf.add_workspace_folder },
              { "<space>wr", vim.lsp.buf.remove_workspace_folder },
              { "<space>wl", function() print(vim.inspect(vim.lsp.buf.list_workspace_folders())) end },
              { "<space>D", vim.lsp.buf.type_definition },
              { "<space>rn", vim.lsp.buf.rename },
              { "<space>ca", vim.lsp.buf.code_action },
              { "gr", vim.lsp.buf.references },
              { "<space>f", function() vim.lsp.buf.format { async = true } end },
           }, { noremap = true, silent = true, buffer = bufnr })
        end
        
      
        ---@ method 1: a custom `wk_label` per key
        nx.map({
           { "<leader>Rc", "<Cmd>SnipClose<CR>", desc = "Close SnipRun", wk_label = "Close" },
           { "<leader>Rf", "<Cmd>%SnipRun<CR>", desc = "Run File" },
           { "<leader>Ri", "<Cmd>SnipInfo<CR>", desc = "SnipRun Info", wk_label = "Info" },
           { "<leader>Rm", "<Cmd>SnipReplMemoryClean<CR>", desc = "SnipRun Clean Memory", wk_label = "Clean Memory" },
           { "<leader>Rr", "<Cmd>SnipReset<CR>", desc = "Reset SnipRun", wk_label = "Reset" },
           { "<leader>Rx", "<Cmd>SnipTerminate<CR>", desc = "Terminate SnipRun", wk_label = "Terminate" },
           { "<leader>R", "<Esc><Cmd>'<,'>SnipRun<CR>", "v", desc = "SnipRun Range", wk_label = "Run Range" },
        })
      
        ---@ method 2: use `sub_desc` in `wrapper_opts` to remove `SnipRun` from all entries
        nx.map({
           { "<leader>Rc", "<Cmd>SnipClose<CR>", desc = "Close SnipRun" },
           { "<leader>Rf", "<Cmd>%SnipRun<CR>", desc = "Run File" },
           { "<leader>Ri", "<Cmd>SnipInfo<CR>", desc = "SnipRun Info" },
           { "<leader>Rm", "<Cmd>SnipReplMemoryClean<CR>", desc = "SnipRun Clean Memory" },
           { "<leader>Rr", "<Cmd>SnipReset<CR>", desc = "Reset SnipRun" },
           { "<leader>Rx", "<Cmd>SnipTerminate<CR>", desc = "Terminate SnipRun" },
           { "<leader>RR", "<Esc><Cmd>'<,'>SnipRun<CR>", "v", desc = "SnipRun Range" },
        }, { wk_label = { sub_desc = "SnipRun" } })
        
      
      nx.hl({
       { "LineNr", fg = "DraculaComment:fg" },
       { "Normal", bg = "DraculaBg:bg" },
       { "BgDarker", bg = palette.bg .. ":#b-15" },
       { "BufferLineSeparatorShadow", fg = "TabLine:bg:#b-10", bg = "Normal:bg" } }
       { { "Directory", "MarkSign" }, link = "DraculaPurple" },
      })
      
      
        nx.hl({ "GitSignsCurrentLineBlame", fg = "Debug:fg", bg = "CursorLine:bg", italic = true })
        ---@ ╰── set a single highlight
        ---@ ╭── or lists of highlights
        nx.hl({
           { "Hex", fg = "#9370DB" },            --   ╮
           { "ColorName", fg = "MediumPurple" }, ---@ ├  kinds of values already possible without nx.nvim
           { "Decimal", fg = 9662683 },          --   ╯
           --
           { "Winbar", fg = "DraculaComment:fg" },
           ---@                       ╭────╯  use single values from other highlight groups
           { "Normal", bg = "DraculaBg:bg" },
           ---@ use a color with transformed brightness  ──╮ ╭─ darken
           { "BufferLineSeparatorShadow", fg = "TabLine:bg:#b-10", bg = "Normal:bg" } }
           ---@ e.g., with hex var ──╮         ╭─ brighten
           { "BgLight", bg = palette.bg .. ":#b+15" },
           ---@           ╭── multiple highlight names
           { { "Directory", "MarkSign" }, link = "DraculaPurple" },
        }, { bold = true, italic = true })
        ---@    ╰── wrapper opts apply values to all entries
        
      
        nx.hl({
           { "NeoTreeTabActive", bg = "NeoTreeNormal:bg" },
           { "NeoTreeTabInactive", fg = "NeoTreeDimText:fg" },   -- ╮
           { "NeoTreeTabSeparatorInactive", fg = "TabLine:bg" }, -- ┤
        }, { bg = "TabLine:bg" }) ---@    applies `bg` these     -- ╯
        
      
      nx.au({
         { "BufWritePost", pattern = "options.lua", command = "source <afile>", desc = "Execute files on save" },
         { "BufWritePre", command = "call mkdir(expand('<afile>:p:h'), 'p')", desc = "Create non-existent parents" },
      })
      nx.au({
         { "BufWinLeave", pattern = "*.*", command = "mkview" },
         { "BufWinEnter", pattern = "*.*", command = "silent! loadview" },
      }, { create_group = "RememberFolds" })
      
      
        nx.au({ "FocusGained", pattern = "*.*", command = "checktime", desc = "Check if buffer changed outside of vim" })
        ---@ ╰── create a single autocommand
        ---@ ╭── or lists of autocommands
        nx.au({
           { "BufWinLeave", pattern = "*.*", command = "mkview" },
           { "BufWinEnter", pattern = "*.*", command = "silent! loadview" },
        }, { pattern = "*.*" })
        ---@     ╰── wrapper opts apply values to all entries without them
        
      
        nx.au({
           "BufWritePre",
           -- group = "FormatOnSave", ---@ use `group` as usual to add the autocmd to an already existing group
           create_group = "FormatOnSave", ---@ or create a new group while creating the autocmd
           callback = function()
              if next(vim.lsp.get_active_clients({ bufnr = 0 })) == nil then return end
              vim.lsp.buf.format({ async = false })
           end,
        })
        nx.au({
           { "BufWinLeave", pattern = "*.*", command = "mkview" },
           { "BufWinEnter", pattern = "*.*", command = "silent! loadview" },
           ---@   ╭── create an autocommand group in `wrapper_opts` and add all autocommands within this "nx.au()" call
        }, { create_group = "RememberFolds" })
        
      
      nx.cmd({
        "LspFormat",
        function() vim.lsp.buf.format({ async = true }) end,
        bang = true,
        desc = "Fromat the Current Buffer",
      })
      
      
        ---@ ╭── create a single command
        nx.cmd({ "ResetTerminal", function() vim.cmd("set scrollback=1 | sleep 10m | set scrollback=10000") end })
        ---@ ╭── or lists of commands
        nx.cmd({
           { "LspFormat", function() vim.lsp.buf.format({ async = true }) end },
           { "LspToggleAutoFormat", function(opt) toggle_format_on_save(opt.args) end, nargs = "?" },
           { "ToggleBufferDiagnostics", function() toggle_buffer_diags(vim.fn.bufnr()) end },
        }, { bang = true })
        ---@   ╰── wrapper opts apply options to all entries without them
        
      
        nx_set({
           dracula_italic = 1,
           dracula_bold = 1,
           dracula_full_special_attrs_support = 1,
           dracula_colorterm = 0,
        })
        -- common way:
        vim.g.dracula_italic = 1
        vim.g.dracula_bold = 1
        vim.g.dracula_full_special_attrs_support = 1
        vim.g.dracula_colorterm = 0
        
      
        nx.set({
           -- General
           clipboard = "unnamedplus", -- use system clipboard
           mouse = "a", -- allow mouse in all modes
           showmode = false, -- print vim mode on enter
           termguicolors = true, -- set term gui colors
           timeoutlen = 350, -- time to wait for a mapped sequence to complete
           fillchars__append = [[eob: ,fold: ,foldopen:,foldsep: ,foldclose:›, vert:▏]],
           listchars__append = [[space:⋅, trail:⋅, eol:↴]],
           -- Auxiliary files
           undofile = true, -- enable persistent undo
           backup = false, -- create a backup file
           swapfile = false, -- create a swap file
           -- Command line
           cmdheight = 0,
           -- Completion menu
           pumheight = 14, -- completion popup menu height
           shortmess__append = "c", -- don't give completion-menu messages
           -- Gutter
           number = true, -- show line numbers
           numberwidth = 3, -- number column width - default "4"
           relativenumber = true, -- set relative line numbers
           signcolumn = "yes:2", -- use fixed width signcolumn - prevents text shift when adding signs
           -- Search
           hlsearch = true, -- highlight matches in previous search pattern
           ignorecase = true, -- ignore case in search patterns
           smartcase = true, -- use smart case
           -- ...
        }, vim.opt)
        
      
        -- if using a global variable, make sure it's set where it will be loaded before it's used in another place
        _G.nx = require("nx")
        -- use anywhere
        nx.map({})
        nx.au({})
        nx.hl({})
        
      
        -- E.g., when using a plugin manger like lazy, add a high priority
        require("lazy").setup({
          -- ...
          { "tenxsoydev/nx.nvim", priority = 100, config = function() _G.nx = require "nx" end },
          -- ...
        })
        
      
        -- or if you prefer not to have the `nx` branding, use another vairable name
        _G.v = require("nx")
        -- use anywhere
        v.map({})
        v.au({})
        v.hl({})
        
      
        local map = require("nx.map")
        local hl = require("nx.hl")
        local au = require("nx.au")
        
    end,
  },
  {
    "zdcthomas/yop.nvim",
    config = function()
      
      {"zdcthomas/yop.nvim"}
      
      
      use("zdcthomas/yop.nvim")
      
      
      require("yop").op_map
      
      
      function (selections, info)
        ...
        return optional_replacement_lines
      end
      
      
        {
          position = {
            first = {row_number, column_number},
            last = {row_number, column_number},
          },
          type = motion_callback_type
        }
        
      
      require("yop").op_map({"n", "v"}, "<leader>b", function(lines, info)
        return { "bread" }
      end)
      
      
      require("yop").op_map("n", "<leader>bb", function(lines, info)
        return { "bread" }
      end, {linewise = true})
      
      
      function(lines, opts)
        -- We don't care about anything non alphanumeric here
        local sort_without_leading_space = function(a, b)
          -- true = a then b
          -- false = b then a
          local pattern = [[^%W*]]
          return string.gsub(a, pattern, "") < string.gsub(b, pattern, "")
        end
        if #lines == 1 then
          -- If only looking at 1 line, sort that line split by some char gotten from input
          local delimeter = utils.get_input("Delimeter: ")
          local split = vim.split(lines[1], delimeter, { trimempty = true })
          -- Remember! `table.sort` mutates the table itself
          table.sort(split, sort_without_leading_space)
          return { utils.join(split, delimeter) }
        else
          -- If there are many lines, sort the lines themselves
          table.sort(lines, sort_without_leading_space)
          return lines
        end
      end
      
      
      function(lines)
        -- Multiple lines can't be searched for
        if #lines > 1 then
          return
        end
        require("telescope.builtin").grep_string({ search = lines[1] })
      end
      
    end,
  },
  {
    "mluders/comfy-line-numbers.nvim",
    config = function()
      
      return {
        'mluders/comfy-line-numbers.nvim'
      }
      
      
      require('comfy-line-numbers').setup({
        labels = {
          '1', '2', '3', '4', '5', '11', '12', '13', '14', '15', '21', '22', '23',
          '24', '25', '31', '32', '33', '34', '35', '41', '42', '43', '44', '45',
          '51', '52', '53', '54', '55', '111', '112', '113', '114', '115', '121',
          '122', '123', '124', '125', '131', '132', '133', '134', '135', '141',
          '142', '143', '144', '145', '151', '152', '153', '154', '155', '211',
          '212', '213', '214', '215', '221', '222', '223', '224', '225', '231',
          '232', '233', '234', '235', '241', '242', '243', '244', '245', '251',
          '252', '253', '254', '255',
        },
        up_key = 'k',
        down_key = 'j',
      
        -- Line numbers will be completely hidden for the following file/buffer types
        hidden_file_types = { 'undotree' },
        hidden_buffer_types = { 'terminal', 'nofile' }
      })
      
    end,
  },
  {
    "cpea2506/relative-toggle.nvim",
    config = function()
      
      {
        "cpea2506/relative-toggle.nvim"
      }
      
      
      require("relative-toggle").setup({
          pattern = "*",
          events = {
              on = { "BufEnter", "FocusGained", "InsertLeave", "WinEnter", "CmdlineLeave" },
              off = { "BufLeave", "FocusLost", "InsertEnter", "WinLeave", "CmdlineEnter" },
          },
      })
      
    end,
  },
  {
    "chrisgrieser/nvim-early-retirement",
    config = function()
      
      -- packer
      use {
      	"chrisgrieser/nvim-early-retirement",
      	config = function () require("early-retirement").setup() end,
      }
      
      -- lazy.nvim
      {
      	"chrisgrieser/nvim-early-retirement",
      	config = true,
      	event = "VeryLazy",
      },
      
      
      defaultOpts = {
      	-- If a buffer has been inactive for this many minutes, close it.
      	retirementAgeMins = 20,
      
      	-- Filetypes to ignore.
      	ignoredFiletypes = {},
      
      	-- Ignore files matching this lua pattern; empty string disables this setting.
      	ignoreFilenamePattern = "",
      
      	-- Will not close the alternate file.
      	ignoreAltFile = true,
      
      	-- Minimum number of open buffers for auto-closing to become active. E.g.,
      	-- by setting this to 4, no auto-closing will take place when you have 3
      	-- or fewer open buffers. Note that this plugin never closes the currently
      	-- active buffer, so a number < 2 will effectively disable this setting.
      	minimumBufferNum = 1,
      
      	-- Ignore buffers with unsaved changes. If false, the buffers will
      	-- automatically be written and then closed.
      	ignoreUnsavedChangesBufs = true,
      
      	-- Ignore non-empty buftypes, for example terminal buffers
      	ignoreSpecialBuftypes = true,
      
      	-- Ignore visible buffers. Buffers that are open in a window or in a tab
      	-- are considered visible by vim. ("a" in `:buffers`)
      	ignoreVisibleBufs = true,
      
      	-- ignore unloaded buffers. Session-management plugin often add buffers
      	-- to the buffer list without loading them.
      	ignoreUnloadedBufs = false,
      
      	-- Show notification on closing. Works with plugins like nvim-notify.
      	notificationOnAutoClose = false,
      
      	-- When a file is deleted, for example via an external program, delete the
      	-- associated buffer as well. Requires Neovim >= 0.10.
      	-- (This feature is independent from the automatic closing)
      	deleteBufferWhenFileDeleted = false,
      
      	-- Function to delete the buffer. The argument provided to the function is
      	-- the buffer number. If nothing is provided the plugin will just call
      	-- nvim_buf_delete.
      	deleteFunction = nil,
      }
      
    end,
  },
  {
    "axkirillov/hbac.nvim",
    config = function()
      
      use { 'axkirillov/hbac.nvim' }
      
      
      {
        'axkirillov/hbac.nvim',
        config = true,
      }
      
      
      require("hbac").setup({
        autoclose     = true, -- set autoclose to false if you want to close manually
        threshold     = 10, -- hbac will start closing unedited buffers once that number is reached
        close_command = function(bufnr)
          vim.api.nvim_buf_delete(bufnr, {})
        end,
        close_buffers_with_windows = false, -- hbac will close buffers with associated windows if this option is `true`
        telescope = {
          -- See #telescope-configuration below
          },
      })
      
      
      local hbac = require("hbac")
      hbac.toggle_pin()
      hbac.close_unpinned()
      hbac.pin_all()
      hbac.unpin_all()
      hbac.toggle_autoclose()
      
      
      require('telescope').load_extension('hbac')
      
      
      require('telescope').extensions.hbac.buffers()
      
      
      -- These actions refresh the picker and the pin states/icons of the open buffers
      -- Use these instead of e.g. `hbac.pin_all()`
      local actions = require("hbac.telescope.actions")
      
      telescope = {
          sort_mru = true,
          sort_lastused = true,
          selection_strategy = "row",
          use_default_mappings = true,  -- false to not include the mappings below
          mappings = {
            i = {
              ["<M-c>"] = actions.close_unpinned,
              ["<M-x>"] = actions.delete_buffer,
              ["<M-a>"] = actions.pin_all,
              ["<M-u>"] = actions.unpin_all,
              ["<M-y>"] = actions.toggle_pin,
            },
            n = {
              -- as above
            },
          },
          -- Pinned/unpinned icons and their hl groups. Defaults to nerdfont icons
          pin_icons = {
            pinned = { "󰐃 ", hl = "DiagnosticOk" },
            unpinned = { "󰤱 ", hl = "DiagnosticError" },
          },
      }
      
      
      telescope = {
        layout_strategy = "vertical",
        sort_lastused = false,
        ignore_current_buffer = true,
        prompt_prefix = "Hbac! ",
        mappings = {
          i = {
            ["<CR>"] = telescope_actions.select_drop,
            ["<C-CR>"] = telescope_actions.select_default,
            ["<M-z>"] = function() print("Hello from Hbac!") end,
          },
        }
      }
      
      
      require("telescope").extensions.hbac.buffers({
        file_ignore_patterns = { ".json" },
        layout_strategy = "horizontal",
        -- etc.
      })
      
      
      lualine_c = {
          {
            function()
              local cur_buf = vim.api.nvim_get_current_buf()
              return require("hbac.state").is_pinned(cur_buf) and "📍" or ""
              -- tip: nerd fonts have pinned/unpinned icons!
            end,
            color = { fg = "#ef5f6b", gui = "bold" },
          }
        }
      
      
      require("resession").setup({
        extensions = {
          hbac = {
          },
        },
      })
      
    end,
  },
  {
    "ragnarok22/whereami.nvim",
    config = function()
      
      {
          "ragnarok22/whereami.nvim",
          cmd = "Whereami"
      }
      
      
      {
          'ragnarok22/whereami.nvim',
          -- Lazy loading on specific command
          cond = {
              cmd {'Whereami'}
          }
      }
      
      
      use 'ragnarok22/whereami.nvim'
      
      
      vim.notify = require("notify")
      
      
      {
        "ragnarok22/whereami.nvim",
        cmd = "Whereami",
        dependencies = {
          "rcarriga/nvim-notify",
          config = function()
            vim.notify = require("notify")
          end
        }
      }
      
      
      local whereami = require("whereami")
      whereami.country() -- show the country
      whereami.city() -- show the city
      whereami.ip() -- show the IP
      whereami.isp() -- show the ISP
      
      -- set keymaps
      vim.keymap.set("n", "<leader>l", whereami.country, { desc = "Show the country" })
      vim.keymap.set("n", "<leader>e", whereami.city, { desc = "Show the city" })
      vim.keymap.set("n", "<leader>i", whereami.ip, { desc = "Show the ip" })
      vim.keymap.set("n", "<leader>s", whereami.isp, { desc = "Show the ISP" })
      
    end,
  },
  {
    "ecthelionvi/NeoComposer.nvim",
    config = function()
      
      require('telescope').load_extension('macros')
      
      
      require('NeoComposer.ui').status_recording()
      
      
      lualine_c = {
      	{ require('NeoComposer.ui').status_recording },
      },
      
      
      {
        provider = function(self)
          return self.status or ""
        end,
        update = {
          "User",
          pattern = { "NeoComposerRecordingSet", "NeoComposerPlayingSet", "NeoComposerDelaySet" },
          callback = function(self)
            self.status = require("neocomposer.ui").status_recording()
          end
        }
      }
      
    end,
  },
  {
    "LukasPietzschmann/telescope-tabs",
    config = function()
      
      {
      	'LukasPietzschmann/telescope-tabs',
      	config = function()
      		require('telescope').load_extension 'telescope-tabs'
      		require('telescope-tabs').setup {
      			-- Your custom config :^)
      		}
      	end,
      	dependencies = { 'nvim-telescope/telescope.nvim' },
      }
      
      
      use {
      	'LukasPietzschmann/telescope-tabs',
      	requires = { 'nvim-telescope/telescope.nvim' },
      	config = function()
      		require'telescope-tabs'.setup{
      			-- Your custom config :^)
      		}
      	end
      }
      
      
      entry_formatter = function(tab_id, buffer_ids, file_names, file_paths, is_current)
      	local entry_string = table.concat(file_names, ', ')
      	return string.format('%d: %s%s', tab_id, entry_string, is_current and ' <' or '')
      end,
      
      
      sort_function = function(tab_id_a, buffer_ids_a, file_names_a, file_paths_a, is_current_a,
      						tab_id_b, buffer_ids_b, file_names_b, file_paths_b, is_current_b)
      	-- Move the current tab to the top of the list.
      	return is_current_b
      end
      
      
      entry_ordinal = function(tab_id, buffer_ids, file_names, file_paths, is_current)
      	return table.concat(file_names, ' ')
      end,
      
      
      show_preview = true,
      
      
      close_tab_shortcut_i = '<C-d>', -- if you're in insert mode
      close_tab_shortcut_n = 'D',     -- if you're in normal mode
      
    end,
  },
  {
    "RutaTang/compter.nvim",
    config = function()
      
      require("lazy").setup({
        { "RutaTang/compter.nvim", config = function()
              require("compter").setup({})
          end,
        }
      })
      
      
      
      require("lazy").setup({
        { "RutaTang/compter.nvim", config = function()
              require("compter").setup({
                  -- Provide and customize templates
                  templates = {
                  },
                  -- Whether fallback to nvim-built-in increase and decrease operation, default to false
                  fallback = false 
              })
          end,
        }
      })
      
      
      require("lazy").setup({
        { "RutaTang/compter.nvim", config=function()
              require("compter").setup(
                  {
                      templates = {
                          -- example template
                          {
                              pattern = [[-\?\d\+]],
                              priority = 0,
                              increase = function(content)
                                  content = tonumber(content)
                                  return content + 1, true
                              end,
                              decrease = function(content)
                                  content = tonumber(content)
                                  return content - 1, true
                              end,
                          },
                          -- more templates
                      }      
                  }
              )
          end
        },
      })
      
      
      {
          pattern = [[-\?\d\+]],
          priority = 0,
          increase = function(content)
              content = tonumber(content)
              return content + 1, true
          end,
          decrease = function(content)
              content = tonumber(content)
              return content - 1, true
          end,
      }
      
      
      -- for lowercase alphabet
      {
          pattern = [[\l]],
          priority = 0,
          increase = function(content)
              local ansiCode = string.byte(content) + 1
              if ansiCode > string.byte("z") then
                  ansiCode = string.byte("a")
              end
              local char = string.char(ansiCode)
              return char, true
          end,
          decrease = function(content)
              local ansiCode = string.byte(content) - 1
              if ansiCode < string.byte("a") then
                  ansiCode = string.byte("z")
              end
              local char = string.char(ansiCode)
              return char, true
          end,
      }
      
      
      -- for uppercase alphabet
      {
          pattern = [[\u]],
          priority = 0,
          increase = function(content)
              local ansiCode = string.byte(content) + 1
              if ansiCode > string.byte("Z") then
                  ansiCode = string.byte("A")
              end
              local char = string.char(ansiCode)
              return char, true
          end,
          decrease = function(content)
              local ansiCode = string.byte(content) - 1
              if ansiCode < string.byte("A") then
                  ansiCode = string.byte("Z")
              end
              local char = string.char(ansiCode)
              return char, true
          end,
      }
      
      
      -- for date format: dd/mm/YYYY
      {
          pattern = [[\d\{2}/\d\{2}/\d\{4}]],
          priority = 100,
          increase = function(content)
              local ts = vim.fn.strptime("%d/%m/%Y", content)
              if ts == 0 then
                  return content, false
              else
                  ts = ts + 24 * 60 * 60
                  return vim.fn.strftime("%d/%m/%Y", ts), true
              end
          end,
          decrease = function(content)
              local ts = vim.fn.strptime("%d/%m/%Y", content)
              if ts == 0 then
                  return content, false
              else
                  ts = ts - 24 * 60 * 60
                  return vim.fn.strftime("%d/%m/%Y", ts), true
              end
          end,
      }
      
      
      -- for emoji ⭐
      {
          pattern = [[⭐\{1,5}]],
          priority = 0,
          increase = function(content)
              local l = #content / 3 + 1
              if l > 5 then
                  l = 1
              end
              return string.rep("⭐", l), true
          end,
          decrease = function(content)
              local l = #content / 3 - 1
              if l < 1 then
                  l = 5
              end
              return string.rep("⭐", l), true
          end,
      }
      
      
      
      -- for circle degree
      {
          pattern = [[\d\{1,3}°]],
          priority = 0,
          increase = function(content)
              local l = tonumber(content:sub(1, -3)) + 1
              if l >= 360 then
                  l = 0
              end
              return string.format("%d°", l), true
          end,
          decrease = function(content)
              local l = tonumber(content:sub(1, -3)) - 1
              if l < 0 then
                  l = 359
              end
              return string.format("%d°", l), true
          end,
      }
      
      
      -- for boolean
      {
          pattern = [[\<\(true\|false\|TRUE\|FALSE\|True\|False\)\>]],
          priority = 100,
          increase = function(content)
              local switch = {
                  ["true"] = "false",
                  ["false"] = "true",
                  ["True"] = "False",
                  ["False"] = "True",
                  ["TRUE"] = "FALSE",
                  ["FALSE"] = "TRUE",
              }
              return switch[content], true
          end,
          decrease = function(content)
              local switch = {
                  ["true"] = "false",
                  ["false"] = "true",
                  ["True"] = "False",
                  ["False"] = "True",
                  ["TRUE"] = "FALSE",
                  ["FALSE"] = "TRUE",
              }
              return switch[content], true
          end,
      }
      
      
      {
          pattern = ..., -- regex pattern to be matched, e.g. [[\d]]
          priority = 0, -- priority, template with higher priority will be matched first
          -- How to increase content (<C-a>)
          -- @param content: content is the matched text
          -- @return newContent, handled: handled means whether continue to matche other templates 
          increase = function(content) 
              ...
              return newContent, true
          end,
          -- How to decrease content (<C-x>)
          -- param and return is same as `increase` above
          decrease = function(content)
              ...
              return newContent, true
          end,
      },
      
      
      
      -- this template match numbers
      {
          pattern = [[-\?\d\+]],
          priority = 0,
          increase = function(content)
              content = tonumber(content)
              return content + 1, true
          end,
          decrease = function(content)
              content = tonumber(content)
              return content - 1, true
          end,
      }
      
    end,
  },
  {
    "yagiziskirik/AirSupport.nvim",
    config = function()
      
      use {
        'yagiziskirik/AirSupport.nvim',
      
        requires = {
          {'nvim-telescope/telescope.nvim'},
          {'nvim-lua/plenary.nvim'},
        }
      }
      
      
      require("AirSupport").setup({
        telescope_new_file_shortcut = "<C-n>",
        telescope_delete_file_shortcut = "<C-d>",
        telescope_edit_file_shortcut = "<C-e>"
      })
      
      
      require("AirSupport").setup({
        telescope_edit_file_shortcut = "<C-r>"
      })
      
    end,
  },
  {
    "aPeoplesCalendar/apc.nvim",
    config = function()
      
      {
          "aPeoplesCalendar/apc.nvim",
          dependencies = {
              "rcarriga/nvim-notify",
          },
          event = "VeryLazy",
          config = function ()
              require("apeoplescalendar").setup() -- configuration options are described below
          end,
      }
      
      
      {
          auto_teaser_filetypes = { "dashboard", "alpha", "starter", }, -- will enable running the teaser automatically for listed filetypes
      }
      
    end,
  },
  {
    "subnut/nvim-ghost.nvim",
  },
  {
    "malbertzard/inline-fold.nvim",
    config = function()
      
      {
        "malbertzard/inline-fold.nvim",
      
        opts = {
          defaultPlaceholder = "…",
          queries = {
      
            -- Some examples you can use
            html = {
              { pattern = 'class="([^"]*)"', placeholder = "@" }, -- classes in html
              { pattern = 'href="(.-)"' }, -- hrefs in html
              { pattern = 'src="(.-)"' }, -- HTML img src attribute
            }
          },
        }
      }
      
      
      vim.api.nvim_create_autocmd({ 'BufEnter', 'BufWinEnter' }, {
        pattern = { '*.html', '*.tsx' },
        callback = function(_)
          if not require('inline-fold.module').isHidden then
            vim.cmd('InlineFoldToggle')
          end
        end,
      })
      
    end,
  },
  {
    "chrisgrieser/nvim-origami",
    config = function()
      
      -- lazy.nvim
      {
      	"chrisgrieser/nvim-origami",
      	event = "VeryLazy",
      	opts = {}, -- needed even when using default config
      
      	-- recommended: disable vim's auto-folding
      	init = function()
      		vim.opt.foldlevel = 99
      		vim.opt.foldlevelstart = 99
      	end,
      },
      
      
      -- default settings
      require("origami").setup {
      	useLspFoldsWithTreesitterFallback = true,
      	pauseFoldsOnSearch = true,
      	foldtext = {
      		enabled = true,
      		padding = 3,
      		lineCount = {
      			template = "%d lines", -- `%d` is replaced with the number of folded lines
      			hlgroup = "Comment",
      		},
      		diagnosticsCount = true, -- uses hlgroups and icons from `vim.diagnostic.config().signs`
      		gitsignsCount = true, -- requires `gitsigns.nvim`
      	},
      	autoFold = {
      		enabled = true,
      		kinds = { "comment", "imports" }, ---@type lsp.FoldingRangeKind[]
      	},
      	foldKeymaps = {
      		setup = true, -- modifies `h`, `l`, and `$`
      		hOnlyOpensOnFirstColumn = false,
      	},
      }
      
      
      vim.keymap.set("n", "<Left>", function() require("origami").h() end)
      vim.keymap.set("n", "<Right>", function() require("origami").l() end)
      vim.keymap.set("n", "<End>", function() require("origami").dollar() end)
      
      
      require("origami").inspectLspFolds("special") -- comment & import only
      require("origami").inspectLspFolds("all")
      
    end,
  },
  {
    "GCBallesteros/NotebookNavigator.nvim",
    config = function()
      
      {
        "GCBallesteros/NotebookNavigator.nvim",
        keys = {
          { "]h", function() require("notebook-navigator").move_cell "d" end },
          { "[h", function() require("notebook-navigator").move_cell "u" end },
          { "<leader>X", "<cmd>lua require('notebook-navigator').run_cell()<cr>" },
          { "<leader>x", "<cmd>lua require('notebook-navigator').run_and_move()<cr>" },
        },
        dependencies = {
          "echasnovski/mini.comment",
          "hkupty/iron.nvim", -- repl provider
          -- "akinsho/toggleterm.nvim", -- alternative repl provider
          -- "benlubas/molten-nvim", -- alternative repl provider
          "anuvyklack/hydra.nvim",
        },
        event = "VeryLazy",
        config = function()
          local nn = require "notebook-navigator"
          nn.setup({ activate_hydra_keys = "<leader>h" })
        end,
      }
      
      
      return {
        "echasnovski/mini.hipatterns",
        event = "VeryLazy",
        dependencies = { "GCBallesteros/NotebookNavigator.nvim" },
        opts = function()
          local nn = require "notebook-navigator"
      
          local opts = { highlighters = { cells = nn.minihipatterns_spec } }
          return opts
        end,
      }
      
      
      return {
        "echasnovski/mini.ai",
        event = "VeryLazy",
        dependencies = { "GCBallesteros/NotebookNavigator.nvim" },
        opts = function()
          local nn = require "notebook-navigator"
      
          local opts = { custom_textobjects = { h = nn.miniai_spec } }
          return opts
        end,
      }
      
      
      {
        -- Code cell marker. Cells start with the marker and end either at the beginning
        -- of the next cell or at the end of the file.
        -- By default, uses language-specific double percent comments like `# %%`.
        -- This can be overridden for each language with this setting.
        cell_markers = {
          -- python = "# %%",
        },
        -- If not `nil` the keymap defined in the string will activate the hydra head.
        -- If you don't want to use hydra you don't need to install it either.
        activate_hydra_keys = nil,
        -- If `true` a hint panel will be shown when the hydra head is active. If `false`
        -- you get a minimalistic hint on the command line.
        show_hydra_hint = true,
        -- Mappings while the hydra head is active.
        -- Any of the mappings can be set to "nil", the string! Not the value! to unamp it
        hydra_keys = {
          comment = "c",
          run = "X",
          run_and_move = "x",
          move_up = "k",
          move_down = "j",
          add_cell_before = "a",
          add_cell_after = "b",
        },
        -- The repl plugin with which to interface
        -- Current options: "iron" for iron.nvim, "toggleterm" for toggleterm.nvim,
        -- "molten" for molten-nvim or "auto" which checks which of the above are 
        -- installed
        repl_provider = "auto",
        -- Syntax based highlighting. If you don't want to install mini.hipattners or
        -- enjoy a more minimalistic look
        syntax_highlight = false,
        -- (Optional) for use with `mini.hipatterns` to highlight cell markers
        cell_highlight_group = "Folded",
      }
      
    end,
  },
  {
    "LintaoAmons/scratch.nvim",
    config = function()
      
      -- use lazy.nvim
      {
        "LintaoAmons/scratch.nvim",
        event = "VeryLazy",
      }
      
      
      return {
        "LintaoAmons/scratch.nvim",
        event = "VeryLazy",
        dependencies = {
          {"ibhagwan/fzf-lua"}, --optional: if you want to use fzf-lua to pick scratch file. Recommanded, since it will order the files by modification datetime desc. (require rg)
          {"nvim-telescope/telescope.nvim"}, -- optional: if you want to pick scratch file by telescope
          {"folke/snacks.nvim"}, -- optional: if you want to pick scratch file by snacks picker
          {"stevearc/dressing.nvim"} -- optional: to have the same UI shown in the GIF
        }
        config = function()
          require("scratch").setup({
            scratch_file_dir = vim.fn.stdpath("cache") .. "/scratch.nvim", -- where your scratch files will be put
            window_cmd = "rightbelow vsplit", -- 'vsplit' | 'split' | 'edit' | 'tabedit' | 'rightbelow vsplit'
            use_telescope = true,
            -- fzf-lua is recommanded, since it will order the files by modification datetime desc. (require rg)
            -- snacks.nvim is also supported as an alternative picker (require rg)
            file_picker = "fzflua", -- "fzflua" | "telescope" | "snacks" | nil
            filetypes = { "lua", "js", "sh", "ts" }, -- you can simply put filetype here
            filetype_details = { -- or, you can have more control here
              json = {}, -- empty table is fine
              ["project-name.md"] = {
                subdir = "project-name" -- group scratch files under specific sub folder
              },
              ["yaml"] = {},
              go = {
                requireDir = true, -- true if each scratch file requires a new directory
                filename = "main", -- the filename of the scratch file in the new directory
                content = { "package main", "", "func main() {", "  ", "}" },
                cursor = {
                  location = { 4, 2 },
                  insert_mode = true,
                },
              },
            },
            localKeys = {
              {
                filenameContains = { "sh" },
                LocalKeys = {
                  {
                    cmd = "<CMD>RunShellCurrentLine<CR>",
                    key = "<C-r>",
                    modes = { "n", "i", "v" },
                  },
                },
              },
            },
            hooks = {
              {
                callback = function()
                  vim.api.nvim_buf_set_lines(0, 0, -1, false, { "hello", "world" })
                end,
              },
            },
          })
        end,
        event = "VeryLazy",
      }
      
      
      vim.keymap.set("n", "<M-C-n>", "<cmd>Scratch<cr>")
      vim.keymap.set("n", "<M-C-o>", "<cmd>ScratchOpen<cr>")
      
    end,
  },
  {
    "0xJohnnyboy/scretch.nvim",
    config = function()
      
      -- Lazy
      {
        '0xJohnnyboy/scretch.nvim',
        dependencies = { 'nvim-telescope/telescope.nvim' },
        -- or
        -- dependencies = { 'ibhagwan/fzf-lua' },
        config = function()
          require('scretch').setup({
            -- your configuration comes here
            -- or leave it empty to use the default settings
            -- refer to the configuration section below
          })
        end,
      },
      
        
      -- Packer
      use {
        '0xJohnnyboy/scretch.nvim',
        requires = 'nvim-telescope/telescope.nvim',
        -- or
        -- requires = 'ibhagwan/fzf-lua' ,
        config = function()
          require('scretch').setup {
            -- your configuration comes here
            -- or leave it empty to use the default settings
            -- refer to the configuration section below
          }
        end
      }
      
      
      local config = {
          scretch_dir = vim.fn.stdpath('data') .. '/scretch/', -- will be created if it doesn't exist
          template_dir = vim.fn.stdpath('data') .. '/scretch/templates', -- will be created if it doesn't exist
          use_project_dir = {
              auto_create_project_dir = false,
              scretch = false,  -- false | true | auto
              scretch_project_dir = ".scretch/",
              template = false, -- false | true | auto
              template_project_dir = ".scretch/templates/",
          },
          default_name = "scretch_",
          default_type = "txt", -- default unnamed Scretches are named "scretch_*.txt"
          split_cmd = "vsplit", -- vim split command used when creating a new Scretch
          backend = "telescope.builtin" -- also accpets "fzf-lua"
      }
      
      
      local s = require("scretch")
      vim.keymap.set('n', '<leader>sn', s.new)
      vim.keymap.set('n', '<leader>snn', s.new_named)
      vim.keymap.set('n', '<leader>sft', s.new_from_template)
      vim.keymap.set('n', '<leader>sl', s.last)
      vim.keymap.set('n', '<leader>ss', s.search)
      vim.keymap.set('n', '<leader>st', s.edit_template)
      vim.keymap.set('n', '<leader>sg', s.grep)
      vim.keymap.set('n', '<leader>sv', s.explore)
      vim.keymap.set('n', '<leader>sat', s.save_as_template)
      
      
      vim.keymap.set('n', '<leader>smsp' s.scretch_use_project_mode)
      vim.keymap.set('n', '<leader>smsa' s.scretch_use_auto_mode)
      vim.keymap.set('n', '<leader>smsg' s.scretch_use_global_mode)
      vim.keymap.set('n', '<leader>smtp' s.template_use_project_mode)
      vim.keymap.set('n', '<leader>smta' s.template_use_auto_mode)
      vim.keymap.set('n', '<leader>smtg' s.template_use_global_mode)
      
    end,
  },
  {
    "JMarkin/gentags.lua",
    config = function()
      
      {
          "JMarkin/gentags.lua",
          cond = vim.fn.executable("ctags") == 1,
          dependencies = {
              "nvim-lua/plenary.nvim",
          },
          event = "VeryLazy",
          opts = {}
      }
      
      
      {
        autostart = true,
        root_dir = vim.g.gentags_root_dir or vim.loop.cwd(),
        cache = {
          path = Path:new(vim.fn.stdpath("cache")):joinpath("tags"), -- path where generated tags store, currently required plenary Path object
        },
        async = true, -- run ctags asynchronous
        bin = "ctags",
        args = { -- extra args
          "--extras=+r+q",
          "--exclude=.git",
          "--exclude=node_modules*",
          "--exclude=.mypy*",
          "--exclude=.pytest*",
          "--exclude=.ruff*",
          "--exclude=BUILD",
          "--exclude=vendor*",
          "--exclude=*.min.*",
        },
        -- mapping ctags --languages <-> neovim filetypes
        lang_ft_map = {
          ["Python"] = { "python" },
          ["Lua"] = { "lua" },
          ["Vim"] = { "vim" },
          ["C,C++,CUDA"] = { "c", "cpp", "h", "cuda" },
          ["JavaScript"] = { "javascript" },
          ["Go"] = { "go" },
        }
      }
      
    end,
  },
  {
    "yutkat/confirm-quit.nvim",
    config = function()
      
      {
        "yutkat/confirm-quit.nvim",
        event = "CmdlineEnter",
        opts = {},
      }
      
      
      use {
        "yutkat/confirm-quit.nvim",
        event = "CmdlineEnter",
        config = function() require "confirm-quit".setup() end,
      }
      
      
      {
        overwrite_q_command = true, -- Replaces :q and :qa with :ConfirmQuit and :ConfirmQuitAll
        quit_message = 'Do you want to quit?', -- Message to show when quitting, can be a function returning a string
      }
      
      
      require "confirm-quit".confirm_quit()     -- :ConfirmQuit
      require "confirm-quit".confirm_quit_all() -- :ConfirmQuitAll
      
      require "confirm-quit".confirm_quit { bang = true }     -- ConfirmQuit!
      require "confirm-quit".confirm_quit_all { bang = true } -- ConfirmQuitAll!
      
      
      vim.keymap.set("n", "<leader>q", require "confirm-quit".confirm_quit)
      vim.keymap.set("n", "<leader>Q", require "confirm-quit".confirm_quit_all)
      
    end,
  },
  {
    "bgaillard/readonly.nvim",
    config = function()
      
      return {
        "bgaillard/readonly.nvim",
        opts = {
          pattern = {
            vim.fn.expand("~") .. "/.aws/config",
            vim.fn.expand("~") .. "/.aws/credentials",
            vim.fn.expand("~") .. "/.ssh/*",
            vim.fn.expand("~") .. "/.secrets.yaml",
            vim.fn.expand("~") .. "/.vault-crypt-files/*",
          }
        },
        lazy = false
      }
      
      
        return {
          "bgaillard/readonly.nvim",
          opts = {
            display_modes = {
              buffer = {
                enabled = true,
              }
            },
            pattern = {
              "/path/to/the/file",
            }
          },
          lazy = false
        }
      
      
        return {
          "bgaillard/readonly.nvim",
          opts = {
            display_modes = {
              command_line = {
                enabled = true,
              }
            },
            pattern = {
              "/path/to/the/file",
            }
          },
          lazy = false
        }
      
      
        return {
          "bgaillard/readonly.nvim",
          dependencies = {
            "rcarriga/nvim-notify", -- Required for the notification display mode
          },
          opts = {
            display_modes = {
              notification = {
                enabled = true
              }
            },
            pattern = {
              "/path/to/the/file",
            }
          },
          lazy = false
        }
      
      
        return {
          "bgaillard/readonly.nvim",
          dependencies = {
            "rcarriga/nvim-notify", -- Required for the notification display mode
          },
          opts = {
            display_modes = {
              notification = {
      
                --- Whether to enable notifications
                enabled = true
      
                --- Default options for "rcarriga/nvim-notify"
                ---
                --- You can override those options to customize the notification.
                ---
                --- see https://github.com/rcarriga/nvim-notify/blob/master/lua/notify/config/init.lua
                opts = {
                  level = vim.log.levels.ERROR,
                  timeout = 5000,
                  max_width = nil,
                  max_height = nil,
                  stages = "fade_in_slide_out",
                  render = "default",
                  background_colour = "#000000",
                  on_open = nil,
                  on_close = nil,
                  minimum_width = 50,
                  fps = 30,
                  top_down = true,
                  merge_duplicates = true,
                  time_formats = {
                    notification_history = "%FT%T",
                    notification = "%T",
                  },
                  icons = {
                    ERROR = "",
                    WARN = "",
                    INFO = "",
                    DEBUG = "",
                    TRACE = "✎",
                  },
                }
            },
            pattern = {
              "/path/to/the/file",
            }
          },
          lazy = false
        }
      
    end,
  },
  {
    "GCBallesteros/jupytext.nvim",
    config = function()
      
      return {
        "GCBallesteros/jupytext.nvim",
        config = true,
        -- Depending on your nvim distro or config you may need to make the loading not lazy
        -- lazy=false,
      }
      
      
      {
        style = "hydrogen",
        output_extension = "auto",  -- Default extension. Don't change unless you know what you are doing
        force_ft = nil,  -- Default filetype. Don't change unless you know what you are doing
        custom_language_formatting = {},
      }
      
      
      require("jupytext").setup({ style = "light" })
      
      
      custom_language_formatting = {
        python = {
          extension = "qmd",
          style = "quarto",
          force_ft = "quarto", -- you can set whatever filetype you want here
        },
      }
      
      
      custom_language_formatting = {
        python = {
          extension = "md",
          style = "markdown",
          force_ft = "markdown", -- you can set whatever filetype you want here
        },
      }
      
    end,
  },
  {
    "ariel-frischer/bmessages.nvim",
    config = function()
      
      {
        "ariel-frischer/bmessages.nvim",
        event = "CmdlineEnter",
        opts = {}
      }
      
      
      use({
        "ariel-frischer/bmessages.nvim",
          config = function()
            require("bmessages").setup({
              -- config here or empty for defaults
            })
          end,
        })
      
      
      { "ariel-frischer/bmessages.nvim",
        config = function()
          require("bmessages").setup({
            -- config here or empty for defaults
          })
        end,
      };
      
      
      local opts = {
        -- Time in milliseconds between each update of the messages buffer.
        timer_interval = 1000,
        -- Default split type for the messages buffer ('vsplit' or 'split').
        split_type = "vsplit",
        -- Default split direction for the messages buffer ('topleft' or 'botright').
        split_direction = nil,
        -- Size of the vertical split when opening the messages buffer.
        split_size_vsplit = nil,
        -- Size of the horizontal split when opening the messages buffer.
        split_size_split = nil,
        -- Automatically scroll to the latest message in the buffer.
        autoscroll = true,
        -- Use a timer to auto-update the messages buffer. When this is disabled,
        -- the buffer will not update, but the buffer becomes modifiable.
        use_timer = true,
        -- Name of the messages buffer.
        buffer_name = "bmessages_buffer",
        -- Don't add user commands for `Bmessages`, `Bmessagesvs`, and `Bmessagessp`.
        disable_create_user_commands = false,
        -- Don't focus the bmessages window after opening.
        keep_focus = false,
      }
      
      
      require("bmessages").toggle({ split_type = "split" })
      
      
      vim.api.nvim_set_keymap("n", "<leader>bm", ":Bmessages<CR>", { noremap = true, silent = true })
      
    end,
  },
  {
    "backdround/tabscope.nvim",
    config = function()
      
      -- Initialize tabscope
      require("tabscope").setup({})
      
      -- To remove tab local buffer, use remove_tab_buffer:
      vim.keymap.set("n", "<M-o>", require("tabscope").remove_tab_buffer)
      
    end,
  },
  {
    "linrongbin16/gentags.nvim",
    config = function()
      
      require("lazy").setup({
        {
          "linrongbin16/gentags.nvim",
          config = function()
            require('gentags').setup()
          end,
        },
      })
      
      
      require("pckr").add({
        {
          "linrongbin16/gentags.nvim",
          config = function()
            require("gentags").setup()
          end,
        },
      })
      
      
      require('gentags').setup(opts)
      
    end,
  },
  {
    "Mr-LLLLL/utilities.nvim",
  },
  {
    "mcauley-penney/visual-whitespace.nvim",
  },
  {
    "Zeioth/distroupdate.nvim",
    config = function()
      
      {
        "Zeioth/distroupgrade.nvim",
        dependencies = "nvim-lua/plenary.nvim",
        event = "VeryLazy",
        opts = {}
      }
      
      
      -- distroupdate.nvim [distro update]
      -- https://github.com/Zeioth/distroupdate.nvim
      {
        "Zeioth/distroupdate.nvim",
        dependencies = { "nvim-lua/plenary.nvim" },
        event = "VeryLazy",
        opts = {
          channel = "stable"
        }
      },
      
    end,
  },
  {
    "SUSTech-data/neopyter",
    config = function()
      
      {
          "SUSTech-data/neopyter",
          dependencies = {
            'nvim-lua/plenary.nvim',
            'nvim-treesitter/nvim-treesitter', -- neopyter don't depend on `nvim-treesitter`, but does depend on treesitter parser of python
            'AbaoFromCUG/websocket.nvim',  -- for mode='direct'
          },
      
          ---@type neopyter.Option
          opts = {
              mode="direct",
              remote_address = "127.0.0.1:9001",
              file_pattern = { "*.ju.*" },
              on_attach = function(bufnr)
                  -- do some buffer keymap
              end,
          },
      }
      
      
      ---@type neopyter.Option
      local default_config = {
          remote_address = "127.0.0.1:9001",
          file_pattern = { "*.ju.*" },
          filename_mapper = function(ju_path)
              local ipynb_path = vim.fn.fnamemodify(ju_path, ":r:r:r") .. ".ipynb"
              if is_windows then
                  ipynb_path = ipynb_path:gsub("\\", "/")
              end
              return ipynb_path
          end,
          --- auto attach to buffer
          auto_attach = true,
          --- auto connect with remote jupyterlab
          auto_connect = true,
          mode = "direct",
          ---@type neopyter.JupyterOption  # ref `:h neopyter.JupyterOption`
          jupyter = {
              auto_activate_file = true,
              partial_sync = false,
              -- Always scroll to the current cell.
              scroll = {
                  enable = true,
                  align = "center",
              },
          },
      
          ---@type neopyter.HighlightOption  # ref `:h neopyter.HighlightOption`
          highlight = {
              enable = true,
              mode = "separator",
          },
          ---@type neopyter.TextObjectOption  # ref `:h neopyter.TextObjectOption`
          textobject = {
              enable = true,
              -- more capture, poorer performance
              queries = { "cellseparator", "cellcontent", "cell" },
          },
          ---@type neopyter.InjectionOption  # ref `:h neopyter.InjectionOption`
          injection = {
              enable = true,
          },
          ---@type neopyter.ParserOption  # ref `:h neopyter.ParserOption`
          parser = {
              trim_whitespace = false,
              python = {},
              r = {},
          },
      }
      
      
      on_attach = function(buf)
          local function map(mode, lhs, rhs, desc)
              vim.keymap.set(mode, lhs, rhs, { desc = desc, buffer = buf })
          end
          -- same, recommend the former
          map("n", "<C-Enter>", "<cmd>Neopyter execute notebook:run-cell<cr>", "run selected")
          -- map("n", "<C-Enter>", "<cmd>Neopyter run current<cr>", "run selected")
      
          -- same, recommend the former
          map("n", "<space>X", "<cmd>Neopyter execute notebook:run-all-above<cr>", "run all above cell")
          -- map("n", "<space>X", "<cmd>Neopyter run allAbove<cr>", "run all above cell")
      
          -- same, recommend the former, but the latter is silent
          map("n", "<space>nt", "<cmd>Neopyter execute kernelmenu:restart<cr>", "restart kernel")
          -- map("n", "<space>nt", "<cmd>Neopyter kernel restart<cr>", "restart kernel")
      
          map("n", "<S-Enter>", "<cmd>Neopyter execute notebook:run-cell-and-select-next<cr>", "run selected and select next")
          map("n", "<M-Enter>", "<cmd>Neopyter execute notebook:run-cell-and-insert-below<cr>", "run selected and insert below")
      
          map("n", "<F5>", "<cmd>Neopyter execute notebook:restart-run-all<cr>", "restart kernel and run all")
      end
      
      
      
      local lspkind = require("lspkind")
      local cmp = require("cmp")
      
      cmp.setup({
          sources = cmp.config.sources({
              -- default: all source, maybe some noice
              { name = "neopyter" },
      
              -- { name = "neopyter", option={ source = { "CompletionProvider:kernel" } } },
          }),
          formatting = {
              format = lspkind.cmp_format({
                  mode = "symbol_text",
                  menu = {
                      buffer = "[Buf]",
                      nvim_lsp = "[LSP]",
                      nvim_lua = "[Lua]",
                      neopyter = "[Neopyter]",
                  },
                  symbol_map = {
                      -- specific complete item kind icon
                      ["Magic"] = "🪄",
                      ["Path"] = "📁",
                      ["Dict key"] = "🔑",
                      ["Instance"] = "󱃻",
                      ["Statement"] = "󱇯",
                  },
              }),
          },
      )}
      
          -- menu item highlight
      vim.api.nvim_set_hl(0, "CmpItemKindMagic", { bg = "NONE", fg = "#D4D434" })
      vim.api.nvim_set_hl(0, "CmpItemKindPath", { link = "CmpItemKindFolder" })
      vim.api.nvim_set_hl(0, "CmpItemKindDictkey", { link = "CmpItemKindKeyword" })
      vim.api.nvim_set_hl(0, "CmpItemKindInstance", { link = "CmpItemKindVariable" })
      vim.api.nvim_set_hl(0, "CmpItemKindStatement", { link = "CmpItemKindVariable" })
      
      
      
      require("blink-cmp").setup({
          sources = {
              per_filetype = {
                  python = { inherit_defaults = true, "neopyter" },
              },
              providers = {
                  neopyter = {
                      name = "Neopyter",
                      module = "neopyter.blink",
                      ---@type neopyter.BlinkCompleterOption
                      opts = {},
                  },
              },
          },
      })
      
      
      
      {
          "SUSTech-data/neopyter",
          ---@type neopyter.Option
          opts = {
              textobject = {
                  enable = true,
                  queries = {
                      "linemagic",
                      "cellseparator",
                      "cellcontent",
                      "cell"
                  },
              },
          },
      }
      
      
      require'nvim-treesitter.configs'.setup {
          textobjects = {
              select = {
                  enable = true,
                  lookahead = true,
                  keymaps = {
                      ["aj"] = { query = "@cell", desc = "Select cell" },
                      ["ij"] = { query = "@cellcontent", desc = "Select cell content" },
                  },
              },
              move = {
                  enable = true,
                  goto_next_start = {
                      ["]j"] = "@cellseparator",
                  },
                  goto_previous_start = {
                      ["[j"] = "@cellseparator",
                  },
              },
          },
      }
      
      
      
      
      -- Reference to `:h neopyter-jupyterlab-api` for all api document
      local current_lab = require("neopyter.jupyter").jupyterlab
      current_lab:execute_command("notebook:export-to-format", {format="html"})
      
      -- Reference to `:h neopyter-notebook-api` for all api document
      local current_notebook = require("neopyter.jupyter").notebook
      
      current_notebook:run_selected_cell()
      current_notebook:run_all_above()
      current_notebook:run_all_below()
      
      
      
      vim.defer_fn(function()
          -- non-async context, API response may be unordered
          current_notebook:run_selected_cell()
          current_notebook:run_all_above()
          current_notebook:run_all_below()
      end, 0)
      
      require("neopyter.async").run(function()
          -- async context, so which will call and return in order
          current_notebook:run_selected_cell()
          current_notebook:run_all_above()
          current_notebook:run_all_below()
      end)
      
      
    end,
  },
  {
    "terje/simctl.nvim",
    config = function()
      
      {
        "terje/simctl.nvim",
        version = "*", -- Use latest release instead of latest commit. Recommended.
      }
      
      
      require("simctl").setup({
        notify = true, -- enable error notifications
        devicePicker = true, -- show the device picker if no deviceId is supplied
        appPicker = true, -- show the app picker if no appId is supplied
        privacyServicePicker = true, -- show the privacy service picker if no service is supplied
        defaultToBootedDevice = false, -- default to booted device if no deviceId is supplied
        openSimulatorApp = true, -- open Simulator.app when booting a device, otherwise the device will run headless
      })
      
      
      local simctl = require("simctl.api")
      
      simctl.boot()
      simctl.erase()
      simctl.launch()
      simctl.list()
      simctl.listapps()
      simctl.openurl()
      simctl.push()
      simctl.shutdown()
      simctl.statusbar()
      simctl.terminate()
      
      simctl.biometry.setEnrollment()
      simctl.biometry.isEnrolled()
      simctl.biometry.toggleEnrollment()
      simctl.biometry.authenticate()
      
      simctl.privacy.grant()
      simctl.privacy.revoke()
      simctl.privacy.reset()
      
      simctl.ui.contentSize()
      simctl.ui.setContentSize()
      simctl.ui.increaseContentSize()
      simctl.ui.decreaseContentSize()
      simctl.ui.appearance()
      simctl.ui.setAppearance()
      simctl.ui.toggleAppearance()
      simctl.ui.increaseContrast()
      
      local pickers = require("simctl.lib.pickers")
      pickers.pickApp()
      pickers.pickDevice()
      
      
      vim.keymap.set("n", "<leader>ib", function()
      require("simctl.api").boot()
      end)
      
      
      local args = {
        deviceId = "FE4BD15E-C65C-45DB-960A-78A771B16D17",
        appId = "host.exp.Exponent"
      }
      
      require("simctl.api").launch(args)
      
      
      local simctl = require("simctl.api")
      
      local args = {
        deviceId = "FE4BD15E-C65C-45DB-960A-78A771B16D17"
        appType = simctl.AppType.User
      }
      
      simctl.listapps(args, function(success, apps, stdout, stderr)
        print(vim.inspect(apps))
      end)
      
      
      local args = {
          deviceId = "FE4BD15E-C65C-45DB-960A-78A771B16D17" -- Device ID. Required
      }
      
      local callback = function(success, _, stdout, stderr)
      end
      
      require("simctl.api").boot(args, callback)
      
      
      local args = {
          deviceId = "FE4BD15E-C65C-45DB-960A-78A771B16D17" -- Device ID. Required. Can be "all" for all devices.
      }
      
      local callback = function(success, _, stdout, stderr)
      end
      
      require("simctl.api").erase(args, callback)
      
      
      local args = {
          appId = "host.exp.Exponent", -- The app to launch. Required
          deviceId = "FE4BD15E-C65C-45DB-960A-78A771B16D17" -- Device ID
      }
      
      local callback = function(success, _, stdout, stderr)
      end
      
      require("simctl.api").launch(args, callback)
      
      
      local callback = function(success, devices, stdout, stderr)
      end
      
      require("simctl.api").list(callback)
      
      
      local simctl = require("simctl.api")
      
      local args = {
          deviceId = "FE4BD15E-C65C-45DB-960A-78A771B16D17" -- Device ID
          appType = simctl.AppType.User -- Optional. Returns all apps if not filtered
      }
      
      local callback = function(success, apps, stdout, stderr)
      end
      
      simctl.listapps(args, callback)
      
      
      local args = {
          deviceId = "FE4BD15E-C65C-45DB-960A-78A771B16D17" -- Device ID
          url = "https://soundthesea.com" -- The URL to open. Required
      }
      
      local callback = function(success, _, stdout, stderr)
      end
      
      require("simctl.api").openurl(args, callback)
      
      
      local args = {
          appId = "com.test.MyNotifiedApp" -- App bundle ID. Required.
          deviceId = "FE4BD15E-C65C-45DB-960A-78A771B16D17" -- Device ID
          payload = "[JSON]" -- The json payload of the push message (see format above in the SimctlNotify documentation)
      }
      
      require("simctl.api").push(args)
      
      
      local args = {
          deviceId = "FE4BD15E-C65C-45DB-960A-78A771B16D17" -- Device ID. Required. Can also be "all" to shut down all running devices.
      }
      
      local callback = function(success, _, stdout, stderr)
      end
      
      require("simctl.api").shutdown(args, callback)
      
      
      local simctl = require("simctl.api")
      local device = { deviceId = "FE4BD15E-C65C-45DB-960A-78A771B16D17" }
      simctl.shutdown(device, function(success)
        if success then
          simctl.erase(device, function(success)
              -- Next step of your dev workflow?
          end)
        end
      end)
      
      
      local simctl = require("simctl.api")
      simctl.biometry.setEnrollment({ enrolled = true })
      
      
      local simctl = require("simctl.api")
      simctl.biometry.isEnrolled({}, function(success, isEnrolled)
          print(isEnrolled)
      end)
      
      
      local simctl = require("simctl.api")
      simctl.biometry.toggleEnrollment({}, function(success, isEnrolled)
          print(isEnrolled)
      end)
      
      
      local simctl = require("simctl.api")
      simctl.biometry.authenticate() -- This is me
      simctl.biometry.authenticate({ match = true }) -- This is me
      simctl.biometry.authenticate({ match = false }) -- This is someone else
      
      
      local simctl = require("simctl.api")
      
      simctl.statusbar({
          [simctl.StatusbarFlag.BATTERY_LEVEL] = 50,
          [simctl.StatusbarFlag.TIME] = "09:41"
      })
      
      
      local simctl = require("simctl.api")
      
      simctl.statusBar({ clear = true })
      
      
      local simctl = require("simctl.api")
      
      simctl.statusBar({}, function(success, result)
          print(result)
      end)
      
      
      local args = {
          appId = "host.exp.Exponent", -- The app to terminate. Required
          deviceId = "FE4BD15E-C65C-45DB-960A-78A771B16D17" -- Device ID. Optional, will pick a running simulator if not supplied ("booted").
      }
      
      local callback = function(success, _, stdout, stderr)
      end
      
      require("simctl.api").terminate(args, callback)
      
      
      local simctl = require("simctl.api")
      
      -- Return current content size
      simctl.ui.contentSize({}, function(success, contentSize)
          print(contentSize)
      end)
      
      -- Set content size to accessibility-large
      simctl.ui.setContentSize({ size = simctl.ui.ContentSize.ACCESSIBILITY_LARGE })
      
      -- Increment content size
      simctl.ui.setContentSize({ size = simctl.ui.ContentSizeModifier.INCREMENT })
      
      -- Return current appearance
      simctl.ui.appearance({}, function(success, appearance)
          print(appearance)
      end)
      
      -- Set appearance to dark
      simctl.ui.setAppearance({ appearance = simctl.ui.Appearance.DARK })
      
      -- Toggle appearance between light and dark
      simctl.ui.toggleAppearance()
      
      -- Return current contrast mode
      simctl.ui.increaseContrast({}, function(success, enabled)
          print("High contrast is " .. tostring(enabled))
      end)
      
      -- Set increased contrast
      simctl.ui.increaseContrast({ enabled = true })
      
      
      local simctl = require("simctl.api")
      
      -- Grant access to photos, showing a device picker and an app picker
      simctl.privacy.grant({}, M.Service.PHOTOS)
      
      -- Revoke access from photos for a specific app
      simctl.privacy.revoke({ appId = "host.exp.Exponent" }, M.Service.PHOTOS)
      
      -- Reset privacy settings for all services
      simctl.privacy.reset({}, M.Service.ALL)
      
      
      local args = {
          appId = "host.exp.Exponent", -- The app to terminate. Required
          deviceId = "FE4BD15E-C65C-45DB-960A-78A771B16D17" -- Device ID. Optional, will pick a running simulator if not supplied ("booted").
      }
      
      local callback = function(success, _, stdout, stderr)
      end
      
      require("simctl.api").uninstall(args, callback)
      
    end,
  },
  {
    "mistricky/codesnap.nvim",
    config = function()
      
      { "mistricky/codesnap.nvim", build = "make" },
      
      
      use {'mistricky/codesnap.nvim', run = 'make'}
      
      
      Plug 'mistricky/codesnap.nvim', { 'do': 'make' }
      
      
      { "mistricky/codesnap.nvim", build = "make build_generator" },
      
      
      {
        "mistricky/codesnap.nvim",
        build = "make build_generator",
        keys = {
          { "<leader>cc", "<cmd>CodeSnap<cr>", mode = "x", desc = "Save selected code snapshot into clipboard" },
          { "<leader>cs", "<cmd>CodeSnapSave<cr>", mode = "x", desc = "Save selected code snapshot in ~/Pictures" },
        },
        opts = {
          save_path = "~/Pictures",
          has_breadcrumbs = true,
          bg_theme = "bamboo",
        },
      }
      
      
      require("codesnap").setup({
        -- The save_path must be ends with .png, unless when you specified a directory path,
        -- CodeSnap will append an auto-generated filename to the specified directory path
        -- For example:
        -- save_path = "~/Pictures"
        -- parsed: "~/Pictures/CodeSnap_y-m-d_at_h:m:s.png"
        -- save_path = "~/Pictures/foo.png"
        -- parsed: "~/Pictures/foo.png"
        save_path = ...
      })
      
      
      require("codesnap").setup({
        -- ...
        has_breadcrumbs = true
      })
      
      
      require("codesnap").setup({
        -- ...
        has_breadcrumbs = true
        show_workspace = true
      })
      
      
      require("codesnap").setup({
        -- ...
        has_breadcrumbs = true
        breadcrumbs_separator = "👉"
      })
      
      
      require("codesnap").setup({
        // ...
      	has_line_number = true,
      })
      
      
      require("codesnap").setup({
        -- The "default" background is one you see at the beginning of the README
        bg_theme = "default"
      })
      
      
      require("codesnap").setup({
        -- ...
        bg_color = "#535c68"
      })
      
      
      require("codesnap").setup({
        bg_x_padding = 122,
        bg_y_padding = 82,
        bg_padding = nil
      })
      
      
      require("codesnap").setup({
        -- ...
        bg_padding = 0
      })
      
      
      require("codesnap").setup({
        -- ...
        watermark = ""
      })
      
      
      local codesnap <const> = require("codesnap")
      
      -- Take a snapshot of the currently selected code and copy the snapshot into the clipboard
      codesnap.copy_into_clipboard()
      
      -- Save the snapshot of the currently selected code and save it on the disk
      codesnap.save_snapshot()
      
      
      require("codesnap").setup({...})
      
      
      {
          mac_window_bar = true,
          title = "CodeSnap.nvim",
          code_font_family = "CaskaydiaCove Nerd Font",
          watermark_font_family = "Pacifico",
          watermark = "CodeSnap.nvim",
          bg_theme = "default",
          breadcrumbs_separator = "/",
          has_breadcrumbs = false,
          has_line_number = false,
          show_workspace = false,
          min_width = 0,
          bg_x_padding = 122,
          bg_y_padding = 82,
          save_path = os.getenv("XDG_PICTURES_DIR") or (os.getenv("HOME").. "/Pictures")
      }
      
    end,
  },
  {
    "AlejandroSuero/freeze-code.nvim",
    config = function()
      
      return {
          "AlejandroSuero/freeze-code.nvim",
          config = function()
              require("freeze-code").setup()
          end,
      }
      
      
      return {
          "AlejandroSuero/freeze-code.nvim",
          config = function()
              require("freeze-code.nvim").setup({
                  -- your configuration goes here
              })
          end,
      }
      
      
      local opts = {
        freeze_path = vim.fn.exepath("freeze"), -- where is freeze installed
        copy_cmd = "", -- the default copy command is native to your OS (see below)
        copy = false, -- copy after screenshot option
        open = false, -- open after screenshot option
        dir = vim.env.PWD, -- where is the image going to be saved "." as default
        freeze_config = { -- configuration options for `freeze` command
          output = "freeze.png",
          config = "base",
          theme = "default",
        },
      }
      
      
      local fz_api = require("freeze-code.utils.api")
      vim.keymap.set("n", "<leader>fz", fz_api.freeze)
      vim.keymap.set("v", "<leader>fz", function()
        fz_api.freeze(vim.fn.line("'<"), vim.fn.line("'>"))
      end)
      -- or using `<cmd>Freeze<cr>`
      vim.keymap.set("n", "<leader>fl", fz.freeze_line)
      -- or using `<cmd>FreezeLine<cr>`
      
    end,
  },
  {
    "ysmb-wtsg/in-and-out.nvim",
    config = function()
      
      {
      	"ysmb-wtsg/in-and-out.nvim",
      	keys = {
      		{
      			"<C-CR>",
      			function()
      				require("in-and-out").in_and_out()
      			end,
      			mode = "i"
                      },
      	},
      }
      
      
      { '"', "'", "(", ")", "{", "}", "[", "]", "`" }
      
      
      {
      	"ysmb-wtsg/in-and-out.nvim",
      	keys = {
      		{
      			"<C-CR>",
      			function()
      				require("in-and-out").in_and_out()
      			end,
      			mode = "i"
                      },
      	},
      	opts = { additional_targets = { "“", "”" } },
      }
      
      
      require("in-and-out.nvim").setup({
      	targets = { "(", ")", "[", "]" }
      })
      
      
      {
      	"ysmb-wtsg/in-and-out.nvim",
              keys = {
                      {
                              "<C-CR>",
                              function()
                                      require("in-and-out").in_and_out()
                              end,
                              mode = "i"
                      },
              },
      	opts = { additional_targets = { "“", "”" } },
      }
      
      
      vim.keymap.set("i", "<C-CR>", function() require("in-and-out").in_and_out()
      end)
      
    end,
  },
  {
    "ChuufMaster/buffer-vacuum",
    config = function()
      
      return {
        {
          'ChuufMaster/buffer-vacuum',
          opts = {}
        },
      }
      
      
      {
          -- The maximum number of buffers to keep (excluding modified buffer)
          max_buffers = 6,
      
          -- Change to True if you want pinned buffers to count to the
          -- maximum number buffers
          count_pinned_buffers = false,
      
          -- Enable notifications every time a buffer is pinned or deleted
          -- Default FALSE
          enable_messages = false,
      }
      
      
      require('auto-session').setup({
          save_extra_cmds = {
              function()
                  local commands = {}
                  for _, bufnr in ipairs(vim.api.nvim_list_bufs()) do
                      if vim.b[bufnr].pinned == 1 then
                          local filename = vim.api.nvim_buf_get_name(bufnr)
                          if filename ~= "" then
                              -- Generate command to set buffer variable directly
                              local escaped_filename = vim.fn.escape(filename, "'\\")
                              table.insert(commands, "call setbufvar(bufnr('" .. escaped_filename .. "'), 'pinned', 1)")
                          end
                      end
                  end
                  if vim.tbl_isempty(commands) then
                      return nil
                  end
                  return commands
              end
          }
          -- your other auto-session options...
      })
      
    end,
  },
  {
    "mong8se/buffish.nvim",
  },
  {
    "niuiic/todo.nvim",
    config = function()
      
      ---@class todo.Todo
      ---@field path string
      ---@field lnum number
      ---@field status string
      ---@field id string
      ---@field dependencies string[]
      ---@field tags string[]
      ---@field content string
      
      
      ---@class todo.TelescopeSearchItem
      ---@field label string
      ---@field todo todo.Todo
      
      
      local config = {
      	---@type fun(): string
      	root_dir = function()
      		local core = require("core")
      		return core.file.root_path()
      	end,
      	---@type string
      	rg_pattern = [[\[.+\] \(.+\)\{?.*\}?: .*]],
      	---@type fun(text: string): todo.Todo | nil
      	parse = function(text)
      		local status, id, dependencies, tags, content =
      			string.match(text, "^.*%[([vbwx%s])%] %(([^:]+):?([^%)]*)%){?([^{}]*)}?: (.*)$")
      		if status ~= nil then
      			local status_map = {
      				[" "] = "TODO",
      				x = "DONE",
      				v = "VERIFY",
      				w = "WORKING",
      				b = "BLOCKED",
      			}
      			return {
      				status = status_map[status],
      				id = id,
      				dependencies = dependencies and vim.split(dependencies, ",") or {},
      				tags = tags and vim.split(tags, ",") or {},
      				content = content,
      			}
      		end
      	end,
      	---@type fun(todo: todo.Todo): [string, string][]
      	badges = function(todo)
      		local core = require("core")
      
      		local tags = core.lua.list.reduce(todo.tags, function(prev, tag)
      			return prev == "" and tag or prev .. "," .. tag
      		end, "")
      
      		local dependencies = core.lua.list.reduce(todo.dependencies, function(prev, dep)
      			return prev == "" and dep or prev .. "," .. dep
      		end, "")
      
      		local roundStart = { "", "TodoRound" }
      		local roundEnd = { "", "TodoRound" }
      		local space = { " ", "TodoSpace" }
      
      		local badges = {
      			{ todo.id, "TodoId" },
      			{ todo.status, "TodoStatus" },
      			{ tags, "TodoTag" },
      			{ dependencies, "TodoDependency" },
      		}
      
      		local result = {}
      		core.lua.list.each(badges, function(badge)
      			if badge[1] ~= "" then
      				table.insert(result, roundStart)
      				table.insert(result, badge)
      				table.insert(result, roundEnd)
      				table.insert(result, space)
      			end
      		end)
      		return result
      	end,
      }
      
      
      local function set_hl()
      	local bg = vim.api.nvim_get_hl(0, { name = "CursorLine" }).bg
      
      	vim.api.nvim_set_hl(0, "TodoId", {
      		fg = "#E0AF68",
      		bg = bg,
      		italic = true,
      	})
      	vim.api.nvim_set_hl(0, "TodoStatus", {
      		fg = "#0DB9D7",
      		bg = bg,
      		italic = true,
      	})
      	vim.api.nvim_set_hl(0, "TodoTag", {
      		fg = "#00FFCC",
      		bg = bg,
      		italic = true,
      	})
      	vim.api.nvim_set_hl(0, "TodoDependency", {
      		fg = "#FF06C1",
      		bg = bg,
      		italic = true,
      	})
      	vim.api.nvim_set_hl(0, "TodoRound", {
      		fg = bg,
      	})
      end
      
    end,
  },
  {
    "QuentinGruber/timespent.nvim",
    config = function()
      
        {
          "quentingruber/timespent.nvim",
          keys = {
            { "<leader>ts", "<cmd>:ShowTimeSpent<cr>", mode = { "n" }, desc = "Show time spent" },
          },
        },
      
    end,
  },
  {
    "SunnyTamang/pendulum.nvim",
  },
  {
    "ptdewey/pendulum-nvim",
    config = function()
      
      {
          "ptdewey/pendulum-nvim",
          config = function()
              require("pendulum").setup()
          end,
      }
      
      
      {
          "ptdewey/pendulum-nvim",
          config = function()
              require("pendulum").setup({
                  gen_reports = false,
              })
          end,
      }
      
      
      require("pendulum").setup({
          log_file = vim.env.HOME .. "/pendulum-log.csv",
          timeout_len = 180,
          timer_len = 120,
          gen_reports = true,
          top_n = 5,
          hours_n = 10,
          time_format = "12h",
          time_zone = "UTC", -- Format "America/New_York"
          report_excludes = {
              branch = {},
              directory = {},
              file = {},
              filetype = {},
              project = {},
          },
          report_section_excludes = {},
      })
      
      
      require('pendulum').setup({
          log_file = vim.fn.expand("$HOME/Documents/my_custom_log.csv"),
          timeout_len = 300,  -- 5 minutes
          timer_len = 60,     -- 1 minute
          gen_reports = true, -- Enable report generation (requires Go)
          top_n = 10,         -- Include top 10 entries in the report
          hours_n = 10,
          time_format = "12h",
          time_zone = "America/New_York",
          report_section_excludes = {
              "branch",       -- Hide `branch` section of the report
              -- Other options includes:
              -- "directory",
              -- "filetype",
              -- "file",
              -- "project",
          },
          report_excludes = {
              filetype = {
                  -- This table controls what to be excluded from `filetype` section
                  "neo-tree", -- Exclude neo-tree filetype
              },
              file = {
                  -- This table controls what to be excluded from `file` section
                  "test.py",  -- Exclude any test.py
                  ".*.go",    -- Exclude all Go files
              }
              project = {
                  -- This table controls what to be excluded from `project` section
                  "unknown_project" -- Exclude unknown (non-git) projects
              },
              directory = {
                  -- This table controls what to be excluded from `directory` section
              },
              branch = {
                  -- This table controls what to be excluded from `branch` section
              },
          },
      })
      
      
      config = function()
          require("pendulum").setup({
              -- disable report generations (avoids Go dependency)
              gen_reports = false,
          })
      end,
      
    end,
  },
  {
    "QuentinGruber/pomodoro.nvim",
    config = function()
      
        {
          "quentingruber/pomodoro.nvim",
          lazy = false, -- needed so the pomodoro can start at launch
          opts = {
            start_at_launch = true,
            work_duration = 25,
            break_duration = 5,
            delay_duration = 1, -- The additionnal work time you get when you delay a break
            long_break_duration = 15,
            breaks_before_long = 4,
            display_ui_on_break = true, -- Disable it if you only want to see the lualine
          },
        },
      
      
      
        {
          "nvim-lualine/lualine.nvim",
          optional = true,
          event = "VeryLazy",
          opts = function(_, opts)
            table.insert(opts.sections.lualine_x, 3, {
              function()
                return require("pomodoro").get_pomodoro_status("🍅❌","🍅","☕")
              end,
            })
          end,
        },
      
      
    end,
  },
  {
    "rlychrisg/truncateline.nvim",
    config = function()
      
      {
        "rlychrisg/truncateline.nvim",
        -- NOTE: these keybinds are not set by default and will need to be set
        -- either here, or wherever you set your keybinds.
        keys = {
            {
                "<leader>l", ":TemporaryToggle<CR>",
                { noremap = true, silent = true, desc = "TruncateLine temporary toggle" },
            },
      
            {
                "<leader>sl", ":ToggleTruncate<CR>",
                { noremap = true, silent = true, desc = "TruncateLine toggle" },
            },
        },
        opts = {
          enabled_on_start = true,
      
          -- this will be appended to the virtual text to distinguish it from the actual text
          -- to disable this behaviour, set truncate_str to ""
          truncate_str = "...",
      
          -- how many characters from the start of the line should be displayed
          -- Note: you might want the total of this setting,
          -- along with truncate_str, to be less than your sidescrolloff
          -- setting, to prevent obscuring text.
          line_start_length = 8,
      
          -- time for in ms for a temporary toggle
          temporary_toggle_dur = 2000,
      
          -- which highlight group should be used for virtual text.
          -- "Comment", or "Normal" are good choices, but anything in
          -- :highlight can be used. you can also create your own and
          -- set the colour in your colour scheme's config.
          hilight_group = "Comment",
        },
      },
      
    end,
  },
  {
    "EL-MASTOR/bufferlist.nvim",
    config = function()
      
      {
        "EL-MASTOR/bufferlist.nvim",
        lazy = true,
        keys = { { "<Leader>b", ':BufferList<CR>', desc = "Open bufferlist" } },
        dependencies = "nvim-tree/nvim-web-devicons",
        cmd = "BufferList",
        opts = {
          -- your configuration comes here
          -- or leave it empty to use the default settings
          -- refer to the configuration section below
        },
      }
      
      
      {
        keymap = {
          close_buf_prefix = "c",
          force_close_buf_prefix = "f",
          save_buf = "s",
          visual_close = "d",
          visual_force_close = "f",
          visual_save = "s",
          multi_close_buf = "m",
          multi_save_buf = "w",
          save_all_unsaved = "a",
          close_all_saved = "d0",
          toggle_path = "p",
          close_bufferlist = "q",
        },
        win_keymaps = {}, -- add keymaps to the BufferList window
        bufs_keymaps = {}, -- add keymaps to each line number in the BufferList window
        width = 40,
        icons = {
          prompt = "", -- for multi_{close,save}_buf prompt
          save_prompt = "󰆓 ",
          line = "▎",
          modified = "󰝥",
        },
        top_prompt = true, -- set this to false if you want the prompt to be at the bottom of the window instead of on top of it.
        show_path = false, -- show the relative paths the first time BufferList window is opened
      }
      
      
      win_keymaps = {
        {
          "<cr>",
          function(opts)
            local curpos = vim.fn.line(".")
            vim.cmd("bwipeout | buffer " .. opts.buffers[curpos])
          end,
        { desc = "BufferList: my description" },
        },
        {
          "r", -- refresh the bufferlist window
          function(opts)
            vim.cmd('bwipeout')
            opts.open_bufferlist()
          end,
          {} -- `desc` here isn't set. So it will be automatically set to "BufferList: custom user defined keymap"
        }
      },
      
      
      bufs_keymaps = {
        {
          "vs",
          function(opts)
            vim.cmd("bwipeout | vs " .. vim.fn.bufname(opts.buffers[opts.line_number]))
          end,
          { desc = "BufferList: show buffer in a split window" }, -- `desc` (if present) will be suffixed with the contents of each line in the BufferList window. for example, this `desc` will be set to: "BufferList: show buffer in a split window  example.lua".
        },
        {
          "h",
          function(opts)
            vim.cmd(":echo 'line_number is: " .. tostring(opts.line_number) .. ", bl_buf is: " .. tostring(opts.bl_buf) .. "'")
          end,
          {}, -- `desc` option is not present here, so it will automatically be set to a pre-set description with the contents of each line in the BufferList window. for example: "BufferList: custom user defined buffers keymap for  example.lua"
        },
      },
      
    end,
  },
  {
    "ellisonleao/dotenv.nvim",
    config = function()
      
      use { "ellisonleao/dotenv.nvim" }
      
      
      require('dotenv').setup()
      
      
      require('dotenv').setup({
        enable_on_load = true, -- will load your .env file upon loading a buffer
        verbose = false, -- show error notification if .env file is not found and if .env is loaded
        file_name = 'myenvfile.env' -- will override the default file name '.env'
      })
      
    end,
  },
  {
    "dzfrias/arena.nvim",
    config = function()
      
      {
        "dzfrias/arena.nvim",
        event = "BufWinEnter",
        -- Calls `.setup()` automatically
        config = true,
      }
      
      
      use {
        "dzfrias/arena.nvim",
        config = function()
          require("arena").setup()
        end
      }
      
      
      {
        -- Maxiumum number of files that the arena window can contain, or `nil` for
        -- an unlimited amount
        max_items = 5,
        -- Always show the enclosing directory for these paths
        always_context = { "mod.rs", "init.lua" },
        -- When set, ignores the current buffer when listing files in the window.
        ignore_current = false,
        -- Options to apply to the arena buffer.
        buf_opts = {
          -- ["relativenumber"] = false,
        },
        -- Filter out buffers per the project they belong to.
        per_project = false,
        --- Add devicons (from nvim-web-devicons, if installed) to buffers
        devicons = false,
      
      
        window = {
          width = 60,
          height = 10,
          border = "rounded",
      
          -- Options to apply to the arena window.
          opts = {},
        },
      
        -- Keybinds for the arena window.
        keybinds = {
            -- ["e"] = function()
            --   vim.cmd("echo \"Hello from the arena!\"")
            -- end
        },
      
        -- Change the way the arena listing looks with custom rendering functions
        renderers = {}
      
        -- Config for frecency algorithm.
        algorithm = {
          -- Multiplies the recency by a factor. Must be greater than zero.
          -- A smaller number will mean less of an emphasis on recency!
          recency_factor = 0.5,
          -- Same as `recency_factor`, but for frequency!
          frequency_factor = 1,
        },
      }
      
      
      require("arena").toggle()
      
      
      require("arena").open()
      
      
      require("arena").close()
      
      
      keybinds = {
        -- An example keybind that prints the linecount of the buffer of the
        -- current line in the window
        ["i"] = function(win)
          local current = win:current()
          local info = vim.fn.getbufinfo(current.bufnr)[1]
          print(info.linecount)
        end,
      }
      
      
      -- Remove the 42nd buffer from the arena window
      require("arena").remove(42)
      
      
      -- Pin the 43rd buffer
      require("arena").pin(43)
      
      
      require("arena").refresh()
      
    end,
  },
  {
    "MisanthropicBit/decipher.nvim",
    config = function()
      
      use 'MisanthropicBit/decipher.nvim'
      
      
      require("decipher").setup({
          float = { -- Floating window options
              padding = 0, -- Zero padding (does not apply to title if any)
              border = { -- Floating window border
                  { "╭", "FloatBorder" },
                  { "─", "FloatBorder" },
                  { "╮", "FloatBorder" },
                  { "│", "FloatBorder" },
                  { "╯", "FloatBorder" },
                  { "─", "FloatBorder" },
                  { "╰", "FloatBorder" },
                  { "│", "FloatBorder" },
              },
              mappings = {
                  close = "q", -- Key to press to close the floating window
                  apply = "a", -- Key to press to apply the encoding/decoding
                  jsonpp = "J", -- Key to prettily format contents as json if possbile
                  help = "?", -- Toggle help
              },
              title = true, -- Display a title with the codec name
              title_pos = "left", -- Position of the title
              autoclose = true, -- Autoclose floating window if insert
                                -- mode is activated or the cursor is moved
              enter = false, -- Automatically enter the floating window if
                             -- opened
              options = {}, -- Options to apply to the floating window contents
          },
      })
      
      
      -- Encode visually selected text as base64. If invoked from normal mode it will
      -- try to use the last visual selection
      vim.keymap.set({ "n", "v" }, "<mykeymap>", function()
          require("decipher").encode_selection("base64")
      end)
      
      -- Decode encoded text using a motion, selecting a codec and previewing the result
      vim.keymap.set("n", "<mykeymap>", function()
          require("decipher").decode_motion_prompt({ preview = true })
      end)
      
    end,
  },
  {
    "philosofonusus/ecolog.nvim",
    config = function()
      
      {
        'ph1losof/ecolog.nvim',
        -- Optional: you can add some keybindings
        -- (I personally use lspsaga so check out lspsaga integration or lsp integration for a smoother experience without separate keybindings)
        keys = {
          { '<leader>ge', '<cmd>EcologGoto<cr>', desc = 'Go to env file' },
          { '<leader>ep', '<cmd>EcologPeek<cr>', desc = 'Ecolog peek variable' },
          { '<leader>es', '<cmd>EcologSelect<cr>', desc = 'Switch env file' },
        },
        -- Lazy loading is done internally
        lazy = false,
        opts = {
          integrations = {
              -- WARNING: for both cmp integrations see readme section below
              nvim_cmp = true, -- If you dont plan to use nvim_cmp set to false, enabled by default
              -- If you are planning to use blink cmp uncomment this line
              -- blink_cmp = true,
          },
          -- Enables shelter mode for sensitive values
          shelter = {
              configuration = {
                  -- Partial mode configuration:
                  -- false: completely mask values (default)
                  -- true: use default partial masking settings
                  -- table: customize partial masking
                  -- partial_mode = false,
                  -- or with custom settings:
                  partial_mode = {
                      show_start = 3,    -- Show first 3 characters
                      show_end = 3,      -- Show last 3 characters
                      min_mask = 3,      -- Minimum masked characters
                  },
                  mask_char = "*",   -- Character used for masking
                  mask_length = nil, -- Optional: fixed length for masked portion (defaults to value length)
                  skip_comments = false, -- Skip masking comment lines in environment files (default: false)
              },
              modules = {
                  cmp = true,       -- Enabled to mask values in completion
                  peek = false,      -- Enable to mask values in peek view
                  files = true, -- Enabled to mask values in file buffers
                  telescope = false, -- Enable to mask values in telescope integration
                  telescope_previewer = false, -- Enable to mask values in telescope preview buffers
                  fzf = false,       -- Enable to mask values in fzf picker
                  fzf_previewer = false, -- Enable to mask values in fzf preview buffers
                  snacks_previewer = false,    -- Enable to mask values in snacks previewer
                  snacks = false,    -- Enable to mask values in snacks picker
              }
          },
          -- true by default, enables built-in types (database_url, url, etc.)
          types = true,
          path = vim.fn.getcwd(), -- Path to search for .env files
          preferred_environment = "development", -- Optional: prioritize specific env files
          -- Controls how environment variables are extracted from code and how cmp works
          provider_patterns = true, -- true by default, when false will not check provider patterns
        },
      }
      
      
      {
        'ph1losof/ecolog.nvim',
        branch = 'beta',
        -- ... rest of your configuration
      }
      
      
      require('cmp').setup({
        sources = {
          { name = 'ecolog' },
          -- your other sources...
        },
      })
      
      
      require('ecolog').setup({
        interpolation = {
          enabled = true,
          disable_security = true,  -- ⚠️ Use with caution!
          -- ... other options
        }
      })
      
      
      require('ecolog').setup({
        -- Enable interpolation with default settings
        interpolation = true,
      
        -- Or disable interpolation
        interpolation = false,
      
        -- Or customize interpolation settings
        interpolation = {
          enabled = true,              -- Enable/disable interpolation
          max_iterations = 10,         -- Maximum iterations for nested interpolation
          warn_on_undefined = true,    -- Warn about undefined variables
          fail_on_cmd_error = false,  -- How to handle command substitution errors
          disable_security = false,    -- Disable security sanitization for command substitution
          features = {
            variables = true,         -- Enable variable interpolation ($VAR, ${VAR})
            defaults = true,         -- Enable default value syntax (${VAR:-default})
            alternates = true,       -- Enable alternate value syntax (${VAR-alternate})
            commands = true,         -- Enable command substitution ($(command))
            escapes = true,         -- Enable escape sequences (\n, \t, etc.)
          }
        }
      })
      
      
      require('ecolog').setup({
        providers = {
          {
            -- Pattern to match environment variable access
            pattern = "ENV%[['\"]%w['\"]%]",
            -- Filetype(s) this provider supports (string or table)
            filetype = "custom_lang",
            -- Function to extract variable name from the line
            extract_var = function(line, col)
              local before_cursor = line:sub(1, col + 1)
              return before_cursor:match("ENV%['\"['\"]%]$")
            end,
            -- Function to return completion trigger pattern
            get_completion_trigger = function()
              return "ENV['"
            end
          }
        }
      })
      
      
      require('ecolog').setup({
        load_shell = true
      })
      
      
      require('ecolog').setup({
        load_shell = {
          enabled = true,     -- Enable shell variable loading
          override = false,   -- When false, .env files take precedence over shell variables
          -- Optional: filter specific shell variables
          filter = function(key, value)
            -- Example: only load specific variables
            return key:match("^(PATH|HOME|USER)$") ~= nil
          end,
          -- Optional: transform shell variables before loading
          transform = function(key, value)
            -- Example: prefix shell variables for clarity
            return "[shell] " .. value
          end
        }
      })
      
      
      require('ecolog').setup({
        monorepo = true,  -- Enable with default configuration
        -- or
        monorepo = {
          enabled = true,
          auto_switch = true,  -- Automatically switch to workspace based on current file
        }
      })
      
      
      require('ecolog').setup({
        monorepo = {
          enabled = true,
          auto_switch = true,
          notify_on_switch = false,  -- Show notifications when switching workspaces
      
          -- Provider configuration
          providers = {
            -- Built-in providers (loaded automatically)
            builtin = {
              "turborepo",
              "nx",
              "lerna",
              "yarn_workspaces",
              "cargo_workspaces"
            },
            -- Custom providers
            custom = {
              {
                module = "my_custom_provider",
                config = { custom_option = "value" }
              }
            }
          },
      
          -- Performance settings
          performance = {
            -- Cache configuration
            cache = {
              max_entries = 1000,
              default_ttl = 300000,     -- 5 minutes
              cleanup_interval = 60000  -- 1 minute
            },
      
            -- Auto-switch throttling
            auto_switch_throttle = {
              min_interval = 100,           -- Minimum ms between checks
              debounce_delay = 250,         -- Debounce delay for rapid changes
              same_file_skip = true,        -- Skip if same file
              workspace_boundary_only = true, -- Only check when crossing boundaries
              max_checks_per_second = 10    -- Rate limiting
            }
          }
        }
      })
      
      
      require('ecolog').setup({
        monorepo = {
          enabled = true,
      
          -- Plugin configuration
          plugins = {
            -- Load plugins from directory
            directory = "/path/to/my/monorepo/plugins",
      
            -- Or register plugins directly
            list = {
              {
                name = "my_monorepo_plugin",
                providers = {
                  {
                    type = "simple",
                    name = "my_simple_provider",
                    detection = {
                      file_markers = { "my-workspace.json" }
                    },
                    workspace = {
                      patterns = { "apps/*", "libs/*" }
                    }
                  }
                },
                hooks = {
                  before_detection = function(path)
                    print("Detecting monorepo at:", path)
                  end,
                  after_workspace_switch = function(new_workspace, old_workspace)
                    print("Switched to workspace:", new_workspace and new_workspace.name or "none")
                  end
                }
              }
            }
          }
        }
      })
      
      
      -- File: lua/my_custom_provider.lua
      local BaseProvider = require("ecolog.monorepo.detection.providers.base")
      
      local MyCustomProvider = {}
      setmetatable(MyCustomProvider, { __index = BaseProvider })
      
      function MyCustomProvider.new(config)
        local default_config = {
          name = "my_custom_provider",
          detection = {
            strategies = { "file_markers" },
            file_markers = { "my-monorepo.json" },
            max_depth = 4,
            cache_duration = 300000,
          },
          workspace = {
            patterns = { "workspaces/*", "projects/*" },
            priority = { "workspaces", "projects" }
          },
          env_resolution = {
            strategy = "workspace_first",
            inheritance = true,
            override_order = { "workspace", "root" }
          },
          priority = 50,
        }
      
        local merged_config = config and vim.tbl_deep_extend("force", default_config, config) or default_config
        local instance = BaseProvider.new(merged_config)
        setmetatable(instance, { __index = MyCustomProvider })
        return instance
      end
      
      return MyCustomProvider
      
      
      -- Using the factory system for quick custom providers
      local Factory = require("ecolog.monorepo.detection.providers.factory")
      
      -- Create from template
      local my_provider = Factory.create_from_template("js_monorepo", {
        name = "my_js_provider",
        detection = {
          file_markers = { "my-package.json" }
        },
        workspace = {
          patterns = { "my-apps/*", "my-packages/*" }
        }
      })
      
      -- Register the provider
      local monorepo = require("ecolog.monorepo")
      monorepo.register_provider(my_provider.new())
      
      
      -- Example: Custom provider with specific resolution
      local MyProvider = {}
      setmetatable(MyProvider, { __index = BaseProvider })
      
      function MyProvider.new(config)
        local default_config = {
          name = "my_provider",
          -- Provider-specific resolution strategy
          env_resolution = {
            strategy = "workspace_first",
            inheritance = true,
            override_order = { "workspace", "root" }
          },
          -- Provider-specific workspace patterns
          workspace = {
            patterns = { "my-apps/*", "my-packages/*" },
            priority = { "my-apps", "my-packages" }
          }
        }
      
        local merged_config = config and vim.tbl_deep_extend("force", default_config, config) or default_config
        local instance = BaseProvider.new(merged_config)
        setmetatable(instance, { __index = MyProvider })
        return instance
      end
      
      return MyProvider
      
      
      local Factory = require("ecolog.monorepo.detection.providers.factory")
      
      -- Available templates: "simple", "js_monorepo", "generic"
      local templates = Factory.get_available_templates()
      
      -- Create from template
      local provider = Factory.create_from_template("js_monorepo", {
        name = "my_js_provider",
        detection = {
          file_markers = { "my-package.json" }
        }
      })
      
      
      -- Opens file in apps/frontend/src/component.tsx
      -- Automatically switches to apps/frontend workspace
      -- Loads environment files from apps/frontend/.env, apps/frontend/.env.local, etc.
      
      
      require('ecolog').setup({
        monorepo = {
          performance = {
            cache = {
              max_entries = 1000,        -- Maximum cache entries
              default_ttl = 300000,      -- 5 minutes default TTL
              cleanup_interval = 60000   -- 1 minute cleanup interval
            }
          }
        }
      })
      
      
      require('ecolog').setup({
        monorepo = {
          performance = {
            auto_switch_throttle = {
              min_interval = 100,               -- Minimum ms between checks
              debounce_delay = 250,             -- Debounce rapid changes
              same_file_skip = true,            -- Skip if same file
              workspace_boundary_only = true,   -- Only check at boundaries
              max_checks_per_second = 10        -- Rate limiting
            }
          }
        }
      })
      
      
      local monorepo = require("ecolog.monorepo")
      
      -- Setup with custom configuration
      monorepo.setup({
        enabled = true,
        providers = {
          builtin = { "turborepo", "nx" }
        }
      })
      
      -- Detection
      local root_path, provider, info = monorepo.detect_monorepo_root()
      if root_path then
        print("Found monorepo at:", root_path)
        print("Provider:", provider.name)
      end
      
      -- Get workspaces
      local workspaces = monorepo.get_workspaces(root_path, provider)
      for _, workspace in ipairs(workspaces) do
        print("Workspace:", workspace.name, "at", workspace.path)
      end
      
      -- Manual workspace switching
      local current_workspace = monorepo.find_current_workspace(nil, workspaces)
      if current_workspace then
        monorepo.set_current_workspace(current_workspace)
      end
      
      -- Register custom provider
      local custom_provider = Factory.create_simple_provider({
        name = "my_provider",
        detection = {
          file_markers = { "my-config.json" }
        }
      })
      monorepo.register_provider(custom_provider.new())
      
      -- Statistics and monitoring
      local stats = monorepo.get_stats()
      print("Monorepo stats:", vim.inspect(stats))
      
      
      {
        vim_env = true, -- false by default
      }
      
      
      -- In your config
      require('ecolog').setup({
        vim_env = true,
        -- ... other options
      })
      
      -- After setup, variables from your .env file will be available in vim.env:
      print(vim.env.DATABASE_URL) -- prints your database URL
      print(vim.env.API_KEY)      -- prints your API key
      
      
         provider_patterns = true  -- Enables both extraction and completion with language patterns
         -- or
         provider_patterns = false -- Disables both, falls back to word under cursor and basic completion
         
      
         provider_patterns = {
           extract = true,  -- Controls variable extraction from code
           cmp = true      -- Controls completion behavior
         }
         
      
         provider_patterns = {
           extract = true,  -- Only extract vars from language patterns
           cmp = true      -- Only complete in valid contexts
         }
         
      
         provider_patterns = {
           extract = false,  -- Extract any word as potential var
           cmp = true       -- Only complete in valid contexts
         }
         
      
         provider_patterns = {
           extract = true,   -- Only extract vars from language patterns
           cmp = false      -- Complete anywhere
         }
         
      
         provider_patterns = {
           extract = false,  -- Extract any word as potential var
           cmp = false      -- Complete anywhere
         }
         
      
      require('ecolog').setup({
        env_file_patterns = { "config/env.*" } -- Matches env.any_here file in the config directory
      })
      
      
      require('ecolog').setup({
        env_file_patterns = {
          "config/.env",      -- Matches .env file in config directory
          "config/.env.*",    -- Matches any .env.* file in config directory
          "environments/*"    -- Matches any file in environments directory
        }
      })
      
      
      -- Match specific environments in config directory
      env_file_patterns = {
        "config/.env.development",
        "config/.env.production"
      }
      
      -- Match all env files in multiple directories
      env_file_patterns = {
        "config/env/*",
        "environments/*",
        ".env*"
      }
      
      -- Match specific naming convention
      env_file_patterns = {
        "env.*.config",
        "env.*.local"
      }
      
      
      require('ecolog').setup({
        sort_file_fn = function(a, b)
          -- Sort by file size (smaller files first)
          local a_size = vim.fn.getfsize(a)
          local b_size = vim.fn.getfsize(b)
          return a_size < b_size
        end
      })
      
      
      sort_file_fn = function(a, b)
        local priority = {
          [".env.production"] = 1,
          [".env.staging"] = 2,
          [".env.development"] = 3,
          [".env"] = 4
        }
        local a_name = vim.fn.fnamemodify(a, ":t")
        local b_name = vim.fn.fnamemodify(b, ":t")
        return (priority[a_name] or 99) < (priority[b_name] or 99)
      end
      
      
      sort_file_fn = function(a, b)
        local a_time = vim.fn.getftime(a)
        local b_time = vim.fn.getftime(b)
        return a_time > b_time  -- Most recently modified first
      end
      
      
      sort_file_fn = function(a, b)
        -- Extract environment type from filename
        local function get_env_type(file)
          local name = vim.fn.fnamemodify(file, ":t")
          return name:match("^%.env%.(.+)$") or ""
        end
        return get_env_type(a) < get_env_type(b)
      end
      
      
      require('ecolog').setup({
        sort_var_fn = function(a, b)
          -- Sort by variable name length (shorter names first)
          return #a.name < #b.name
        end
      })
      
      
      sort_var_fn = function(a, b)
        -- Sort variables with types before those without
        if a.type and not b.type then
          return true
        elseif not a.type and b.type then
          return false
        end
        -- Then sort alphabetically by name
        return a.name < b.name
      end
      
      
      sort_var_fn = function(a, b)
        local priority = {
          [".env.local"] = 1,
          [".env"] = 2,
          ["shell"] = 3
        }
        local a_priority = priority[a.source] or 99
        local b_priority = priority[b.source] or 99
        return a_priority < b_priority
      end
      
      
      sort_var_fn = function(a, b)
        -- Sort API keys first, then database variables, then others
        local function get_category(var)
          if var.name:match("_KEY$") then return 1
          elseif var.name:match("^DB_") then return 2
          else return 3 end
        end
        local a_cat = get_category(a)
        local b_cat = get_category(b)
        if a_cat ~= b_cat then
          return a_cat < b_cat
        end
        return a.name < b.name
      end
      
      
      require('cmp').setup({
        sources = {
          { name = 'ecolog' },
          -- your other sources...
        },
      })
      
      
      require('ecolog').setup({
        integrations = {
          nvim_cmp = false,
        },
      })
      
      
      require('ecolog').setup({
        integrations = {
          blink_cmp = true,
        },
      })
      
      
      {
        "saghen/blink.cmp",
        opts = {
          sources = {
            default = { 'ecolog', 'lsp', 'path', 'snippets', 'buffer' },
            providers = {
              ecolog = { name = 'ecolog', module = 'ecolog.integrations.cmp.blink_cmp' },
            },
          },
        },
      }
      
      
      require('ecolog').setup({
        integrations = {
          omnifunc = true,  -- Enable omnifunc integration with automatic setup (default)
          -- Or with configuration options:
          omnifunc = {
            auto_setup = false,  -- Disable automatic setup, allowing manual configuration
          },
        },
      })
      
      
      require('ecolog').setup({
        shelter = {
          modules = {
            cmp = true,  -- Enable shelter mode for all completion interfaces including omnifunc
          }
        }
      })
      
      
      -- In your configuration, for specific filetypes:
      vim.api.nvim_create_autocmd("FileType", {
        pattern = { "javascript", "typescript", "python" },  -- Add your desired filetypes
        callback = function()
          vim.bo.omnifunc = "v:lua.require'ecolog.integrations.cmp.omnifunc'.complete"
        end,
      })
      
      -- Or for a specific buffer:
      vim.bo.omnifunc = "v:lua.require'ecolog.integrations.cmp.omnifunc'.complete"
      
      
      require('ecolog').setup({
          integrations = {
              lsp = true,
          }
      })
      
      
      require('ecolog').setup({
          integrations = {
              lsp = false,
          }
      })
      
      
      require('ecolog').setup({
          integrations = {
              lspsaga = true,
          }
      })
      
      
      {
        'ph1losof/ecolog.nvim',
        opts = {
          integrations = {
            lspsaga = true,
          }
        },
      }
      
      
      require('telescope').load_extension('ecolog')
      
      
      require('telescope').setup({
        extensions = {
          ecolog = {
            shelter = {
              -- Whether to show masked values when copying to clipboard
              mask_on_copy = false,
            },
            -- Default keybindings
            mappings = {
              -- Key to copy value to clipboard
              copy_value = "<C-y>",
              -- Key to copy name to clipboard
              copy_name = "<C-n>",
              -- Key to append value to buffer
              append_value = "<C-a>",
              -- Key to append name to buffer (defaults to <CR>)
              append_name = "<CR>",
              -- Key to edit environment variable
              edit_var = "<C-e>",
            },
          }
        }
      })
      
      
      require('ecolog').setup({
        integrations = {
          fzf = {
            shelter = {
              mask_on_copy = false, -- Whether to mask values when copying
            },
            mappings = {
              copy_value = "ctrl-y",  -- Copy variable value to clipboard
              copy_name = "ctrl-n",   -- Copy variable name to clipboard
              append_value = "ctrl-a", -- Append value at cursor position
              append_name = "enter",   -- Append name at cursor position
              edit_var = "ctrl-e",     -- Edit environment variable
            },
          }
        }
      })
      
      
      require('ecolog').setup({
        integrations = {
          snacks = {
            shelter = {
              mask_on_copy = false, -- Whether to mask values when copying
            },
            keys = {
              copy_value = "<C-y>",  -- Copy variable value to clipboard
              copy_name = "<C-u>",   -- Copy variable name to clipboard
              append_value = "<C-a>", -- Append value at cursor position
              append_name = "<CR>",   -- Append name at cursor position
              edit_var = "<C-e>",     -- Edit environment variable
            },
            layout = {  -- Any Snacks layout configuration
              preset = "dropdown",
              preview = false,
            },
          }
        }
      })
      
      
      require("ecolog").setup({
        -- Your other configuration options
        integrations = {
          telescope = {
            custom_actions = {
              -- Define a custom action that appends the variable with special formatting
              format_var = {
                key = "<C-f>",
                callback = function(item, picker)
                  -- item contains: name, value, masked_value, source, type
                  return "${" .. item.name .. "}"
                end,
                opts = {
                  close_on_action = true, -- Close the picker after action
                  notify = true,          -- Show notification after action
                  message = "Formatted variable appended" -- Custom notification message
                }
              }
            }
          },
          fzf = {
            custom_actions = {
              -- Similar structure for FZF custom actions
            }
          },
          snacks = {
            custom_actions = {
              -- Similar structure for Snacks custom actions
            }
          }
        }
      })
      
      
      -- For Telescope
      require("telescope").extensions.ecolog.add_action(
        "format_var",          -- Action name
        "<C-f>",               -- Key mapping
        function(item, picker) -- Callback function
          return "${" .. item.name .. "}"
        end,
        {                      -- Options
          close_on_action = true,
          notify = true,
          message = "Formatted variable appended"
        }
      )
      
      -- For FZF
      require("ecolog.integrations.fzf").add_action("format_var", "ctrl-f", function(item, picker)
        return "${" .. item.name .. "}"
      end, { notify = true })
      
      -- For Snacks
      require("ecolog.integrations.snacks").add_action("format_var", "<C-f>", function(item, picker)
        return "${" .. item.name .. "}"
      end, { close_on_action = true })
      
      
      require('ecolog').setup({
        integrations = {
          statusline = {
            hidden_mode = false,  -- Hide when no env file is loaded
            icons = {
              enabled = true,     -- Enable icons in statusline
              env = "🌲",         -- Icon for environment file
              shelter = "🛡️",     -- Icon for shelter mode
            },
            format = {
              env_file = function(name)
                return name       -- Format environment file name
              end,
              vars_count = function(count)
                return string.format("%d vars", count)  -- Format variables count
              end,
            },
            highlights = {
              enabled = true,           -- Enable custom highlights
              env_file = "Directory",   -- Highlight group for file name
              vars_count = "Number",    -- Highlight group for vars count
              icons = "Special"
            },
          }
        }
      })
      
      
      vim.o.statusline = "%{%v:lua.require'ecolog'.get_status()%}"
      
      
      require('lualine').setup({
        sections = {
          lualine_x = {
            require('ecolog.integrations.statusline').lualine(),
          }
        }
      })
      
      
      require('ecolog').setup({
        integrations = {
          statusline = {
            highlights = {
              enabled = true,
              -- Using highlight groups
              env_file = "Directory",   -- Highlight group for file name
              vars_count = "Number",    -- Highlight group for vars count
              icons = "Special",        -- Highlight group for icons
      
              -- OR using hex color codes
              env_file = "#7FBBB3",     -- Hex color for file name
              vars_count = "#A7C080",   -- Hex color for vars count
              icons = "#ED8796",        -- Hex color for icons
      
              -- OR different highlights for env and shelter icons
              icons = {
                env = "String",         -- Highlight group for env icon
                shelter = "WarningMsg"  -- Highlight group for shelter icon
              },
              -- OR with hex colors
              icons = {
                env = "#83C092",        -- Hex color for env icon
                shelter = "#E67E80"     -- Hex color for shelter icon
              }
            },
          }
        }
      })
      
      
      require('ecolog').setup({
        integrations = {
          secret_managers = {
            aws = {
              enabled = true, -- Enable AWS Secrets Manager integration
              override = false, -- When true, AWS secrets take precedence over .env files and shell variables
              region = "us-west-2", -- Required: AWS region where your secrets are stored
              profile = "default", -- Optional: AWS profile to use
              secrets = { -- Optional: List of secret names to fetch on startup
                "my-app/dev/database",
                "my-app/dev/api"
              },
              filter = function(key, value) -- Optional: Filter function for secrets
                return true -- Return true to include the secret, false to exclude it
              end,
              transform = function(key, value) -- Optional: Transform function for secret values
                return value -- Return the transformed value
              end
            }
          }
        }
      })
      
      
      require('ecolog').setup({
        integrations = {
          secret_managers = {
            vault = {
              enabled = true, -- Enable HCP Vault Secrets integration
              override = false, -- When true, Vault secrets take precedence over .env files and shell variables
              apps = { -- Optional: List of application names to fetch secrets from by default
                "sample-app",
                "database"
              },
              filter = function(key, value) -- Optional: Filter function for secrets
                return true -- Return true to include the secret, false to exclude it
              end,
              transform = function(key, value) -- Optional: Transform function for secret values
                return value -- Return the transformed value
              end
            }
          }
        }
      })
      
      
      require('ecolog').setup({
        shelter = {
          modules = {
            telescope_previewer = true, -- Mask values in telescope preview buffers
          }
        }
      })
      
      
      require('ecolog').setup({
        shelter = {
          modules = {
            fzf_previewer = true, -- Mask values in fzf preview buffers
          }
        }
      })
      
      
      require('ecolog').setup({
        shelter = {
          modules = {
            snacks_previewer = true,    -- Mask values in snacks previewer
          }
        }
      })
      
      
      require('ecolog').setup({
          shelter = {
              configuration = {
                  -- Partial mode configuration:
                  -- false: completely mask values (default)
                  -- true: use default partial masking settings
                  -- table: customize partial masking
                  -- partial_mode = false,
                  -- or with custom settings:
                  partial_mode = {
                      show_start = 3,    -- Show first 3 characters
                      show_end = 3,      -- Show last 3 characters
                      min_mask = 3,      -- Minimum masked characters
                  },
                  mask_char = "*",   -- Character used for masking
                  mask_length = nil, -- Optional: fixed length for masked portion (defaults to value length)
                  skip_comments = false, -- Skip masking comment lines in environment files (default: false)
              },
              modules = {
                  cmp = false,       -- Mask values in completion
                  peek = false,      -- Mask values in peek view
                  files = false,     -- Mask values in files
                  telescope = false, -- Mask values in telescope integration
                  telescope_previewer = false, -- Mask values in telescope preview buffers
                  fzf = false,       -- Mask values in fzf picker
                  fzf_previewer = false, -- Mask values in fzf preview buffers
                  snacks = false,    -- Mask values in snacks picker
                  snacks_previewer = false,    -- Mask values in snacks previewer
              }
          },
          path = vim.fn.getcwd(), -- Path to search for .env files
          preferred_environment = "development", -- Optional: prioritize specific env files
      })
      
      
         partial_mode = false
         -- Example: "my-secret-key" -> "************"
         
      
         partial_mode = true
         -- Example: "my-secret-key" -> "my-***-key"
         
      
         partial_mode = {
             show_start = 4,    -- Show more start characters
             show_end = 2,      -- Show fewer end characters
             min_mask = 3,      -- Minimum mask length
         }
         -- Example: "my-secret-key" -> "my-s***ey"
         
      
         shelter = {
             configuration = {
                 partial_mode = false,
                 mask_length = 5  -- All masked values will be 5 characters long
             }
         }
         -- Examples:
         -- "my-secret-key" -> "*****"    -- Long value becomes 5 chars
         -- "short" -> "*****"            -- Short value padded to 5 chars
         -- "very-long-secret" -> "*****" -- Long value truncated to 5 chars
         
      
         shelter = {
             configuration = {
                 partial_mode = true,
                 mask_length = 5  -- Masked portion will be 5 characters
             }
         }
         -- Example: "my-secret-key" -> "my-*****-key"
         -- Example: "short-key" -> "sho*****key"
         
      
      shelter = {
          modules = {
              files = true  -- Simply enable/disable files module
          }
      }
      
      
      shelter = {
          modules = {
              files = {
                  shelter_on_leave = false,  -- Control automatic re-enabling of shelter when leaving buffer
                  disable_cmp = true,        -- Disable completion in sheltered buffers (default: true)
                  skip_comments = false,     -- Skip masking comment lines in environment files (default: false)
              }
          },
          configuration = {
              skip_comments = false,     -- Skip masking comment lines in environment files (default: false)
          }
      }
      
      
      shelter = {
          configuration = {
              -- Pattern-based rules take precedence
              patterns = {
                  ["*_KEY"] = "full",      -- Always fully mask API keys
                  ["TEST_*"] = "none",     -- Never mask test variables
              },
              -- Source-based rules as fallback
              sources = {
                  [".env.*"] = "full",
                  [".env.local"] = "none",
                  ["shell"] = "none",
              },
          }
      }
      
      
         shelter = {
             configuration = {
                mask_char = "•"  -- Use dots
             }
         }
         -- or
         shelter = {
             configuration = {
                mask_char = "█"  -- Use blocks
             }
         }
         
      
         shelter = {
             configuration = {
                highlight_group = "NonText"  -- Use a different highlight group for masked values
             }
         }
         
      
      require('ecolog').setup({
        custom_types = {
            semver = {
              pattern = "^v?%d+%.%d+%.%d+%-?[%w]*$",
              validate = function(value)
                local major, minor, patch = value:match("^v?(%d+)%.(%d+)%.(%d+)")
                return major and minor and patch
              end,
            },
           aws_region = {
            pattern = "^[a-z]{2}%-[a-z]+%-[0-9]$",
            validate = function(value)
              local valid_regions = {
                ["us-east-1"] = true,
                ["us-west-2"] = true,
                -- ... etc
              }
              return valid_regions[value] == true
            end
          }
        },
        types = {
          -- Built-in types
          url = true,          -- URLs (http/https)
          localhost = true,    -- Localhost URLs
          ipv4 = true,        -- IPv4 addresses
          database_url = true, -- Database connection strings
          number = true,       -- Integers and decimals
          boolean = true,      -- true/false/yes/no/1/0
          json = true,         -- JSON objects and arrays
          iso_date = true,     -- ISO 8601 dates (YYYY-MM-DD)
          iso_time = true,     -- ISO 8601 times (HH:MM:SS)
          hex_color = true,    -- Hex color codes (#RGB or #RRGGBB)
        }
      })
      
      
      require('ecolog').setup({
        custom_types = {
          jwt = {
            pattern = "^[A-Za-z0-9%-_]+%.[A-Za-z0-9%-_]+%.[A-Za-z0-9%-_]+$",
            validate = function(value)
              local parts = vim.split(value, ".", { plain = true })
              return #parts == 3
            end
          },
        }
        types = {
          url = true,
          number = true,
        }
      })
      
      
         -- In your config
         if vim.fn.getcwd():match("production") then
           require('ecolog').setup({
             shelter = {
                 configuration = {
                     partial_mode = {
                         show_start = 3,    -- Number of characters to show at start
                         show_end = 3,      -- Number of characters to show at end
                         min_mask = 3,      -- Minimum number of mask characters
                     },
                     mask_char = "*",   -- Character used for masking
                     -- Mask all values from production files
                     sources = {
                         [".env.prod"] = "full",
                         [".env.local"] = "partial",
                         ["shell"] = "none",
                     },
                 },
                 modules = {
                     cmp = true,       -- Mask values in completion
                     peek = true,      -- Mask values in peek view
                     files = true,     -- Mask values in files
                     telescope = false, -- Mask values in telescope
                     telescope_previewer = false, -- Mask values in telescope preview buffers
                 }
             },
             path = vim.fn.getcwd(), -- Path to search for .env files
             preferred_environment = "development", -- Optional: prioritize specific env files
           })
         end
         
      
         shelter = {
             configuration = {
                 -- Mask values based on their source file
                 sources = {
                     [".env.prod"] = "full",
                     [".env.local"] = "partial",
                     ["shell"] = "none",
                 },
                 -- Pattern-based rules take precedence
                 patterns = {
                     ["*_KEY"] = "full",      -- Always fully mask API keys
                     ["TEST_*"] = "none",     -- Never mask test variables
                 },
             }
         }
         
      
         shelter = {
             configuration = {
                mask_char = "•"  -- Use dots
             }
         }
         -- or
         shelter = {
             configuration = {
                mask_char = "█"  -- Use blocks
             }
         }
         -- or
         shelter = {
             configuration = {
                highlight_group = "NonText"  -- Use a different highlight group for masked values
             }
         }
         
      
        {
          'ph1losof/ecolog.nvim',
          keys = {
            { '<leader>e', '', desc = '+ecolog', mode = { 'n', 'v' } },
            { '<leader>el', '<Cmd>EcologShelterLinePeek<cr>', desc = 'Peek line' },
            { '<leader>ey', '<Cmd>EcologCopy<cr>', desc = 'Copy value under cursor' },
            { '<leader>ei', '<Cmd>EcologInterpolationToggle<cr>', desc = 'Toggle interpolation' },
            { '<leader>eh', '<Cmd>EcologShellToggle<cr>', desc = 'Toggle shell variables' },
            { '<leader>ge', '<cmd>EcologGoto<cr>', desc = 'Go to env file' },
            { '<leader>ec', '<cmd>EcologSnacks<cr>', desc = 'Open a picker' },
            { '<leader>eS', '<cmd>EcologSelect<cr>', desc = 'Switch env file' },
            { '<leader>es', '<cmd>EcologShelterToggle<cr>', desc = 'Shelter toggle' },
          },
          opts = {
            preferred_environment = 'local',
            types = true,
            monorepo = {
              enabled = true,
              auto_switch = true,
              notify_on_switch = false,
            },
            providers = {
              {
                pattern = '{{[%w_]+}}?$',
                filetype = 'http',
                extract_var = function(line, col)
                  local utils = require 'ecolog.utils'
                  return utils.extract_env_var(line, col, '{{([%w_]+)}}?$')
                end,
                get_completion_trigger = function()
                  return '{{'
                end,
              },
            },
            interpolation = {
              enabled = true,
              features = {
                commands = false,
              },
            },
            sort_var_fn = function(a, b)
              if a.source == 'shell' and b.source ~= 'shell' then
                return false
              end
              if a.source ~= 'shell' and b.source == 'shell' then
                return true
              end
      
              return a.name < b.name
            end,
            integrations = {
              lspsaga = true,
              blink_cmp = true,
              snacks = true,
              statusline = {
                hidden_mode = true,
                icons = { enabled = true, env = 'E', shelter = 'S' },
                highlights = {
                  env_file = 'Directory',
                  vars_count = 'Number',
                },
              },
            },
            shelter = {
              configuration = {
                patterns = {
                  ['DATABASE_URL'] = 'full',
                },
                sources = {
                  ['.env.example'] = 'none',
                },
                partial_mode = {
                  min_mask = 5,
                  show_start = 1,
                  show_end = 1,
                },
                mask_char = '*',
              },
              modules = {
                files = true,
                peek = false,
                snacks_previewer = true,
                snacks = false,
                cmp = true,
              },
            },
            path = vim.fn.getcwd(),
          },
        }
      
    end,
  },
  {
    "theKnightsOfRohan/hexer.nvim",
    config = function()
      
      return {
          "theKnightsOfRohan/hexer.nvim",
          dependencies = {
              "MunifTanjim/nui.nvim",
          },
          config = function()
              require("hexer").setup()
          end,
      }
      
      
      -- open() parses the passed string arg and opens the hexr buffer, with nil or an empty string representing retaining the past table.
      require("hexer"):open(arg)
      -- close() is how the hexer buffer closes normally. Useful if you want to remap your own close keys.
      -- Note that a BufLeave autocmd is already set for if you leave hexer or open another buffer with it open.
      require("hexer"):close()
      
    end,
  },
  {
    "neanvo/buben.nvim",
    config = function()
      
      {
          "neanvo/buben.nvim",
          dependencies = {
              "nvim-telescope/telescope.nvim",
          },
          opts = {}
      }
      
      
      use {
          "neanvo/buben.nvim",
          requires = { "nvim-telescope/telescope.nvim" },
          config = function()
              require("buben").setup()
          end
      }
      
      
      require("buben").setup({
          -- Path where address mappings will be stored
          storage_path = vim.fn.stdpath("data") .. "/buben_addresses.json",
      
          -- Popup window configuration for address input/editing
          popup = {
              -- Width of the input popup window
              width = 40,
      
              -- Border style for the popup window
              -- Possible values: "none", "single", "double", "rounded", "solid", "shadow"
              border = "rounded",
          },
      
          -- Enable/disable address concealment
          -- When true, the original address will be hidden and only the label will be shown
          conceal = true,
      
          -- Symbol used to point to the label
          -- Can be any string, including Unicode characters (e.g. "→", "⇒", "▶")
          arrow = "→",
      
          -- Enable/disable default highlight groups
          -- Set to false if you want to define all highlights manually
          use_default_highlights = true,
      })
      
      
      vim.keymap.set("n", "<leader>ba", require("buben").add_address, { desc = "Add blockchain address" })
      vim.keymap.set("n", "<leader>bt", require("buben").toggle_visibility, { desc = "Toggle address visibility" })
      vim.keymap.set("n", "<leader>bl", require("buben").open_telescope, { desc = "List addresses" })
      
      
      vim.api.nvim_set_hl(0, "BubenName", { fg = "#98c379", bg = "#565c64" })
      vim.api.nvim_set_hl(0, "BubenChain", { fg = "#61afef", bg = "#565c64" })
      
      
      require("buben").setup({
          use_default_highlights = false
      })
      
      
      -- Define all highlight groups manually
      vim.api.nvim_set_hl(0, "BubenName", { fg = "#c678dd", bold = true })
      vim.api.nvim_set_hl(0, "BubenChain", { fg = "#98c379", italic = true })
      vim.api.nvim_set_hl(0, "BubenSeparator", { fg = "#565c64" })
      vim.api.nvim_set_hl(0, "BubenTitle", { fg = "#e5c07b", bold = true })
      
    end,
  },
  {
    "josephburgess/nvumi",
    config = function()
      
      {
        "josephburgess/nvumi",
        dependencies = { "folke/snacks.nvim" },
        opts = {
          virtual_text = "newline", -- or "inline"
          prefix = " 🚀 ", -- prefix shown before the output
          date_format = "iso", -- or: "uk", "us", "long"
          keys = {
            run = "<CR>", -- run/refresh calculations
            reset = "R", -- reset buffer
            yank = "<leader>y", -- yank output of current line
            yank_all = "<leader>Y", -- yank all outputs
          },
          -- see below for more on custom conversions/functions
          custom_conversions = {},
          custom_functions = {}
        }
      }
      
      
      vim.keymap.set("n", "<leader>on", "<CMD>Nvumi<CR>", { desc = "[O]pen [N]vumi" })
      
      
      {
        opts = {
          custom_conversions = {
            {
              id = "kmh",
              phrases = "kmh, kmph, klicks, kilometers per hour",
              base_unit = "speed",
              format = "km/h",
              ratio = 1,
            },
            {
              id = "mph",
              phrases = "mph, miles per hour",
              base_unit = "speed",
              format = "mph",
              ratio = 1.609344, -- 1 mph = 1.609344 km/h
            },
          },
        }
      }
      
      
      {
        opts = {
          custom_functions = {
            {
              def = { phrases = "square, sqr" },
              fn = function(args)
                if #args < 1 or type(args[1]) ~= "number" then
                  return { error = "square requires a single numeric argument" }
                end
                return { result = args[1] * args[1] }
              end,
            },
            {
              def = { id = "greet", phrases = "hello, hi" },
              fn = function(args)
                local name = args[1] or "stranger"
                return { result = "Hello, " .. name .. "!" }
              end,
            },
            {
              def = { phrases = "coinflip, flip" },
              fn = function()
                return { result = (math.random() > 0.5) and "Heads" or "Tails" }
              end,
            },
          },
        }
      }
      
      
      opts = {
        date_format = "iso", -- or: "uk", "us", "long"
      }
      
    end,
  },
  {
    "redoxahmii/json-to-types.nvim",
    config = function()
      
      {
          "Redoxahmii/json-to-types.nvim",
          build = "sh install.sh npm", -- Replace `npm` with your preferred package manager (e.g., yarn, pnpm).
          ft = "json",
          keys = {
            {
              "<leader>cU",
              "<CMD>ConvertJSONtoLang typescript<CR>",
              desc = "Convert JSON to TS",
            },
            {
              "<leader>ct",
              "<CMD>ConvertJSONtoLangBuffer typescript<CR>",
              desc = "Convert JSON to TS Buffer",
            },
          },
        }
      
      
            {
              "<leader>Rw",
              function()
                require("kulala.api").on("after_next_request", function(data)
                  local filename = "kulala.json"
                  local file = io.open(filename, "w")
                  if not file then
                    print("Error: Failed to open file for writing")
                    return
                  end
                  file:write(data.body)
                  file:close()
                  vim.cmd("edit " .. filename)
                  local buf = vim.api.nvim_get_current_buf()
                  vim.cmd("ConvertJSONtoLang typescript")
                  vim.api.nvim_buf_delete(buf, { force = true })
                  os.remove(filename)
                end)
                require("kulala").run()
              end,
              desc = "Toggle API Callback for JSON to TS Buffer",
            },
      
    end,
  },
  {
    "ovk/endec.nvim",
    config = function()
      
      {
          "ovk/endec.nvim",
          event = "VeryLazy",
          opts = {
              -- Override default configuration here
          }
      }
      
      
      use({
          "ovk/endec.nvim",
          config = function()
              require("endec").setup({
                  -- Override default configuration here
              })
          end
      })
      
      
      keymaps = {
          defaults = false,
      
          encode_base64_inplace = "gB"
      }
      
    end,
  },
  {
    "kiyoon/jupynium.nvim",
    config = function()
      
      use { "kiyoon/jupynium.nvim", run = "pip3 install --user ." }
      -- use { "kiyoon/jupynium.nvim", run = "uv pip install . --python=$HOME/.virtualenvs/jupynium/bin/python" }
      -- use { "kiyoon/jupynium.nvim", run = "conda run --no-capture-output -n jupynium pip install ." }
      use { "rcarriga/nvim-notify" }   -- optional
      use { "stevearc/dressing.nvim" } -- optional, UI for :JupyniumKernelSelect
      
      
        {
          "kiyoon/jupynium.nvim",
          build = "pip3 install --user .",
          -- build = "uv pip install . --python=$HOME/.virtualenvs/jupynium/bin/python",
          -- build = "conda run --no-capture-output -n jupynium pip install .",
        },
        "rcarriga/nvim-notify",   -- optional
        "stevearc/dressing.nvim", -- optional, UI for :JupyniumKernelSelect
      
      
      require("jupynium").setup({
        --- For Conda environment named "jupynium",
        -- python_host = { "conda", "run", "--no-capture-output", "-n", "jupynium", "python" },
        python_host = vim.g.python3_host_prog or "python3",
      
        default_notebook_URL = "localhost:8888/nbclassic",
      
        -- Write jupyter command but without "notebook"
        -- When you call :JupyniumStartAndAttachToServer and no notebook is open,
        -- then Jupynium will open the server for you using this command. (only when notebook_URL is localhost)
        jupyter_command = "jupyter",
        --- For Conda, maybe use base environment
        --- then you can `conda install -n base nb_conda_kernels` to switch environment in Jupyter Notebook
        -- jupyter_command = { "conda", "run", "--no-capture-output", "-n", "base", "jupyter" },
      
        -- Used when notebook is launched by using jupyter_command.
        -- If nil or "", it will open at the git directory of the current buffer,
        -- but still navigate to the directory of the current buffer. (e.g. localhost:8888/nbclassic/tree/path/to/buffer)
        notebook_dir = nil,
      
        -- Used to remember the last session (password etc.).
        -- e.g. '~/.mozilla/firefox/profiles.ini'
        -- or '~/snap/firefox/common/.mozilla/firefox/profiles.ini'
        firefox_profiles_ini_path = nil,
        -- nil means the profile with Default=1
        -- or set to something like 'default-release'
        firefox_profile_name = nil,
      
        -- Open the Jupynium server if it is not already running
        -- which means that it will open the Selenium browser when you open this file.
        -- Related command :JupyniumStartAndAttachToServer
        auto_start_server = {
          enable = false,
          file_pattern = { "*.ju.*" },
        },
      
        -- Attach current nvim to the Jupynium server
        -- Without this step, you can't use :JupyniumStartSync
        -- Related command :JupyniumAttachToServer
        auto_attach_to_server = {
          enable = true,
          file_pattern = { "*.ju.*", "*.md" },
        },
      
        -- Automatically open an Untitled.ipynb file on Notebook
        -- when you open a .ju.py file on nvim.
        -- Related command :JupyniumStartSync
        auto_start_sync = {
          enable = false,
          file_pattern = { "*.ju.*", "*.md" },
        },
      
        -- Automatically keep filename.ipynb copy of filename.ju.py
        -- by downloading from the Jupyter Notebook server.
        -- WARNING: this will overwrite the file without asking
        -- Related command :JupyniumDownloadIpynb
        auto_download_ipynb = true,
      
        -- Automatically close tab that is in sync when you close buffer in vim.
        auto_close_tab = true,
      
        -- Always scroll to the current cell.
        -- Related command :JupyniumScrollToCell
        autoscroll = {
          enable = true,
          mode = "always", -- "always" or "invisible"
          cell = {
            top_margin_percent = 20,
          },
        },
      
        scroll = {
          page = { step = 0.5 },
          cell = {
            top_margin_percent = 20,
          },
        },
      
        -- Files to be detected as a jupynium file.
        -- Add highlighting, keybindings, commands (e.g. :JupyniumStartAndAttachToServer)
        -- Modify this if you already have lots of files in Jupytext format, for example.
        jupynium_file_pattern = { "*.ju.*" },
      
        use_default_keybindings = true,
        textobjects = {
          use_default_keybindings = true,
        },
      
        syntax_highlight = {
          enable = true,
        },
      
        -- Dim all cells except the current one
        -- Related command :JupyniumShortsightedToggle
        shortsighted = false,
      
        -- Configure floating window options
        -- Related command :JupyniumKernelHover
        kernel_hover = {
          floating_win_opts = {
            max_width = 84,
            border = "none",
          },
        },
      
        notify = {
          ignore = {
            -- "download_ipynb",
            -- "error_download_ipynb",
            -- "attach_and_init",
            -- "error_close_main_page",
            -- "notebook_closed",
          },
        },
      })
      
      -- You can link highlighting groups.
      -- This is the default (when colour scheme is unknown)
      -- Try with CursorColumn, Pmenu, Folded etc.
      vim.cmd [[
      hi! link JupyniumCodeCellSeparator CursorLine
      hi! link JupyniumMarkdownCellSeparator CursorLine
      hi! link JupyniumMarkdownCellContent CursorLine
      hi! link JupyniumMagicCommand Keyword
      ]]
      
      -- Please share your favourite settings on other colour schemes, so I can add defaults.
      -- Currently, tokyonight is supported.
      
      
      local cmp = require "cmp"
      local compare = cmp.config.compare
      
      cmp.setup {
        sources = {
          { name = "jupynium", priority = 1000 },  -- consider higher priority than LSP
          { name = "nvim_lsp", priority = 100 },
          -- ...
        },
        sorting = {
          priority_weight = 1.0,
          comparators = {
            compare.score,            -- Jupyter kernel completion shows prior to LSP
            compare.recently_used,
            compare.locality,
            -- ...
          },
        },
      }
      
      
      require("blink.cmp").setup {
        sources = {
          default = {
            "jupynium",
            -- ...
          },
          providers = {
            jupynium = {
              name = "Jupynium",
              module = "jupynium.blink_cmp",
              -- Consider higher priority than LSP
              score_offset = 100,
            },
            -- ...
          },
        },
      }
      
      
      require("jupynium").get_folds()
      
      
      --- Execute javascript in the browser. It will switch to the correct tab before executing.
      ---@param bufnr: integer | nil If given, before executing the code it will switch to the tab of this buffer. Requires syncing in advance.
      ---@param code string Javascript code
      ---@return boolean, object: Success, response
      Jupynium_execute_javascript(bufnr, code)
      
      
      -- Use bufnr=nil if you don't want to switch tab
      local code = [[return [Jupyter.notebook.kernel.name, Jupyter.kernelselector.kernelspecs];]]
      local status_ok, kernel_name_and_spec = Jupynium_execute_javascript(0, code)
      if status_ok then
        local kernel_name = kernel_name_and_spec[1]   -- "python3"
        local kernel_spec = kernel_name_and_spec[2]
        local kernel_language = kernel_spec[kernel_name].spec.language  -- "python"
        local kernel_display_name = kernel_spec[kernel_name].spec.display_name  -- "Python 3 (ipykernel)"
      end
      
    end,
  },
  {
    "y3owk1n/time-machine.nvim",
    config = function()
      
      -- time-machine.lua
      return {
       "y3owk1n/time-machine.nvim",
       version = "*", -- remove this if you want to use the `main` branch
       opts = {
        -- your configuration comes here
        -- or leave it empty to use the default settings
        -- refer to the configuration section below
       }
      }
      
      
      require("time-machine").setup({
        -- your configuration
      })
      
      
      vim.opt.undofile = true                      -- Enable persistent undo
      vim.opt.undodir = vim.fn.expand("~/.undodir") -- Set custom undo directory
      
      
      ---@type TimeMachine.Config
      {
       split_opts = {
        split = "left", -- where to open the tree panel
        width = 50, -- columns number
       },
       float_opts = {
        width = 0.8, -- between 0 and 1
        height = 0.8, -- between 0 and 1
        winblend = 0,
       },
       diff_tool = "native", -- default diff engine
       native_diff_opts = { -- only used when diff_tool is "native"
        result_type = "unified",
        ctxlen = 3,
        algorithm = "histogram",
       },
       external_diff_args = {}, -- set additional arguments for external diff tools
       keymaps = {
        undo = "u",
        redo = "<C-r>",
        restore_undopoint = "<CR>",
        refresh_timeline = "r",
        preview_sequence_diff = "p",
        tag_sequence = "t",
        close = "q",
        help = "g?",
        toggle_current_timeline = "c",
       },
       ignore_filesize = nil, -- e.g. 10 * 1024 * 1024
       ignored_filetypes = {
        "terminal",
        "nofile",
        "time-machine-list",
        "mason",
        "snacks_picker_list",
        "snacks_picker_input",
        "snacks_dashboard",
        "snacks_notif_history",
        "lazy",
       },
       time_format = "relative", -- "pretty"|"relative"|"unix"
       log_level = vim.log.levels.WARN,
       log_file = vim.fn.stdpath("cache") .. "/time-machine.log",
      }
      
      
      ---@alias TimeMachine.DiffTool "native"|TimeMachine.DiffToolExternal
      ---@alias TimeMachine.DiffToolExternal "difft"|"diff"|"delta"
      ---@alias TimeMachine.SplitDirection 'left'|'right'
      
      ---@class TimeMachine.Config
      ---@field diff_tool? TimeMachine.DiffTool The diff tool to use
      ---@field native_diff_opts? vim.diff.Opts The options for vim.diff
      ---@field external_diff_args? table<TimeMachine.DiffToolExternal, string[]> The arguments for external diff tools
      ---@field ignore_filesize? integer|nil The file size to ignore undo saved to disk
      ---@field ignored_filetypes? string[] The file types to ignore undo saved to disk
      ---@field split_opts? TimeMachine.Config.SplitOpts The split options
      ---@field float_opts? TimeMachine.Config.FloatOpts The floating window options
      ---@field keymaps? TimeMachine.Config.Keymaps The keymaps for actions
      ---@field time_format? "pretty"|"relative"|"unix" The time format to display
      ---@field log_level? integer The log level
      ---@field log_file? string The log file path
      
      ---@class TimeMachine.Config.Keymaps
      ---@field undo? string The keymap to undo
      ---@field redo? string The keymap to redo
      ---@field restore_undopoint? string The keymap to restore the undopoint
      ---@field refresh_timeline? string The keymap to refresh the timeline
      ---@field preview_sequence_diff? string The keymap to preview the sequence diff
      ---@field tag_sequence? string The keymap to tag the sequence
      ---@field close? string The keymap to close the timeline
      ---@field help? string The keymap to show the help
      ---@field toggle_current_timeline? string The keymap to toggle to only show the current timeline
      
      ---@class TimeMachine.Config.SplitOpts
      ---@field split? TimeMachine.SplitDirection The split direction
      ---@field width? integer The width of the split
      
      ---@class TimeMachine.Config.FloatOpts
      ---@field width? integer The width of the window
      ---@field height? integer The height of the window
      ---@field winblend? integer The winblend of the window
      
      
      {
       "y3owk1n/time-machine.nvim",
       cmd = {
        "TimeMachineToggle",
        "TimeMachinePurgeBuffer",
        "TimeMachinePurgeAll",
        "TimeMachineLogShow",
        "TimeMachineLogClear",
       },
       ---@type TimeMachine.Config
       opts = {},
       keys = {
        {
         "<leader>t",
         "",
         desc = "Time Machine",
        },
        {
         "<leader>tt",
         "<cmd>TimeMachineToggle<cr>",
         desc = "[Time Machine] Toggle Tree",
        },
        {
         "<leader>tx",
         "<cmd>TimeMachinePurgeCurrent<cr>",
         desc = "[Time Machine] Purge current",
        },
        {
         "<leader>tX",
         "<cmd>TimeMachinePurgeAll<cr>",
         desc = "[Time Machine] Purge all",
        },
        {
         "<leader>tl",
         "<cmd>TimeMachineLogShow<cr>",
         desc = "[Time Machine] Show log",
        },
       },
      },
      
      
      require("time-machine").toggle()
      
      -- or any of the equivalents
      
      :TimeMachineToggle
      :lua require("time-machine").toggle()
      
      
      ---@param force? boolean Whether to force the purge
      require("time-machine").purge_buffer(force)
      
      -- or any of the equivalents
      
      :TimeMachinePurgeBuffer
      :TimeMachinePurgeBuffer! -- force
      :lua require("time-machine").purge_buffer()
      
      
      ---@param force? boolean Whether to force the purge
      require("time-machine").purge_all(force)
      
      -- or any of the equivalents
      
      :TimeMachinePurgeAll
      :TimeMachinePurgeAll! -- force
      :lua require("time-machine").purge_all()
      
      
      require("time-machine").show_log()
      
      -- or any of the equivalents
      
      :TimeMachineLogShow
      :lua require("time-machine").show_log()
      
      
      require("time-machine").clear_log()
      
      -- or any of the equivalents
      
      :TimeMachineLogClear
      :lua require("time-machine").clear_log()
      
      
      vim.api.nvim_create_autocmd("User", {
        pattern = "TimeMachineUndoCreated",
        callback = function()
          -- do something
        end,
      })
      
      
      vim.api.nvim_set_hl(0, "TimeMachineCurrent", { link = "Visual" })
      vim.api.nvim_set_hl(0, "TimeMachineCurrent", { fg = "#7dcfff", bold = true })
      
      
      {
       "catppuccin/nvim",
       optional = true,
       opts = function(_, opts)
        local colors = require("catppuccin.palettes").get_palette()
      
        local c_utils = require("catppuccin.utils.colors")
      
        ---@type {[string]: CtpHighlight}
        local highlights = {
         TimeMachineCurrent = {
          bg = c_utils.darken(colors.blue, 0.18, colors.base)
         },
         TimeMachineTimeline = { fg = colors.blue, style = { "bold" } },
         TimeMachineTimelineAlt = { fg = colors.overlay2 },
         TimeMachineKeymap = { fg = colors.teal, style = { "italic" } },
         TimeMachineInfo = { fg = colors.subtext0, style = { "italic" } },
         TimeMachineSeq = { fg = colors.peach, style = { "bold" } },
         TimeMachineTag = { fg = colors.yellow, style = { "bold" } },
        }
      
        opts.custom_highlights = opts.custom_highlights or {}
      
        for key, value in pairs(highlights) do
         opts.custom_highlights[key] = value
        end
       end,
      },
      
    end,
  },
  {
    "BibekBhusal0/bufstack.nvim",
    config = function()
      
      return {
          'BibekBhusal0/bufstack.nvim',
          dependencies = {
              'MunifTanjim/nui.nvim',        -- required if you want to use menu
              'nvim-lua/plenary.nvim'        -- required to shorten path
          },
          opts = {
              max_tracked = 16,
              shorten_path = true
          }
      }
      
      
      require('bufstack').setup({
        max_tracked = 16, -- Default: 16
        shorten_path = true, -- Default: false
      })
      
      
      vim.keymap.set('n', '<leader>bn', '<Cmd>BufStackNext<CR>')
      vim.keymap.set('n', '<leader>bp', '<Cmd>BufStackPrev<CR>')
      vim.keymap.set('n', '<leader>bl', '<Cmd>BufStackList<CR>')
      vim.keymap.set('n', '<leader>br', '<Cmd>BufReopen<CR>')
      
    end,
  },
  {
    "OXY2DEV/ui.nvim",
    config = function()
      
      {
          "OXY2DEV/ui.nvim",
          lazy = false
      };
      
      
      return {
          "OXY2DEV/ui.nvim",
          lazy = false
      };
      
      
      local MiniDeps = require("mini.deps");
      
      MiniDeps.add({
          source = "OXY2DEV/ui.nvim"
      });
      
      
      require("ui").setup({
          popupmenu = {
              enable = true,
      
              winconfig = {},
              tooltip = nil,
      
              styles = {
                  default = {
                      padding_left = " ",
                      padding_right = " ",
      
                      icon = nil,
                      text = nil,
      
                      normal_hl = nil,
                      select_hl = "CursorLine",
                      icon_hl = nil
                  },
      
                  example = {
                      condition = function ()
                          return true;
                      end,
      
                      icon = "I "
                  }
              }
          },
      
          cmdline = {
              enable = true,
      
              styles = {
                  default = {
                      cursor = "Cursor",
                      filetype = "vim",
      
                      icon = { { "I ", "@comment" } },
                      offset = 0,
      
                      title = nil,
                      winhl = ""
                  },
      
                  example = {
                      condition = function ()
                          return true;
                      end,
      
                      cursor = "@comment"
                  }
              }
          },
      
          message = {
              enable = true,
              wrap_notify = true,
              respect_replace_last = true,
      
              message_winconfig = {},
              list_winconfig = {},
              confirm_winconfig = {},
              history_winconfig = {},
      
              ignore = function ()
                  return false:
              end,
      
              showcmd = {
                  max_width = 10,
                  modifier = nil
              },
      
              msg_styles = {
                  default = {
                      duration = 500,
      
                      modifier = nil,
                      decorations = {
                          icon = { { "I " } }
                      }
                  },
      
                  example = {
                      condition = function ()
                          return true;
                      end,
      
                      decorations = {
                          icon = { { "B " } }
                      }
                  }
              },
      
              is_list = function ()
                  return false;
              end,
      
              list_styles = {
                  default = {
                      modifier = nil,
      
                      row = nil,
                      col = nil,
      
                      width = nil,
                      height = nil,
      
                      winhl = nil
                  },
      
                  example = {
                      condition = function ()
                          return true;
                      end,
      
                      border = "rounded"
                  }
              },
              confirm_styles = {
                  default = {
                      modifier = nil,
      
                      row = nil,
                      col = nil,
      
                      width = nil,
                      height = nil,
      
                      winhl = nil
                  },
      
                  example = {
                      condition = function ()
                          return true;
                      end,
      
                      border = "rounded"
                  }
              }
          }
      });
      
    end,
  },
  {
    "athar-qadri/weather.nvim",
    config = function()
      
      {
        "athar-qadri/weather.nvim",
        dependencies = {
          "nvim-lua/plenary.nvim",  -- Required for HTTP requests
          "rcarriga/nvim-notify",   -- Optional, for notifications
        },
        config = function()
          local weather = require("weather")
          weather:setup({
            settings = {
              update_interval = 60 * 10 * 1000,  -- 10 minutes
              minimum_magnitude = 5,
              location = { lat = 34.0787, lon = 74.7659 },
              temperature_unit = "celsius",
            },
          })
          require("weather.notify").start()  -- Start notifications
        end,
      }
      
      
      use {
        'athar-qadri/weather.nvim',
        requires = {
          {'nvim-lua/plenary.nvim'},         -- Required for HTTP requests
          {'rcarriga/nvim-notify'},          -- Optional, for notifications
          {'nvim-lualine/lualine.nvim'},     -- Optional, for status line integration
        }
      }
      
      
      require('weather'):setup({
        settings = {
          update_interval = 15 * 60 * 1000,  -- 15 minutes in milliseconds
          temperature_unit = "celsius",      -- "celsius" or "fahrenheit"
          location = { lat = 37.7749, lon = -122.4194 },  -- Optional fixed location
        },
        default = {
          minimum_magnitude = 4.0,           -- Minimum earthquake magnitude for alerts
          minimum_radius = 20,               -- Minimum radius in km for earthquake alerts
          default_sources = { "meteo", "usgs" },  -- Data sources
        },
      })
      
      
      require('lualine').setup({
        options = {
          theme = {
            normal = {
              a = { bg = "#65D1FF", fg = "#112638", gui = "bold" },
              b = { bg = "#112638", fg = "#c3ccdc" },
              c = { bg = "#112638", fg = "#c3ccdc" },
            },
            -- Other modes defined...
          },
        },
        sections = {
          lualine_x = {
            { require("weather.lualine").default_c() },
            {
              require("lazy.status").updates,
              cond = require("lazy.status").has_updates,
              color = { fg = "#ff9e64" },
            },
            { "lsp_status" },
            { "filesize" },
            { "filetype" },
          },
        },
      })
      
    end,
  },
  {
    "Penaz91/MiniDYM",
  },
  {
    "attilarepka/header.nvim",
    config = function()
      
      use({ "attilarepka/header.nvim", config = function() require("header").setup() end})
      
      
      {"attilarepka/header.nvim", config = true}
      
      
      {
          allow_autocmds = true,
          file_name = true,
          author = nil,
          project = nil,
          date_created = true,
          date_created_fmt = "%Y-%m-%d %H:%M:%S",
          date_modified = true,
          date_modified_fmt = "%Y-%m-%d %H:%M:%S",
          line_separator = "------",
          use_block_header = true,
          copyright_text = nil,
          license_from_file = false,
      }
      
      
      require("header").setup({
        -- your override config
      })
      
      
      require("header").setup({
          allow_autocmds = true,
          file_name = true,
          author = "Foo",
          project = "header.nvim",
          date_created = true,
          date_created_fmt = "%Y-%m-%d %H:%M:%S",
          date_modified = true,
          date_modified_fmt = "%Y-%m-%d %H:%M:%S",
          line_separator = "------",
          use_block_header = false,
          copyright_text = "Copyright 2023",
          license_from_file = false,
      })
      
      
      require("header").setup({
          ...
          license_from_file = true
      })
      
      
      local header = require("header")
      
      vim.keymap.set("n", "<leader>hh", function() header.add_headers() end)
      -- see supported licenses below, method handles case-insensitively
      vim.keymap.set("n", "<leader>hm", function() header.add_license_header("mit") end)
      
      
      local augroup = vim.api.nvim_create_augroup
      local autocmd = vim.api.nvim_create_autocmd
      
      augroup("mygroup", { clear = true })
      
      autocmd("BufWritePre", {
          pattern = "*",
          callback = function()
              local header = require("header")
              if header and header.update_date_modified then
                  header.update_date_modified()
              else
                  vim.notify_once("header.update_date_modified is not available", vim.log.levels.WARN)
              end
          end,
          group = "mygroup",
          desc = "Update header's date modified",
      })
      
      
      local augroup = vim.api.nvim_create_augroup
      local autocmd = vim.api.nvim_create_autocmd
      
      augroup("mygroup", { clear = true })
      
      autocmd({ "BufNewFile", "BufReadPost" }, {
        pattern = "*",
        callback = function()
          local header = require("header")
          if not header then
            vim.notify_once(
              "Could not automatically add header to new file: header module couldn't be found",
              vim.log.levels.ERROR
            )
            return
          end
      
          local lines = vim.api.nvim_buf_get_lines(0, 0, -1, false)
          local is_empty = #lines == 1 and lines[1] == ""
      
          if header.config.allow_autocmds and is_empty then
            local original_fmt = header.config.date_created_fmt
            local now = os.date(header.config.date_created_fmt, os.time())
      
            -- force add_headers to use the current datetime, otherwise it will show 1970-01-01
            header.config.date_created_fmt = now
            header.add_headers()
      
            header.config.date_created_fmt = original_fmt -- restore the original format
          end
        end,
        group = "mygroup",
        desc = "Add copyright header to new/empty files",
      })
      
      
    end,
  },
  {
    "Owen-Dechow/videre.nvim",
    config = function()
      
        return {
            "Owen-Dechow/videre.nvim",
            cmd = "Videre",
            dependencies = {
                "Owen-Dechow/graph_view_yaml_parser", -- Optional: add YAML support
                "Owen-Dechow/graph_view_toml_parser", -- Optional: add TOML support
                "a-usr/xml2lua.nvim", -- Optional | Experimental: add XML support
            },
            opts = {
                round_units = false,
                simple_statusline = true, -- If you are just starting out with Videre,
                                          --   setting this to `false` will give you
                                          --   descriptions of available keymaps.
            }
        }
        
      
        vim.pack.add {
            "https://github.com/Owen-Dechow/videre.nvim",
            "https://github.com/Owen-Dechow/graph_view_yaml_parser", -- Optional: add YAML support
            "https://github.com/Owen-Dechow/graph_view_toml_parser", -- Optional: add TOML support
            "https://github.com/a-usr/xml2lua.nvim", -- Optional | Experimental: add XML support
        }
        
        require('videre').setup {
            round_units = false,
            simple_statusline = true, -- If you are just starting out with Videre,
                                      --   setting this to `false` will give you
                                      --   descriptions of available keymaps.
        }
        
      
        {
            -- set the window editor type
            editor_type = "split", -- split, floating
        
            -- configure the floating window style
            floating_editor_style = {
                margin = 2,
                border = "double",
                zindex = 10
            },
        
            -- Number of lines before collapsing
            max_lines = 5,
        
            -- Set the unit style to round
            round_units = true,
        
            -- Set the connection style to round
            round_connections = true,
        
            -- Disable line wrapping for the graph buffer
            disable_line_wrap = true,
        
            -- Set side scroll off for graph buffer
            side_scrolloff = 20,
        
            -- Change the string between the keymap and
            --   description of callback within the statusline
            -- FOR FONTS WITH LIGATURES TRY USING "꞊" INSTEAD OF "=". 
            -- Other great options include "->", ": ", "=>", & " ".
            keymap_desc_deliminator = "=",
        
            -- Character used to represent empty space
            space_char = "·",
        
            -- Use simple statusline instead of providing
            --   descriptions of keymaps.
            simple_statusline = true,   
        
            -- Show breadcrumbs to show where you are in
            --   a Videre graph.
            breadcrumbs = true,
        
            -- Set the priority of keymaps for the quick
            --   action keymap.
            keymap_priorities = {
                    expand = 5,
                    link_forward = 4,
                    link_backward = 3,
                    link_down = 1,
                    link_up = 1,
                    collapse = 2,
                    set_as_root = 1,
            },
        
            -- Set the keys actions will be mapped to
            keymaps = {
                -- Expanding collapsed areas
                expand = "E",
        
                -- Collapse expanded areas
                collapse = "E",
        
                -- Jump to linked unit
                link_forward = "L",
        
                -- Jump back to unit parent
                link_backward = "H",
        
                -- Jump down a unit
                link_down = "J",
        
                -- Jump up a unit
                link_up = "K",
        
                -- Set current unit as root
                set_as_root = "R",
        
                -- Aliased to first priority available keymap
                quick_action = "<CR>",
        
                -- Close the window
                close_window = "q",
        
                -- Open the help menu
                help = "g?",
        
                -- Change the key of the current field
                change_key = "C",
        
                -- Change the value of the current field
                change_value = "V",
        
                -- Delete the current field
                delete_field = "D",
        
                -- Add a field to the unit 
                add_field = "A",
            }
        }
        
    end,
  },
  {
    "mahyarmirrashed/famous-quotes.nvim",
    config = function()
      
      use 'mahyarmirrashed/famous-quotes'
      
      
      {
        "mahyarmirrashed/famous-quotes.nvim",
        config = function()
          require("famous-quotes").setup()
        end,
      }
      
      
      -- Get one random quote (default)
      local quote = require('famous-quotes').get_quote()
      print(quote[1].author .. ': ' .. quote[1].quote)
      
      -- Get three random quotes
      local quotes = require('famous-quotes').get_quote(3)
      for _, q in ipairs(quotes) do
        print(q.author .. ': ' .. q.quote)
      end
      
      -- Get all quotes
      local all_quotes = require('famous-quotes').get_quote(-1)
      
    end,
  },
  {
    "iquzart/toggleword.nvim",
    config = function()
      
      {
        "iquzart/toggleword.nvim",
         opts = {
           key = "<leader>tt" -- optional, defaults to <leader>tt,
         }
      }
      
      
      use {
        "yourname/toggleword.nvim",
        config = function()
          require("toggleword").setup()
        end,
      }
      
      
      require("toggleword").setup {
        key = "<leader>tw",
        toggle_groups = {
          {"start", "stop"},
          {"open",  "close"},
          {"active", "inactive"},
        }
      }
      
    end,
  },
  {
    "johannww/tts.nvim",
    config = function()
      
      {
          "johannww/tts.nvim",
          cmd = { "TTS", "TTSFile" },
          dependencies = { "nvim-lua/plenary.nvim" },
          opts = {
              voice = "en-GB-SoniaNeural",
              speed = 1.0,
          },
      },
      
      
    end,
  },
  {
    "piersolenski/brewfile.nvim",
    config = function()
      
      return {
        "piersolenski/brewfile.nvim",
        opts = {
          -- Auto-dump Brewfile after brew commands finish
          dump_on_change = true,
          -- Show confirmation prompts for uninstall actions
          confirmation_prompt = true,
        },
        keys = {
          {
            "<leader>b",
            desc = "Brewfile",
          },
          {
            "<leader>bi",
            function()
              require("brewfile").install()
            end,
            desc = "Brew install package",
            mode = { "n" },
          },
          {
            "<leader>br",
            function()
              require("brewfile").dump()
            end,
            desc = "Dump Brewfile and refresh the buffer",
            mode = { "n" },
          },
          {
            "<leader>bo",
            function()
              require("brewfile").open_homepage()
            end,
            desc = "Open package homepage",
            mode = { "n" },
          },
          {
            "<leader>bd",
            function()
              require("brewfile").uninstall()
            end,
            desc = "Brew uninstall package",
            mode = { "n" },
          },
          {
            "<leader>bD",
            function()
              require("brewfile").force_uninstall()
            end,
            desc = "Brew force uninstall package",
            mode = { "n" },
          },
          {
            "<leader>bI",
            function()
              require("brewfile").info()
            end,
            desc = "Brew package info",
            mode = { "n" },
          },
          {
            "<leader>bu",
            function()
              require("brewfile").upgrade()
            end,
            desc = "Brew upgrade package",
            mode = { "n" },
          },
        },
      }
      
    end,
  },
  {
    "ravsii/timers.nvim",
    config = function()
      
      {
        'ravsii/timers.nvim',
        version = "*", -- use latest stable release
        -- See below, empty is fine
        opts = {},
      }
      
      
      {
        'ravsii/timers.nvim',
        ---@module "timers.config"
        ---@type Config
        opts = {
          -- Save timers across reloads / sessions.
          -- If true, neovim will save your active timers on disk and load them
          -- back after you enter it again.
          -- Keep in mind that timer is _still_ ticking, even when Neovim is
          -- closed.
          persistent = false,
          -- Default values for new timers, if they weren't passed explicitly.
          default_timer = {
            icon = "󱎫",
            log_level = vim.log.levels.INFO,
            message = "Timer Finished!",
            title = "timers.nvim",
          },
          dashboard = {
            -- Dashboard update interval, ms.
            -- Timers don't show anything below seconds (ms, ns, etc) anyways.
            update_interval = 1000,
            -- [0,1] for percentage of the screen, (1,∞) for an absolute value.
            width = 0.8,
            -- [0,1] for percentage of the screen, (1,∞) for an absolute value.
            height = 0.8,
            -- Font to use. Available fonts: DiamFont, Terrace, tmplr.
            -- Or, you can provide a custom font using "fonts" field and use its name
            font = "DiamFont",
            fonts = { }, -- See: Custom fonts
          },
        },
      }
      
      
      {
        'ravsii/timers.nvim',
        ---@module "timers.config"
        ---@type Config
        opts = {
          dashboard = {
            fonts = {
              Terrace = {
                -- change padding between letters. It's 1 by default.
                padding = 10,
                -- replace a letter
                ["s"] = {
                  "    ",
                  " ▄▄▄",
                  "▀▄▄ ",
                  "▄▄▄▀",
                },
              },
            },
          },
        },
      }
      
      
      ---@alias FontTable table<string, Font>
      ---@alias Font {
      ---  padding?: number,
      ---  ["s"]: string[],
      ---  [":"]: string[],
      ---  ["0"]: string[],
      ---  ["1"]: string[],
      ---  ["2"]: string[],
      ---  ["3"]: string[],
      ---  ["4"]: string[],
      ---  ["5"]: string[],
      ---  ["6"]: string[],
      ---  ["7"]: string[],
      ---  ["8"]: string[],
      ---  ["9"]: string[],
      ---}
      
      
      {
        'ravsii/timers.nvim',
        ---@module "timers.config"
        ---@type Config
        opts = {
          dashboard = {
            font = "MyFont"
            fonts = {
              MyFont = {
                padding = 2,
                  ["s"] = {
                    " ",
                    "┏",
                    "┛",
                  },
                  [":"] = {
                    " ",
                    "•",
                    "•",
                  },
                  -- other letters...
              },
            },
          },
        },
      }
      
      
      {
        "ravsii/timers.nvim",
        keys = {
          { "<leader>T", "", desc = "+timers" },
          { "<leader>Ta", function() require("timers.ui").active_timers() end, desc = "Active timers" },
          { "<leader>Td", function() require("timers.ui").dashboard() end, desc = "Dashboard" },
          { "<leader>Tn", function() require("timers.ui").create_timer() end, desc = "New timer" },
          { "<leader>Tc", function() require("timers.ui").cancel() end, desc = "Cancel a timer" },
          { "<leader>TC", function() require("timers.ui").cancel_all() end, desc = "Cancel all timers" },
          { "<leader>Tr", function() require("timers.ui").resume() end, desc = "Resume a timer" },
          { "<leader>Tp", function() require("timers.ui").pause() end, desc = "Pause a timer" },
        },
      }
      
      
      local d = require("timers.duration")
      local u = require("timers.unit")
      
      -- Create durations
      local d1 = d.from(5000) -- milliseconds
      local d2 = d.from(5 * u.SECOND)
      local d3 = d.parse_format("5h5m5s")
      
      -- Convert
      local ms = d3:asMilliseconds() -- 18305000
      local sec = d3:asSeconds() -- 18305
      
      -- Arithmetic
      local diff = d3:sub(d1)
      local diff2 = d3:sub(1000) -- remove 1s from d3
      
      -- Display
      local str = d3:into_hms() -- "05:05:05"
      
      
      local d = require("timers.duration")
      local t = require("timers.timer")
      local u = require("timers.unit")
      
      -- Create a timer (not started yet)
      local timer1 = t.new(d.from(5000)) -- 5 seconds
      -- Duration (first argument) can also be a number in milliseconds.
      local timer2 = t.new(5000, { message = "Done!" }) -- number in ms + options
      
      local pomodoro_timer = t.new(d.from(25 * u.MINUTE), {
        -- Options:
        -- message, icon, title, log_level, on_start, on_finish
        title = "Pomodoro",
        message = "Pomodoro is over",
        icon = "",
        on_finish = function()
          m.start_timer(break_timer)
        end,
      })
      
      -- Access fields
      print(timer1.created) -- creation time (os.time)
      print(timer1.duration:asSeconds()) -- duration in seconds
      
      -- Get remaining time after starting
      local remaining = timer1:expire_in()
      print(remaining:asMilliseconds())
      
      
      local c = require("timers.config")
      local d = require("timers.duration")
      local m = require("timers.manager")
      local t = require("timers.timer")
      local u = require("timers.unit")
      
      -- Create a timer
      local timer_obj = t.new(d.from(5000), { message = "Done!" })
      
      -- Start the timer
      -- It returns id and cancel-func, so you can cancel your timer somewhere
      -- else
      local id, cancel = m.start_timer(timer_obj)
      
      -- Cancel a timer
      cancel() -- using the cancel function
      m.cancel(id) -- or by ID directly
      
      -- Cancel all timers
      m.cancel_all()
      
      -- Pausing and resuming timers
      m.pause(id)
      m.resume(id)
      
      -- Query timers
      local closest_timer = m.get_closest_timer()
      local all_timers = m.timers()
      local active_count = m.timers_count()
      
      
      local pomodoro_25_5 = function()
        local t = require("timers.timer")
        local d = require("timers.duration")
        local u = require("timers.unit")
        local m = require("timers.manager")
      
        local break_duration = d.from(5 * u.MINUTE)
        local break_timer = t.new(break_duration, {
          message = "Break is over",
          title = "Break",
          log_level = vim.log.levels.WARN,
          icon = "⏾",
        })
      
        local ppomodoro_duration = d.from(25 * u.MINUTE)
        local pomodoro_timer = t.new(ppomodoro_duration, {
          title = "Pomodoro",
          message = "Pomodoro is over",
          icon = "",
          on_finish = function()
            m.start_timer(break_timer)
          end,
        })
      
        m.start_timer(pomodoro_timer)
      end
      
      -- and in keys you can now use
      keys = {
        { "<leader>Tp", pomodoro_25_5, desc = "Start Pomodoro 25/5 timer" },
      }
      
      
      local d = require("timers.duration")
      local m = require("timers.manager")
      local t = require("timers.timer")
      local u = require("timers.unit")
      
      local infinite_timer -- new var here, so we can access it in on_finish
      infinite_timer = t.new(d.from(5 * u.SECOND), {
        title = "Infinite",
        message = "It never ends",
        icon = "♾️",
        on_finish = function()
          m.start_timer(infinite_timer)
        end,
      })
      
      m.start_timer(infinite_timer)
      
      
      {
        'nvim-lualine/lualine.nvim',
        opts = {
          sections = {
            -- other secions
            lualine_z = {
              { function() return require("timers.integrations.lualine").closest_timer() end },
              { 'progress' },
            },
          },
        },
      }
      
    end,
  },
  {
    "VidocqH/data-viewer.nvim",
    config = function()
      
      requir("lazy").setup({
        {
          'vidocqh/data-viewer.nvim',
          opts = {},
          dependencies = {
            "nvim-lua/plenary.nvim",
            "kkharji/sqlite.lua", -- Optional, sqlite support
          }
        },
      })
      
      
      local config = {
        autoDisplayWhenOpenFile = false,
        maxLineEachTable = 100,
        columnColorEnable = true,
        columnColorRoulette = { -- Highlight groups
          "DataViewerColumn0",
          "DataViewerColumn1",
          "DataViewerColumn2",
        },
        view = {
          float = true, -- False will open in current window
          width = 0.8, -- Less than 1 means ratio to screen width, valid when float = true
          height = 0.8, -- Less than 1 means ratio to screen height, valid when float = true
          zindex = 50, -- Valid when float = true
        },
        keymap = {
          quit = "q",
          next_table = "<C-l>",
          prev_table = "<C-h>",
        },
      }
      
    end,
  },
  {
    "theKnightsOfRohan/csvlens.nvim",
    config = function()
      
      return {
          "theKnightsOfRohan/csvlens.nvim",
          dependencies = {
              "akinsho/toggleterm.nvim"
          },
          config = true,
          opts = { --[[ Place your opts here ]] }
      }
      
      
      require("csvlens").setup({
          direction = "float", -- "float" | "vertical" | "horizontal" |  "tab"
          exec_path = "csvlens", -- You can specify the path to the executable if you wish. Otherwise, it will use the command in the PATH.
          exec_install_path = vim.fn.stdpath("data") .. "/csvlens.nvim/", -- directory to install the executable to if it's not found in the exec_path, ends with /
      })
      
    end,
  },
  {
    "emmanueltouzery/decisive.nvim",
    config = function()
      
      vim.keymap.set('n', '<leader>cca', ":lua require('decisive').align_csv({})<cr>", {desc="align CSV", silent=true})
      vim.keymap.set('n', '<leader>ccA', ":lua require('decisive').align_csv_clear({})<cr>", {desc="align CSV clear", silent=true})
      vim.keymap.set('n', '[c', ":lua require('decisive').align_csv_prev_col()<cr>", {desc="align CSV prev col", silent=true})
      vim.keymap.set('n', ']c', ":lua require('decisive').align_csv_next_col()<cr>", {desc="align CSV next col", silent=true})
      
      -- setup text objects (optional)
      require('decisive').setup{}
      
      
      return {
        "emmanueltouzery/decisive.nvim",
        config = function()
          require('decisive').setup{}
        end,
        lazy=true,
        ft = {'csv'},
        keys = {
          { '<leader>cca', ":lua require('decisive').align_csv({})<cr>",       { silent = true }, desc = "Align CSV",          mode = 'n' },
          { '<leader>ccA', ":lua require('decisive').align_csv_clear({})<cr>", { silent = true }, desc = "Align CSV clear",    mode = 'n' },
          { '[c', ":lua require('decisive').align_csv_prev_col()<cr>",         { silent = true }, desc = "Align CSV prev col", mode = 'n' },
          { ']c', ":lua require('decisive').align_csv_next_col()<cr>",         { silent = true }, desc = "Align CSV next col", mode = 'n' },
        }
      }
      
    end,
  },
  {
    "hat0uma/csvview.nvim",
    config = function()
      
      {
        "hat0uma/csvview.nvim",
        ---@module "csvview"
        ---@type CsvView.Options
        opts = {
          parser = { comments = { "#", "//" } },
          keymaps = {
            -- Text objects for selecting fields
            textobject_field_inner = { "if", mode = { "o", "x" } },
            textobject_field_outer = { "af", mode = { "o", "x" } },
            -- Excel-like navigation:
            -- Use <Tab> and <S-Tab> to move horizontally between fields.
            -- Use <Enter> and <S-Enter> to move vertically between rows and place the cursor at the end of the field.
            -- Note: In terminals, you may need to enable CSI-u mode to use <S-Tab> and <S-Enter>.
            jump_next_field_end = { "<Tab>", mode = { "n", "v" } },
            jump_prev_field_end = { "<S-Tab>", mode = { "n", "v" } },
            jump_next_row = { "<Enter>", mode = { "n", "v" } },
            jump_prev_row = { "<S-Enter>", mode = { "n", "v" } },
          },
        },
        cmd = { "CsvViewEnable", "CsvViewDisable", "CsvViewToggle" },
      }
      
      
      {
        parser = {
          --- The number of lines that the asynchronous parser processes per cycle.
          --- This setting is used to prevent monopolization of the main thread when displaying large files.
          --- If the UI freezes, try reducing this value.
          --- @type integer
          async_chunksize = 50,
      
          --- Specifies the delimiter character to separate columns.
          --- This can be configured in one of three ways:
          ---
          --- 1. As a single string for a fixed delimiter.
          ---    e.g., delimiter = ","
          ---
          --- 2. As a function that dynamically returns the delimiter.
          ---    e.g., delimiter = function(bufnr) return "\t" end
          ---
          --- 3. As a table for advanced configuration:
          ---    - `ft`: Maps filetypes to specific delimiters. This has the highest priority.
          ---    - `fallbacks`: An ordered list of delimiters to try for automatic detection
          ---      when no `ft` rule matches. The plugin will test them in sequence and use
          ---      the first one that highest scores based on the number of fields in each line.
          ---
          --- Note: Only fixed-length strings are supported as delimiters.
          --- Regular expressions (e.g., `\s+`) are not currently supported.
          --- @type CsvView.Options.Parser.Delimiter
          delimiter = {
            ft = {
              csv = ",",
              tsv = "\t",
            },
            fallbacks = {
              ",",
              "\t",
              ";",
              "|",
              ":",
              " ",
            },
          },
      
          --- The quote character
          --- If a field is enclosed in this character, it is treated as a single field and the delimiter in it will be ignored.
          --- e.g:
          ---  quote_char= "'"
          --- You can also specify it on the command line.
          --- e.g:
          --- :CsvViewEnable quote_char='
          --- @type string
          quote_char = '"',
      
          --- The comment prefix characters
          --- If the line starts with one of these characters, it is treated as a comment.
          --- Comment lines are not displayed in tabular format.
          --- You can also specify it on the command line.
          --- e.g:
          --- :CsvViewEnable comment=#
          --- @type string[]
          comments = {
            -- "#",
            -- "--",
            -- "//",
          },
      
          --- Maximum lookahead for multi-line fields
          --- This limits how many lines ahead the parser will look when trying to find 
          --- the closing quote of a multi-line field. Setting this too high may cause
          --- performance issues when editing files with unmatched quotes.
          --- @type integer
          max_lookahead = 50,
        },
        view = {
          --- minimum width of a column
          --- @type integer
          min_column_width = 5,
      
          --- spacing between columns
          --- @type integer
          spacing = 2,
      
          --- The display method of the delimiter
          --- "highlight" highlights the delimiter
          --- "border" displays the delimiter with `│`
          --- You can also specify it on the command line.
          --- e.g:
          --- :CsvViewEnable display_mode=border
          ---@type CsvView.Options.View.DisplayMode
          display_mode = "highlight",
      
          --- The line number of the header row
          --- Controls which line should be treated as the header for the CSV table.
          --- This affects both visual styling and the sticky header feature.
          ---
          --- Values:
          --- - `true`: Automatically detect the header line (default)
          --- - `integer`: Specific line number to use as header (1-based)
          --- - `false`: No header line, treat all lines as data rows
          ---
          --- When a header is defined, it will be:
          --- - Highlighted with the CsvViewHeaderLine highlight group
          --- - Used for the sticky header feature if enabled
          --- - Excluded from normal data processing in some contexts
          ---
          --- See also: `view.sticky_header`
          --- @type integer|false|true
          header_lnum = true,
      
          --- The sticky header feature settings
          --- If `view.header_lnum` is set, the header line is displayed at the top of the window.
          sticky_header = {
            --- Whether to enable the sticky header feature
            --- @type boolean
            enabled = true,
      
            --- The separator character for the sticky header window
            --- set `false` to disable the separator
            --- @type string|false
            separator = "─",
          },
        },
      
        --- Keymaps for csvview.
        --- These mappings are only active when csvview is enabled.
        --- You can assign key mappings to each action defined in `opts.actions`.
        --- For example:
        --- 
      
      -- Simple event logging
      local group = vim.api.nvim_create_augroup("CsvViewEvents", {})
      
      vim.api.nvim_create_autocmd("User", {
        pattern = "CsvViewAttach",
        group = group,
        callback = function(args)
          local bufnr = tonumber(args.data)
          print("CSV view enabled for buffer", bufnr)
        end,
      })
      
      vim.api.nvim_create_autocmd("User", {
        pattern = "CsvViewDetach", 
        group = group,
        callback = function(args)
          local bufnr = tonumber(args.data)
          print("CSV view disabled for buffer", bufnr)
        end,
      })
      
    end,
  },
  {
    "LuxVim/nvim-luxmotion",
    config = function()
      
      {
        "LuxVim/nvim-luxmotion",
        config = function()
          require("luxmotion").setup({
            cursor = {
              duration = 250,
              easing = "ease-out",
              enabled = true,
            },
            scroll = {
              duration = 400,
              easing = "ease-out",
              enabled = true,
            },
            performance = { enabled = false },
            keymaps = {
              cursor = true,
              scroll = true,
            },
          })
        end,
      }
      
      
      use {
        "LuxVim/nvim-luxmotion",
        config = function()
          require("luxmotion").setup()
        end
      }
      
      
      lua << EOF
      require("luxmotion").setup()
      EOF
      
      
      require("luxmotion").setup({
        cursor = {
          duration = 250,       -- Cursor animation duration (ms)
          easing = "ease-out",  -- Cursor easing function
          enabled = true,
        },
        scroll = {
          duration = 400,       -- Scroll animation duration (ms)
          easing = "ease-out",  -- Scroll easing function
          enabled = true,
        },
        performance = {
          enabled = false,      -- Enable performance mode
        },
        keymaps = {
          cursor = true,        -- Enable cursor motion keymaps
          scroll = true,        -- Enable scroll motion keymaps
        },
      })
      
      
      local luxmotion = require("luxmotion")
      
      -- Global control
      luxmotion.enable()
      luxmotion.disable()
      luxmotion.toggle()
      
      -- Individual controls
      luxmotion.enable_cursor()
      luxmotion.disable_cursor()
      luxmotion.enable_scroll()
      luxmotion.disable_scroll()
      
      -- Performance mode
      local performance = require("luxmotion.performance")
      performance.enable()
      performance.disable()
      performance.toggle()
      performance.is_active()
      
      -- Manual motion (if custom keymaps are used)
      local cursor_keymaps = require("luxmotion.cursor.keymaps")
      cursor_keymaps.smooth_move("j", 5)
      cursor_keymaps.smooth_word_move("w", 3)
      cursor_keymaps.smooth_find_move("f", "x", 2)
      cursor_keymaps.smooth_text_object_move("}", 1)
      
      
      require("luxmotion").setup({
        keymaps = {
          cursor = false,
          scroll = false,
        },
      })
      
      -- Define your own
      local cursor_keymaps = require("luxmotion.cursor.keymaps")
      vim.keymap.set("n", "j", function()
        cursor_keymaps.smooth_move("j", vim.v.count1)
      end)
      
      
      require("luxmotion").setup({
        cursor = {
          duration = 100,
          easing = "linear",
        },
        scroll = {
          duration = 500,
          easing = "ease-out",
        },
      })
      
      
      require("luxmotion").setup({
        cursor = {
          duration = 150,
          easing = "linear",
        },
        performance = { enabled = true },
      })
      
    end,
  },
  {
    "sphamba/smear-cursor.nvim",
    config = function()
      
      return {
        "sphamba/smear-cursor.nvim",
        opts = {},
      }
      
      
      return {
        "sphamba/smear-cursor.nvim",
      
        opts = {
          -- Smear cursor when switching buffers or windows.
          smear_between_buffers = true,
      
          -- Smear cursor when moving within line or to neighbor lines.
          -- Use `min_horizontal_distance_smear` and `min_vertical_distance_smear` for finer control
          smear_between_neighbor_lines = true,
      
          -- Draw the smear in buffer space instead of screen space when scrolling
          scroll_buffer_space = true,
      
          -- Set to `true` if your font supports legacy computing symbols (block unicode symbols).
          -- Smears will blend better on all backgrounds.
          legacy_computing_symbols_support = false,
      
          -- Smear cursor in insert mode.
          -- See also `vertical_bar_cursor_insert_mode` and `distance_stop_animating_vertical_bar`.
          smear_insert_mode = true,
        },
      }
      
      
      >   opts = {
      >     -- Smear cursor color. Defaults to Cursor GUI color if not set.
      >     -- Set to "none" to match the text color at the target cursor position.
      >     cursor_color = "#d3cdc3",
      >   }
      > 
      
        opts = {                                -- Default  Range
          stiffness = 0.8,                      -- 0.6      [0, 1]
          trailing_stiffness = 0.6,             -- 0.45     [0, 1]
          stiffness_insert_mode = 0.7,          -- 0.5      [0, 1]
          trailing_stiffness_insert_mode = 0.7, -- 0.5      [0, 1]
          damping = 0.95,                       -- 0.85     [0, 1]
          damping_insert_mode = 0.95,           -- 0.9      [0, 1]
          distance_stop_animating = 0.5,        -- 0.1      > 0
        },
      
      
        opts = {
          time_interval = 7, -- milliseconds
        },
      
      
      >   opts = {
      >     cursor_color = "#ff8800",
      >     stiffness = 0.3,
      >     trailing_stiffness = 0.1,
      >     damping = 0.5,
      >     trailing_exponent = 5,
      >     never_draw_over_target = true,
      >     hide_target_hack = true,
      >     gamma = 1,
      >   }
      > 
      
        opts = {
          stiffness = 0.5,
          trailing_stiffness = 0.5,
          matrix_pixel_threshold = 0.5,
        },
      
      
        opts = {
          legacy_computing_symbols_support = true,
        },
      
      
        opts = {
          transparent_bg_fallback_color = "#303030",
        },
      
      
        opts = {
          cterm_cursor_colors = { 240, 245, 250, 255 },
          cterm_bg = 235,
        }
      
      
        opts = {
          hide_target_hack = true,
          never_draw_over_target = true,
        }
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-animate.md",
  },
  {
    "rachartier/tiny-glimmer.nvim/",
  },
  {
    "y3owk1n/undo-glow.nvim/",
  },
  {
    "gen740/SmoothCursor.nvim",
    config = function()
      
      use { 'gen740/SmoothCursor.nvim',
        config = function()
          require('smoothcursor').setup()
        end
      }
      
      
      { 'gen740/SmoothCursor.nvim',
        config = function()
          require('smoothcursor').setup()
        end
      }
      
      
      require('smoothcursor').setup({
          type = "default",           -- Cursor movement calculation method, choose "default", "exp" (exponential) or "matrix".
      
          cursor = "",              -- Cursor shape (requires Nerd Font). Disabled in fancy mode.
          texthl = "SmoothCursor",   -- Highlight group. Default is { bg = nil, fg = "#FFD400" }. Disabled in fancy mode.
          linehl = nil,              -- Highlights the line under the cursor, similar to 'cursorline'. "CursorLine" is recommended. Disabled in fancy mode.
      
          fancy = {
              enable = false,        -- enable fancy mode
              head = { cursor = "▷", texthl = "SmoothCursor", linehl = nil }, -- false to disable fancy head
              body = {
                  { cursor = "󰝥", texthl = "SmoothCursorRed" },
                  { cursor = "󰝥", texthl = "SmoothCursorOrange" },
                  { cursor = "●", texthl = "SmoothCursorYellow" },
                  { cursor = "●", texthl = "SmoothCursorGreen" },
                  { cursor = "•", texthl = "SmoothCursorAqua" },
                  { cursor = ".", texthl = "SmoothCursorBlue" },
                  { cursor = ".", texthl = "SmoothCursorPurple" },
              },
              tail = { cursor = nil, texthl = "SmoothCursor" } -- false to disable fancy tail
          },
      
          matrix = {  -- Loaded when 'type' is set to "matrix"
              head = {
                  -- Picks a random character from this list for the cursor text
                  cursor = require('smoothcursor.matrix_chars'),
                  -- Picks a random highlight from this list for the cursor text
                  texthl = {
                      'SmoothCursor',
                  },
                  linehl = nil,  -- No line highlight for the head
              },
              body = {
                  length = 6,  -- Specifies the length of the cursor body
                  -- Picks a random character from this list for the cursor body text
                  cursor = require('smoothcursor.matrix_chars'),
                  -- Picks a random highlight from this list for each segment of the cursor body
                  texthl = {
                      'SmoothCursorGreen',
                  },
              },
              tail = {
                  -- Picks a random character from this list for the cursor tail (if any)
                  cursor = nil,
                  -- Picks a random highlight from this list for the cursor tail
                  texthl = {
                      'SmoothCursor',
                  },
              },
              unstop = false,  -- Determines if the cursor should stop or not (false means it will stop)
          },
      
          autostart = true,           -- Automatically start SmoothCursor
          always_redraw = true,       -- Redraw the screen on each update
          flyin_effect = nil,         -- Choose "bottom" or "top" for flying effect
          speed = 25,                 -- Max speed is 100 to stick with your current position
          intervals = 35,             -- Update intervals in milliseconds
          priority = 10,              -- Set marker priority
          timeout = 3000,             -- Timeout for animations in milliseconds
          threshold = 3,              -- Animate only if cursor moves more than this many lines
          max_threshold = nil,        -- If you move more than this many lines, don't animate (if `nil`, deactivate check)
          disable_float_win = false,  -- Disable in floating windows
          enabled_filetypes = nil,    -- Enable only for specific file types, e.g., { "lua", "vim" }
          disabled_filetypes = nil,   -- Disable for these file types, ignored if enabled_filetypes is set. e.g., { "TelescopePrompt", "NvimTree" }
          -- Show the position of the latest input mode positions. 
          -- A value of "enter" means the position will be updated when entering the mode.
          -- A value of "leave" means the position will be updated when leaving the mode.
          -- `nil` = disabled
          show_last_positions = nil,  
      })
      
      
      local autocmd = vim.api.nvim_create_autocmd
      
      autocmd({ 'ModeChanged' }, {
        callback = function()
          local current_mode = vim.fn.mode()
          if current_mode == 'n' then
            vim.api.nvim_set_hl(0, 'SmoothCursor', { fg = '#8aa872' })
            vim.fn.sign_define('smoothcursor', { text = '' })
          elseif current_mode == 'v' then
            vim.api.nvim_set_hl(0, 'SmoothCursor', { fg = '#bf616a' })
            vim.fn.sign_define('smoothcursor', { text = '' })
          elseif current_mode == 'V' then
            vim.api.nvim_set_hl(0, 'SmoothCursor', { fg = '#bf616a' })
            vim.fn.sign_define('smoothcursor', { text = '' })
          elseif current_mode == '' then
            vim.api.nvim_set_hl(0, 'SmoothCursor', { fg = '#bf616a' })
            vim.fn.sign_define('smoothcursor', { text = '' })
          elseif current_mode == 'i' then
            vim.api.nvim_set_hl(0, 'SmoothCursor', { fg = '#668aab' })
            vim.fn.sign_define('smoothcursor', { text = '' })
          end
        end,
      })
      
      
      vim.fn.sign_define('smoothcursor_v', { text = ' ' })
      vim.fn.sign_define('smoothcursor_V', { text = '' })
      vim.fn.sign_define('smoothcursor_i', { text = '' })
      vim.fn.sign_define('smoothcursor_�', { text = '' })
      vim.fn.sign_define('smoothcursor_R', { text = '󰊄' })
      
    end,
  },
  {
    "cxwx/specs.nvim",
    config = function()
      
      use {'edluffy/specs.nvim'}
      
      
      require('specs').setup{ 
          show_jumps  = true,
          min_jump = 30,
          popup = {
              delay_ms = 0, -- delay before popup displays
              inc_ms = 10, -- time increments used for fade/resize effects 
              blend = 10, -- starting blend, between 0-100 (fully transparent), see :h winblend
              width = 10,
              winhl = "PMenu",
              fader = require('specs').linear_fader,
              resizer = require('specs').shrink_resizer
          },
          ignore_filetypes = {},
          ignore_buftypes = {
              nofile = true,
          },
      }
      
      
      require('specs').setup{ 
          popup = {
      	-- Simple constant blend effect
              fader = function(blend, cnt)
                  if cnt > 100 then
                      return 80
                  else return nil end
              end,
      	-- Growing effect from left to right
              resizer = function(width, ccol, cnt)
                  if width-cnt > 0 then
                      return {width+cnt, ccol}
                  else return nil end
              end,
          }
      }
      
      
      -- Press <C-b> to call specs!
      vim.api.nvim_set_keymap('n', '<C-b>', ':lua require("specs").show_specs()', { noremap = true, silent = true })
      
      -- You can even bind it to search jumping and more, example:
      vim.api.nvim_set_keymap('n', 'n', 'n:lua require("specs").show_specs()<CR>', { noremap = true, silent = true })
      vim.api.nvim_set_keymap('n', 'N', 'N:lua require("specs").show_specs()<CR>', { noremap = true, silent = true })
      
      -- Or maybe you do a lot of screen-casts and want to call attention to a specific line of code:
      vim.api.nvim_set_keymap('n', '<leader>v', ':lua require("specs").show_specs({width = 97, winhl = "Search", delay_ms = 610, inc_ms = 21})<CR>', { noremap = true, silent = true })
      
    end,
  },
  {
    "LuxVim/nvim-luxterm",
    config = function()
      
      {
        "luxvim/nvim-luxterm",
        config = function()
          require("luxterm").setup({
            -- Optional configuration
            manager_width = 0.8,
            manager_height = 0.8,
            preview_enabled = true,
            auto_hide = true,
            keymaps = {
              toggle_manager = "<C-/>",
            }
          })
        end
      }
      
      
      use {
        "luxvim/nvim-luxterm",
        config = function()
          require("luxterm").setup()
        end
      }
      
      
      require("luxterm").setup({
        -- Your configuration here
      })
      
      
      require("luxterm").setup({
        -- Manager window dimensions (0.1 to 1.0)
        manager_width = 0.8,          -- 80% of screen width
        manager_height = 0.8,         -- 80% of screen height
        
        -- Enable live preview pane
        preview_enabled = true,
        
        -- Focus new sessions when created via :LuxtermNew
        focus_on_create = false,
        
        -- Auto-hide floating windows when cursor leaves
        auto_hide = true,
        
        -- Keybinding configuration
        keymaps = {
          toggle_manager = "<C-/>",     -- Toggle session manager
          next_session = "<C-k>",       -- Next session keybinding
          prev_session = "<C-j>",       -- Previous session keybinding
          global_session_nav = false,   -- Enable global session navigation
        }
      })
      
      
      -- Get API after setup
      local luxterm = require("luxterm").setup()
      
      -- Create and manage sessions
      local session = luxterm.create_session({ name = "work", activate = true })
      luxterm.delete_session(session.id, { confirm = true })
      luxterm.switch_session(session.id)
      
      -- Manager control
      luxterm.toggle_manager()
      local is_open = luxterm.is_manager_open()
      
      -- Information retrieval
      local sessions = luxterm.get_sessions()
      local active = luxterm.get_active_session()
      local stats = luxterm.get_stats()
      local config = luxterm.get_config()
      
      
      -- Session validation and status
      session:is_valid()           -- Returns true if session buffer is valid
      session:get_status()         -- Returns "running" or "stopped"
      session:activate()           -- Make this session the active one
      
      -- Content preview
      local preview = session:get_content_preview()  -- Returns array of preview lines
      
      
      require("luxterm").setup({
        preview_enabled = false,      -- Disable preview pane
        manager_width = 0.6,         -- Smaller window
        auto_hide = false,           -- Keep windows open
        keymaps = {
          toggle_manager = "<C-t>",   -- Use Ctrl+T instead
        }
      })
      
      
      require("luxterm").setup({
        keymaps = {
          next_session = "<C-k>",         -- Next session
          prev_session = "<C-j>",         -- Previous session
          global_session_nav = true,      -- Enable global navigation (works everywhere)
        }
      })
      
      
      -- Apply a preset after setup
      require("luxterm.config").apply_preset("minimal")    -- No preview, smaller window
      require("luxterm.config").apply_preset("compact")    -- 60% screen, preview enabled
      require("luxterm.config").apply_preset("full_screen") -- 95% screen, no auto-hide
      
      
      -- Additional custom keybindings after setup
      vim.keymap.set("n", "<leader>tn", ":LuxtermNew<CR>", { desc = "New terminal" })
      vim.keymap.set("n", "<leader>tl", ":LuxtermList<CR>", { desc = "List terminals" })
      vim.keymap.set("n", "<leader>tk", ":LuxtermKill<CR>", { desc = "Kill terminal" })
      vim.keymap.set("n", "<leader>tj", ":LuxtermNext<CR>", { desc = "Next terminal session" })
      vim.keymap.set("n", "<leader>th", ":LuxtermPrev<CR>", { desc = "Previous terminal session" })
      
      
      -- Check plugin status and performance metrics
      :LuxtermStats
      
      -- List all sessions with status
      :LuxtermList
      
      -- Verify configuration
      :lua print(vim.inspect(require("luxterm").get_config()))
      
      -- Test configuration presets
      :lua require("luxterm.config").apply_preset("minimal")
      
    end,
  },
  {
    "waiting-for-dev/ergoterm.nvim",
    config = function()
      
      {
        "waiting-for-dev/ergoterm.nvim",
        config = function()
          require("ergoterm").setup()
        end
      }
      
      
      use {
        "waiting-for-dev/ergoterm.nvim",
        config = function()
          require("ergoterm").setup()
        end
      }
      
      
      require("ergoterm").setup()
      
      
      local map = vim.keymap.set
      local opts = { noremap = true, silent = true }
      
      -- Terminal creation with different layouts
      map("n", "<leader>cs", ":TermNew layout=below<CR>", opts)   -- Split below
      map("n", "<leader>cv", ":TermNew layout=right<CR>", opts)   -- Vertical split
      map("n", "<leader>cf", ":TermNew layout=float<CR>", opts)   -- Floating window
      map("n", "<leader>ct", ":TermNew layout=tab<CR>", opts)     -- New tab
      
      -- Open terminal picker
      map("n", "<leader>cl", ":TermSelect<CR>", opts)  -- List and select terminals
      
      -- Send text to last focused terminal
      map("n", "<leader>cs", ":TermSend! new_line=false<CR>", opts)  -- Send line without newline
      map("x", "<leader>cs", ":TermSend! new_line=false<CR>", opts)  -- Send selection without newline
      
      -- Send and show output without focusing terminal
      map("n", "<leader>cx", ":TermSend! action=visible<CR>", opts)  -- Execute in terminal, keep focus
      map("x", "<leader>cx", ":TermSend! action=visible<CR>", opts)  -- Execute selection in terminal, keep focus
      
      -- Send as markdown code block
      map("n", "<leader>cS", ":TermSend! action=visible trim=false decorator=markdown_code<CR>", opts)
      map("x", "<leader>cS", ":TermSend! action=visible trim=false decorator=markdown_code<CR>", opts)
      
      
      local terms = require("ergoterm.terminal")
      
      -- Create standalone terminals
      local lazygit = terms.Terminal:new({
        name = "lazygit",
        cmd = "lazygit",
        layout = "float",
        dir = "git_dir",
        selectable = false,
        bang_target = false
      })
      
      local claude = terms.Terminal:new({
        name = "claude",
        cmd = "claude",
        layout = "right",
        dir = "git_dir",
        selectable = false,
        watch_files = true
      })
      
      -- Map to keybindings for quick access
      vim.keymap.set("n", "<leader>gg", function() lazygit:toggle() end, { desc = "Open lazygit" })
      vim.keymap.set("n", "<leader>ci", function() claude:toggle() end, { desc = "Open claude" })
      
      
      local term = require("ergoterm.terminal").Terminal
      
      term:new({
        name = "Phoenix Server",
        cmd = "iex -S mix phx.server",
        layout = "right",
        sticky = true
      })
      
      term:new({
        name = "DB Console",
        cmd = "psql -U postgres my_database",
        layout = "below",
        sticky = true
      })
      
      
      local terms = require("ergoterm.terminal")
      
      -- Create a terminal instance
      local term = terms.Terminal:new({ cmd = "htop", layout = "float" })
      
      -- These methods cascade - focus() will start() and open() if needed
      term:focus()  -- Automatically calls start() and open() if not already done
      
      -- You can also call methods individually
      term:start()  -- Just start the job process
      term:open()   -- Just create the window (calls start() if needed)
      
      
      -- Send current line interactively (focuses terminal)
      term:send("single_line")
      
      -- Send custom text without focusing terminal
      term:send({"echo hello", "ls -la"}, { action = "visible" })
      
      -- Send visual selection silently (no UI changes)
      term:send("visual_selection", { action = "silent" })
      
      -- Send with custom formatting
      term:send({"print('hello')"}, { trim = false, decorator = "markdown_code" })
      
      
      -- Add timestamp to each line
      local function timestamp_decorator(text)
        local timestamp = os.date("%H:%M:%S")
        local result = {}
        for _, line in ipairs(text) do
          table.insert(result, string.format("[%s] %s", timestamp, line))
        end
        return result
      end
      
      -- Use with Terminal:send()
      terminal:send({"echo hello"}, { decorator = timestamp_decorator })
      
      
      local terms = require("ergoterm.terminal")
      
      -- Create persistent Claude terminal
      local claude = terms.Terminal:new({
        name = "claude",
        cmd = "claude",
        layout = "right",
        dir = "git_dir",
        selectable = false,
        watch_files = true
      })
      
      local map = vim.keymap.set
      local opts = { noremap = true, silent = true }
      
      -- Toggle Claude terminal
      map("n", "<leader>ai", function() claude:toggle() end, { desc = "Toggle Claude" })
      
      -- Reference current file to Claude
      map("n", "<leader>aa", function()
        local file = vim.fn.expand("%:p")
        claude:send({ "@" .. file .. " " }, { new_line = false })
      end, opts)
      
      -- Sends current line to Claude session
      map("n", "<leader>as", function()
        claude:send("single_line")
      end, opts)
      
      -- Sends current visual selection to Claude session
      map("v", "<leader>as", function()
        claude:send("visual_selection", { trim = false })
      end, opts)
      
      -- Send code to Claude as markdown (preserves formatting)
      map("n", "<leader>aS", function()
        claude:send("single_line", { trim = false, decorator = "markdown_code" })
      end, opts)
      map("v", "<leader>aS", function()
        claude:send("visual_selection", { trim = false, decorator = "markdown_code" })
      end, opts)
      
      
      require("ergoterm").setup({
        -- Terminal defaults - applied to all new terminals but overridable per instance
        terminal_defaults = {
          -- Default shell command
          shell = vim.o.shell,
      
          -- Default window layout
          layout = "below",
      
          -- Auto-scroll terminal output
          auto_scroll = false,
      
          -- Allow terminals to be targeted by bang commands by default
          bang_target = true,
      
          -- Watch for file changes when terminal produces output (requires vim's autoread option)
          watch_files = false,
      
          -- Cleanup terminal when process exits successfully (exit code 0)
          cleanup_on_success = true,
      
          -- Cleanup terminal when process exits with failure (exit code non-zero)
          cleanup_on_failure = false,
      
          -- Open terminal window when process exits successfully (exit code 0)
          show_on_success = false,
      
          -- Open terminal window when process exits with failure (exit code non-zero)
          show_on_failure = false,
      
          -- Default action to invoke when selecting terminal in picker
          default_action = function(term) term:focus() end,
      
          -- Remember terminal mode between visits
          persist_mode = false,
      
          -- Start terminals in insert mode
          start_in_insert = true,
      
          -- Show terminals in picker by default
          selectable = true,
      
          -- Keep terminals visible in picker even when stopped, provided `selectable` is also true
          sticky = false,
      
          -- Default tags for categorizing and filtering terminals
          tags = {},
      
          -- Floating window options
          float_opts = {
            title_pos = "left",
            relative = "editor",
            border = "single",
            zindex = 50
          },
          
          -- Floating window transparency
          float_winblend = 10,
          
          -- Size configuration for different layouts
          size = {
            below = "50%",   -- 50% of screen height
            above = "50%",   -- 50% of screen height
            left = "50%",    -- 50% of screen width
            right = "50%"    -- 50% of screen width
          },
      
          -- Clean job environment
          clear_env = false,
      
          -- Environment variables for terminal jobs
          env = nil,  -- Example: { PATH = "/custom/path", DEBUG = "1" }
          
          -- Default callbacks (all no-ops by default)
          on_close = function(term) end,
          on_create = function(term) end,
          on_focus = function(term) end,
          on_job_exit = function(term, job_id, exit_code, event_name) end,
          on_job_stderr = function(term, channel_id, data_lines, stream_name) end,
          on_job_stdout = function(term, channel_id, data_lines, stream_name) end,
          on_open = function(term) end,
          on_start = function(term) end,
          on_stop = function(term) end,
        },
        
        -- Picker configuration
        picker = {
          -- Picker to use for terminal selection
          -- Can be "telescope", "fzf-lua", "vim-ui-select", or a custom picker object
          -- nil = auto-detect (telescope > fzf-lua > vim.ui.select)
          picker = nil,
      
          -- Default actions available in terminal picker
          -- These replace the built-in actions entirely
          select_actions = {
            default = { fn = function(term) term:focus() end, desc = "Open" },
            ["<C-s>"] = { fn = function(term) term:focus("below") end, desc = "Open in horizontal split" },
            ["<C-v>"] = { fn = function(term) term:focus("right") end, desc = "Open in vertical split" },
            ["<C-t>"] = { fn = function(term) term:focus("tab") end, desc = "Open in tab" },
            ["<C-f>"] = { fn = function(term) term:focus("float") end, desc = "Open in float window" }
          },
      
          -- Additional actions to append to select_actions
          -- These are merged with select_actions, allowing you to add custom actions
          -- without replacing the defaults
          extra_select_actions = {}
        }
      })
      
    end,
  },
  {
    "ingur/floatty.nvim",
    config = function()
      
      { "ingur/floatty.nvim" }
      
      
      
      -- initialize config
      local term = require("floatty").setup({})
      
      -- set toggle keybinds (supports v:count by default!)
      vim.keymap.set('n', '<C-t>', function() term.toggle() end)
      vim.keymap.set('t', '<C-t>', function() term.toggle() end)
      
      
      -- NOTE: all options can be functions to be evaluated
      local defaults = {
          file = nil,                -- File to open (if any)
          cmd = vim.o.shell,         -- Terminal command to run
          cwd = vim.fn.getcwd,       -- Working directory of the command
          id = function() return vim.v.count end, -- Identifier for the float
          start_in_insert = true,    -- Start in insert mode
          focus = true,              -- Focus the window after opening
          on_open = nil,             -- Callback(config, buf) when buffer is created
          on_exit = nil,             -- Callback(config, buf) when buffer is destroyed
          window = {
              row = nil,               -- Supports percentages (<=1) and absolute sizes (>1)
              col = nil,               -- Supports percentages (<=1) and absolute sizes (>1)
              width = 0.8,             -- Supports percentages (<=1) and absolute sizes (>1)
              height = 0.8,            -- Supports percentages (<=1) and absolute sizes (>1)
              h_align = "center",      -- "left", "center", "right" (used when col is nil)
              v_align = "center",      -- "top", "center", "bottom" (used when row is nil)
              border = "rounded",      -- Border style
              zindex = 50,             -- Z-index of the float
              title = "",              -- window title
              title_pos = "center",    -- "left", "center", "right"
              -- see :h nvim_open_win() for more config options
          },
          wo = {                     -- Window-local options
              cursorcolumn = false,
              cursorline = false,
              cursorlineopt = "both",
              fillchars = "eob: ,lastline:…",
              list = false,
              listchars = "extends:…,tab:  ",
              number = false,
              relativenumber = false,
              signcolumn = "no",
              spell = false,
              winbar = "",
              statuscolumn = "",
              wrap = false,
              sidescrolloff = 0,
              -- other window options are also supported
          },
      }
      
      
      local term = require("floatty").setup({
          window = {
              row = function() return vim.o.lines - 11 end,
              width = 1.0,
              height = 8,
          },
      })
      
      vim.keymap.set('n', '<C-t>', function() term.toggle() end)
      vim.keymap.set('t', '<C-t>', function() term.toggle() end)
      
      
      local lazygit = require("floatty").setup({
          cmd = "lazygit",
          id = vim.fn.getcwd, -- Use the current working directory as the float's ID
      })
      
      vim.keymap.set('n', '<C-g>', function() lazygit.toggle() end)
      vim.keymap.set('t', '<C-g>', function() lazygit.toggle() end)
      
      
      local term = require("floatty").setup()
      local layout = "horizontal"
      
      term.toggle_layout = function()
          layout = layout == "horizontal" and "vertical" or "horizontal"
          if layout == "horizontal" then
              term.window = {
                  row = function() return vim.o.lines - 11 end,
                  width = 1.0,
                  height = 8,
                  h_align = "center",
              }
          else
              term.window = {
                  row = nil,
                  height = function() return vim.o.lines - 3 end,
                  width = 0.25,
                  h_align = "right",
                  v_align = "top",
              }
          end
      end
      
      vim.keymap.set('n', '<leader>tt', term.toggle_layout)
      
    end,
  },
  {
    "imranZERO/multiterm.nvim",
    config = function()
      
      {
          "imranzero/multiterm.nvim",
          event = "VeryLazy",
          opts = {
              -- Recommended keymaps:
              keymaps = {
                  toggle = "<F12>",
                  list = "<leader><F12>",
              },
          
              -- Add configuration options here if needed
          },
      }
      
      
      require("multiterm").setup({
          -- Recommended keymaps:
          vim.keymap.set({ "n", "v", "i", "t" }, "<F12>", "<Plug>(Multiterm)"),
          vim.keymap.set("n", "<leader><F12>", "<Plug>(MultitermList)"),
      
          -- Add configuration options here if needed
      })
      
      
      -- Map <F12> to toggle the selected terminal window
      vim.keymap.set({ "n", "v", "i", "t" }, "<F12>", "<Plug>(Multiterm)"),
      
      -- Map <leader><F12> to open the pop-up list of the active terminal windows
      vim.keymap.set("n", "<leader><F12>", "<Plug>(MultitermList)"),
      
      
          opts = {
              keymaps = {
                  toggle = "<F12>",
                  list = "<leader><F12>",
              },
          },
      
      
      -- Default options, do not put this in your configuration file
      
      require("multiterm").setup({
          height = 0.8,
          width = 0.8,
          border = 'rounded',
          term_hl = 'Normal',
          border_hl = 'FloatBorder',
          show_term_tag = true,
          show_backdrop = true,
          backdrop_bg = 'Black',
          backdrop_transparency = 60,
          fullscreen = false,
          show_tab = true,
          tabline_hl_active = "PmenuSel", 
          tabline_hl_inactive = "Pmenu", 
          term_keys = {
              next = { "<C-Right>", "<C-l>" },
              prev = { "<C-Left>", "<C-h>" },
              use_ctrl = true,
          },
      )}
      
    end,
  },
  {
    "Dan7h3x/neaterm.nvim",
    config = function()
      
      {
          "Dan7h3x/neaterm.nvim",
          branch = "stable",
          event = "VeryLazy",
          opts = {
            -- Your custom options here (optional)
          },
          dependencies = {
            "nvim-lua/plenary.nvim",
            "ibhagwan/fzf-lua",
          },
      }
      
      
      default_opts = {
        -- Terminal settings
        shell = vim.o.shell,
        float_width = 0.5,
        float_height = 0.4,
        move_amount = 3,
        resize_amount = 2,
        border = 'rounded',
      
        -- Appearance
        highlights = {
          normal = 'Normal',
          border = 'FloatBorder',
          title = 'Title',
        },
      
        -- Window management
        min_width = 20,
        min_height = 3,
      
      
        -- custom terminals
        terminals = {
          ranger = {
            name = "Ranger",
            cmd = "ranger",
            type = "float",
            float_width = 0.8,
            float_height = 0.8,
            keymaps = {
              quit = "q",
              select = "<CR>",
              preview = "p",
            },
            on_exit = function(selected_file)
              if selected_file then
                vim.cmd('edit ' .. selected_file)
              end
            end
          },
          lazygit = {
            name = "LazyGit",
            cmd = "lazygit",
            type = "float",
            float_width = 0.9,
            float_height = 0.9,
            keymaps = {
              quit = "q",
              commit = "c",
              push = "P",
            },
          },
          btop = {
            name = "Btop",
            cmd = "btop",
            type = "float",
            float_width = 0.8,
            float_height = 0.8,
            keymaps = {
              quit = "q",
              help = "h",
            },
          },
      
        },
      
        -- Default keymaps
        use_default_keymaps = true,
        keymaps = {
          toggle = '<A-t>',
          new_vertical = '<C-\\>',
          new_horizontal = '<C-.>',
          new_float = '<C-A-t>',
          close = '<A-d>',
          next = '<C-PageDown>',
          prev = '<C-PageUp>',
          move_up = '<C-A-Up>',
          move_down = '<C-A-Down>',
          move_left = '<C-A-Left>',
          move_right = '<C-A-Right>',
          resize_up = '<C-S-Up>',
          resize_down = '<C-S-Down>',
          resize_left = '<C-S-Left>',
          resize_right = '<C-S-Right>',
          focus_bar = '<C-A-b>',
          repl_toggle = '<leader>rt',
          repl_send_line = '<leader>rl',
          repl_send_selection = '<leader>rs',
          repl_send_buffer = '<leader>rb',
          repl_clear = '<leader>rc',
          repl_history = '<leader>rh',
          repl_variables = '<leader>rv',
          repl_restart = '<leader>rR',
        },
      
        -- REPL configurations
        repl = {
          float_width = 0.6,
          float_height = 0.4,
          save_history = true,
          history_file = vim.fn.stdpath('data') .. '/neaterm_repl_history.json',
          max_history = 100,
          update_interval = 5000,
        },
      
        -- REPL language configurations
        repl_configs = {
          python = {
            name = "Python (IPython)",
            cmd = "ipython --no-autoindent --colors='Linux'",
            startup_cmds = {
              -- "import sys",
              -- "sys.ps1 = 'In []: '",
              -- "sys.ps2 = '   ....: '",
            },
            get_variables_cmd = "whos",
            inspect_variable_cmd = "?",
            exit_cmd = "exit()",
          },
          r = {
            name = "R (Radian)",
            cmd = "radian",
            startup_cmds = {
              -- "options(width = 80)",
              -- "options(prompt = 'R> ')",
            },
            get_variables_cmd = "ls.str()",
            inspect_variable_cmd = "str(",
            exit_cmd = "q(save='no')",
          },
          lua = {
            name = "Lua",
            cmd = "lua",
            exit_cmd = "os.exit()",
          },
          node = {
            name = "Node.js",
            cmd = "node",
            get_variables_cmd = "Object.keys(global)",
            exit_cmd = ".exit",
          },
          sh = {
            name = "Shell",
            cmd = vim.o.shell,
            startup_cmds = {
              "PS1='$ '",
              "TERM=xterm-256color",
            },
            get_variables_cmd = "set",
            inspect_variable_cmd = "echo $",
            exit_cmd = "exit",
          },
        },
      
        -- Terminal features
        features = {
          auto_insert = true,
          auto_close = true,
          restore_layout = true,
          smart_sizing = true,
          persistent_history = true,
          native_search = true,
          clipboard_sync = true,
          shell_integration = true,
        },
      }
      
    end,
  },
  {
    "LoricAndre/OneTerm.nvim",
  },
  {
    "nikvdp/neomux",
  },
  {
    "willothy/flatten.nvim",
    config = function()
      
      require("lazy").setup({
        {
          "willothy/flatten.nvim",
          config = true,
          -- or pass configuration with
          -- opts = {  }
          -- Ensure that it runs first to minimize delay when opening file from terminal
          lazy = false,
          priority = 1001,
        },
        --- ...
      })
      
      
      require("flatten").setup({
        -- your config
      })
      
      
      local flatten = require("flatten")
      
      local config = {
        hooks = {
          should_block = flatten.hooks.should_block,
          should_nest = flatten.hooks.should_nest,
          pre_open = flatten.hooks.pre_open,
          post_open = flatten.hooks.post_open,
          block_end = flatten.hooks.block_end,
          no_files = flatten.hooks.no_files,
          guest_data = flatten.hooks.guest_data,
          pipe_path = flatten.hooks.pipe_path,
        },
        block_for = {
          gitcommit = true,
          gitrebase = true,
        },
        disable_cmd_passthrough = false,
        nest_if_no_args = false,
        nest_if_cmds = false,
        window = {
          open = "current",
          diff = "tab_vsplit",
          focus = "first",
        },
        integrations = {
          kitty = false,
          wezterm = false,
        },
      }
      
      
      local flatten = {
        "willothy/flatten.nvim",
        opts = function()
          ---@type Terminal?
          local saved_terminal
      
          return {
            window = {
              open = "alternate",
            },
            hooks = {
              should_block = function(argv)
                -- Note that argv contains all the parts of the CLI command, including
                -- Neovim's path, commands, options and files.
                -- See: :help v:argv
      
                -- In this case, we would block if we find the `-b` flag
                -- This allows you to use `nvim -b file1` instead of
                -- `nvim --cmd 'let g:flatten_wait=1' file1`
                return vim.tbl_contains(argv, "-b")
      
                -- Alternatively, we can block if we find the diff-mode option
                -- return vim.tbl_contains(argv, "-d")
              end,
              pre_open = function()
                local term = require("toggleterm.terminal")
                local termid = term.get_focused_id()
                saved_terminal = term.get(termid)
              end,
              post_open = function(bufnr, winnr, ft, is_blocking)
                if is_blocking and saved_terminal then
                  -- Hide the terminal while it's blocking
                  saved_terminal:close()
                else
                  -- If it's a normal file, just switch to its window
                  vim.api.nvim_set_current_win(winnr)
      
                  -- If we're in a different wezterm pane/tab, switch to the current one
                  -- Requires willothy/wezterm.nvim
                  require("wezterm").switch_pane.id(
                    tonumber(os.getenv("WEZTERM_PANE"))
                  )
                end
      
                -- If the file is a git commit, create one-shot autocmd to delete its buffer on write
                -- If you just want the toggleable terminal integration, ignore this bit
                if ft == "gitcommit" or ft == "gitrebase" then
                  vim.api.nvim_create_autocmd("BufWritePost", {
                    buffer = bufnr,
                    once = true,
                    callback = vim.schedule_wrap(function()
                      vim.api.nvim_buf_delete(bufnr, {})
                    end),
                  })
                end
              end,
              block_end = function()
                -- After blocking ends (for a git commit, etc), reopen the terminal
                vim.schedule(function()
                  if saved_terminal then
                    saved_terminal:open()
                    saved_terminal = nil
                  end
                end)
              end,
            },
          }
        end,
      }
      
      
      local pipe_path = function()
        -- If running in a terminal inside Neovim:
        if vim.env.NVIM then
          return vim.env.NVIM
        end
        -- If running in a Kitty terminal,
        -- all tabs/windows/os-windows in the same instance of kitty
        -- will open in the first neovim instance
        if vim.env.KITTY_PID then
          local addr = ("%s/%s"):format(
            vim.fn.stdpath("run"),
            "kitty.nvim-" .. vim.env.KITTY_PID
          )
          if not vim.uv.fs_stat(addr) then
            vim.fn.serverstart(addr)
          end
          return addr
        end
      end
      
      
    end,
  },
  {
    "willothy/wezterm.nvim",
    config = function()
      
      {
          'willothy/wezterm.nvim',
          config = true
      }
      
      
      {
          'willothy/wezterm.nvim',
          opts = {
              create_commands = false
          }
      }
      
      
      -- Switch tab by index using vim.v.count
      vim.keymap.set("n", "<leader>wt", require('wezterm').switch_tab.index)
      
    end,
  },
  {
    "akinsho/toggleterm.nvim",
    config = function()
      
      use {"akinsho/toggleterm.nvim", tag = '*', config = function()
        require("toggleterm").setup()
      end}
      
      
      {
        -- amongst your other plugins
        {'akinsho/toggleterm.nvim', version = "*", config = true}
        -- or
        {'akinsho/toggleterm.nvim', version = "*", opts = {--[[ things you want to change go here]]}}
      }
      
      
      require("toggleterm").setup{
        -- size can be a number or function which is passed the current terminal
        size = 20 | function(term)
          if term.direction == "horizontal" then
            return 15
          elseif term.direction == "vertical" then
            return vim.o.columns * 0.4
          end
        end,
        open_mapping = [[<c-\>]], -- or { [[<c-\>]], [[<c-¥>]] } if you also use a Japanese keyboard.
        on_create = fun(t: Terminal), -- function to run when the terminal is first created
        on_open = fun(t: Terminal), -- function to run when the terminal opens
        on_close = fun(t: Terminal), -- function to run when the terminal closes
        on_stdout = fun(t: Terminal, job: number, data: string[], name: string) -- callback for processing output on stdout
        on_stderr = fun(t: Terminal, job: number, data: string[], name: string) -- callback for processing output on stderr
        on_exit = fun(t: Terminal, job: number, exit_code: number, name: string) -- function to run when terminal process exits
        hide_numbers = true, -- hide the number column in toggleterm buffers
        shade_filetypes = {},
        autochdir = false, -- when neovim changes it current directory the terminal will change it's own when next it's opened
        highlights = {
          -- highlights which map to a highlight group name and a table of it's values
          -- NOTE: this is only a subset of values, any group placed here will be set for the terminal window split
          Normal = {
            guibg = "<VALUE-HERE>",
          },
          NormalFloat = {
            link = 'Normal'
          },
          FloatBorder = {
            guifg = "<VALUE-HERE>",
            guibg = "<VALUE-HERE>",
          },
        },
        shade_terminals = true, -- NOTE: this option takes priority over highlights specified so if you specify Normal highlights you should set this to false
        shading_factor = '<number>', -- the percentage by which to lighten dark terminal background, default: -30
        shading_ratio = '<number>', -- the ratio of shading factor for light/dark terminal background, default: -3
        start_in_insert = true,
        insert_mappings = true, -- whether or not the open mapping applies in insert mode
        terminal_mappings = true, -- whether or not the open mapping applies in the opened terminals
        persist_size = true,
        persist_mode = true, -- if set to true (default) the previous terminal mode will be remembered
        direction = 'vertical' | 'horizontal' | 'tab' | 'float',
        close_on_exit = true, -- close the terminal window when the process exits
        clear_env = false, -- use only environmental variables from `env`, passed to jobstart()
         -- Change the default shell. Can be a string or a function returning a string
        shell = vim.o.shell,
        auto_scroll = true, -- automatically scroll to the bottom on terminal output
        -- This field is only relevant if direction is set to 'float'
        float_opts = {
          -- The border key is *almost* the same as 'nvim_open_win'
          -- see :h nvim_open_win for details on borders however
          -- the 'curved' border is a custom border type
          -- not natively supported but implemented in this plugin.
          border = 'single' | 'double' | 'shadow' | 'curved' | ... other options supported by win open
          -- like `size`, width, height, row, and col can be a number or function which is passed the current terminal
          width = <value>,
          height = <value>,
          row = <value>,
          col = <value>,
          winblend = 3,
          zindex = <value>,
          title_pos = 'left' | 'center' | 'right', position of the title of the floating window
        },
        winbar = {
          enabled = false,
          name_formatter = function(term) --  term: Terminal
            return term.name
          end
        },
        responsiveness = {
          -- breakpoint in terms of `vim.o.columns` at which terminals will start to stack on top of each other
          -- instead of next to each other
          -- default = 0 which means the feature is turned off
          horizontal_breakpoint = 135,
        }
      }
      
      
      local trim_spaces = true
      vim.keymap.set("v", "<space>s", function()
          require("toggleterm").send_lines_to_terminal("single_line", trim_spaces, { args = vim.v.count })
      end)
          -- Replace with these for the other two options
          -- require("toggleterm").send_lines_to_terminal("visual_lines", trim_spaces, { args = vim.v.count })
          -- require("toggleterm").send_lines_to_terminal("visual_selection", trim_spaces, { args = vim.v.count })
      
      -- For use as an operator map:
      -- Send motion to terminal
      vim.keymap.set("n", [[<leader><c-\>]], function()
        set_opfunc(function(motion_type)
          require("toggleterm").send_lines_to_terminal(motion_type, false, { args = vim.v.count })
        end)
        vim.api.nvim_feedkeys("g@", "n", false)
      end)
      -- Double the command to send line to terminal
      vim.keymap.set("n", [[<leader><c-\><c-\>]], function()
        set_opfunc(function(motion_type)
          require("toggleterm").send_lines_to_terminal(motion_type, false, { args = vim.v.count })
        end)
        vim.api.nvim_feedkeys("g@_", "n", false)
      end)
      -- Send whole file
      vim.keymap.set("n", [[<leader><leader><c-\>]], function()
        set_opfunc(function(motion_type)
          require("toggleterm").send_lines_to_terminal(motion_type, false, { args = vim.v.count })
        end)
        vim.api.nvim_feedkeys("ggg@G''", "n", false)
      end)
      
      
      require'toggleterm'.setup {
        shade_terminals = false
      }
      
      
      -- fzf is just an example
      require'toggleterm'.setup {
        shade_filetypes = { "none", "fzf" }
      }
      
      
      
      require'toggleterm'.setup{
        persist_size = false
      }
      
      
      function _G.set_terminal_keymaps()
        local opts = {buffer = 0}
        vim.keymap.set('t', '<esc>', [[<C-\><C-n>]], opts)
        vim.keymap.set('t', 'jk', [[<C-\><C-n>]], opts)
        vim.keymap.set('t', '<C-h>', [[<Cmd>wincmd h<CR>]], opts)
        vim.keymap.set('t', '<C-j>', [[<Cmd>wincmd j<CR>]], opts)
        vim.keymap.set('t', '<C-k>', [[<Cmd>wincmd k<CR>]], opts)
        vim.keymap.set('t', '<C-l>', [[<Cmd>wincmd l<CR>]], opts)
        vim.keymap.set('t', '<C-w>', [[<C-\><C-n><C-w>]], opts)
      end
      
      -- if you only want these mappings for toggle term use term://*toggleterm#* instead
      vim.cmd('autocmd! TermOpen term://* lua set_terminal_keymaps()')
      
      
      Terminal:new {
        cmd = string -- command to execute when creating the terminal e.g. 'top'
        display_name = string -- the name of the terminal
        direction = string -- the layout for the terminal, same as the main config options
        dir = string -- the directory for the terminal
        close_on_exit = bool -- close the terminal window when the process exits
        highlights = table -- a table with highlights
        env = table -- key:value table with environmental variables passed to jobstart()
        clear_env = bool -- use only environmental variables from `env`, passed to jobstart()
        on_open = fun(t: Terminal) -- function to run when the terminal opens
        on_close = fun(t: Terminal) -- function to run when the terminal closes
        auto_scroll = boolean -- automatically scroll to the bottom on terminal output
        -- callbacks for processing the output
        on_stdout = fun(t: Terminal, job: number, data: string[], name: string) -- callback for processing output on stdout
        on_stderr = fun(t: Terminal, job: number, data: string[], name: string) -- callback for processing output on stderr
        on_exit = fun(t: Terminal, job: number, exit_code: number, name: string) -- function to run when terminal process exits
      }
      
      
      local Terminal  = require('toggleterm.terminal').Terminal
      local lazygit = Terminal:new({ cmd = "lazygit", hidden = true })
      
      function _lazygit_toggle()
        lazygit:toggle()
      end
      
      vim.api.nvim_set_keymap("n", "<leader>g", "<cmd>lua _lazygit_toggle()<CR>", {noremap = true, silent = true})
      
      
      local lazygit = Terminal:new({ cmd = "lazygit", count = 5 })
      
      
      local lazygit = Terminal:new({
        cmd = "lazygit",
        dir = "git_dir",
        direction = "float",
        float_opts = {
          border = "double",
        },
        -- function to run on opening the terminal
        on_open = function(term)
          vim.cmd("startinsert!")
          vim.api.nvim_buf_set_keymap(term.bufnr, "n", "q", "<cmd>close<CR>", {noremap = true, silent = true})
        end,
        -- function to run on closing the terminal
        on_close = function(term)
          vim.cmd("startinsert!")
        end,
      })
      
      function _lazygit_toggle()
        lazygit:toggle()
      end
      
      vim.api.nvim_set_keymap("n", "<leader>g", "<cmd>lua _lazygit_toggle()<CR>", {noremap = true, silent = true})
      
    end,
  },
  {
    "norcalli/nvim-terminal.lua",
  },
  {
    "numToStr/FTerm.nvim",
    config = function()
      
      use "numToStr/FTerm.nvim"
      
      
      require'FTerm'.setup({
          border = 'double',
          dimensions  = {
              height = 0.9,
              width = 0.9,
          },
      })
      
      -- Example keybindings
      vim.keymap.set('n', '<A-i>', '<CMD>lua require("FTerm").toggle()<CR>')
      vim.keymap.set('t', '<A-i>', '<C-\\><C-n><CMD>lua require("FTerm").toggle()<CR>')
      
      
      {
          ---Filetype of the terminal buffer
          ---@type string
          ft = 'FTerm',
      
          ---Command to run inside the terminal
          ---NOTE: if given string[], it will skip the shell and directly executes the command
          ---@type fun():(string|string[])|string|string[]
          cmd = os.getenv('SHELL'),
      
          ---Neovim's native window border. See `:h nvim_open_win` for more configuration options.
          border = 'single',
      
          ---Close the terminal as soon as shell/command exits.
          ---Disabling this will mimic the native terminal behaviour.
          ---@type boolean
          auto_close = true,
      
          ---Highlight group for the terminal. See `:h winhl`
          ---@type string
          hl = 'Normal',
      
          ---Transparency of the floating window. See `:h winblend`
          ---@type integer
          blend = 0,
      
          ---Object containing the terminal window dimensions.
          ---The value for each field should be between `0` and `1`
          ---@type table<string,number>
          dimensions = {
              height = 0.8, -- Height of the terminal window
              width = 0.8, -- Width of the terminal window
              x = 0.5, -- X axis of the terminal window
              y = 0.5, -- Y axis of the terminal window
          },
      
          ---Replace instead of extend the current environment with `env`.
          ---See `:h jobstart-options`
          ---@type boolean
          clear_env = false,
      
          ---Map of environment variables extending the current environment.
          ---See `:h jobstart-options`
          ---@type table<string,string>|nil
          env = nil,
      
          ---Callback invoked when the terminal exits.
          ---See `:h jobstart-options`
          ---@type fun()|nil
          on_exit = nil,
      
          ---Callback invoked when the terminal emits stdout data.
          ---See `:h jobstart-options`
          ---@type fun()|nil
          on_stdout = nil,
      
          ---Callback invoked when the terminal emits stderr data.
          ---See `:h jobstart-options`
          ---@type fun()|nil
          on_stderr = nil,
      }
      
      
      require('FTerm').open()
      
      -- or create a vim command
      vim.api.nvim_create_user_command('FTermOpen', require('FTerm').open, { bang = true })
      
      
      require('FTerm').close()
      
      -- or create a vim command
      vim.api.nvim_create_user_command('FTermClose', require('FTerm').close, { bang = true })
      
      
      require('FTerm').exit()
      
      -- or create a vim command
      vim.api.nvim_create_user_command('FTermExit', require('FTerm').exit, { bang = true })
      
      
      require('FTerm').toggle()
      
      -- or create a vim command
      vim.api.nvim_create_user_command('FTermToggle', require('FTerm').toggle, { bang = true })
      
      
      -- run() can take `string` or `table` just like `cmd` config
      require('FTerm').run('man ls') -- with string
      require('FTerm').run({'yarn', 'build'})
      require('FTerm').run({'node', vim.api.nvim_get_current_buf()})
      
      -- Or you can do this
      vim.api.nvim_create_user_command('ManLs', function()
          require('FTerm').run('man ls')
      end, { bang = true })
      
      vim.api.nvim_create_user_command('YarnBuild', function()
          require('FTerm').run({'yarn', 'build'})
      end, { bang = true })
      
      
      require('FTerm').scratch({ cmd = 'yarn build' })
      require('FTerm').scratch({ cmd = {'cargo', 'build', '--target', os.getenv('RUST_TARGET')} })
      
      -- Scratch terminals are awesome because you can do this
      vim.api.nvim_create_user_command('YarnBuild', function()
          require('FTerm').scratch({ cmd = {'yarn', 'build'} })
      end, { bang = true })
      
      vim.api.nvim_create_user_command('CargoBuild', function()
          require('FTerm').scratch({ cmd = {'cargo', 'build', '--target', os.getenv("RUST_TARGET")} })
      end, { bang = true })
      
      -- Code Runner - execute commands in a floating terminal
      local runners = { lua = 'lua', javascript = 'node' }
      
      vim.keymap.set('n', '<leader><Enter>', function()
          local buf = vim.api.nvim_buf_get_name(0)
          local ftype = vim.filetype.match({ filename = buf })
          local exec = runners[ftype]
          if exec ~= nil then
              require('FTerm').scratch({ cmd = { exec, buf } })
          end
      end)
      
      
      local fterm = require("FTerm")
      
      local gitui = fterm:new({
          ft = 'fterm_gitui', -- You can also override the default filetype, if you want
          cmd = "gitui",
          dimensions = {
              height = 0.9,
              width = 0.9
          }
      })
      
      -- Use this to toggle gitui in a floating terminal
      vim.keymap.set('n', '<A-g>', function()
          gitui:toggle()
      end)
      
      
      local fterm = require("FTerm")
      
      local btop = fterm:new({
          ft = 'fterm_btop',
          cmd = "btop"
      })
      
       -- Use this to toggle btop in a floating terminal
      vim.keymap.set('n', '<A-b>', function()
          btop:toggle()
      end)
      
    end,
  },
  {
    "pianocomposer321/consolation.nvim",
    config = function()
      
      function() vim.cmd("vnew | term") end
      
      
      function(self)
          local winnr = self.get_winnr()
          if winnr == -1 then
              vim.cmd("vnew")
              vim.cmd("b"..self.bufnr)
          else
              vim.cmd(winnr.."wincmd w")
          end
      end
      
      
      function(self)
          local winnr = self.get_winnr()
          vim.cmd(winnr.."wincmd c")
      end
      
      
      function (self) vim.cmd("bd! "..self.bufnr) end
      
       
      local Wrapper = require("consolation").Wrapper
      
      BuiltinTerminalWrapper = Wrapper:new()
      BuiltinTerminalWraper:setup {
          create = function() vim.cmd("vnew | term") end,
          open = function(self)
              if self:is_open() then
                  local winnr = vim.fn.bufwinnr(self.bufnr)
                  vim.cmd(winnr.."wincmd w")
              else
                  vim.cmd("vnew")
                  vim.cmd("b"..self.bufnr)
              end
          end,
          close = function(self)
              local winnr = vim.fn.bufwinnr(self.bufnr)
              vim.cmd(winnr.."wincmd c")
          end,
          kill = function(self)
              vim.cmd("bd! "..self.bufnr)
          end
      }
      
      
      -- Try:
      
      -- BuiltinTerminalWraper:open {cmd = "echo hi"}
      -- BuiltinTerminalWraper:send_command {cmd = "echo hi again"}
      -- BuiltinTerminalWraper:close()
      -- BuiltinTerminalWraper:toggle()
      -- BuiltinTerminalWraper:kill()
      
      
      local term = require("Fterm.terminal")
      Runner = term:new():setup()
      
      FtermWrapper = Wrapper:new()
      FtermWrapper:setup {
          create = function() Runner:open() end,
          open = function(_) Runner:open() end,
          close = function(_) Runner:close() end,
          kill = function(_) Runner:close(true) end
      }
      
    end,
  },
  {
    "jghauser/kitty-runner.nvim",
    config = function()
      
      use {
        "jghauser/kitty-runner.nvim",
        config = function()
          require("kitty-runner").setup()
        end
      }
      
      
      {
        "jghauser/kitty-runner.nvim",
        config = function()
          require("kitty-runner").setup()
        end
      }
      
      
      require("kitty-runner").setup({
        -- name of the kitty terminal:
        runner_name = "kitty-runner-" .. uuid,
        -- kitty arguments when sending lines/command:
        run_cmd = {"send-text", "--"},
        -- kitty arguments when killing a runner:
        kill_cmd = {"close-window"},
        -- use default keymaps:
        use_keymaps = true,
        -- the port used to communicate with the kitty terminal:
        kitty_port = "unix:/tmp/kitty-" .. uuid,
        -- the type of window that kitty will create:
        -- - os-window = a new window
        -- - window = a new split within the current window (see below)
        -- - More info: https://sw.kovidgoyal.net/kitty/glossary/#term-os_window
        mode = "os-window"
      })
      
      
      local opts = require("kitty-runner.config").window_config
      require("kitty-runner").setup(opts)
      
      
      {
        runner_name = "kitty-runner-" .. uuid,
        run_cmd = { "send-text", "--match=title:" .. "kitty-runner-" .. uuid },
        kill_cmd = { "close-window", "--match=title:" .. "kitty-runner-" .. uuid },
        use_keymaps = true,
        kitty_port = "unix:/tmp/kitty",
        mode = "window"
      }
      
    end,
  },
  {
    "jlesquembre/nterm.nvim",
    config = function()
      
      require'nterm.main'.init({
        maps = true,  -- load defaut mappings
        shell = "fish",
        size = 20,
        direction = "horizontal", -- horizontal or vertical
        popup = 2000,     -- Number of miliseconds to show the info about the commmand. 0 to dissable
        popup_pos = "SE", --  one of "NE" "SE" "SW" "NW"
        autoclose = 2000, -- If command is sucesful, close the terminal after that number of miliseconds. 0 to disable
      })
      
      -- Optional, if you want to use the telescope extension
      require('telescope').load_extension('nterm')
      
      
      vim.api.nvim_set_keymap(
        "n",
        "<leader>gp",
        "<cmd>lua require'nterm.main'.term_send('git push', 'git', {popup=3000, popup_pos="NE", autoclose=0})<cr>"
      )
      
    end,
  },
  {
    "s1n7ax/nvim-terminal",
    config = function()
      
      use {
          's1n7ax/nvim-terminal',
          config = function()
              vim.o.hidden = true
              require('nvim-terminal').setup()
          end,
      }
      
      
      -- following option will hide the buffer when it is closed instead of deleting
      -- the buffer. This is important to reuse the last terminal buffer
      -- IF the option is not set, plugin will open a new terminal every single time
      vim.o.hidden = true
      
      require('nvim-terminal').setup({
          window = {
              -- Do `:h :botright` for more information
              -- NOTE: width or height may not be applied in some "pos"
              position = 'botright',
      
              -- Do `:h split` for more information
              split = 'sp',
      
              -- Width of the terminal
              width = 50,
      
              -- Height of the terminal
              height = 15,
          },
      
          -- keymap to disable all the default keymaps
          disable_default_keymaps = false,
      
          -- keymap to toggle open and close terminal window
          toggle_keymap = '<leader>;',
      
          -- increase the window height by when you hit the keymap
          window_height_change_amount = 2,
      
          -- increase the window width by when you hit the keymap
          window_width_change_amount = 2,
      
          -- keymap to increase the window width
          increase_width_keymap = '<leader><leader>+',
      
          -- keymap to decrease the window width
          decrease_width_keymap = '<leader><leader>-',
      
          -- keymap to increase the window height
          increase_height_keymap = '<leader>+',
      
          -- keymap to decrease the window height
          decrease_height_keymap = '<leader>-',
      
          terminals = {
              -- keymaps to open nth terminal
              {keymap = '<leader>1'},
              {keymap = '<leader>2'},
              {keymap = '<leader>3'},
              {keymap = '<leader>4'},
              {keymap = '<leader>5'},
          },
      })
      
      
      vim.api.nvim_set_keymap('n', '<leader>t', ':lua NTGlobal["terminal"]:toggle()<cr>', silent)
      vim.api.nvim_set_keymap('n', '<leader>1', ':lua NTGlobal["terminal"]:open(1)<cr>', silent)
      vim.api.nvim_set_keymap('n', '<leader>+', ':lua NTGlobal["window"]:change_height(2)<cr>', silent)
      vim.api.nvim_set_keymap('n', '<leader>-', ':lua NTGlobal["window"]:change_height(-2)<cr>', silent)
      
      
      terminal = require('nvim-terminal').DefaultTerminal;
      
      local silent = { silent = true }
      
      vim.api.nvim_set_keymap('n', '<leader>t', ':lua terminal:toggle()<cr>', silent)
      vim.api.nvim_set_keymap('n', '<leader>1', ':lua terminal:open(1)<cr>', silent)
      vim.api.nvim_set_keymap('n', '<leader>2', ':lua terminal:open(2)<cr>', silent)
      vim.api.nvim_set_keymap('n', '<leader>3', ':lua terminal:open(3)<cr>', silent)
      
      
      local Terminal = require('nvim-terminal.terminal')
      local Window = require('nvim-terminal.window')
      
      local window = Window:new({
      	position = 'botright',
      	split = 'sp',
      	width = 50,
      	height = 15
      })
      
      terminal = Terminal:new(window)
      
    end,
  },
  {
    "m00qek/baleia.nvim",
    config = function()
      
      {
        "m00qek/baleia.nvim",
        version = "*",
        config = function()
          vim.g.baleia = require("baleia").setup({ })
      
          -- Command to colorize the current buffer
          vim.api.nvim_create_user_command("BaleiaColorize", function()
            vim.g.baleia.once(vim.api.nvim_get_current_buf())
          end, { bang = true })
      
          -- Command to show logs 
          vim.api.nvim_create_user_command("BaleiaLogs", vim.g.baleia.logger.show, { bang = true })
        end,
      }
      
      
      vim.g.baleia = require("baleia").setup({ })
      vim.api.nvim_create_autocmd({ "BufWinEnter" }, {
        pattern = "*.txt",
        callback = function()
          vim.g.baleia.automatically(vim.api.nvim_get_current_buf())
        end,
      })
      
      
      vim.g.baleia = require("baleia").setup({ })
      vim.api.nvim_create_autocmd({ "BufReadPost" }, {
        pattern = "quickfix",
        callback = function()
          vim.api.nvim_set_option_value("modifiable", true, { buf = buffer })
          vim.g.baleia.automatically(vim.api.nvim_get_current_buf())
          vim.api.nvim_set_option_value("modified", false, { buf = buffer })
          vim.api.nvim_set_option_value("modifiable", false, { buf = buffer })
        end,
      })
      
      
      {
        "m00qek/baleia.nvim",
        version = "*",
        config = function()
          vim.g.conjure_baleia = require("baleia").setup({ line_starts_at = 3 })
      
          local augroup = vim.api.nvim_create_augroup("ConjureBaleia", { clear = true })
      
          vim.api.nvim_create_user_command("BaleiaColorize", function()
            vim.g.conjure_baleia.once(vim.api.nvim_get_current_buf())
          end, { bang = true })
      
          vim.api.nvim_create_user_command("BaleiaLogs", vim.g.conjure_baleia.logger.show, { bang = true })
        end,
      },
      {
        "Olical/conjure",
        ft = { "clojure", "fennel" },
        config = function()
          require("conjure.main").main()
          require("conjure.mapping")["on-filetype"]()
        end,
        init = function()
          -- Print color codes if baleia.nvim is available
          local colorize = require("lazyvim.util").has("baleia.nvim")
          vim.g["conjure#log#strip_ansi_escape_sequences_line_limit"] = colorize and 1 or nil
      
          -- Disable diagnostics in log buffer and colorize it
          vim.api.nvim_create_autocmd({ "BufWinEnter" }, {
            pattern = "conjure-log-*",
            callback = function()
              local buffer = vim.api.nvim_get_current_buf()
              vim.diagnostic.enable(false, { bufnr = buffer })
              if colorize and vim.g.conjure_baleia then
                vim.g.conjure_baleia.automatically(buffer)
              end
            end,
          })
        end,
      },
      
      
      vim.g.baleia = require("baleia").setup({ log = 'DEBUG' })
      vim.api.nvim_create_user_command("BaleiaLogs", vim.g.conjure_baleia.logger.show, { bang = true })
      
      
      local new_lines = { '\x1b[32mHello \x1b[33mworld!' }
      
      -- appending using Neovim standard API
      local lastline = vim.api.nvim_buf_line_count(0)
      vim.api.nvim_buf_set_lines(0, lastline, lastline, true, new_lines)
      
      -- appending using Baleia API
      local lastline = vim.api.nvim_buf_line_count(0)
      local baleia = require('baleia').setup { }
      baleia.buf_set_lines(0, lastline, lastline, true, new_lines)
      
    end,
  },
  {
    "samjwill/nvim-unception",
  },
  {
    "kassio/neoterm",
  },
  {
    "nyngwang/NeoTerm.lua",
    config = function()
      
      use {
        'nyngwang/NeoTerm.lua',
        config = function ()
          require('neo-term').setup {
            exclude_filetypes = { 'oil' },
            -- exclude_buftypes = {}, -- 'terminal' will always be added by NeoTerm.lua
            -- enabled by default!
            -- presets = {
            --   'vim-test',
            -- }
          }
          vim.keymap.set('n', '<M-Tab>', function () vim.cmd('NeoTermToggle') end)
          vim.keymap.set('t', '<M-Tab>', function () vim.cmd('NeoTermEnterNormal') end)
        end
      }
      
    end,
  },
  {
    "idanarye/nvim-channelot",
  },
  {
    "chomosuke/term-edit.nvim",
    config = function()
      
      {
          'chomosuke/term-edit.nvim',
          event = 'TermOpen',
          version = '1.*',
      }
      
      
      use { 'chomosuke/term-edit.nvim', tag = 'v1.*' }
      
      
      require 'term-edit'.setup {
          -- Mandatory option:
          -- Set this to a lua pattern that would match the end of your prompt.
          -- Or a table of multiple lua patterns where at least one would match the
          -- end of your prompt at any given time.
          -- For most bash/zsh user this is '%$ '.
          -- For most powershell/fish user this is '> '.
          -- For most windows cmd user this is '>'.
          prompt_end = '%$ ',
          -- How to write lua patterns: https://www.lua.org/pil/20.2.html
      }
      
      
      local default_opts = {
          -- Setting this true will enable printing debug information with print()
          debug = false,
      
          -- Number of event loops it takes for <Left>, <Right> or <BS> keys to change
          -- the cursor's position.
          -- If term-edit.nvim is unreliable, increasing this value could help.
          -- Decreasing this value can increase the responsiveness of term-edit.nvim
          feedkeys_delay = 10,
      
          -- Use case 1: I want to press 'o' instead of 'i' to enter insert.
          --   `mapping = { n --[[normal mode]] = { i = 'o' } }`
          --   `vim.keymap.set('n', 'o', 'i', { remap = true })` will achieve the same
          --   thing. (won't work without remap = true)
          -- Use case 2: I want to map 'c' to 'd' and 'd' to 'c'
          --   (keymap with remap is no longer an option)
          --   `mapping = { n = { c = 'd', d = 'c' } }` (will also map 'cc' to 'dd'
          --   and 'dd' to 'cc')
          -- Use case 3: I already mapped s to something else and do not want
          --   term-edit.nvim to override my mapping.
          --   `mapping = { n = { s = false } }`
          --
          -- For more examples and detailed explaination, see :h term-edit.mapping
          mapping = {
              -- mode = {
              --     lhs = new_lhs
              -- }
          },
      
          -- If this function returns true, term-edit.nvim will use up and down arrow
          -- to move the cursor as well as left and right arrow.
          -- It will be called before terminal mode is entered and the cursor is moved.
          use_up_down_arrows = function()
              return false
              -- -- In certain environment, left and right arrows can not move the
              -- -- cursor to the previous or next line, but up and down arrows can,
              -- -- one example is ipython.
              -- -- Below is an example that works for ipython
              --
              -- -- get content for line under cursor
              -- local line = vim.fn.getline(vim.fn.line '.')
              -- if line:find(']:', 1, true) or line:find('...:', 1, true) then
              --   return true
              -- else
              --   return false
              -- end
          end,
      
          -- Used to detect the start of the command
          -- prompt_end = no default, this is mandatory
      
          -- Set this to change the register that term-edit uses for yank and put.
          default_reg = '"',
      }
      
    end,
  },
  {
    "mikesmithgh/kitty-scrollback.nvim",
    config = function()
      
          vim.keymap.set({ 'n' }, '<Esc>', '<Plug>(KsbCloseOrQuitAll)', {})
          
      
          return {
            {
              'mikesmithgh/kitty-scrollback.nvim',
              lazy = true,
              cmd = { 'KittyScrollbackGenerateKittens', 'KittyScrollbackCheckHealth' },
              event = { 'User KittyScrollbackLaunch' },
              config = function()
                vim.keymap.set({ 'n' }, '<Esc>', '<Plug>(KsbCloseOrQuitAll)', {}) -- quit kitty-scrollback.nvim with Esc key
                -- vim.keymap.set({ 'n' }, 'q', '<Plug>(KsbCloseOrQuitAll)', {}) -- uncomment if you would like to also quit with the q key
                require('kitty-scrollback').setup()
              end,
            },
          }
          
      
        {
          'mikesmithgh/kitty-scrollback.nvim',
          enabled = true,
          lazy = true,
          cmd = { 'KittyScrollbackGenerateKittens', 'KittyScrollbackCheckHealth', 'KittyScrollbackGenerateCommandLineEditing' },
          event = { 'User KittyScrollbackLaunch' },
          -- version = '*', -- latest stable version, may have breaking changes if major version changed
          -- version = '^6.0.0', -- pin major version, include fixes and features that do not have breaking changes
          config = function()
            require('kitty-scrollback').setup()
          end,
        }
      
      
        use({
          'mikesmithgh/kitty-scrollback.nvim',
          disable = false,
          opt = true,
          cmd = { 'KittyScrollbackGenerateKittens', 'KittyScrollbackCheckHealth', 'KittyScrollbackGenerateCommandLineEditing' },
          event = { 'User KittyScrollbackLaunch' },
          -- tag = '*', -- latest stable version, may have breaking changes if major version changed
          -- tag = 'v6.0.0', -- pin specific tag
          config = function()
            require('kitty-scrollback').setup()
          end,
        })
      
      
      require('kitty-scrollback').setup({
          myconfig = {
            kitty_get_text = {
              ansi = false,
            },
          }
      })
      
      
      require('kitty-scrollback').setup({
          myconfig = {
            kitty_get_text = {
              ansi = false,
            },
          },
          myfnconfig = function(kitty_data)
            return {
              kitty_get_text = {
                extent = (kitty_data.scrolled_by > kitty_data.lines) and 'all' or 'screen',
              },
            }
          end,
      })
      
      
        ksb_builtin_get_text_all = {
          kitty_get_text = {
            ansi = false,
          },
        }
      
      
        ksb_builtin_get_text_all = {
          kitty_get_text = {
            extent = 'all',
          },
        },
      
      
        ksb_builtin_get_text_all = {
          kitty_get_text = {
            ansi = false,
            extent = 'all',
          },
        },
      
      
      require('kitty-scrollback').setup({
          -- global configuration
          {
            status_window = {
              autoclose = true,
            },
          },
          -- builtin configuration override
          ksb_builtin_get_text_all = {
            kitty_get_text = {
              ansi = false,
            },
          },
          -- user defined configuration table
          myconfig = {
            kitty_get_text = {
              ansi = false,
            },
          },
          -- user defined configuration function
          myfnconfig = function(kitty_data)
            return {
              kitty_get_text = {
                extent = (kitty_data.scrolled_by > kitty_data.lines) and 'all' or 'screen',
              },
            }
          end,
      })
      
      
      {
        -- KsbCallbacks? fire and forget callback functions
        callbacks = {
          -- fun(kitty_data: KsbKittyData, opts: KsbOpts)? callback executed after initializing kitty-scrollback.nvim
          after_setup = nil,
          -- fun(kitty_data: KsbKittyData, opts: KsbOpts)? callback executed after launch started to process the scrollback buffer
          after_launch = nil,
          -- fun(kitty_data: KsbKittyData, opts: KsbOpts)?  callback executed after scrollback buffer is loaded and cursor is positioned
          after_ready = nil,
          -- fun(paste_window_data: KsbPasteWindowData, kitty_data: KsbKittyData, opts: KsbOpts)? callback executed after the paste window is opened or resized
          after_paste_window_ready = nil,
        },
        -- boolean? if true, enabled all default keymaps
        keymaps_enabled = true,
        -- boolean? if true, restore options that were modified while processing the scrollback buffer
        restore_options = false,
        -- KsbHighlights? highlight overrides
        highlight_overrides = {
          -- table? status window Normal highlight group
          KittyScrollbackNvimStatusWinNormal = {},
          -- table? status window heart icon highlight group
          KittyScrollbackNvimStatusWinHeartIcon = {},
          -- table? status window spinner icon highlight group 
          KittyScrollbackNvimStatusWinSpinnerIcon = {},
          -- table? status window ready icon highlight group
          KittyScrollbackNvimStatusWinReadyIcon = {},
          -- table? status window kitty icon highlight group
          KittyScrollbackNvimStatusWinKittyIcon = {},
          -- table? status window vim icon highlight group
          KittyScrollbackNvimStatusWinNvimIcon = {},
          -- table? paste window Normal highlight group
          KittyScrollbackNvimPasteWinNormal = {},
          -- table? paste window FloatBorder highlight group
          KittyScrollbackNvimPasteWinFloatBorder = {},
          -- table? paste window FloatTitle highlight group
          KittyScrollbackNvimPasteWinFloatTitle = {},
          -- table? scrollback buffer window Visual selection highlight group
          KittyScrollbackNvimVisual = {},
          -- table? scrollback buffer window Normal highlight group
          KittyScrollbackNvimNormal = {},
        },
        -- KsbStatusWindowOpts? options for status window indicating that kitty-scrollback.nvim is ready
        status_window = {
          -- boolean If true, show status window in upper right corner of the screen
          enabled = true,
          -- boolean If true, use plaintext instead of nerd font icons
          style_simple = false,
          -- boolean If true, close the status window after kitty-scrollback.nvim is ready
          autoclose = false,
          -- boolean If true, show a timer in the status window while kitty-scrollback.nvim is loading
          show_timer = false,
          -- KsbStatusWindowIcons? Icons displayed in the status window
          icons = {
            -- string kitty status window icon
            kitty = '󰄛',
            -- string heart string heart status window icon
            heart = '󰣐', -- variants 󰣐 |  |  | ♥ |  | 󱢠 | 
            -- string nvim status window icon
            nvim = '', -- variants  |  |  | 
          },
        },
      
        -- KsbPasteWindowOpts? options for paste window that sends commands to Kitty
        paste_window = {
          --- BoolOrFn? If true, use Normal highlight group. If false, use NormalFloat
          highlight_as_normal_win = nil,
          -- string? The filetype of the paste window. If nil, use the shell that is configured for kitty
          filetype = nil,
          -- boolean? If true, hide mappings in the footer when the paste window is initially opened
          hide_footer = false,
          -- integer? The winblend setting of the window, see :help winblend
          winblend = 0,
          -- KsbWinOptsOverride? Paste float window overrides, see nvim_open_win() for configuration
          winopts_overrides = nil,
          -- KsbFooterWinOptsOverride? Paste footer window overrides, see nvim_open_win() for configuration
          footer_winopts_overrides = nil,
          -- string? register used during yanks to paste window, see :h registers
          yank_register = '',
          -- boolean? If true, the yank_register copies content to the paste window. If false, disable yank to paste window
          yank_register_enabled = true,
        },
      
        -- KsbKittyGetText? options passed to get-text when reading scrollback buffer, see kitty @ get-text --help
        kitty_get_text = {
          -- boolean If true, the text will include the ANSI formatting escape codes for colors, bold, italic, etc.
          ansi = true,
          -- string What text to get. The default of screen means all text currently on the screen. all means all the screen+scrollback and selection means the currently selected text. first_cmd_output_on_screen means the output of the first command that was run in the window on screen. last_cmd_output means the output of the last command that was run in the window. last_visited_cmd_output means the first command output below the last scrolled position via scroll_to_prompt. last_non_empty_output is the output from the last command run in the window that had some non empty output. The last four require shell_integration to be enabled. Choices: screen, all, first_cmd_output_on_screen, last_cmd_output, last_non_empty_output, last_visited_cmd_output, selection
          extent = 'all',
          -- boolean If true, clear the selection in the matched window, if any.
          clear_selection = true,
        },
        -- boolean? if true execute :checkhealth kitty-scrollback and skip setup
        checkhealth = false,
        -- string? Sets the mode for coloring the Visual highlight group in the scrollback buffer window. darken uses a darkened version of the Normal highlight group to improve readability. kitty uses the colors defined for selection_foreground and selection_background in your Kitty configuration. nvim uses the default colors defined in the Visual highlight group. reverse reverses the foreground and background colors of the visual selection.
        visual_selection_highlight_mode = 'darken',
      }
      
      
      -- kitty-scrollback-nvim-kitten-config.lua
      
      -- put your general Neovim configurations here
      vim.g.mapleader = ' '
      vim.g.maplocalleader = ','
      
      vim.keymap.set({ 'n' }, '<C-e>', '5<C-e>', {})
      vim.keymap.set({ 'n' }, '<C-y>', '5<C-y>', {})
      
      -- add kitty-scrollback.nvim to the runtimepath to allow us to require the kitty-scrollback module
      -- pick a runtimepath that corresponds with your package manager, if you are not sure leave them all it will not cause any issues
      vim.opt.runtimepath:append(vim.fn.stdpath('data') .. '/lazy/kitty-scrollback.nvim') -- lazy.nvim
      vim.opt.runtimepath:append(vim.fn.stdpath('data') .. '/site/pack/packer/opt/kitty-scrollback.nvim') -- packer
      vim.opt.runtimepath:append(vim.fn.stdpath('data') .. '/site/pack/mikesmithgh/start/kitty-scrollback.nvim') -- pack
      require('kitty-scrollback').setup({
        -- put your kitty-scrollback.nvim configurations here
      })
      
      
      local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
      if not vim.loop.fs_stat(lazypath) then
        vim.fn.system({ "git", "clone", "--filter=blob:none", "https://github.com/folke/lazy.nvim.git", "--branch=stable", lazypath, })
      end
      vim.opt.rtp:prepend(lazypath)
      
      require("lazy").setup({
        "mikesmithgh/kitty-scrollback.nvim",
        enabled = true,
        lazy = true,
        cmd = { 'KittyScrollbackGenerateKittens', 'KittyScrollbackCheckHealth', 'KittyScrollbackGenerateCommandLineEditing' },
        event = { "User KittyScrollbackLaunch" },
        config = function()
          require("kitty-scrollback").setup({
            {
              callbacks = {
                after_ready = vim.defer_fn(function()
                  vim.fn.confirm(vim.env.NVIM_APPNAME .. " kitty-scrollback.nvim example!")
                end, 1000),
              },
            },
          })
        end,
      })
      
      
      if vim.env.KITTY_SCROLLBACK_NVIM == 'true' then
          -- kitty-scrollback.nvim specific configuration
      end
      
      
      vim.api.nvim_create_autocmd({ 'FileType' }, {
        group = vim.api.nvim_create_augroup('KittyScrollbackNvimFileType', { clear = true }),
        pattern = { 'kitty-scrollback' },
        callback = function()
          -- add your logic here
          vim.print('kitty-scrollback.nvim is open!')
          return true
        end,
      })
      
      
      require('kitty-scrollback').setup({
        {
          callbacks = {
            after_ready = function(kitty_data)
              vim.print(kitty_data)
            end,
          },
        },
      })
      
    end,
  },
  {
    "niuiic/terminal.nvim",
    config = function()
      
      ---@param bufnr number | nil
      ---@param on_term_to_open (fun(bufnr: number | nil): boolean) | nil
      ---@param on_term_opened (fun(bufnr: number, pid: number, channel: number)) | nil
      local open = function(bufnr, on_term_to_open, on_term_opened) end
      
      
      -- open terminal vertically
      local open_vs_terminal = function()
      	vim.cmd("vsplit")
      	require("terminal").open(0)
      end
      
      -- open terminal horizontally
      local open_hs_terminal = function()
      	-- set height to 50
      	vim.cmd("50split")
      	require("terminal").open(0)
      end
      
      -- open terminal in float window
      local open_float_terminal = function()
      	-- 'niuiic/core.nvim' required
      	local core = require("core")
      
      	local size = core.win.proportional_size(0.8, 0.6)
      
      	local handle = core.win.open_float(0, {
      		enter = true,
      		relative = "editor",
      		width = size.width,
      		height = size.height,
      		row = size.row,
      		col = size.col,
      		style = "minimal",
      		border = "rounded",
      		title = "terminal",
      		title_pos = "center",
      	})
      	require("terminal").open(0)
      end
      
      
      local utils = require("terminal.utils")
      
      local config = {
      	---@type fun(bufnr: number | nil): boolean
      	on_term_to_open = function()
      		-- return false to prevent opening terminal
      		return true
      	end,
      	---@type fun(bufnr: number, pid: number, channel: number)
      	on_term_opened = function() end,
      }
      
      
      local terms = {}
      
      local set_line_number = function(show_line_number)
      	local options = {
      		"number",
      		"relativenumber",
      	}
      	for _, option in ipairs(options) do
      		vim.api.nvim_set_option_value(option, show_line_number, {
      			win = 0,
      		})
      	end
      end
      
      local set_keymap = function(bufnr)
      	local modes = { "t", "n" }
      
      	for _, mode in ipairs(modes) do
      		vim.api.nvim_buf_set_keymap(bufnr, mode, "<C-z>", "", {
      			callback = function()
      				require("terminal").open()
      			end,
      		})
      
      		vim.api.nvim_buf_set_keymap(bufnr, mode, "<C-x>", "", {
      			callback = function()
      				vim.uv.kill(terms[bufnr], "sigkill")
      				table.remove(terms, bufnr)
      				vim.api.nvim_buf_delete(bufnr, {
      					force = true,
      				})
      			end,
      		})
      
      		vim.api.nvim_buf_set_keymap(bufnr, mode, "<C-k>", "", {
      			callback = function()
      				-- 'akinsho/bufferline.nvim' required
      				vim.cmd("BufferLineCycleNext")
      			end,
      		})
      
      		vim.api.nvim_buf_set_keymap(bufnr, mode, "<C-j>", "", {
      			callback = function()
      				vim.cmd("BufferLineCyclePrev")
      			end,
      		})
      
      		vim.api.nvim_buf_set_keymap(bufnr, mode, "<space>bh", "", {
      			callback = function()
      				vim.cmd("BufferLineMovePrev")
      			end,
      		})
      
      		vim.api.nvim_buf_set_keymap(bufnr, mode, "<space>bl", "", {
      			callback = function()
      				vim.cmd("BufferLineMoveNext")
      			end,
      		})
      
      		vim.api.nvim_buf_set_keymap(bufnr, mode, "<space>bo", "", {
      			callback = function()
      				vim.cmd("BufferLinePick")
      			end,
      		})
      
      		vim.api.nvim_buf_set_keymap(bufnr, mode, "<C-q>", "", {
      			callback = function()
      				vim.cmd("Quit")
      			end,
      		})
      
      		vim.api.nvim_buf_set_keymap(bufnr, mode, "<esc>", "", {
      			callback = function()
      				vim.cmd("stopinsert")
      			end,
      		})
      	end
      end
      
      return {
      	config = function()
      		require("terminal").setup({
      			on_term_opened = function(bufnr, pid)
      				vim.api.nvim_set_option_value("filetype", "terminal", {
      					buf = bufnr,
      				})
      
      				set_line_number(false)
      
      				set_keymap(bufnr)
      
      				terms[bufnr] = pid
      			end,
      		})
      
      		vim.api.nvim_create_autocmd({ "BufEnter" }, {
      			pattern = { "*" },
      			callback = function(args)
      				local filetype = vim.api.nvim_get_option_value("filetype", {
      					buf = args.buf,
      				})
      				set_line_number(filetype ~= "terminal")
      			end,
      		})
      	end,
      	keys = {
      		{
      			"<C-z>",
      			function()
      				require("terminal").open()
      			end,
      			desc = "open terminal",
      		},
      	},
      }
      
      
      on_term_opened = function(bufnr, pid, channel)
      	local enter = vim.api.nvim_replace_termcodes("<cr>", true, true, true)
      	vim.defer_fn(function()
      		vim.api.nvim_feedkeys("node index.js" .. enter, "in", true)
      	end, 100)
      	-- or
      	vim.defer_fn(function()
      		vim.api.nvim_chan_send(channel, "echo hello" .. enter)
      	end, 100)
      end
      
    end,
  },
  {
    "NeViRAIDE/nekifoch.nvim",
    config = function()
      
      {
          'NeViRAIDE/nekifoch.nvim',
          build = 'chmod +x ./install.sh && ./install.sh',
          cmd = 'Nekifoch',
          config = true,
      }
      
      
      {
          kitty_conf_path = '~/.config/kitty/kitty.conf',
          borders = 'single', --available values are: 'rounded', 'single', 'double', 'shadow', 'solid', 'none'
      }
      
      
      require('nekifoch').setup({
        kitty_conf_path = vim.fn.expand('~/.config/kitty/kitty.conf')
      })
      
      
      {
          'NeViRAIDE/nekifoch.nvim',
          build = 'chmod +x ./install.sh && ./install.sh',
          cmd = 'Nekifoch', -- to add lazy loading
          opts = {
              kitty_conf_path = vim.fn.expand('~/.config/kitty/kitty.conf'), -- your kitty config path
          }
      }
      
    end,
  },
  {
    "2KAbhishek/termim.nvim/",
  },
  {
    "samharju/yeet.nvim",
    config = function()
      
      {
          "samharju/yeet.nvim",
          dependencies = {
              "stevearc/dressing.nvim", -- optional, provides sane UX
          },
          version = "*", -- use the latest release, remove for master
          cmd = "Yeet",
          opts = {},
      }
      
      
      use({
          "samharju/yeet.nvim",
          requires = {
              "stevearc/dressing.nvim", -- optional, provides sane UX
          },
          tag = "*", -- use the latest release, remove for master
          cmd = "Yeet",
          config = function()
              require("yeet").setup({})
          end,
      })
      
      
      vim.keymap.set("n", "<leader>yy", function()
          require("yeet").execute(
              "source venv/bin/activate",
              { clear_before_yeet = false }
          )
      end)
      
      
      {
          "samharju/yeet.nvim",
          keys = {
              {
                  -- Pop command cache open.
                  "<leader><BS>", function() require("yeet").list_cmd() end,
              },
              {
                  -- Douple tap \ to yeet at something.
                  "\\\\",
                  function() require("yeet").execute() end,
              },
              {
                  -- Run command without clearing terminal, interrupt previous command.
                  "<leader>\\",
                  function() require("yeet").execute(nil, { clear_before_yeet = false, interrupt_before_yeet = true, }) end,
              },
              {
                  -- Yeet visual selection. Useful sending code to a repl or running multiple shell commands.
                  -- Using yeet_and_run = true and clear_before_yeet = false heavily suggested, if not
                  -- already set in setup.
                  "\\\\",
                  function() require("yeet").execute_selection({ yeet_and_run = true, clear_before_yeet = false, }) end,
                  mode = { "v" },
              },
              {
                  -- Open target selection.
                  "<leader>yt",
                  function() require("yeet").select_target() end,
              },
              {
                  -- Toggle autocommand for yeeting after write.
                  "<leader>yo",
                  function() require("yeet").toggle_post_write() end,
              },
              {
                  -- Parse last command output with current vim.o.errorformat and send them to quickfix.
                  "<leader>ye",
                  function() require("yeet").setqflist({ open = true }) end,
              },
          },
      }
      
      
      -- Pop command cache open.
      vim.keymap.set("n", "<leader><BS>", require("yeet").list_cmd)
      -- Douple tap \ to yeet at something.
      vim.keymap.set("n", "\\\\", require("yeet").execute)
      -- Run command without clearing terminal, interrupt previous command.
      vim.keymap.set("n", "<leader>\\", function()
          require("yeet").execute(
              nil,
              { clear_before_yeet = false, interrupt_before_yeet = true }
          )
      end)
      -- Yeet visual selection. Useful sending code to a repl or running multiple shell commands.
      -- Using yeet_and_run = true and clear_before_yeet = false heavily suggested, if not
      -- already set in setup.
      vim.keymap.set("v", "\\\\", function()
          require("yeet").execute_selection({
              yeet_and_run = true,
              clear_before_yeet = false,
          })
      end)
      -- Open target selection.
      vim.keymap.set("n", "<leader>yt", require("yeet").select_target)
      -- Toggle autocommand for yeeting after write.
      vim.keymap.set("n", "<leader>yo", require("yeet").toggle_post_write)
      -- Parse last command output with current vim.o.errorformat and send them to quickfix.
      vim.keymap.set("n", "<leader>ye", function()
          require("yeet").setqflist({ open = true })
      end)
      
      
      {
          opts = {
              -- Send <CR> to channel after command for immediate execution.
              yeet_and_run = true,
              -- Send C-c before execution
              interrupt_before_yeet = false,
              -- Send 'clear<CR>' to channel before command for clean output.
              clear_before_yeet = true,
      
              -- Yeets pop a vim.notify by default if you have one of these available
              -- and configured to override `vim.notify`:
              --   noice.nvim, nvim-notify, fidget.nvim
              -- Force success notifications on or off by setting true/false:
      
              --notify_on_success = false,
      
              -- Print warning if pane list could not be fetched, e.g. tmux not running.
              warn_tmux_not_running = false,
              -- Command used by tmux to create a new pane. Must output the pane id with -PF '#D'.
              tmux_split_pane_command = "tmux split-window -dhPF  '#D'",
              -- Retries the last used target if the target is unavailable (e.g., tmux pane closed).
              -- Useful for maintaining workflow without re-selecting the target manually.
              -- Works with: term buffers, tmux panes, tmux windows
              retry_last_target_on_failure = false,
              -- Hide neovim term buffers in `yeet.select_target`
              hide_term_buffers = false,
              -- Resolver for cache file
              cache = function()
                 -- resolves project path and uses stdpath("cache")/yeet/<project>, see :h yeet
              end
      
              -- Open cache file instead of in memory prompt.
              use_cache_file = true
      
              -- Window options for cache float
              cache_window_opts = function()
                 -- returns a default config for vim.api.nvim_open_win with width
                 -- of max 120 columns and height of 15 lines. See yeet/conf.lua.
              end,
      
              -- Callback used before command is sent to target.
              -- You can use your own placeholders and replace them as you wish in the callback.
              custom_eval = nil
          }
      })
      
      
          opts = {
              custom_eval = function(cmd_string)
                  if string.match(cmd_string, "<file>") then
                      local fname = vim.fn.fnamemodify(vim.api.nvim_buf_get_name(0), ":.")
                      cmd_string = string.gsub(cmd_string, "<file>", fname)
                  end
                  return cmd_string
              end
         }
      
      
      {
          "theprimeagen/harpoon",
          branch = "harpoon2",
          dependencies = {
              "nvim-lua/plenary.nvim",
              "samharju/yeet.nvim",
          },
          config = function()
              local harpoon = require("harpoon")
              harpoon:setup({
                  yeet = {
                      select = function(list_item, _, _)
                          require("yeet").execute(list_item.value)
                      end,
                  },
              })
      
              vim.keymap.set( "n", "<leader><BS>",
                  function() harpoon.ui:toggle_quick_menu(harpoon:list("yeet")) end
              )
      
              -- other harpoon keymaps etc
              -- ...
          end,
      
      }
      
      
    end,
  },
  {
    "isak102/ghostty.nvim",
    config = function()
      
      {
          "isak102/ghostty.nvim",
          config = function()
              require("ghostty").setup()
          end,
      }
      
      
      {
          -- The autocmd pattern matched against the filename of the buffer. If this pattern
          -- matches, ghostty.nvim will run on save in that buffer. This pattern is passed to
          -- nvim_create_autocmd, check `:h autocmd-pattern` for more information. Can be
          -- either a string or a list of strings
          file_pattern = "*/ghostty/config",
          -- The ghostty executable to run.
          ghostty_cmd = "ghostty",
          -- The timeout in milliseconds for the check command.
          -- If the command takes longer than this it will be killed.
          check_timeout = 1000,
      }
      
    end,
  },
  {
    "laktak/tome",
  },
  {
    "Axot017/multiterm.nvim",
    config = function()
      
      use {
        'Axot017/multiterm.nvim',
        config = function()
          require('multiterm').setup()
        end
      }
      
      
      {
        'Axot017/multiterm.nvim',
        opts = {}
      }
      
      
      require('multiterm').setup({
        -- Logging level (1=DEBUG, 2=INFO, 3=WARN, 4=ERROR)
        log_level = 4,
      
        -- Terminal-specific key mappings
        mappings = {
          -- Mode-specific mappings
          t = {
            -- Key = action or {action = action, opts = {}}
            ["<C-x>"] = "<C-\\><C-n>",
            ["<Esc>"] = {
              action = "<C-\\><C-n>",
              opts = {desc = "Exit terminal mode"}
            }
          },
          n = {
            -- Normal mode mappings for terminal buffers
            ["q"] = function() require('multiterm').close_active() end
          }
        },
      
        -- Window configuration (can be a table or a function that returns a table)
        window = {
          relative = "editor",
          width = 80,
          height = 20,
          style = "minimal",
          border = "rounded",
          row = 10,
          col = 10,
        }
      })
      
      
      window = function()
        local default_width = math.floor(vim.o.columns * 0.8)
        local default_height = math.floor(vim.o.lines * 0.8)
      
        return {
          relative = "editor",
          width = default_width,
          height = default_height,
          style = "minimal",
          border = "rounded",
          row = math.floor((vim.o.lines - default_height) / 2),
          col = math.floor((vim.o.columns - default_width) / 2),
        }
      end
      
      
      -- Toggle a terminal bound to key 'g'
      vim.keymap.set('n', '<leader>tg', function() require('multiterm').toggle('g') end)
      
      -- Interactively bind a key to a terminal
      vim.keymap.set('n', '<leader>tb', function() require('multiterm').bind_toggle() end)
      
      -- Remove a terminal with binding 'g'
      vim.keymap.set('n', '<leader>rg', function() require('multiterm').remove('g') end)
      
      -- Interactively remove a terminal
      vim.keymap.set('n', '<leader>rb', function() require('multiterm').bind_remove() end)
      
      -- Remove all terminals
      vim.keymap.set('n', '<leader>ra', function() require('multiterm').remove_all() end)
      
      -- Close active terminal
      vim.keymap.set('n', '<leader>tc', function() require('multiterm').close_active() end)
      
      -- Send text to a terminal with binding 'g'
      vim.keymap.set('n', '<leader>sg', function() require('multiterm').send_text('g', 'echo "Hello world"\n') end)
      
      -- Send visually selected text to a terminal with binding 'g'
      vim.keymap.set('v', '<leader>sg', function() require('multiterm').send_selection('g') end)
      
      -- Interactively choose a terminal to send visually selected text to
      vim.keymap.set('v', '<leader>sb', function() require('multiterm').bind_send_selection() end)
      
    end,
  },
  {
    "da-moon/telescope-toggleterm.nvim",
    config = function()
      
      use {
        "https://git.sr.ht/~havi/telescope-toggleterm.nvim",
        event = "TermOpen",
        requires = {
           "akinsho/nvim-toggleterm.lua",
           "nvim-telescope/telescope.nvim",
           "nvim-lua/popup.nvim",
           "nvim-lua/plenary.nvim",
        },
        config = function()
           require("telescope").load_extension "toggleterm"
        end,
      }
      
      
      require("telescope-toggleterm").setup {
         telescope_mappings = {
            -- <ctrl-c> : kill the terminal buffer (default) .
            ["<C-c>"] = require("telescope-toggleterm").actions.exit_terminal,
         },
      }
      
    end,
  },
  {
    "benoror/gpg.nvim",
    config = function()
      
      -- ~/.config/nvim/lua/plugins/gpg.lua
      {
         "benoror/gpg.nvim",
      }
      
    end,
  },
  {
    "mfussenegger/nvim-dap",
  },
  {
    "sakhnik/nvim-gdb",
  },
  {
    "rcarriga/nvim-dap-ui",
    config = function()
      
      use { "rcarriga/nvim-dap-ui", requires = {"mfussenegger/nvim-dap", "nvim-neotest/nvim-nio"} }
      
      
      { "rcarriga/nvim-dap-ui", dependencies = {"mfussenegger/nvim-dap", "nvim-neotest/nvim-nio"} }
      
      
      require("lazydev").setup({
        library = { "nvim-dap-ui" },
      })
      
      
      require("dapui").setup()
      
      
      require("dapui").open()
      require("dapui").close()
      require("dapui").toggle()
      
      
      local dap, dapui = require("dap"), require("dapui")
      dap.listeners.before.attach.dapui_config = function()
        dapui.open()
      end
      dap.listeners.before.launch.dapui_config = function()
        dapui.open()
      end
      dap.listeners.before.event_terminated.dapui_config = function()
        dapui.close()
      end
      dap.listeners.before.event_exited.dapui_config = function()
        dapui.close()
      end
      
      
      require("dapui").float_element(<element ID>, <optional settings>)
      
      
      require("dapui").eval(<expression>)
      
    end,
  },
  {
    "pocco81/dap-buddy.nvim",
  },
  {
    "Weissle/persistent-breakpoints.nvim",
    config = function()
      
      require('persistent-breakpoints').setup{
      	load_breakpoints_event = { "BufReadPost" }
      }
      
      
      require('persistent-breakpoints').setup{
      	save_dir = vim.fn.stdpath('data') .. '/nvim_checkpoints',
      	-- when to load the breakpoints? "BufReadPost" is recommanded.
      	load_breakpoints_event = nil,
      	-- record the performance of different function. run :lua require('persistent-breakpoints.api').print_perf_data() to see the result.
      	perf_record = false,
      	-- perform callback when loading a persisted breakpoint
      	--- @param opts DAPBreakpointOptions options used to create the breakpoint ({condition, logMessage, hitCondition})
      	--- @param buf_id integer the buffer the breakpoint was set on
      	--- @param line integer the line the breakpoint was set on
      	on_load_breakpoint = nil,
          -- set this to true if the breakpoints are not loaded when you are using a session-like plugin.
      	always_reload = false,
      } 
      
      
      local opts = { noremap = true, silent = true }
      local keymap = vim.api.nvim_set_keymap
      -- Save breakpoints to file automatically.
      keymap("n", "<YourKey1>", "<cmd>lua require('persistent-breakpoints.api').toggle_breakpoint()<cr>", opts)
      keymap("n", "<YourKey2>", "<cmd>lua require('persistent-breakpoints.api').set_conditional_breakpoint()<cr>", opts)
      keymap("n", "<YourKey3>", "<cmd>lua require('persistent-breakpoints.api').clear_all_breakpoints()<cr>", opts)
      keymap("n", "<YourKey4>", "<cmd>lua require('persistent-breakpoints.api').set_log_point()<cr>", opts)
      
    end,
  },
  {
    "ofirgall/goto-breakpoints.nvim",
    config = function()
      
      use 'ofirgall/goto-breakpoints.nvim'
      
      
      local map = vim.keymap.set
      map('n', ']d', require('goto-breakpoints').next, {})
      map('n', '[d', require('goto-breakpoints').prev, {})
      map('n', ']S', require('goto-breakpoints').stopped, {})
      
    end,
  },
  {
    "andrewferrier/debugprint.nvim",
    config = function()
      
      return {
          "andrewferrier/debugprint.nvim",
      
          -- opts = { … },
      
          dependencies = {
              "echasnovski/mini.nvim",         -- Optional: Needed for line highlighting (full mini.nvim plugin)
                                               -- ... or ...
              "echasnovski/mini.hipatterns",   -- Optional: Needed for line highlighting ('fine-grained' hipatterns plugin)
      
              "ibhagwan/fzf-lua",              -- Optional: If you want to use the `:Debugprint search` command with fzf-lua
              "nvim-telescope/telescope.nvim", -- Optional: If you want to use the `:Debugprint search` command with telescope.nvim
              "folke/snacks.nvim",             -- Optional: If you want to use the `:Debugprint search` command with snacks.nvim
          },
      
          lazy = false, -- Required to make line highlighting work before debugprint is first used
          version = "*", -- Remove if you DON'T want to use the stable version
      }
      
      
      return {
          "andrewferrier/debugprint.nvim",
          opts = {
              keymaps = {
                  normal = {
                      plain_below = "g?p",
                      plain_above = "g?P",
                      variable_below = "g?v",
                      variable_above = "g?V",
                      variable_below_alwaysprompt = "",
                      variable_above_alwaysprompt = "",
                      surround_plain = "g?sp",
                      surround_variable = "g?sv",
                      surround_variable_alwaysprompt = "",
                      textobj_below = "g?o",
                      textobj_above = "g?O",
                      textobj_surround = "g?so",
                      toggle_comment_debug_prints = "",
                      delete_debug_prints = "",
                  },
                  insert = {
                      plain = "<C-G>p",
                      variable = "<C-G>v",
                  },
                  visual = {
                      variable_below = "g?v",
                      variable_above = "g?V",
                  },
              },
              -- … Other options
          },
      }
      
    end,
  },
  {
    "t-troebst/perfanno.nvim",
    config = function()
      
      require("perfanno").setup()
      
      
      local perfanno = require("perfanno")
      local util = require("perfanno.util")
      
      perfanno.setup {
          -- Creates a 10-step RGB color gradient beween background color and "#CC3300"
          line_highlights = util.make_bg_highlights(nil, "#CC3300", 10),
          vt_highlight = util.make_fg_highlight("#CC3300"),
      }
      
      local keymap = vim.api.nvim_set_keymap
      local opts = {noremap = true, silent = true}
      
      keymap("n", "<LEADER>plf", ":PerfLoadFlat<CR>", opts)
      keymap("n", "<LEADER>plg", ":PerfLoadCallGraph<CR>", opts)
      keymap("n", "<LEADER>plo", ":PerfLoadFlameGraph<CR>", opts)
      
      keymap("n", "<LEADER>pe", ":PerfPickEvent<CR>", opts)
      
      keymap("n", "<LEADER>pa", ":PerfAnnotate<CR>", opts)
      keymap("n", "<LEADER>pf", ":PerfAnnotateFunction<CR>", opts)
      keymap("v", "<LEADER>pa", ":PerfAnnotateSelection<CR>", opts)
      
      keymap("n", "<LEADER>pt", ":PerfToggleAnnotations<CR>", opts)
      
      keymap("n", "<LEADER>ph", ":PerfHottestLines<CR>", opts)
      keymap("n", "<LEADER>ps", ":PerfHottestSymbols<CR>", opts)
      keymap("n", "<LEADER>pc", ":PerfHottestCallersFunction<CR>", opts)
      keymap("v", "<LEADER>pc", ":PerfHottestCallersSelection<CR>", opts)
      
      
      require("perfanno").setup {
          -- List of highlights that will be used to highlight hot lines (or nil to disable).
          line_highlights = require("perfanno.util").make_bg_highlights(nil, "#FF0000", 10),
          -- Highlight used for virtual text annotations (or nil to disable virtual text).
          vt_highlight = require("perfanno.util").make_fg_highlight("#FF0000"),
      
          -- Annotation formats that can be cycled between via :PerfCycleFormat
          --   "percent" controls whether percentages or absolute counts should be displayed
          --   "format" is the format string that will be used to display counts / percentages
          --   "minimum" is the minimum value below which lines will not be annotated
          -- Note: this also controls what shows up in the telescope finders
          formats = {
              {percent = true, format = "%.2f%%", minimum = 0.5},
              {percent = false, format = "%d", minimum = 1}
          },
      
          -- Automatically annotate files after :PerfLoadFlat and :PerfLoadCallGraph
          annotate_after_load = true,
          -- Automatically annotate newly opened buffers if information is available
          annotate_on_open = true,
      
          -- Options for telescope-based hottest line finders
          telescope = {
              -- Enable if possible, otherwise the plugin will fall back to vim.ui.select
              enabled = pcall(require, "telescope"),
              -- Annotate inside of the preview window
              annotate = true,
          },
      
          -- Node type patterns used to find the function that surrounds the cursor
          ts_function_patterns = {
              -- These should work for most languages (at least those used with perf)
              default = {
                  "function",
                  "method",
              },
              -- Otherwise you can add patterns for specific languages like:
              -- weirdlang = {
              --     "weirdfunc",
              -- }
          }
      }
      
      local telescope = require("telescope")
      local actions = telescope.extensions.perfanno.actions
      telescope.setup {
          extensions = {
              perfanno = {
                  -- Special mappings in the telescope finders
                  mappings = {
                      ["i"] = {
                          -- Find hottest callers of selected entry
                          ["<C-h>"] = actions.hottest_callers,
                          -- Find hottest callees of selected entry
                          ["<C-l>"] = actions.hottest_callees,
                      },
      
                      ["n"] = {
                          ["gu"] = actions.hottest_callers,
                          ["gd"] = actions.hottest_callees,
                      }
                  }
              }
          }
      }
      
      
      local traces = {
          "event 1" = {
             {
                 count = 42,
                 frames = {
                      "symbol1 /home/user/Project/src_1.cpp:57",
                      "symbol2 /home/user/Project/src_2.cpp:32",
                      "symbol1 /home/user/Project/src_1.cpp:42"
                 }
             },
             {
                 count = 99,
                 frames = {
                      "symbol3 /home/user/Project/src_1.cpp:20",
                      "0x1231232",
                      "__foo_bar",
                      "symbol4 /home/user/Project/src_3.cpp:50"
                 }
             },
             -- more traces...
          },
      
          "event 2" = {
              -- ...
          },
      
          -- more events...
      }
      
      require("perfanno").load_traces(traces)
      
      
      {symbol = "symbol1", file = "/home/user/Project/src_1.cpp", linenr = 42}
      
    end,
  },
  {
    "niuiic/dap-utils.nvim",
    config = function()
      
      require("dap-utils").setup({
      	-- filetype = function while returns dap config
      	rust = function(run)
      		-- nvim-dap start to work after call `run`
      		-- the arguments of `run` is same to `dap.run`, see :h dap-api.
      		local config = {
      			-- `name` is required for config
      			name = "Launch",
      			type = "lldb",
      			request = "launch",
      			program = nil,
      			cwd = "${workspaceFolder}",
      			stopOnEntry = false,
      			args = {},
      		}
      		local core = require("core")
      		vim.cmd("!cargo build")
      		local root_path = core.file.root_path()
      		local target_dir = root_path .. "/target/debug/"
      		if core.file.file_or_dir_exists(target_dir) then
      			local executable = {}
      			for path, path_type in vim.fs.dir(target_dir) do
      				if path_type == "file" then
      					local perm = vim.fn.getfperm(target_dir .. path)
      					if string.match(perm, "x", 3) then
      						table.insert(executable, path)
      					end
      				end
      			end
      			if #executable == 1 then
      				config.program = target_dir .. executable[1]
      				run(config)
      			else
      				vim.ui.select(executable, { prompt = "Select executable" }, function(choice)
      					if not choice then
      						return
      					end
      					config.program = target_dir .. choice
      					run(config)
      				end)
      			end
      		else
      			vim.ui.input({ prompt = "Path to executable: ", default = root_path .. "/target/debug/" }, function(input)
      				config.program = input
      				run(config)
      			end)
      		end
      	end,
      })
      
      
      require("dap-utils").setup({
      	javascript = function(run)
      		local core = require("core")
      		run({
      			{
      				name = "Launch project",
      				type = "pwa-node",
      				request = "launch",
      				cwd = "${workspaceFolder}",
      				runtimeExecutable = "pnpm",
      				runtimeArgs = {
      					"debug",
      				},
      			},
      			{
      				name = "Launch cmd",
      				type = "pwa-node",
      				request = "launch",
      				cwd = core.file.root_path(),
      				runtimeExecutable = "pnpm",
      				runtimeArgs = {
      					"debug:cmd",
      				},
      			},
      			{
      				name = "Launch file",
      				type = "pwa-node",
      				request = "launch",
      				program = "${file}",
      				cwd = "${workspaceFolder}",
      			},
      			{
      				name = "Attach",
      				type = "pwa-node",
      				request = "attach",
      				processId = require("dap.utils").pick_process,
      				cwd = "${workspaceFolder}",
      			},
      		})
      	end,
      })
      
    end,
  },
  {
    "theHamsta/nvim-dap-virtual-text",
    config = function()
      
      require("nvim-dap-virtual-text").setup()
      
      
      require("nvim-dap-virtual-text").setup {
          enabled = true,                        -- enable this plugin (the default)
          enabled_commands = true,               -- create commands DapVirtualTextEnable, DapVirtualTextDisable, DapVirtualTextToggle, (DapVirtualTextForceRefresh for refreshing when debug adapter did not notify its termination)
          highlight_changed_variables = true,    -- highlight changed values with NvimDapVirtualTextChanged, else always NvimDapVirtualText
          highlight_new_as_changed = false,      -- highlight new variables in the same way as changed variables (if highlight_changed_variables)
          show_stop_reason = true,               -- show stop reason when stopped for exceptions
          commented = false,                     -- prefix virtual text with comment string
          only_first_definition = true,          -- only show virtual text at first definition (if there are multiple)
          all_references = false,                -- show virtual text on all all references of the variable (not only definitions)
          clear_on_continue = false,             -- clear virtual text on "continue" (might cause flickering when stepping)
          --- A callback that determines how a variable is displayed or whether it should be omitted
          --- @param variable Variable https://microsoft.github.io/debug-adapter-protocol/specification#Types_Variable
          --- @param buf number
          --- @param stackframe dap.StackFrame https://microsoft.github.io/debug-adapter-protocol/specification#Types_StackFrame
          --- @param node userdata tree-sitter node identified as variable definition of reference (see `:h tsnode`)
          --- @param options nvim_dap_virtual_text_options Current options for nvim-dap-virtual-text
          --- @return string|nil A text how the virtual text should be displayed or nil, if this variable shouldn't be displayed
          display_callback = function(variable, buf, stackframe, node, options)
          -- by default, strip out new line characters
            if options.virt_text_pos == 'inline' then
              return ' = ' .. variable.value:gsub("%s+", " ")
            else
              return variable.name .. ' = ' .. variable.value:gsub("%s+", " ")
            end
          end,
          -- position of virtual text, see `:h nvim_buf_set_extmark()`, default tries to inline the virtual text. Use 'eol' to set to end of line
          virt_text_pos = vim.fn.has 'nvim-0.10' == 1 and 'inline' or 'eol',
      
          -- experimental features:
          all_frames = false,                    -- show virtual text for all stack frames not only current. Only works for debugpy on my machine.
          virt_lines = false,                    -- show virtual lines instead of virtual text (will flicker!)
          virt_text_win_col = nil                -- position the virtual text at a fixed window column (starting from the first text column) ,
                                                 -- e.g. 80 to position at column 80, see `:h nvim_buf_set_extmark()`
      }
      
      
      require("nvim-dap-virtual-text").setup {
        commented = true,
      }
      
      
      require("nvim-dap-virtual-text").setup {
        show_stop_reason = false,
      }
      
    end,
  },
  {
    "chrisgrieser/nvim-chainsaw",
    config = function()
      
      -- lazy.nvim
      {
      	"chrisgrieser/nvim-chainsaw",
      	event = "VeryLazy",
      	opts = {} -- required even if left empty
      },
      
      -- packer
      use {
      	"chrisgrieser/nvim-chainsaw"
      	config = function ()
      		require("chainsaw").setup()
      	end,
      }
      
      
      -- log the name & value of the variable under the cursor
      require("chainsaw").variableLog()
      
      -- like variableLog, but with syntax specific to inspect an object, for example
      -- `console.log(JSON.stringify(foobar))` in javascript
      require("chainsaw").objectLog()
      
      -- inspect the type of the variable under cursor, such as `typeof foo` in js
      require("chainsaw").typeLog()
      
      -- assertion statement for variable under cursor
      require("chainsaw").assertLog()
      
      -- Minimal log statement, with an emoji for differentiation. Intended for
      -- control flow inspection, that is to quickly glance whether a condition was
      -- triggered or not.
      require("chainsaw").emojiLog()
      
      -- Sound-playing statement for audible debugging.
      -- Depending on the type of log statement, it is either a terminal bell
      -- (requiring the terminal) or a system sound.
      -- Inspired by https://news.ycombinator.com/item?id=41519046
      require("chainsaw").sound()
      
      -- create log statement, and position the cursor to enter a message
      require("chainsaw").messageLog()
      
      -- 1st call: start measuring the time
      -- 2nd call: log the time duration since the 1st statement
      require("chainsaw").timeLog()
      
      -- debug statements like `debugger` in javascript or `breakpoint()` in python
      require("chainsaw").debugLog()
      
      -- prints the stacktrace of the current call
      require("chainsaw").stacktraceLog()
      
      -- clearing statement, such as `console.clear()`
      require("chainsaw").clearLog()
      
      ---------------------------------------------------
      
      -- remove all log statements or all log statements in visually selected region
      -- created by nvim-chainsaw
      require("chainsaw").removeLogs()
      
      
      myVariable.myF[i]eld = "foobar"
      -- prints: myVariable.myField
      
      myVa[r]iable.myField = "foobar"
      -- prints: myVariable
      
      
      -- [] marks the cursor position
      
      -- default behavior
      local f[o]obar = 1
      -- will insert log statement here, below the cursor line
      
      -- multi-line assignments
      local f[o]o = {
      	bar = 1
      }
      -- will insert log statement, here after the assignment
      
      -- returns statements
      local function foobar()
      	-- will insert log statement here, before the return
      	return f[o]o
      end
      
      
      local marker = require("chainsaw.config.config").config.marker
      require("snacks").picker.grep_word {
      	title = marker .. " log statements",
      	cmd = "rg",
      	args = { "--trim" },
      	search = marker,
      	regex = false,
      	live = false,
      }
      
      
      -- default settings
      require("chainsaw").setup {
      	-- The marker should be a unique string, since signs and highlights are based
      	-- on it. Furthermore, `.removeLogs()` will remove any line with it. Thus,
      	-- unique emojis or strings (e.g., "[Chainsaw]") are recommended.
      	marker = "🪚",
      
      	-- Appearance of lines with the marker
      	visuals = {
      		icon = "󰹈", ---@type string|false as opposed to the marker only used in nvim, thus nerdfont glyphs are okay
      		signHlgroup = "DiagnosticSignInfo", ---@type string|false
      		signPriority = 50,
      		lineHlgroup = false, ---@type string|false
      
      		nvimSatelliteIntegration = {
      			enabled = true,
      			hlgroup = "DiagnosticSignInfo",
      			icon = "▪",
      			leftOfScrollbar = false,
      			priority = 40, -- compared to other handlers (diagnostics are 50)
      		},
      	},
      
      	-- Auto-install a pre-commit hook that prevents commits containing the marker
      	-- string. Will not be installed if there is already another pre-commit-hook.
      	preCommitHook = {
      		enabled = false,
      		notifyOnInstall = true,
      		hookPath = ".chainsaw", -- relative to git root
      
      		-- Will insert the marker as `%s`. (Pre-commit hooks requires a shebang
      		-- and exit non-zero when marker is found to block the commit.)
      		hookContent = [[#!/bin/sh
      			if git grep --fixed-strings --line-number "%s" .; then
      				echo
      				echo "nvim-chainsaw marker found. Aborting commit."
      				exit 1
      			fi
      		]],
      
      		-- Relevant if you track your nvim-config via git and use a custom marker,
      		-- as your config will then always include the marker and falsely trigger
      		-- the pre-commit hook.
      		notInNvimConfigDir = true,
      
      		-- List of git roots where the hook should not be installed. Supports
      		-- globs and `~`. Must match the full directory.
      		dontInstallInDirs = {
      			-- "~/special-project"
      			-- "~/repos/**",
      		},
      	},
      
      	-- configuration for specific logtypes
      	logTypes = {
      		emojiLog = {
      			emojis = { "🔵", "🟩", "⭐", "⭕", "💜", "🔲" },
      		},
      	},
      
      	-----------------------------------------------------------------------------
      	-- see https://github.com/chrisgrieser/nvim-chainsaw/blob/main/lua/chainsaw/config/log-statements-data.lua
      	logStatements = require("chainsaw.config.log-statements-data").logStatements,
      	supersets = require("chainsaw.config.log-statements-data").supersets,
      }
      
      
      require("chainsaw").setup ({
      	logStatements = {
      		variableLog = {
      			javascript = 'console.log("{{marker}} {{var}}:", {{var}});',
      			yourFiletype = "", -- <-- add the statement for your filetype here
      		},
      		-- the same for the other log statement operations
      	},
      })
      
      
      require("chainsaw").setup {
      	logStatements = {
      		variableLog = {
      			nvim_lua = "Chainsaw({{var}}) -- {{marker}}",
      		},
      	},
      }
      
      
      -- Option 1: nvim-lspconfig
      require("lspconfig").lua_ls.setup {
      	settings = {
      		Lua = {
      			diagnostics = {
      				globals = { "Chainsaw", "vim" },
      			},
      		},
      	},
      }
      
      
      -- Option 3: lazydev.nvim
      opts = {
      	library = {
      		{ path = "nvim-chainsaw", words = { "Chainsaw" } },
      	},
      },
      
      
      require("chainsaw").setup {
      	logStatements = {
      		variableLog = {
      			javascript = {
      				"/* prettier-ignore */ // {{marker}}",
      				'console.log("{{marker}} {{var}}:", {{var}});',
      			},
      		},
      	},
      }
      
      
      require("chainsaw.visuals.statusline").countInBuffer()
      
    end,
  },
  {
    "Willem-J-an/visidata.nvim",
  },
  {
    "igorlfs/nvim-dap-view",
    config = function()
      
      return {
          {
              "igorlfs/nvim-dap-view",
              ---@module 'dap-view'
              ---@type dapview.Config
              opts = {},
          },
      }
      
    end,
  },
  {
    "Carcuis/dap-breakpoints.nvim",
    config = function()
      
      require("persistent-breakpoints").setup()
      require("dap-breakpoints").setup()
      
      
      -- default config
      require('dap-breakpoints').setup{
        auto_load = true,         -- auto load breakpoints on 'BufReadPost'
        auto_save = true,         -- auto save breakpoints when make changes to breakpoints
        auto_reveal_popup = true, -- auto show pop up property when navigate to next/prev breakpoint
        virtual_text = {
          enabled = true,
          priority = 10,
          current_line_only = false,
          preset = "default", ---@type "default" | "separate" | "icons_only" | "messages_only"
          order = "chl", ---@type string order of conditional, hit_condition, log_point, omit a char to hide that type
          layout = {
            position = 121, ---@type "eol" | "right_align" | integer
            spaces = 4, -- spaces between code and virtual text, only for position = "eol"
          },
          prefix = {
            normal = "",
            log_point = "󰰍 ",
            conditional = "󰯲 ",
            hit_condition = "󰰁 ",
          },
          custom_text_handler = nil, ---@type nil | fun(bp: DapBp.Breakpoint): string
        },
      }
      
      
      -- add below to your neovim configuration
      local dapbp_api = require("dap-breakpoints.api")
      local dapbp_keymaps = {
        { "<leader>b", dapbp_api.toggle_breakpoint, desc = "Toggle Breakpoint" },
        { "<leader>dts", dapbp_api.set_breakpoint, desc = "Set Breakpoint" },
        { "<leader>dtc", dapbp_api.set_conditional_breakpoint, desc = "Set Conditional Breakpoint" },
        { "<leader>dth", dapbp_api.set_hit_condition_breakpoint, desc = "Set Hit Condition Breakpoint" },
        { "<leader>dtl", dapbp_api.set_log_point, desc = "Set Log Point" },
        {
          "<leader>dtL",
          function()
            M.load_breakpoints({
              notify = "always"  ---@type "always" | "never" | "on_empty" | "on_some"
            })
          end,
          desc = "Load Breakpoints"
        },
        {
          "<leader>dtS",
          function()
            dapbp_api.save_breakpoints({
              notify = "always"  ---@type "always" | "never" | "on_empty" | "on_some"
            })
          end,
          desc = "Save Breakpoints"
        },
        { "<leader>dte", dapbp_api.edit_property, desc = "Edit Breakpoint Property" },
        { "<leader>dtE", function() dapbp_api.edit_property({ all = true }) end, desc = "Edit All Breakpoint Properties" },
        { "<leader>dtv", dapbp_api.toggle_virtual_text, desc = "Toggle Breakpoint Virtual Text" },
        { "<leader>dtC", dapbp_api.clear_all_breakpoints, desc = "Clear All Breakpoints" },
        { "[b", dapbp_api.go_to_previous, desc = "Go to Previous Breakpoint" },
        { "]b", dapbp_api.go_to_next, desc = "Go to Next Breakpoint" },
        { "<M-b>", dapbp_api.popup_reveal, desc = "Reveal Breakpoint" },
      }
      for _, keymap in ipairs(dapbp_keymaps) do
        vim.keymap.set("n", keymap[1], keymap[2], { desc = keymap.desc })
      end
      
    end,
  },
  {
    "kevinhwang91/nvim-bqf",
    config = function()
      
      use {'kevinhwang91/nvim-bqf'}
      
      
      use {'kevinhwang91/nvim-bqf', ft = 'qf'}
      
      -- optional
      use {'junegunn/fzf', run = function()
          vim.fn['fzf#install']()
      end
      }
      
      -- optional, highly recommended
      use {'nvim-treesitter/nvim-treesitter', run = ':TSUpdate'}
      
      
      {
          auto_enable = {
              description = [[Enable nvim-bqf in quickfix window automatically]],
              default = true
          },
          magic_window = {
              description = [[Give the window magic, when the window is splited horizontally, keep
                  the distance between the current line and the top/bottom border of neovim unchanged.
                  It's a bit like a floating window, but the window is indeed a normal window, without
                  any floating attributes.]],
              default = true
          },
          auto_resize_height = {
              description = [[Resize quickfix window height automatically.
                  Shrink higher height to size of list in quickfix window, otherwise extend height
                  to size of list or to default height (10)]],
              default = false
          },
          preview = {
              auto_preview = {
                  description = [[Enable preview in quickfix window automatically]],
                  default = true
              },
              border = {
                  description = [[The border for preview window,
                      `:h nvim_open_win() | call search('border:')`]],
                  default = 'rounded',
              },
              show_title = {
                  description = [[Show the window title]],
                  default = true
              },
              show_scroll_bar = {
                  description = [[Show the scroll bar]],
                  default = true
              },
              delay_syntax = {
                  description = [[Delay time, to do syntax for previewed buffer, unit is millisecond]],
                  default = 50
              },
              win_height = {
                  description = [[The height of preview window for horizontal layout,
                      large value (like 999) perform preview window as a "full" mode]],
                  default = 15
              },
              win_vheight = {
                  description = [[The height of preview window for vertical layout]],
                  default = 15
              },
              winblend = {
                  description = [[The winblend for preview window, `:h winblend`]],
                  default = 12
              },
              wrap = {
                  description = [[Wrap the line, `:h wrap` for detail]],
                  default = false
              },
              buf_label = {
                  description = [[Add label of current item buffer at the end of the item line]],
                  default = true
              },
              should_preview_cb = {
                  description = [[A callback function to decide whether to preview while switching buffer,
                      with (bufnr: number, qwinid: number) parameters]],
                  default = nil
              }
          },
          func_map = {
              description = [[The table for {function = key}]],
              default = [[see ###Function table for detail]],
          },
          filter = {
              fzf = {
                  action_for = {
                      ['ctrl-t'] = {
                          description = [[Press ctrl-t to open up the item in a new tab]],
                          default = 'tabedit'
                      },
                      ['ctrl-v'] = {
                          description = [[Press ctrl-v to open up the item in a new vertical split]],
                          default = 'vsplit'
                      },
                      ['ctrl-x'] = {
                          description = [[Press ctrl-x to open up the item in a new horizontal split]],
                          default = 'split'
                      },
                      ['ctrl-q'] = {
                          description = [[Press ctrl-q to toggle sign for the selected items]],
                          default = 'signtoggle'
                      },
                      ['ctrl-c'] = {
                          description = [[Press ctrl-c to close quickfix window and abort fzf]],
                          default = 'closeall'
                      }
                  },
                  extra_opts = {
                      description = 'Extra options for fzf',
                      default = {'--bind', 'ctrl-o:toggle-all'}
                  }
              }
          }
      }
      
      
      local context = {context = {bqf = {}}}
      
      
      context = {
          bqf = {
              pattern_hl = {
                  description = [[search pattern from current position]],
                  type = 'string'
              },
              lsp_ranges_hl = {
                  description = [[a list of lsp range. The length of list is equal to the items',
                  pairwise correspondence each other]],
                  type = 'table'
              }
          }
      }
      
      
      local cmd = vim.cmd
      local api = vim.api
      local fn = vim.fn
      
      local function createQf()
          cmd('enew')
          local bufnr = api.nvim_get_current_buf()
          local lines = {}
          for i = 1, 3 do
              table.insert(lines, ('%d | %s'):format(i, fn.strftime('%F')))
          end
          api.nvim_buf_set_lines(bufnr, 0, -1, false, lines)
          fn.setqflist({
              {bufnr = bufnr, lnum = 1, col = 5}, {bufnr = bufnr, lnum = 2, col = 10},
              {bufnr = bufnr, lnum = 3, col = 13}
          })
      end
      
      function _G.bqfPattern()
          createQf()
          fn.setqflist({}, 'r', {context = {bqf = {pattern_hl = [[\d\+]]}}, title = 'patternHl'})
          cmd('cw')
      end
      
      function _G.bqfLspRanges()
          createQf()
          local lspRanges = {}
          table.insert(lspRanges,
              {start = {line = 0, character = 4}, ['end'] = {line = 0, character = 8}})
          table.insert(lspRanges,
              {start = {line = 1, character = 9}, ['end'] = {line = 1, character = 11}})
          table.insert(lspRanges,
              {start = {line = 2, character = 12}, ['end'] = {line = 2, character = 14}})
          fn.setqflist({}, 'r', {context = {bqf = {lsp_ranges_hl = lspRanges}}, title = 'lspRangesHl'})
          cmd('cw')
      end
      
      function _G.qfRanges()
          createQf()
          local items = fn.getqflist()
          local it1, it2, it3 = items[1], items[2], items[3]
          it1.end_lnum, it1.end_col = it1.lnum, it1.col + 4
          it2.end_lnum, it2.end_col = it2.lnum, it2.col + 2
          it3.end_lnum, it3.end_col = it3.lnum, it3.col + 2
          fn.setqflist({}, 'r', {items = items, title = 'qfRangesHl'})
          cmd('cw')
      end
      
      -- Save and source me(`so %`). Run `:lua bqfPattern()`, `:lua bqfLspRanges()` and `:lua qfRanges()`
      
      
      vim.cmd([[
          hi BqfPreviewBorder guifg=#3e8e2d ctermfg=71
          hi BqfPreviewTitle guifg=#3e8e2d ctermfg=71
          hi BqfPreviewThumb guibg=#3e8e2d ctermbg=71
          hi link BqfPreviewRange Search
      ]])
      
      require('bqf').setup({
          auto_enable = true,
          auto_resize_height = true, -- highly recommended enable
          preview = {
              win_height = 12,
              win_vheight = 12,
              delay_syntax = 80,
              border = {'┏', '━', '┓', '┃', '┛', '━', '┗', '┃'},
              show_title = false,
              should_preview_cb = function(bufnr, qwinid)
                  local ret = true
                  local bufname = vim.api.nvim_buf_get_name(bufnr)
                  local fsize = vim.fn.getfsize(bufname)
                  if fsize > 100 * 1024 then
                      -- skip file size greater than 100k
                      ret = false
                  elseif bufname:match('^fugitive://') then
                      -- skip fugitive buffer
                      ret = false
                  end
                  return ret
              end
          },
          -- make `drop` and `tab drop` to become preferred
          func_map = {
              drop = 'o',
              openc = 'O',
              split = '<C-s>',
              tabdrop = '<C-t>',
              -- set to empty string to disable
              tabc = '',
              ptogglemode = 'z,',
          },
          filter = {
              fzf = {
                  action_for = {['ctrl-s'] = 'split', ['ctrl-t'] = 'tab drop'},
                  extra_opts = {'--bind', 'ctrl-o:toggle-all', '--prompt', '> '}
              }
          }
      })
      
      
      local fn = vim.fn
      local cmd = vim.cmd
      local api = vim.api
      
      cmd([[
          packadd nvim-bqf
          packadd fzf
          packadd nvim-treesitter
          packadd vim-grepper
          packadd coc.nvim
      ]])
      
      -- https://github.com/mhinz/vim-grepper
      vim.g.grepper = {tools = {'rg', 'grep'}, searchreg = 1}
      cmd(([[
          aug Grepper
              au!
              au User Grepper ++nested %s
          aug END
      ]]):format([[call setqflist([], 'r', {'context': {'bqf': {'pattern_hl': '\%#' . getreg('/')}}})]]))
      
      -- try `gsiw` under word
      cmd([[
          nmap gs  <plug>(GrepperOperator)
          xmap gs  <plug>(GrepperOperator)
      ]])
      
      -- https://github.com/neoclide/coc.nvim
      -- if you use coc-fzf, you should disable its CocLocationsChange event
      -- to make bqf work for <Plug>(coc-references)
      
      -- vim.schedule(function()
      --     cmd('au! CocFzfLocation User CocLocationsChange')
      -- end)
      vim.g.coc_enable_locationlist = 0
      cmd([[
          aug Coc
              au!
              au User CocLocationsChange lua _G.jumpToLoc()
          aug END
      ]])
      
      cmd([[
          nmap <silent> gr <Plug>(coc-references)
          nnoremap <silent> <leader>qd <Cmd>lua _G.diagnostic()<CR>
      ]])
      
      -- just use `_G` prefix as a global function for a demo
      -- please use module instead in reality
      function _G.jumpToLoc(locs)
          locs = locs or vim.g.coc_jump_locations
          fn.setloclist(0, {}, ' ', {title = 'CocLocationList', items = locs})
          local winid = fn.getloclist(0, {winid = 0}).winid
          if winid == 0 then
              cmd('abo lw')
          else
              api.nvim_set_current_win(winid)
          end
      end
      
      function _G.diagnostic()
          fn.CocActionAsync('diagnosticList', '', function(err, res)
              if err == vim.NIL then
                  local items = {}
                  for _, d in ipairs(res) do
                      local text = ('[%s%s] %s'):format((d.source == '' and 'coc.nvim' or d.source),
                          (d.code == vim.NIL and '' or ' ' .. d.code), d.message:match('([^\n]+)\n*'))
                      local item = {
                          filename = d.file,
                          lnum = d.lnum,
                          end_lnum = d.end_lnum,
                          col = d.col,
                          end_col = d.end_col,
                          text = text,
                          type = d.severity
                      }
                      table.insert(items, item)
                  end
                  fn.setqflist({}, ' ', {title = 'CocDiagnosticList', items = items})
      
                  cmd('bo cope')
              end
          end)
      end
      -- you can also subscribe User `CocDiagnosticChange` event to reload your diagnostic in quickfix
      -- dynamically, enjoy yourself :)
      
      
      local fn = vim.fn
      
      function _G.qftf(info)
          local items
          local ret = {}
          -- The name of item in list is based on the directory of quickfix window.
          -- Change the directory for quickfix window make the name of item shorter.
          -- It's a good opportunity to change current directory in quickfixtextfunc :)
          --
          -- local alterBufnr = fn.bufname('#') -- alternative buffer is the buffer before enter qf window
          -- local root = getRootByAlterBufnr(alterBufnr)
          -- vim.cmd(('noa lcd %s'):format(fn.fnameescape(root)))
          --
          if info.quickfix == 1 then
              items = fn.getqflist({id = info.id, items = 0}).items
          else
              items = fn.getloclist(info.winid, {id = info.id, items = 0}).items
          end
          local limit = 31
          local fnameFmt1, fnameFmt2 = '%-' .. limit .. 's', '…%.' .. (limit - 1) .. 's'
          local validFmt = '%s │%5d:%-3d│%s %s'
          for i = info.start_idx, info.end_idx do
              local e = items[i]
              local fname = ''
              local str
              if e.valid == 1 then
                  if e.bufnr > 0 then
                      fname = fn.bufname(e.bufnr)
                      if fname == '' then
                          fname = '[No Name]'
                      else
                          fname = fname:gsub('^' .. vim.env.HOME, '~')
                      end
                      -- char in fname may occur more than 1 width, ignore this issue in order to keep performance
                      if #fname <= limit then
                          fname = fnameFmt1:format(fname)
                      else
                          fname = fnameFmt2:format(fname:sub(1 - limit))
                      end
                  end
                  local lnum = e.lnum > 99999 and -1 or e.lnum
                  local col = e.col > 999 and -1 or e.col
                  local qtype = e.type == '' and '' or ' ' .. e.type:sub(1, 1):upper()
                  str = validFmt:format(fname, lnum, col, qtype, e.text)
              else
                  str = e.text
              end
              table.insert(ret, str)
          end
          return ret
      end
      
      vim.o.qftf = '{info -> v:lua._G.qftf(info)}'
      
      -- Adapt fzf's delimiter in nvim-bqf
      require('bqf').setup({
          filter = {
              fzf = {
                  extra_opts = {'--bind', 'ctrl-o:toggle-all', '--delimiter', '│'}
              }
          }
      })
      
    end,
  },
  {
    "yorickpeterse/nvim-pqf",
    config = function()
      
      require('pqf').setup({
        signs = {
          error = { text = 'E', hl = 'DiagnosticSignError' },
          warning = { text = 'W', hl = 'DiagnosticSignWarn' },
          info = { text = 'I', hl = 'DiagnosticSignInfo' },
          hint = { text = 'H', hl = 'DiagnosticSignHint' },
        },
      
        -- By default, only the first line of a multi line message will be shown.
        -- When this is true, multiple lines will be shown for an entry, separated by
        -- a space
        show_multiple_lines = false,
      
        -- How long filenames in the quickfix are allowed to be. 0 means no limit.
        -- Filenames above this limit will be truncated from the beginning with
        -- `filename_truncate_prefix`.
        max_filename_length = 0,
      
        -- Prefix to use for truncated filenames.
        filename_truncate_prefix = '[...]',
      })
      
    end,
  },
  {
    "nyngwang/NeoWell.lua",
    config = function()
      
      local NOREF_NOERR_TRUNC = { noremap = true, silent = true, nowait = true }
      ----
      use {
        'nyngwang/NeoWell.lua',
        config = function ()
          require('neo-well').setup {
            height = 10
          }
        end
      }
      vim.keymap.set('n', '\\', function () vim.cmd('NeoWellToggle') end, NOREF_NOERR_TRUNC)
      vim.keymap.set('n', '<Leader>/', function () vim.cmd('NeoWellAppend') end, NOREF_NOERR_TRUNC)
      vim.keymap.set('n', '<CR>', function ()
        -- vim.cmd('NeoZoomToggle') -- remove this if you don't know what it is
        vim.cmd('NeoWellJump')
      end, NOREF_NOERR_TRUNC)
      vim.keymap.set('n', '<Leader>r', function () vim.cmd('NeoWellEdit') end, NOREF_NOERR_TRUNC)
      vim.keymap.set('n', '<Leader>d', function () vim.cmd('NeoWellOut') end, NOREF_NOERR_TRUNC)
      vim.keymap.set('n', '<Leader>D', function () vim.cmd('NeoWellWipeOut') end, NOREF_NOERR_TRUNC)
      
    end,
  },
  {
    "ashfinal/qfview.nvim",
    config = function()
      
      require('qfview').setup()
      
      
      {
        "ashfinal/qfview.nvim",
        event = "UIEnter",
        config = true,
      },
      
    end,
  },
  {
    "niuiic/quickfix.nvim",
    config = function()
      
      -- path: string
      require('quickfix').store(path)
      require('quickfix').restore(path)
      
      
      -- name: string | nil
      require('quickfix').make(name)
      
      
      -- remove qf item
      require('quickfix').remove()
      
      
      local config = {
      	---@type {[string]: quickfix.Make}
      	make = {
      		node = {
      			cmd = "node",
      			args = { "index.js" },
      			-- fields of options
      			-- - cwd: (string) Set the current working directory for the sub-process.
      			-- - env: table<string,string> Set environment variables for the new process. Inherits the
      			--   current environment with `NVIM` set to |v:servername|.
      			-- - clear_env: (boolean) `env` defines the job environment exactly, instead of merging current
      			--   environment.
      			-- - stdin: (string|string[]|boolean) If `true`, then a pipe to stdin is opened and can be written
      			--   to via the `write()` method to SystemObj. If string or string[] then will be written to stdin
      			--   and closed. Defaults to `false`.
      			-- - stdout: (boolean|function)
      			--   Handle output from stdout. When passed as a function must have the signature `fun(err: string, data: string)`.
      			--   Defaults to `true`
      			-- - stderr: (boolean|function)
      			--   Handle output from stderr. When passed as a function must have the signature `fun(err: string, data: string)`.
      			--   Defaults to `true`.
      			-- - text: (boolean) Handle stdout and stderr as text. Replaces `\r\n` with `\n`.
      			-- - timeout: (integer) Run the command with a time limit. Upon timeout the process is sent the
      			--   TERM signal (15) and the exit code is set to 124.
      			-- - detach: (boolean) If true, spawn the child process in a detached state - this will make it
      			--   a process group leader, and will effectively enable the child to keep running after the
      			--   parent exits. Note that the child process will still keep the parent's event loop alive
      			--   unless the parent process calls |uv.unref()| on the child's process handle.
      			options = {},
      			-- return false means this make config would not work
      			is_enabled = function()
      				return vim.bo.filetype == "javascript"
      			end,
      			-- parse command output and set qf_list
      			-- for basic usage, just copy this function and modify the regex
      			-- note that error messages may come from `output` or `err`
      			-- for advanced user, do filtering, mapping or something else as you like.
      			parser = function(output, err)
      				-- in this example, the error messages comes from `err`(stderr)
      				local lines = vim.split(err, "\n")
      				---@type {file_name: string, lnum: number, text: string}
      				local qf_item
      				-- qf_list is an array of qf_item
      				local qf_list = {}
      				for _, line in ipairs(lines) do
      					-- if line match this regex, it should be the start of a new qf_item, or it should be extra info for the previous qf_item
      					local file, line_nr, msg = string.match(line, "^(%S+):(%d+):?(.*)")
      					msg = msg or ""
      					if file and line then
      						if qf_item then
      							table.insert(qf_list, qf_item)
      						end
      						qf_item = { filename = file, lnum = tonumber(line_nr), text = msg }
      					else
      						if qf_item then
      							qf_item.text = qf_item.text .. "\n" .. line
      						end
      					end
      				end
      				table.insert(qf_list, qf_item)
      				vim.fn.setqflist(qf_list)
      			end,
      		},
      		tsc = {
      			cmd = "pnpm",
      			args = { "tsc", "index.ts" },
      			-- parser can be string or function
      			-- this parser is defined below
      			parser = "tsc",
      		},
      	},
      	---@type {[string]: fun(output: string, err: string)}
      	parser = {
      		tsc = function(output, _)
      			local lines = vim.split(output, "\n")
      			local qf_item
      			local qf_list = {}
      			for _, line in ipairs(lines) do
      				local file, line_nr, msg = string.match(line, "^(%S+)%((%d+),%d+%):(.*)")
      				if file and line then
      					if qf_item then
      						table.insert(qf_list, qf_item)
      					end
      					qf_item = { filename = file, lnum = tonumber(line_nr), text = msg }
      				else
      					if qf_item then
      						qf_item.text = qf_item.text .. "\n" .. line
      					end
      				end
      			end
      			table.insert(qf_list, qf_item)
      			vim.fn.setqflist(qf_list)
      		end,
      	},
      }
      
    end,
  },
  {
    "stevearc/quicker.nvim",
    config = function()
      
      {
        'stevearc/quicker.nvim',
        ft = "qf",
        ---@module "quicker"
        ---@type quicker.SetupOptions
        opts = {},
      }
      
      
      require("packer").startup(function()
        use({
          "stevearc/quicker.nvim",
          config = function()
            require("quicker").setup()
          end,
        })
      end)
      
      
      require("paq")({
        { "stevearc/quicker.nvim" },
      })
      
      
      require("quicker").setup()
      
      
      vim.keymap.set("n", "<leader>q", function()
        require("quicker").toggle()
      end, {
        desc = "Toggle quickfix",
      })
      vim.keymap.set("n", "<leader>l", function()
        require("quicker").toggle({ loclist = true })
      end, {
        desc = "Toggle loclist",
      })
      require("quicker").setup({
        keys = {
          {
            ">",
            function()
              require("quicker").expand({ before = 2, after = 2, add_to_existing = true })
            end,
            desc = "Expand quickfix context",
          },
          {
            "<",
            function()
              require("quicker").collapse()
            end,
            desc = "Collapse quickfix context",
          },
        },
      })
      
      
      require("quicker").setup({
        -- Local options to set for quickfix
        opts = {
          buflisted = false,
          number = false,
          relativenumber = false,
          signcolumn = "auto",
          winfixheight = true,
          wrap = false,
        },
        -- Set to false to disable the default options in `opts`
        use_default_opts = true,
        -- Keymaps to set for the quickfix buffer
        keys = {
          -- { ">", "<cmd>lua require('quicker').expand()<CR>", desc = "Expand quickfix content" },
        },
        -- Callback function to run any custom logic or keymaps for the quickfix buffer
        on_qf = function(bufnr) end,
        edit = {
          -- Enable editing the quickfix like a normal buffer
          enabled = true,
          -- Set to true to write buffers after applying edits.
          -- Set to "unmodified" to only write unmodified buffers.
          autosave = "unmodified",
        },
        -- Keep the cursor to the right of the filename and lnum columns
        constrain_cursor = true,
        highlight = {
          -- Use treesitter highlighting
          treesitter = true,
          -- Use LSP semantic token highlighting
          lsp = true,
          -- Load the referenced buffers to apply more accurate highlights (may be slow)
          load_buffers = false,
        },
        follow = {
          -- When quickfix window is open, scroll to closest item to the cursor
          enabled = false,
        },
        -- Map of quickfix item type to icon
        type_icons = {
          E = "󰅚 ",
          W = "󰀪 ",
          I = " ",
          N = " ",
          H = " ",
        },
        -- Border characters
        borders = {
          vert = "┃",
          -- Strong headers separate results from different files
          strong_header = "━",
          strong_cross = "╋",
          strong_end = "┫",
          -- Soft headers separate results within the same file
          soft_header = "╌",
          soft_cross = "╂",
          soft_end = "┨",
        },
        -- How to trim the leading whitespace from results. Can be 'all', 'common', or false
        trim_leading_whitespace = "common",
        -- Maximum width of the filename column
        max_filename_width = function()
          return math.floor(math.min(95, vim.o.columns / 2))
        end,
        -- How far the header should extend to the right
        header_length = function(type, start_col)
          return vim.o.columns - start_col
        end,
      })
      
    end,
  },
  {
    "coffebar/transfer.nvim",
    config = function()
      
      {
        "coffebar/transfer.nvim",
        lazy = true,
        cmd = { "TransferInit", "DiffRemote", "TransferUpload", "TransferDownload", "TransferDirDiff", "TransferRepeat" },
        opts = {},
      },
      
      
      -- .nvim/deployment.lua
      return {
        ["example_name"] = {
          host = "myhost",
          username = "web", -- optional
          password = true, -- optional [string|true will prompt for password each time]
          mappings = {
            {
              ["local"] = "live", -- path relative to project root
              ["remote"] = "/var/www/example.com", -- absolute path or relative to user home
            },
            {
              ["local"] = "test",
              ["remote"] = "/var/www/test.example.com",
            },
          },
          excludedPaths = { -- optional
            "live/src/", -- local path relative to project root
            "test/src/",
          },
          upload_on_save = false
        },
      }
      
      
      {
        window = {
          mappings = {
            -- upload (sync files)
            uu = {
              function(state)
                vim.cmd("TransferUpload " .. state.tree:get_node().path)
              end,
              desc = "upload file or directory",
              nowait = true,
            },
            -- download (sync files)
            ud = {
              function(state)
                vim.cmd("TransferDownload" .. state.tree:get_node().path)
              end,
              desc = "download file or directory",
              nowait = true,
            },
            -- diff directory with remote
            uf = {
              function(state)
                local node = state.tree:get_node()
                local context_dir = node.path
                if node.type ~= "directory" then
                  -- if not a directory
                  -- one level up
                  context_dir = context_dir:gsub("/[^/]*$", "")
                end
                vim.cmd("TransferDirDiff " .. context_dir)
                vim.cmd("Neotree close")
              end,
              desc = "diff with remote",
            },
          },
        },
      }
      
      
      require("which-key").add({
        { "<leader>u", group = "Upload / Download", icon = "" },
        {
          "<leader>ud",
          "<cmd>TransferDownload<cr>",
          desc = "Download from remote server (scp)",
          icon = { color = "green", icon = "󰇚" },
        },
        {
          "<leader>uf",
          "<cmd>DiffRemote<cr>",
          desc = "Diff file with remote server (scp)",
          icon = { color = "green", icon = "" },
        },
        {
          "<leader>ui",
          "<cmd>TransferInit<cr>",
          desc = "Init/Edit Deployment config",
          icon = { color = "green", icon = "" },
        },
        {
          "<leader>ur",
          "<cmd>TransferRepeat<cr>",
          desc = "Repeat transfer command",
          icon = { color = "green", icon = "󰑖" },
        },
        {
          "<leader>uu",
          "<cmd>TransferUpload<cr>",
          desc = "Upload to remote server (scp)",
          icon = { color = "green", icon = "󰕒" },
        },
      })
      
      
      return {
        "coffebar/transfer.nvim",
        lazy = true,
        cmd = { "TransferInit", "DiffRemote", "TransferUpload", "TransferDownload", "TransferDirDiff", "TransferRepeat" },
        opts = {},
        dependencies = { 'folke/snacks.nvim' },
        specs = {
          {
            'folke/snacks.nvim',
            opts = {
              picker = {
                actions = {
                  transfer_up = function(_, item)
                    vim.cmd.TransferUpload(item.file)
                  end,
                  transfer_down = function(_, item)
                    vim.cmd.TransferDownload(item.file)
                  end,
                  transfer_diff = function(_, item)
                    if item.dir then
                      vim.cmd.TransferDirDiff(item.file)
                    else
                      vim.cmd.DiffRemote(item.file)
                    end
                  end,
                },
                win = {
                  list = {
                    keys = {
                      ['tu'] = 'transfer_up',
                      ['td'] = 'transfer_down',
                      ['tD'] = 'transfer_diff',
                    }
                  }
                }
              }
            }
          }
        }
      }
      
    end,
  },
  {
    "OscarCreator/rsync.nvim",
    config = function()
      
      -- packer.nvim
      use {
          'OscarCreator/rsync.nvim',
          run = 'make',
          requires = {'nvim-lua/plenary.nvim'},
          config = function()
              require("rsync").setup()
          end
      }
      -- lazy.nvim
      {
          'OscarCreator/rsync.nvim',
          build = 'make',
          dependencies = 'nvim-lua/plenary.nvim',
          config = function()
              require("rsync").setup()
          end,
      }
      
      
      ---@type RsyncConfig
      {
          -- triggers `RsyncUp` when fugitive thinks something might have changed in the repo.
          fugitive_sync = false,
          -- triggers `RsyncUp` when you save a file.
          sync_on_save = true,
          -- the path to the project configuration
          project_config_path = ".nvim/rsync.toml",
          -- called when the rsync command exits, provides the exit code and the used command
          on_exit = function(code, command)
          end,
          -- called when the rsync command prints to stderr, provides the data and the used command
          on_stderr = function(data, command)
          end,
      }
      
    end,
  },
  {
    "sachinsenal0x64/hot.nvim",
    config = function()
      
          -- Enable Current directory 
          vim.opt.autochdir == true,
      
          {
              'sachinsenal0x64/hot.nvim',
              config = function()
                local opts = require('hot.params').opts
        
                -- Update the Lualine Status
                Reloader = opts.tweaks.default
                Reloader = '💤'
        
                Pattern = opts.tweaks.patterns
                Pattern = { 'main.py', 'main.go' }
        
                opts.tweaks.start = '🚀'
                opts.tweaks.stop = '💤'
                opts.tweaks.test = '🧪'
                opts.tweaks.test_done = '🧪.✅'
                opts.tweaks.test_fail = '🧪.❌'
        
                -- If the 'main.*' file doesn't exist, it will fall back to 'index.*'
                opts.tweaks.custom_file = 'index'
        
                -- Add Languages
                opts.set.languages.python = {
                  cmd = 'python3',
                  desc = 'Run Python file asynchronously',
                  kill_desc = 'Kill the running Python file',
                  emoji = '🐍',
                  test = 'python -m unittest -v',
                  ext = { '.py' },
                }
        
                opts.set.languages.go = {
                  cmd = 'go run',
                  desc = 'Run Go file asynchronously',
                  kill_desc = 'Kill the running Go file',
                  emoji = '🐹',
                  test = 'go test',
                  ext = { '.go' },
                }
        
                -- Thot Health Check
                vim.api.nvim_set_keymap('n', 'ho', '<Cmd>lua require("thot").check()<CR>', { noremap = true, silent = true })
        
                -- Keybinds
        
                -- Start
                vim.api.nvim_set_keymap('n', '<F3>', '<Cmd>lua require("hot").restart()<CR>', { noremap = true, silent = true })
                -- Silent
                vim.api.nvim_set_keymap('n', '<F4>', '<Cmd>lua require("hot").silent()<CR>', { noremap = true, silent = true })
                -- Stop
                vim.api.nvim_set_keymap('n', '<F5>', '<Cmd>lua require("hot").stop()<CR>', { noremap = true, silent = true })
                -- Test
                vim.api.nvim_set_keymap('n', '<F6>', '<Cmd>lua require("hot").test_restart()<CR>', { noremap = true, silent = true })
                -- Close Buffer
                vim.api.nvim_set_keymap('n', '<F8>', '<Cmd>lua require("hot").close_output_buffer()<CR>', { noremap = true, silent = true })
                -- Open Buffer
                vim.api.nvim_set_keymap('n', '<F7>', '<Cmd>lua require("hot").open_output_buffer()<CR>', { noremap = true, silent = true })
        
                -- Auto Reload on Save
        
                local save_group = vim.api.nvim_create_augroup('save_mapping', { clear = true })
                vim.api.nvim_create_autocmd('BufWritePost', {
                  desc = 'Reloader',
                  group = save_group,
                  pattern = Pattern,
                  callback = function()
                    require('hot').silent()
                  end,
                })
              end,
            },
      
      
      
      
       
      local hot = {
                'Reloader',
              },
      
      sections = {
      
          lualine_b = {
                  hot,
         }
      },   
      
      
    end,
  },
  {
    "David-Kunz/jester",
    config = function()
      
      require("jester").setup({
        dap = {
          console = "externalTerminal"
        }
      })
      
      
      {
        cmd = "jest -t '$result' -- $file", -- run command
        identifiers = {"test", "it"}, -- used to identify tests
        prepend = {"describe"}, -- prepend describe blocks
        expressions = {"call_expression"}, -- tree-sitter object used to scan for tests/describe blocks
        path_to_jest_run = 'jest', -- used to run tests
        path_to_jest_debug = './node_modules/.bin/jest', -- used for debugging
        terminal_cmd = ":vsplit | terminal", -- used to spawn a terminal for running tests, for debugging refer to nvim-dap's config
        dap = { -- debug adapter configuration
          type = 'node2',
          request = 'launch',
          cwd = vim.fn.getcwd(),
          runtimeArgs = {'--inspect-brk', '$path_to_jest', '--no-coverage', '-t', '$result', '--', '$file'},
          args = { '--no-cache' },
          sourceMaps = false,
          protocol = 'inspector',
          skipFiles = {'<node_internals>/**/*.js'},
          console = 'integratedTerminal',
          port = 9229,
          disableOptimisticBPs = true
        }
      }
      
      
      :lua require"jester".debug({ dap = { console = "externalTerminal" } })
      
    end,
  },
  {
    "klen/nvim-test",
    config = function()
      
      
      use {
        "klen/nvim-test",
        config = function()
          require('nvim-test').setup()
        end
      }
      
      
      require('nvim-test').setup {
        run = true,                 -- run tests (using for debug)
        commands_create = true,     -- create commands (TestFile, TestLast, ...)
        filename_modifier = ":.",   -- modify filenames before tests run(:h filename-modifiers)
        silent = false,             -- less notifications
        term = "terminal",          -- a terminal to run ("terminal"|"toggleterm")
        termOpts = {
          direction = "vertical",   -- terminal's direction ("horizontal"|"vertical"|"float")
          width = 96,               -- terminal's width (for vertical|float)
          height = 24,              -- terminal's height (for horizontal|float)
          go_back = false,          -- return focus to original window after executing
          stopinsert = "auto",      -- exit from insert mode (true|false|"auto")
          keep_one = true,          -- keep only one terminal for testing
        },
        runners = {               -- setup tests runners
          cs = "nvim-test.runners.dotnet",
          go = "nvim-test.runners.go-test",
          haskell = "nvim-test.runners.hspec",
          javascriptreact = "nvim-test.runners.jest",
          javascript = "nvim-test.runners.jest",
          lua = "nvim-test.runners.busted",
          python = "nvim-test.runners.pytest",
          ruby = "nvim-test.runners.rspec",
          rust = "nvim-test.runners.cargo-test",
          typescript = "nvim-test.runners.jest",
          typescriptreact = "nvim-test.runners.jest",
        }
      }
      
      
        require('nvim-test.runners.jest'):setup {
          command = "~/node_modules/.bin/jest",                                       -- a command to run the test runner
          args = { "--collectCoverage=false" },                                       -- default arguments
          env = { CUSTOM_VAR = 'value' },                                             -- custom environment variables
      
          file_pattern = "\\v(__tests__/.*|(spec|test))\\.(js|jsx|coffee|ts|tsx)$",   -- determine whether a file is a testfile
          find_files = { "{name}.test.{ext}", "{name}.spec.{ext}" },                  -- find testfile for a file
      
          filename_modifier = nil,                                                    -- modify filename before tests run (:h filename-modifiers)
          working_directory = nil,                                                    -- set working directory (cwd by default)
        }
      
    end,
  },
  {
    "nvim-neotest/neotest",
    config = function()
      
      use {
        "nvim-neotest/neotest",
        requires = {
          "nvim-neotest/nvim-nio",
          "nvim-lua/plenary.nvim",
          "antoinemadec/FixCursorHold.nvim",
          "nvim-treesitter/nvim-treesitter"
        }
      }
      
      
      {
        "nvim-neotest/neotest",
        dependencies = {
          "nvim-neotest/nvim-nio",
          "nvim-lua/plenary.nvim",
          "antoinemadec/FixCursorHold.nvim",
          "nvim-treesitter/nvim-treesitter"
        }
      }
      
      
      require("neotest").setup({
        adapters = {
          require("neotest-python")({
            dap = { justMyCode = false },
          }),
          require("neotest-plenary"),
          require("neotest-vim-test")({
            ignore_file_types = { "python", "vim", "lua" },
          }),
        },
      })
      
      
      require("neotest").run.run()
      
      
      require("neotest").run.run(vim.fn.expand("%"))
      
      
      require("neotest").run.run({strategy = "dap"})
      
      
      require("neotest").run.stop()
      
      
      require("neotest").run.attach()
      
      
      local lib = require("neotest.lib")
      
      function PlenaryNeotestAdapter.discover_positions(path)
        local query = [[
        ;; describe blocks
        ((function_call
            name: (identifier) @func_name (#match? @func_name "^describe$")
            arguments: (arguments (_) @namespace.name (function_definition))
        )) @namespace.definition
      
      
        ;; it blocks
        ((function_call
            name: (identifier) @func_name
            arguments: (arguments (_) @test.name (function_definition))
        ) (#match? @func_name "^it$")) @test.definition
      
        ;; async it blocks (async.it)
        ((function_call
            name: (
              dot_index_expression
                field: (identifier) @func_name
            )
            arguments: (arguments (_) @test.name (function_definition))
          ) (#match? @func_name "^it$")) @test.definition
          ]]
        return lib.treesitter.parse_positions(path, query, { nested_namespaces = true })
      end
      
    end,
  },
  {
    "andythigpen/nvim-coverage",
    config = function()
      
      require("coverage").setup()
      
      
      use({
        "andythigpen/nvim-coverage",
        requires = "nvim-lua/plenary.nvim",
        -- Optional: needed for PHP when using the cobertura parser
        rocks = { 'lua-xmlreader' },
        config = function()
          require("coverage").setup()
        end,
      })
      
      
       {
          "andythigpen/nvim-coverage",
          version = "*",
          config = function()
            require("coverage").setup({
              auto_reload = true,
            })
          end,
        },
      
      
      require("coverage").setup({
      	commands = true, -- create commands
      	highlights = {
      		-- customize highlight groups created by the plugin
      		covered = { fg = "#C3E88D" },   -- supports style, fg, bg, sp (see :h highlight-gui)
      		uncovered = { fg = "#F07178" },
      	},
      	signs = {
      		-- use your own highlight groups or text markers
      		covered = { hl = "CoverageCovered", text = "▎" },
      		uncovered = { hl = "CoverageUncovered", text = "▎" },
      	},
      	summary = {
      		-- customize the summary pop-up
      		min_coverage = 80.0,      -- minimum coverage threshold (used for highlighting)
      	},
      	lang = {
      		-- customize language specific settings
      	},
      })
      
      
      local M = {}
      
      --- Loads a coverage report.
      -- This method should perform whatever steps are necessary to generate a coverage report.
      -- The coverage report results should passed to the callback, which will be cached by the plugin.
      -- @param callback called with results of the coverage report
      M.load = function(callback)
        -- TODO: callback(results)
      end
      
      --- Returns a list of signs that will be placed in buffers.
      -- This method should use the coverage data (previously generated via the load method) to 
      -- return a list of signs.
      -- @return list of signs
      M.sign_list = function(data)
        -- TODO: generate a list of signs using:
        -- require("coverage.signs").new_covered(bufnr, linenr)
        -- require("coverage.signs").new_uncovered(bufnr, linenr)
      end
      
      --- Returns a summary report.
      -- @return summary report
      M.summary = function(data)
        -- TODO: generate a summary report in the format
        return {
          files = {
            { -- all fields, except filename, are optional - the report will be blank if the field is nil
              filename = fname,            -- filename displayed in the report
              statements = statements,     -- number of total statements in the file
              missing = missing,           -- number of lines missing coverage (uncovered) in the file
              excluded = excluded,         -- number of lines excluded from coverage reporting in the file
              branches = branches,         -- number of total branches in the file
              partial = partial_branches,  -- number of branches that are partially covered in the file
              coverage = coverage,         -- coverage percentage (float) for this file
            }
          },
          totals = { -- optional
            statements = total_statements,     -- number of total statements in the report
            missing = total_missing,           -- number of lines missing coverage (uncovered) in the report
            excluded = total_excluded,         -- number of lines excluded from coverage reporting in the report
            branches = total_branches,         -- number of total branches in the report
            partial = total_partial_branches,  -- number of branches that are partially covered in the report
            coverage = total_coverage,         -- coverage percentage to display in the report
          }
        }
      end
      
      return M
      
    end,
  },
  {
    "quolpr/quicktest.nvim",
    config = function()
      
      {
        "quolpr/quicktest.nvim",
        config = function()
          local qt = require("quicktest")
      
          qt.setup({
            -- Choose your adapter, here all supported adapters are listed
            adapters = {
              require("quicktest.adapters.golang")({}),
              require("quicktest.adapters.vitest")({}),
              require("quicktest.adapters.playwright")({}),
              require("quicktest.adapters.pytest")({}),
              require("quicktest.adapters.elixir"),
              require("quicktest.adapters.criterion"),
              require("quicktest.adapters.dart"),
              require("quicktest.adapters.rspec"),
            },
            -- split or popup mode, when argument not specified
            default_win_mode = "split",
            use_builtin_colorizer = true
          })
        end,
        dependencies = {
          "nvim-lua/plenary.nvim",
          "MunifTanjim/nui.nvim",
        },
        keys = {
          {
            "<leader>tl",
            function()
              local qt = require("quicktest")
              -- current_win_mode return currently opened panel, split or popup
              qt.run_line()
              -- You can force open split or popup like this:
              -- qt.run_line('split')
              -- qt.run_line('popup')
            end,
            desc = "[T]est Run [L]line",
          },
          {
            "<leader>tf",
            function()
              local qt = require("quicktest")
      
              qt.run_file()
            end,
            desc = "[T]est Run [F]ile",
          },
          {
            '<leader>td',
            function()
              local qt = require 'quicktest'
      
              qt.run_dir()
            end,
            desc = '[T]est Run [D]ir',
          },
          {
            '<leader>ta',
            function()
              local qt = require 'quicktest'
      
              qt.run_all()
            end,
            desc = '[T]est Run [A]ll',
          },
          {
            "<leader>tp",
            function()
              local qt = require("quicktest")
      
              qt.run_previous()
            end,
            desc = "[T]est Run [P]revious",
          },
          {
            "<leader>tt",
            function()
              local qt = require("quicktest")
      
              qt.toggle_win("split")
            end,
            desc = "[T]est [T]oggle Window",
          },
          {
            "<leader>tc",
            function()
              local qt = require("quicktest")
      
              qt.cancel_current_run()
            end,
            desc = "[T]est [C]ancel Current Run",
          },
        },
      }
      
      
      local qt = require("quicktest")
      
      -- Choose your adapter, here all supported adapters are listed
      qt.setup({
        adapters = {
          require("quicktest.adapters.golang"),
          require("quicktest.adapters.vitest")({}),
          require("quicktest.adapters.playwright")({}),
          require("quicktest.adapters.pytest")({}),
          require("quicktest.adapters.elixir"),
          require("quicktest.adapters.criterion"),
          require("quicktest.adapters.dart"),
          require("quicktest.adapters.rspec"),
        },
        -- split or popup mode, when argument not specified
        default_win_mode = "split",
        use_builtin_colorizer = true
      })
      
      vim.keymap.set("n", "<leader>tl", qt.run_line, {
        desc = "[T]est Run [L]line",
      })
      vim.keymap.set("n", "<leader>tf", qt.run_file, {
        desc = "[T]est Run [F]ile",
      })
      vim.keymap.set("n", "<leader>td", qt.run_dir, {
        desc = "[T]est Run [D]ir",
      })
      vim.keymap.set("n", "<leader>ta", qt.run_all, {
        desc = "[T]est Run [A]ll",
      })
      vim.keymap.set("n", "<leader>tR", qt.run_previous, {
        desc = "[T]est Run [P]revious",
      })
      -- vim.keymap.set("n", "<leader>tt", function()
      --   qt.toggle_win("popup")
      -- end, {
      --   desc = "[T]est [T]oggle popup window",
      -- })
      vim.keymap.set("n", "<leader>tt", function()
        qt.toggle_win("split")
      end, {
        desc = "[T]est [T]oggle Window",
      })
      vim.keymap.set("n", "<leader>tc", function()
        qt.cancel_current_run()
      end, {
        desc = "[T]est [C]ancel Current Run",
      })
      
      
      local qt = require 'quicktest'
      
      -- Choose your adapter, here all supported adapters are listed
      qt.setup({
        adapters = {
          require("quicktest.adapters.golang")({
            ---@field cwd (fun(bufnr: integer, current: string?): string)?
            ---@field bin (fun(bufnr: integer, current: string?): string)?
            ---@field additional_args (fun(bufnr: integer): string[])?
            ---@field args (fun(bufnr: integer, current: string[]): string[])?
            ---@field env (fun(bufnr: integer, current: table<string, string>): table<string, string>)?
            ---@field is_enabled (fun(bufnr: integer, type: RunType, current: boolean): boolean)?
      
            additional_args = function(bufnr) return { '-race', '-count=1' } end
            -- bin = function(bufnr, current) return current end
            -- cwd = function(bufnr, current) return current end
          }),
          require("quicktest.adapters.vitest")({
            ---@class VitestAdapterOptions
            ---@field cwd (fun(bufnr: integer, current: string?): string)?
            ---@field bin (fun(bufnr: integer, current: string?): string)?
            ---@field config_path (fun(bufnr: integer, current: string): string)?
            ---@field args (fun(bufnr: integer, current: string[]): string[])?
            ---@field env (fun(bufnr: integer, current: table<string, string>): table<string, string>)?
            ---@field is_enabled (fun(bufnr: integer, type: RunType, current: boolean): boolean)?
      
            -- bin = function(bufnr, current) return current end
            -- cwd = function(bufnr, current) return current end
            -- config_path = function(bufnr, current) return current end
          }),
          require("quicktest.adapters.elixir")({
            ---@class ElixirAdapterOptions
            ---@field cwd (fun(bufnr: integer, current: string?): string)?
            ---@field bin (fun(bufnr: integer, current: string?): string)?
            ---@field args (fun(bufnr: integer, current: string[]): string[])?
            ---@field env (fun(bufnr: integer, current: table<string, string>): table<string, string>)?
            ---@field is_enabled (fun(bufnr: integer, type: RunType, current: boolean): boolean)?
          }),
          require("quicktest.adapters.playwright")({
            ---@class PlaywrightAdapterOptions
            ---@field cwd (fun(bufnr: integer, current: string?): string)?
            ---@field bin (fun(bufnr: integer, current: string?): string)?
            ---@field config_path (fun(bufnr: integer, current: string): string)?
            ---@field args (fun(bufnr: integer, current: string[]): string[])?
            ---@field env (fun(bufnr: integer, current: table<string, string>): table<string, string>)?
            ---@field is_enabled (fun(bufnr: integer, type: RunType, current: boolean): boolean)?
          }),
          require("quicktest.adapters.pytest")({
            ---@class PytestAdapterOptions
            ---@field cwd (fun(bufnr: integer, current: string?): string)?
            ---@field bin (fun(bufnr: integer, current: string?): string)?
            ---@field args (fun(bufnr: integer, current: string[]): string[])?
            ---@field env (fun(bufnr: integer, current: table<string, string>): table<string, string>)?
            ---@field is_enabled (fun(bufnr: integer, type: RunType, current: boolean): boolean)?
      
            -- bin = function(bufnr, current) return current end
            -- cwd = function(bufnr, current) return current end
          }),
          require("quicktest.adapters.elixir")({
            ---@class ElixirAdapterOptions
            ---@field cwd (fun(bufnr: integer, current: string?): string)?
            ---@field bin (fun(bufnr: integer, current: string?): string)?
            ---@field args (fun(bufnr: integer, current: string[]): string[])?
            ---@field env (fun(bufnr: integer, current: table<string, string>): table<string, string>)?
            ---@field is_enabled (fun(bufnr: integer, type: RunType, current: boolean): boolean)?
          }),
          require("quicktest.adapters.criterion")({
            builddir = function(bufnr) return "build" end,
            additional_args = function(bufnr) return {'arg1', 'arg2'} end,
          }),
          require("quicktest.adapters.dart")({
            ---@class DartAdapterOptions
            ---@field cwd (fun(bufnr: integer, current: string?): string)?
            ---@field bin (fun(bufnr: integer, current: string?): string)?
            ---@field args (fun(bufnr: integer, current: string[]): string[])?
            ---@field env (fun(bufnr: integer, current: table<string, string>): table<string, string>)?
            ---@field is_enabled (fun(bufnr: integer, type: RunType, current: boolean): boolean)?
          }),
          require("quicktest.adapters.rspec")({
            ---@class RspecAdapterOptions
            ---@field bin (fun(bufnr: integer, fallback: string): string)?
            ---@field cwd (fun(bufnr: integer, fallback: string): string)?
            ---@field is_enabled (fun(bufnr: integer, fallback: boolean): boolean)?
          }),
        },
        -- split or popup mode, when argument not specified
        default_win_mode = "split",
      })
      
      -- Find nearest test under cursor and run in popup
      qt.run_line('popup')
      -- Find nearest test under cursor and run in split
      qt.run_line('split')
      -- Find nearest test under cursor and run in currently opened window(popup or split)
      qt.run_line()
      
      -- Run all tests of file in popup/split
      qt.run_file('popup')
      qt.run_file('split')
      qt.run_line()
      
      -- Run all tests of current file dir in popup/split
      qt.run_dir('popup')
      qt.run_dir('split')
      qt.run_dir()
      
      -- Run all tests of project in popup/split
      qt.run_all('popup')
      qt.run_all('split')
      qt.run_all()
      
      -- Open or close split/popup if already opened, without running tests.
      -- Just open and close window.
      qt.toggle_win('popup')
      qt.toggle_win('split')
      
      -- Take previous test run and run in popup/split
      qt.run_previous('popup')
      qt.run_previous('split')
      qt.run_previous()
      
      
      local qt = require("quicktest")
      local playwright = require("quicktest.adapters.playwright")
      local vitest = require("quicktest.adapters.vitest")
      
      qt.setup({
        adapters = {
          vitest({
            is_enabled = function(bufnr)
              return vitest.imports_from_vitest(bufnr)
            end
          }),
          playwright({
            is_enabled = function(bufnr)
              -- In case you are not using the default `@playwright` package but your own
              -- wrapper, you can specify the package-name that has to be imported
              return playwright.imports_from_playwright(bufnr, "my-custom-playwright")
            end
          }),
        },
      })
      
      
      local Job = require("plenary.job")
      
      local M = {
        name = "myadapter",
      }
      ---@class MyRunParams
      ---@field func_names string[]
      ---@field bufnr integer
      ---@field cursor_pos integer[]
      
      --- Optional:
      --- Builds parameters for running tests based on buffer number and cursor position.
      --- This function should be customized to extract necessary information from the buffer.
      ---@param bufnr integer
      ---@param cursor_pos integer[]
      ---@return MyRunParams, nil | string
      -- M.build_line_run_params = function(bufnr, cursor_pos)
      --   -- You can get current function name to run based on bufnr and cursor_pos
      --   -- Check hot it is done for golang at `lua/quicktest/adapters/golang`
      --   return {
      --     bufnr = bufnr,
      --     cursor_pos = cursor_pos,
      --     func_names = {},
      --     -- Add other parameters as needed
      --   }, nil
      -- end
      
      --- Optional:
      ---@param bufnr integer
      ---@param cursor_pos integer[]
      ---@return MyRunParams, nil | string
      -- M.build_file_run_params = function(bufnr, cursor_pos)
      --   return {
      --     bufnr = bufnr,
      --     cursor_pos = cursor_pos,
      --     -- Add other parameters as needed
      --   }, nil
      -- end
      
      --- Optional:
      ---@param bufnr integer
      ---@param cursor_pos integer[]
      ---@return MyRunParams, nil | string
      -- M.build_dir_run_params = function(bufnr, cursor_pos)
      --   return {
      --     bufnr = bufnr,
      --     cursor_pos = cursor_pos,
      --     -- Add other parameters as needed
      --   }, nil
      -- end
      
      --- Optional:
      ---@param bufnr integer
      ---@param cursor_pos integer[]
      ---@return MyRunParams, nil | string
      -- M.build_all_run_params = function(bufnr, cursor_pos)
      --   return {
      --     bufnr = bufnr,
      --     cursor_pos = cursor_pos,
      --     -- Add other parameters as needed
      --   }, nil
      -- end
      
      --- Executes the test with the given parameters.
      ---@param params MyRunParams
      ---@param send fun(data: any)
      ---@return integer
      M.run = function(params, send)
        local job = Job:new({
          command = "test_command",
          args = { "--some-flag" }, -- Modify based on how your test command needs to be structured
          on_stdout = function(_, data)
            send({ type = "stdout", output = data })
          end,
          on_stderr = function(_, data)
            send({ type = "stderr", output = data })
          end,
          on_exit = function(_, return_val)
            send({ type = "exit", code = return_val })
          end,
        })
      
        job:start()
      
        return job.pid
      end
      
      --- Optional: title of the test run
      ---@param params MyRunParams
      -- M.title = function(params)
      --   return "Running test"
      -- end
      
      --- Optional: handles actions to take after the test run, based on the results.
      ---@param params any
      ---@param results any
      -- M.after_run = function(params, results)
      --   -- Implement actions based on the results, such as updating UI or handling errors
      -- end
      
      --- Checks if the adapter is enabled for the given buffer.
      ---@param bufnr integer
      ---@return boolean
      M.is_enabled = function(bufnr)
        local bufname = vim.api.nvim_buf_get_name(bufnr)
        return vim.endswith(bufname, "test.ts") or vim.endswith(bufname, "test.js")
      end
      
      return M
      
    end,
  },
  {
    "zkucekovic/tdd.nvim",
    config = function()
      
      {
        "zkucekovic/tdd.nvim",
        config = function()
          require("tdd").setup() -- no config needed
        end,
      }
      
      
      {
        "zkucekovic/tdd.nvim",
        branch = "feature/some-dev-branch",
        version = false,
        config = function()
          require("tdd").setup()
        end,
      }
      
    end,
  },
  {
    "nvim-neotest/neotest-jest",
    config = function()
      
      use({
        "nvim-neotest/neotest",
        requires = {
          ...,
          "nvim-neotest/neotest-jest",
        }
        config = function()
          require("neotest").setup({
            ...,
            adapters = {
              require("neotest-jest")({
                jestCommand = "npm test --",
                jestArguments = function(defaultArguments, context)
                  return defaultArguments
                end,
                jestConfigFile = "custom.jest.config.ts",
                env = { CI = true },
                cwd = function(path)
                  return vim.fn.getcwd()
                end,
                isTestFile = require("neotest-jest.jest-util").defaultIsTestFile,
              }),
            }
          })
        end
      })
      
      
      ---@async
      ---@param file_path string?
      ---@return boolean
      isTestFile = function(file_path)
        if not file_path then
          return false
        end
      
        return vim.fn.fnamemodify(file_path, ":e:e") == "testy.js"
      end
      
      
      require('neotest').setup({
        ...,
        adapters = {
          require('neotest-jest')({
            jestCommand = require('neotest-jest.jest-util').getJestCommand(vim.fn.expand '%:p:h') .. ' --watch',
          }),
        }
      })
      
      
      vim.api.nvim_set_keymap("n", "<leader>tw", "<cmd>lua require('neotest').run.run({ jestCommand = 'jest --watch ' })<cr>", {})
      
      
      require('neotest').setup({
        ...,
        adapters = {
          require('neotest-jest')({
            ...,
            jest_test_discovery = false,
          }),
        }
      })
      
      
      require("neotest").setup({
      	...,
      	discovery = {
      		enabled = false,
      	},
      })
      
      
      jestConfigFile = function(file)
        if file:find("/packages/") then
          -- Matches "some/path/" in "some/path/src/"
          local match = file:match("(.*/[^/]+/)src")
      
          if match then
            return match .. "jest.config.ts"
          end
        end
      
        return vim.fn.getcwd() .. "/jest.config.ts"
      end,
      
      
      cwd = function(file)
        if file:find("/packages/") then
          -- Matches "some/path/" in "some/path/src/"
          local match = file:match("(.*/[^/]+/)src")
      
          if match then
            return match
          end
        end
      
        return vim.fn.getcwd()
      end
      
    end,
  },
  {
    "MisanthropicBit/neotest-busted",
    config = function()
      
      require("neotest").setup({
          adapters = {
              require("neotest-busted")({
                  -- Leave as nil to let neotest-busted automatically find busted
                  busted_command = "<path to a busted executable>",
                  -- Extra arguments to busted
                  busted_args = { "--shuffle-files" },
                  -- List of paths to add to package.path in neovim before running busted
                  busted_paths = { "my/custom/path/?.lua" },
                  -- List of paths to add to package.cpath in neovim before running busted
                  busted_cpaths = { "my/custom/path/?.so" },
                  -- Custom config to load via -u to set up testing.
                  -- If nil, will look for a 'minimal_init.lua' file
                  minimal_init = "custom_init.lua",
                  -- Only use a luarocks installation in the project's directory. If
                  -- true, installations in $HOME and global installations will be
                  -- ignored. Useful for isolating the test environment
                  local_luarocks_only = true,
                  -- Find parametric tests
                  parametric_test_discovery = false,
              }),
          },
      })
      
      
      local async = require("neotest-busted.async")
      local control = require("neotest.async").control
      
      describe("async", function()
          before_each(async(function()
              vim.print("async before_each")
          end))
      
          it("async test", async(function()
              local timer = vim.loop.new_timer()
              local event = control.event()
      
              -- Print a message after 2 seconds
              timer:start(2000, 0, function()
                  timer:stop()
                  timer:close()
                  vim.print("Hello from async test")
                  event.set()
              end)
      
              -- Wait for the timer to complete
              event.wait()
          end))
      end)
      
      
      describe("parametric tests", function()
          for i = 1, 3 do
              it(("test %d"):format(i), function()
                  assert.are.same(i, i)
              end)
          end
      end)
      
    end,
  },
  {
    "michaelb/sniprun",
  },
  {
    "CRAG666/code_runner.nvim",
    config = function()
      
      require("lazy").setup({
        { "CRAG666/code_runner.nvim", config = true },
      }
      
      
      use 'CRAG666/code_runner.nvim'
      
      
      require "paq"{ 'CRAG666/code_runner.nvim'; }
      
      
      require('code_runner').setup({
        filetype = {
          java = {
            "cd $dir &&",
            "javac $fileName &&",
            "java $fileNameWithoutExt"
          },
          python = "python3 -u",
          typescript = "deno run",
          rust = {
            "cd $dir &&",
            "rustc $fileName &&",
            "$dir/$fileNameWithoutExt"
          },
          c = function(...)
            c_base = {
              "cd $dir &&",
              "gcc $fileName -o",
              "/tmp/$fileNameWithoutExt",
            }
            local c_exec = {
              "&& /tmp/$fileNameWithoutExt &&",
              "rm /tmp/$fileNameWithoutExt",
            }
            vim.ui.input({ prompt = "Add more args:" }, function(input)
              c_base[4] = input
              vim.print(vim.tbl_extend("force", c_base, c_exec))
              require("code_runner.commands").run_from_fn(vim.list_extend(c_base, c_exec))
            end)
          end,
        },
      })
      
      
      -- this is a config example
      require('code_runner').setup {
        filetype_path = vim.fn.expand('~/.config/nvim/code_runner.json'),
        project_path = vim.fn.expand('~/.config/nvim/project_manager.json')
      }
      
      
      vim.keymap.set('n', '<leader>rr', ':RunCode<CR>', { noremap = true, silent = false })
      vim.keymap.set('n', '<leader>rf', ':RunFile<CR>', { noremap = true, silent = false })
      vim.keymap.set('n', '<leader>rft', ':RunFile tab<CR>', { noremap = true, silent = false })
      vim.keymap.set('n', '<leader>rp', ':RunProject<CR>', { noremap = true, silent = false })
      vim.keymap.set('n', '<leader>rc', ':RunClose<CR>', { noremap = true, silent = false })
      vim.keymap.set('n', '<leader>crf', ':CRFiletype<CR>', { noremap = true, silent = false })
      vim.keymap.set('n', '<leader>crp', ':CRProjects<CR>', { noremap = true, silent = false })
      
      
      require("code_runner").run_code() -- Runs based on file type, first checking if belongs to project, then if filetype mapping exists.
      require("code_runner").run_from_fn() -- Run any command.
      require("code_runner").run_filetype() -- Run the current file (optionally you can select an opening mode).
      require("code_runner").run_project() -- Run the current project(If you are in a project otherwise you will not do anything,).
      require("code_runner").run_close()   -- Close runner(Doesn't work in better_term mode, use native plugin options).
      require("code_runner").get_filetype_command() -- Get the current command for this filetype
      require("code_runner").get_project_command() -- Get the current command for this project
      
      
      -- in setup function
      filetype = {
        java = { "cd $dir &&", "javac $fileName &&", "java $fileNameWithoutExt" },
        python = "python3 -u",
        typescript = "deno run",
        rust = { "cd $dir &&",
          "rustc $fileName &&",
          "$dir/$fileNameWithoutExt"
        },
        cs = function(...)
          local root_dir = require("lspconfig").util.root_pattern "*.csproj"(vim.loop.cwd())
          return "cd " .. root_dir .. " && dotnet run$end"
        end,
      },
      
      
      project = {
        ["~/python/intel_2021_1"] = {
          name = "Intel Course 2021",
          description = "Simple python project",
          file_name = "POO/main.py"
        },
        ["~/deno/example"] = {
          name = "ExapleDeno",
          description = "Project with deno using other command",
          file_name = "http/main.ts",
          command = "deno run --allow-net"
        },
        ["~/cpp/example"] = {
          name = "ExapleCpp",
          description = "Project with make file",
          command = "make buid && cd buid/ && ./compiled_file"
        },
        ["~/private/.*terraform%-prod.-/.-"] = {
          name = "ExampleTerraform",
          description = "All Folders in ~/private containing \"terraform-prod\"",
          command = "terraform plan",
        },
      },
      
      
      {
      ...
          filetype = {
            -- Using tectonic compiler
            tex = function(...)
              require("code_runner.hooks.ui").select {
                Single = function()
                  local preview = require "code_runner.hooks.preview_pdf"
                  preview.run {
                    command = "tectonic",
                    args = { "$fileName", "--keep-logs", "-o", "/tmp" },
                    preview_cmd = "zathura --fork",
                    overwrite_output = "/tmp",
                  }
                end,
                Project = function()
                  -- this is my personal config for compiling a project with tectonic
                  -- for example --keep-logs is used to keep the logs of the compilation, see tectonic -X build --help for more info
                  require("code_runner.hooks.tectonic").build("zathura --fork", { "--keep-logs" }) -- Build the project, default command is tectonic -X build
                end,
              }
            end,
            markdown = function(...)
              local hook = require "code_runner.hooks.preview_pdf"
              require("code_runner.hooks.ui").select {
                Normal = function()
                  hook.run {
                    command = "pandoc",
                    args = { "$fileName", "-o", "$tmpFile", "-t pdf" },
                    preview_cmd = "zathura --fork",
                  }
                end,
                Presentation = function()
                  hook.run {
                    command = "pandoc",
                    args = { "$fileName", "-o", "$tmpFile", "-t beamer" },
                    preview_cmd = "zathura --fork",
                  }
                end,
                Eisvogel = function()
                  hook.run {
                    command = "bash",
                    args = { "./build.sh" },
                    preview_cmd = "zathura --fork",
                    overwrite_output = ".",
                  }
                end,
              }
            end,
        ...
      }
      
      
      
      -- custom function to run ts file
      -- and print result in a new vertical windows
      local function runTsFile(fileName)
        -- Check if the current file is a TypeScript file
        if string.match(fileName, '%.ts$') then
          -- Save the current window id
          local current_win = vim.fn.win_getid()
      
          -- Close previous terminal windows
          vim.cmd 'silent! wincmd w | if &buftype ==# "terminal" | q | endif'
      
          -- Open a vertical terminal
          vim.cmd 'vsplit term://'
      
          -- Run the TypeScript file and print the result
          vim.fn.termopen('ts-node ' .. fileName)
      
          -- Restore the focus to the original window
          vim.fn.win_gotoid(current_win)
        else
          print 'Not a TypeScript file!'
        end
      end
      
      -- hooks config
      {
        filetype = {
          typescript = function()
            local cr_au = require "code_runner.hooks.autocmd"
            -- stop previous job (if has any)
            cr_au.stop_job() -- CodeRunnerJobPosWrite
      
            local fileName = vim.fn.expand '%:p'
            local fn = function()
              runTsFile(fileName)
            end
      
            -- run the command the first time
            fn()
      
            -- listen to bufwrite event after the first run time
            cr_au.create_au_write(fn)
          end,
        },
      }
      
      
      require("code_runner").get_filetype_command() -- get the current command for this filetype
      require("code_runner").get_project_command() -- get the current command for this project
      
      
      require("harpoon.term").sendCommand(1, require("code_runner.commands").get_filetype_command() .. "\n")
      
    end,
  },
  {
    "is0n/jaq-nvim",
    config = function()
      
        use {"is0n/jaq-nvim"}
        
      
      require('jaq-nvim').setup{
        cmds = {
          -- Uses vim commands
          internal = {
            lua = "luafile %",
            vim = "source %"
          },
      
          -- Uses shell commands
          external = {
            markdown = "glow %",
            python   = "python3 %",
            go       = "go run %",
            sh       = "sh %"
          }
        },
      
        behavior = {
          -- Default type
          default     = "float",
      
          -- Start in insert mode
          startinsert = false,
      
          -- Use `wincmd p` on startup
          wincmd      = false,
      
          -- Auto-save files
          autosave    = false
        },
      
        ui = {
          float = {
            -- See ':h nvim_open_win'
            border    = "none",
      
            -- See ':h winhl'
            winhl     = "Normal",
            borderhl  = "FloatBorder",
      
            -- See ':h winblend'
            winblend  = 0,
      
            -- Num from `0-1` for measurements
            height    = 0.8,
            width     = 0.8,
            x         = 0.5,
            y         = 0.5
          },
      
          terminal = {
            -- Window position
            position = "bot",
      
            -- Window size
            size     = 10,
      
            -- Disable line numbers
            line_no  = false
          },
      
          quickfix = {
            -- Window position
            position = "bot",
      
            -- Window size
            size     = 10
          }
        }
      }
      
    end,
  },
  {
    "jedrzejboczar/toggletasks.nvim",
    config = function()
      
      use {
          'jedrzejboczar/toggletasks.nvim',
          requires = {
              'nvim-lua/plenary.nvim',
              'akinsho/toggleterm.nvim',
              'nvim-telescope/telescope.nvim/',
          },
          -- To enable YAML config support
          rocks = 'lyaml',
      }
      
      
      require('toggletasks').setup {
          debug = false,
          silent = false,  -- don't show "info" messages
          short_paths = true,  -- display relative paths when possible
          -- Paths (without extension) to task configuration files (relative to scanned directory)
          -- All supported extensions will be tested, e.g. '.toggletasks.json', '.toggletasks.yaml'
          search_paths = {
              'toggletasks',
              '.toggletasks',
              '.nvim/toggletasks',
          },
          -- Directories to consider when searching for available tasks for current window
          scan = {
              global_cwd = true,    -- vim.fn.getcwd(-1, -1)
              tab_cwd = true,       -- vim.fn.getcwd(-1, tab)
              win_cwd = true,       -- vim.fn.getcwd(win)
              lsp_root = true,      -- root_dir for first LSP available for the buffer
              dirs = {},            -- explicit list of directories to search or function(win): dirs
              rtp = false,          -- scan directories in &runtimepath
              rtp_ftplugin = false, -- scan in &rtp by filetype, e.g. ftplugin/c/toggletasks.json
          },
          tasks = {}, -- list of global tasks or function(win): tasks
                      -- this is basically the "Config format" defined using Lua tables
          -- Language server priorities when selecting lsp_root (default is 0)
          lsp_priorities = {
              ['null-ls'] = -10,
          },
          -- Defaults used when opening task's terminal (see Terminal:new() in toggleterm/terminal.lua)
          toggleterm = {
              close_on_exit = false,
              hidden = true,
          },
          -- Configuration of telescope pickers
          telescope = {
              spawn = {
                  open_single = true,  -- auto-open terminal window when spawning a single task
                  show_running = false, -- include already running tasks in picker candidates
                  -- Replaces default select_* actions to spawn task (and change toggleterm
                  -- direction for select horiz/vert/tab)
                  mappings = {
                      select_float = '<C-f>',
                      spawn_smart = '<C-a>',  -- all if no entries selected, else use multi-select
                      spawn_all = '<M-a>',    -- all visible entries
                      spawn_selected = nil,   -- entries selected via multi-select (default <tab>)
                  },
              },
              -- Replaces default select_* actions to open task terminal (and change toggleterm
              -- direction for select horiz/vert/tab)
              select = {
                  mappings = {
                      select_float = '<C-f>',
                      open_smart = '<C-a>',
                      open_all = '<M-a>',
                      open_selected = nil,
                      kill_smart = '<C-q>',
                      kill_all = '<M-q>',
                      kill_selected = nil,
                      respawn_smart = '<C-s>',
                      respawn_all = '<M-s>',
                      respawn_selected = nil,
                  },
              },
          },
      }
      
      
      require('telescope').load_extension('toggletasks')
      
      
      vim.keymap.set('n', '<space>ts', require('telescope').extensions.toggletasks.spawn,
          { desc = 'toggletasks: spawn' })
      
      
      require('toggletasks').auto_spawn('SessionLoadPost', 'auto')
      
      
      require('toggletasks').auto_spawn({'VimEnter', 'SessionLoadPost'}, function(tasks)
          return tasks
              :with_tag('auto')
              :not_tag('test')
              :from_file('/some/path/toggletasks.json')
              :name_matches('^/some/path.*$')
              :filter(function(task)
                  return task.config.name ~= 'Hello world'
              end)
      end)
      
      
      require('toggletasks').setup {
          tasks = function(win)
              local ft = vim.api.nvim_buf_get_option(vim.api.nvim_win_get_buf(win), 'filetype')
              local tasks = {
                  {
                      name = 'Some task',
                      cmd = 'echo "hello"'
                  },
              }
              if ft == 'lua' then
                  -- table.insert(tasks, { name = ... })
              end
              return tasks
          end,
          -- ...
      }
      
    end,
  },
  {
    "EthanJWright/vs-tasks.nvim",
    config = function()
      
      {
        "EthanJWright/vs-tasks.nvim",
        dependencies = {
          "nvim-lua/popup.nvim",
          "nvim-lua/plenary.nvim",
          "nvim-telescope/telescope.nvim",
        },
      }
      
      
      {
        "EthanJWright/vs-tasks.nvim",
        dependencies = {
          "nvim-lua/popup.nvim",
          "nvim-lua/plenary.nvim",
          "folke/snacks.nvim",
        },
        opts = {
          picker = "snacks" -- Use snacks.nvim picker instead of telescope
        }
      }
      
      
      require("telescope").load_extension("vstask")
      
      
      require("telescope").load_extension("vstask")
      
      
      lua <<EOF
      require("vstask").setup({
        cache_json_conf = true, -- don't read the json conf every time a task is ran
        cache_strategy = "last", -- can be "most" or "last" (most used / last used)
        config_dir = ".vscode", -- directory to look for tasks.json and launch.json
        support_code_workspace = true -- load from a *.code-workspace file, if available
        telescope_keys = { -- change the telescope bindings used to launch tasks
          vertical = '<C-v>',
          split = '<C-p>',
          tab = '<C-t>',
          current = '<CR>',
          background = '<C-b>',
          watch_job = '<C-w>',
          kill_job = '<C-d>',
          run = '<C-r>',
        },
        autodetect = { -- auto load scripts
          npm = "on"
        },
        terminal = 'nvim',-- can be 'nvim' or 'toggleterm'
        term_opts = {
          vertical = {
            direction = "vertical",
            size = "80"
          },
          horizontal = {
            direction = "horizontal",
            size = "10"
          },
          current = {
            direction = "float",
          },
          tab = {
            direction = 'tab',
          }
        },
        json_parser = vim.json.decode,
        default_tasks = {
              {
                label = " npm install",
                type = "shell",
                command = "npm i",
                filetypes = { "typescript" }, -- remove field to always add
              },
            },
        ignore_input_default = false -- always ignore an input default if `true`
      })
      EOF
      
      
      require("vstask").setup({
        picker = "snacks", -- Use snacks.nvim picker
        cache_json_conf = true,
        cache_strategy = "last",
        config_dir = ".vscode",
        support_code_workspace = true,
        -- Note: telescope_keys still work for key mappings even with snacks picker
        telescope_keys = {
          vertical = '<C-v>',
          split = '<C-p>',
          tab = '<C-t>',
          current = '<CR>',
          background = '<C-b>',
          watch_job = '<C-w>',
          kill_job = '<C-d>',
          run = '<C-r>',
        },
        -- ... other configuration options work the same
      })
      
      
      lua <<EOF
          {
            'Joakker/lua-json5',
            run = './install.sh'
          }
      EOF
      
      
      lua <<EOF
      require("vstask").setup({
          json_parser = require('json5').parse
      })
      EOF
      
      
      lua require("telescope").extensions.vstask.tasks() -- open task list in telescope
      lua require("telescope").extensions.vstask.inputs() -- open the input list, set new input
      lua require("telescope").extensions.vstask.jobs() -- view and manage all jobs (running and completed)
      lua require("telescope").extensions.vstask.history() -- search history of tasks
      lua require("telescope").extensions.vstask.close() -- close the task runner (if toggleterm)
      lua require("telescope").extensions.vstask.run() -- open menu to type cli cmd and run it with standard bindings
      
      
      lua require("telescope").extensions.vstask.tasks(require('telescope.themes').get_dropdown()) -- open task list in telescope
      
      
      function _RUN_LAST_TASK()
        local vstask_ok, vstask = pcall(require, "vstask")
        if not vstask_ok then
          return
        end
        local cmd = vstask.get_last()
        vim.cmd("vsplit")
        vim.cmd("term " .. cmd)
      end
      
    end,
  },
  {
    "stevearc/overseer.nvim",
    config = function()
      
      {
        'stevearc/overseer.nvim',
        opts = {},
      }
      
      
      require('packer').startup(function()
          use {
            'stevearc/overseer.nvim',
            config = function() require('overseer').setup() end
          }
      end)
      
      
      require "paq" {
          {'stevearc/overseer.nvim'};
      }
      
      
      require('overseer').setup()
      
    end,
  },
  {
    "smzm/hydrovim",
  },
  {
    "desdic/greyjoy.nvim",
    config = function()
      
      {
          "desdic/greyjoy.nvim",
          config = function()
              greyjoy.setup({
                  extensions = {
                      generic = {
                          commands = {
                              ["run {filename}"] = { command = { "python3 {filename}" }, filetype = "python" },
                          },
                      },
                  },
              })
      
              greyjoy.load_extension("generic")
          end
      }
      
      
      {
        ui = {
          buffer = { -- width and height for the buffer output
            width = math.ceil(math.min(vim.o.columns, math.max(80, vim.o.columns - 20))),
            height = math.ceil(math.min(vim.o.lines, math.max(20, vim.o.lines - 10))),
          },
          toggleterm = { -- by default no size is defined for the toggleterm by
            -- greyjoy.nvim it will be dependent on the user configured size for toggle
            -- term.
            size = nil,
          },
          term = {
            width_pct = 0.2, -- 20% of screen
          },
          telescope = {
              keys = {
                  select = "<CR>", -- enter
                  edit = "<C-e>", -- CTRL-e
              },
          }
        },
        toggleterm = {
            -- default_group_id can be a number or a function that takes a string as parameter.
            -- The string passed as parameter is the name of the plugin so its possible to do logic based
            -- on plugin name and function should always return a number like:
            -- default_group_id = function(plugin) return 1 end
            default_group_id = 1,
        },
        enable = true,
        border = "rounded", -- style for vim.ui.selector
        style = "minimal",
        show_command = false, -- show command to run in menu
        show_command_in_output = true, -- show command that was just executed in output
        patterns = {".git", ".svn"}, -- patterns to find the root of the project
        output_result = require("greyjoy.terminals").buffer,
        extensions = {}, -- extensions configurations
        run_groups = {}, -- See `Run groups`
        overrides = {}, -- Stores internal overrides of commands
      }
      
      
      {
      	...
           run_groups = { fast = { "generic", "makefile", "cargo", "docker_compose" } },
      	...
      }
      
      
      return {
          "desdic/greyjoy.nvim",
          keys = {
              { "<leader>gr", "<cmd>Greyjoy<CR>", desc = "[G]reyjoy [r]un" },
          },
          cmd = { "Greyjoy", "Greyedit", "GreyjoyRunLast" },
          config = function()
              local greyjoy = require("greyjoy")
      
              local tmpmakename = nil
      
              local pre_make = function(command)
                  tmpmakename = os.tmpname()
                  table.insert(command.command, "2>&1")
                  table.insert(command.command, "|")
                  table.insert(command.command, "tee")
                  table.insert(command.command, tmpmakename)
              end
      
              -- A bit hacky solution to checking when tee has flushed its file
              local post_make = function()
                  vim.cmd(":cexpr []")
                  local cmd = { "inotifywait", "-e", "close_write", tmpmakename }
      
                  local job_id = vim.fn.jobstart(cmd, {
                      stdout_buffered = true,
                      on_exit = function(_, _, _)
                          if tmpmakename ~= nil then
                              vim.cmd(":cgetfile " .. tmpmakename)
                              os.remove(tmpmakename)
                          end
                      end,
                  })
      
                  if job_id <= 0 then
                      vim.notify("Failed to start inotifywait!")
                  end
              end
      
              greyjoy.setup({
                  ui = {
                      term = {
                          height = 10,
                      },
                  },
                  output_results = require("greyjoy.terminals").term,
                  extensions = {
                      makefile = {
                          pre_hook = pre_make,
                          post_hook = post_make,
                      },
                  }
              })
      
              greyjoy.load_extension("makefile")
          end,
      }
      
      
      extensions = {
          kitchen = {
              targets = { "converge", "verify", "destroy", "test", "login" },
              include_all = false,
          }
      }
      
    end,
  },
  {
    "Shatur/neovim-tasks",
    config = function()
      
      local Path = require('plenary.path')
      require('tasks').setup({
          default_params = { -- Default module parameters with which `neovim.json` will be created.
            cmake = {
              cmd = 'cmake', -- CMake executable to use, can be changed using `:Task set_module_param cmake cmd`.
              build_type = 'Debug', -- Build type, can be changed using `:Task set_module_param cmake build_type`.
              build_kit = 'default', -- default build kit, can be changed using `:Task set_module_param cmake build_kit`.
              dap_name = 'codelldb', -- DAP configuration name from `require('dap').configurations`. If there is no such configuration, a new one with this name as `type` will be created.
              build_dir = tostring(Path:new('{cwd}', 'build', '{build_kit}', '{build_type}')), -- Build directory. The expressions `{cwd}`, `{build_kit}` and `{build_type}` will be expanded with the corresponding text values. Could be a function that return the path to the build directory.
              cmake_kits_file = nil, -- set path to JSON file containing cmake kits
              cmake_build_types_file = nil, -- set path to JSON file containing cmake kits
              clangd_cmdline = {
                'clangd',
                '--background-index',
                '--clang-tidy',
                '--header-insertion=never',
                '--completion-style=detailed',
                '--offset-encoding=utf-8',
                '-j=4',
              }, -- command line for invoking clangd - this array will be extended with --compile-commands-dir and --query-driver after each cmake configure with parameters inferred from build_kit, build_type and build_dir
              ignore_presets = false, -- if true, cmake presets will not be used, build_kit and build_type will be used instead even if CMakePresets.json or CMakeUserPresets.json files are present in the project root.
              restart_clangd_after_configure = true, -- if true, clangd will be restarted after each cmake configure with updated compile_commands.json file and --query-driver parameters mattching current cmake build_kit and build_type or build_preset.
            },
            bazel = {
              cmd = 'bazel',
              dap_name = 'codelldb',
            },
            zig = {
              cmd = 'zig', -- zig command which will be invoked
              dap_name = 'codelldb', -- DAP configuration name from `require('dap').configurations`. If there is no such configuration, a new one with this name as `type` will be created.
              build_type = 'Debug', -- build type, can be changed using `:Task set_module_param zig build_type`
              build_step = 'install', -- build step, cah be changed using `:Task set_module_param zig build_step`
            },
            cargo = {
              dap_name = 'codelldb', -- DAP configuration name from `require('dap').configurations`. If there is no such configuration, a new one with this name as `type` will be created.
            },
            npm = {
              cmd = 'npm', -- npm command which will be invoked. If using yarn or pnpm, change here.
              working_directory = vim.loop.cwd(), -- working directory in which NPM will be invoked
            },
            make = {
              cmd = 'make', -- make command which will be invoked
              args = {
                all = { '-j10', 'all' }, -- :Task start make all   → make -j10 all
                build = {}, -- :Task start make build → make
                nuke = { 'clean' }, -- :Task start make nuke  → make clean
              },
            },
          },
          save_before_run = true,
          params_file = 'neovim.json',
          quickfix = {
            pos = 'botright',
            height = 12,
            only_on_error = false,
          },
          dap_open_command = function() return require('dap').repl.open() end,
      
      
      vim.keymap.set( "n", "<leader>cC", [[:Task start cmake configure<cr>]], { silent = true } )
      vim.keymap.set( "n", "<leader>cD", [[:Task start cmake configureDebug<cr>]], { silent = true } )
      vim.keymap.set( "n", "<leader>cP", [[:Task start cmake reconfigure<cr>]], { silent = true } )
      vim.keymap.set( "n", "<leader>cT", [[:Task start cmake ctest<cr>]], { silent = true } )
      vim.keymap.set( "n", "<leader>cK", [[:Task start cmake clean<cr>]], { silent = true } )
      vim.keymap.set( "n", "<leader>ct", [[:Task set_module_param cmake target<cr>]], { silent = true } )
      vim.keymap.set( "n", "<C-c>", [[:Task cancel<cr>]], { silent = true } )
      vim.keymap.set( "n", "<leader>cr", [[:Task start cmake run<cr>]], { silent = true } )
      vim.keymap.set( "n", "<F7>", [[:Task start cmake debug<cr>]], { silent = true } )
      vim.keymap.set( "n", "<leader>cb", [[:Task start cmake build<cr>]], { silent = true } )
      vim.keymap.set( "n", "<leader>cB", [[:Task start cmake build_all<cr>]], { silent = true } )
      
      -- open ccmake in embedded terminal
      local function openCCMake()
          local build_dir = tostring( require( 'tasks.cmake_utils.cmake_utils' ).getBuildDir() )
          vim.cmd( [[bo sp term://ccmake ]] .. build_dir )
      end
      vim.keymap.set( "n", "<leader>cc", openCCMake, { silent = true } )
      
      -- if project is using presets, provide preset selection for both <leader>cv and <leader>ck
      -- if not, provide build type (<leader>cv) and kit (<leader>ck) selection
      
      local function selectPreset()
          local availablePresets = cmake_presets.parse( 'buildPresets' )
      
          vim.ui.select( availablePresets, { prompt = 'Select build preset' }, function( choice, idx )
              if not idx then
                  return
              end
              local projectConfig = ProjectConfig:new()
              if not projectConfig[ 'cmake' ] then
                  projectConfig[ 'cmake' ] = {}
              end
      
              projectConfig[ 'cmake' ][ 'build_preset' ] = choice
      
              -- autoselect will invoke projectConfig:write()
              cmake_utils.autoselectConfigurePresetFromCurrentBuildPreset( projectConfig )
      
          end)
      end
      
      local function selectBuildKitOrPreset()
          if cmake_utils.shouldUsePresets() then
              selectPreset()
          else
              tasks.set_module_param( 'cmake', 'build_kit' )
          end
      end
      
      vim.keymap.set( "n", "<leader>ck", selectBuildKitOrPreset, { silent = true } )
      
      local function selectBuildTypeOrPreset()
          if cmake_utils.shouldUsePresets() then
              selectPreset()
          else
              tasks.set_module_param( 'cmake', 'build_type' )
          end
      end
      
      vim.keymap.set( "n", "<leader>cv", selectBuildTypeOrPreset, { silent = true } )
      
      
      vim.lsp.config('clangd', {
          cmd = require( 'tasks.cmake_utils.cmake_utils' ).currentClangdArgs(),
      })
      
      
      local Path = require('plenary.path')
      local lualine = require( 'lualine' )
      local ProjectConfig = require( 'tasks.project_config' )
      
      local function cmakeStatus()
          local cmake_config = ProjectConfig:new()[ 'cmake' ]
          local cmakelists_dir = cmake_config.source_dir and cmake_config.source_dir or vim.loop.cwd()
          if ( Path:new( cmakelists_dir ) / 'CMakeLists.txt' ):exists() then
              local cmake_utils = require( 'tasks.cmake_utils.cmake_utils' )
      
              if cmake_utils.shouldUsePresets( cmake_config ) then
                  local preset = cmake_config.build_preset or 'not selected'
                  local cmakeTarget = cmake_config.target and cmake_config.target or 'all'
      
                  return 'CMake preset: ' .. preset .. ', target: ' .. cmakeTarget
              else
                  local cmakeBuildType = cmake_config.build_type or 'not selected'
                  local cmakeKit = cmake_config.build_kit or 'not selected'
                  local cmakeTarget = cmake_config.target or 'all'
      
                  return 'CMake variant: ' .. cmakeBuildType .. ', kit: ' .. cmakeKit .. ', target: ' .. cmakeTarget
              end
          else
              return ''
          end
      end
      
      lualine.setup({
          sections = {
              lualine_c = { { 'filename', path = 1 } },
              lualine_x = { 'encoding', 'fileformat', 'filetype', cmakeStatus }
          }
      })
      
      
      require('tasks').setup({
        default_params = {
          ...
          make = {
            cmd = 'make',
            args = {
              all = { '-j10', 'all' },    -- :Task start make all   → make -j10 all
              build = {},                 -- :Task start make build → make
              nuke = { 'clean' },         -- :Task start make nuke  → make clean
            },
          },
          ...
        }
      })
      
      
      vim.keymap.set( "n", "<leader>ni", [[:Task start npm install<cr>]] )
      vim.keymap.set( "n", "<leader>nl", [[:Task start npm run lint<cr>]] )
      vim.keymap.set( "n", "<leader>nr", [[:Task start npm run rollup<cr>]] )
      vim.keymap.set( "n", "<leader>ns", [[:Task start npm run clean<cr>]] )
      vim.keymap.set( "n", "<leader>ns", [[:Task start npm run start<cr>]] )
      
      
      {
        params = {
          -- A table of parameter names. Possible values:
          'parameter_name1', -- A string parameter, on setting user will be prompted with vim.ui.input.
          parameter_name2 = { 'one', 'two' }, -- A table with possible values, on setting user will be prompted with vim.ui.select to pick one of these values.
          parameter_name3 = func, -- A function that generates a string or a table.
        }
        condition = function() return Path:new('file'):exists() end -- A function that returns `true` if this module could be applied to this directory. Used when `auto` is used as module name.
        tasks = {
          -- A table of module tasks. Possible values:
          task_name1 = {
            -- Required parameters:
            cmd = 'command' -- Command to execute.
            -- Optional parameters:
            cwd = 'directory' -- Command working directory. Default to current working directory.
            after_success = callback -- A callback to execute on success.
            dap_name = 'dap_name' -- A debug adapter name. If exists, the task will be launched through the adapter. Usually taken from a module parameter. Implies ignoring all streams below.
            -- Disable a stream output to quickfix. If both are disabled, quickfix will not show up. If you want to capture output of a stream in a next task, you need to disable it.
            ignore_stdout = true,
            ignore_stderr = true,
          },
          task_name2 = func1, -- A function that returns a table as above. Accepts configuration for this module and previous job.
          task_name3 = { func2, func3 }, -- A list of functions as above. Tasks will be executed in chain.
        }
      }
      
    end,
  },
  {
    "milanglacier/yarepl.nvim",
    config = function()
      
      { 'milanglacier/yarepl.nvim', config = true }
      
      
      -- below is the default configuration, there's no need to copy paste them if
      -- you are satisfied with the default configuration, just calling
      -- `require('yarepl').setup {}` is sufficient.
      local yarepl = require 'yarepl'
      
      yarepl.setup {
          -- see `:h buflisted`, whether the REPL buffer should be buflisted.
          buflisted = true,
          -- whether the REPL buffer should be a scratch buffer.
          scratch = true,
          -- the filetype of the REPL buffer created by `yarepl`
          ft = 'REPL',
          -- How yarepl open the REPL window, can be a string or a lua function.
          -- See below example for how to configure this option
          wincmd = 'belowright 15 split',
          -- The available REPL palattes that `yarepl` can create REPL based on.
          -- To disable a built-in meta, set its key to `false`, e.g., `metas = { R = false }`
          metas = {
              aichat = { cmd = 'aichat', formatter = 'bracketed_pasting', source_syntax = 'aichat' },
              radian = { cmd = 'radian', formatter = 'bracketed_pasting_no_final_new_line', source_syntax = 'R' },
              ipython = { cmd = 'ipython', formatter = 'bracketed_pasting', source_syntax = 'ipython' },
              python = { cmd = 'python', formatter = 'trim_empty_lines', source_syntax = 'python' },
              R = { cmd = 'R', formatter = 'trim_empty_lines', source_syntax = 'R' },
              bash = {
                  cmd = 'bash',
                  formatter = vim.fn.has 'linux' == 1 and 'bracketed_pasting' or 'trim_empty_lines',
                  source_syntax = 'bash',
              },
              zsh = { cmd = 'zsh', formatter = 'bracketed_pasting', source_syntax = 'bash' },
          },
          -- when a REPL process exits, should the window associated with those REPLs closed?
          close_on_exit = true,
          -- whether automatically scroll to the bottom of the REPL window after sending
          -- text? This feature would be helpful if you want to ensure that your view
          -- stays updated with the latest REPL output.
          scroll_to_bottom_after_sending = true,
          -- Format REPL buffer names as #repl_name#n (e.g., #ipython#1) instead of using terminal defaults
          format_repl_buffers_names = true,
          os = {
              -- Some hacks for Windows. macOS and Linux users can simply ignore
              -- them. The default options are recommended for Windows user.
              windows = {
                  -- Send a final `\r` to the REPL with delay,
                  send_delayed_final_cr = true,
              },
          },
          -- Display the first line as virtual text to indicate the actual
          -- command sent to the REPL.
          source_command_hint = {
              enabled = false,
              hl_group = 'Comment',
          },
      }
      
      
      wincmd = 'belowright 15 split'
      -- will create a horizontal split below the current using window and takes up 15 lines for the new window
      wincmd = 'vertical 30 split'
      -- will create a vertical split right to the current using window and takes up 30 columns for the new window
      
      
      wincmd = function(bufnr, name)
          vim.api.nvim_open_win(bufnr, true, {
              relative = 'editor',
              row = math.floor(vim.o.lines * 0.25),
              col = math.floor(vim.o.columns * 0.25),
              width = math.floor(vim.o.columns * 0.5),
              height = math.floor(vim.o.lines * 0.5),
              style = 'minimal',
              title = name,
              border = 'rounded',
              title_pos = 'center',
          })
      end
      
      
      
      float_wincmd = function(bufnr, name)
          vim.api.nvim_open_win(bufnr, true, {
              relative = 'editor',
              row = math.floor(vim.o.lines * 0.25),
              col = math.floor(vim.o.columns * 0.25),
              width = math.floor(vim.o.columns * 0.5),
              height = math.floor(vim.o.lines * 0.5),
              style = 'minimal',
              title = name,
              border = 'rounded',
              title_pos = 'center',
          })
      end
      
      yarepl.setup {
          metas = {
              -- REPL local settings
              ipython = { wincmd = 'topleft 25 split' },
              radian = { wincmd = float_wincmd },
          }
          -- global settings
          wincmd = 'belowright 15 split',
      }
      
      
      metas = {
          R = false
      }
      
      
      metas = {
          ipython = { cmd = { 'ipython', '--simple-prompt' } }
      }
      
      
      function send_line_verbatim(lines)
          -- each line is a string
          return lines
      end
      
      function ipython_or_python()
          if vim.fn.executable 'ipython' == 1 then
              return { 'ipython', '--simple-prompt' }
          else
              return 'python'
          end
      end
      
      function ipython_or_python_formatter(lines)
          if vim.fn.executable 'ipython' == 1 then
              return yarepl.formatter.bracketed_pasting(lines)
          else
              return yarepl.formatter.trim_empty_lines(lines)
          end
      end
      
      metas = {
          ipython_new = { cmd = { 'ipython', '--simple-prompt' }, formatter = send_line_verbatim },
          ipython_or_python = { cmd = ipython_or_python, formatter = ipython_or_python_formatter },
      }
      
      
      
      -- Calling this function will return a function that takes a list of strings as
      -- input and returns a list of strings. This can be used as the formatter function
      -- of meta.
      
      -- these are the default config
      yarepl.formatter.factory {
          -- Specifies whether to return tabs in the string as spaces.
          replace_tab_by_space = false,
          -- Specifies the number of spaces to replace the tab (if enabled).
          number_of_spaces_to_replace_tab = 8,
          -- For a list of strings containing more than one string:
          when_multi_lines = {
              -- The prefixing code sent to the repl firstly.
              open_code = '',
              -- The suffixing code sent to the repl finally.
              end_code = '\r',
              -- Whether to remove empty lines from the list of strings.
              trim_empty_lines = false,
              -- Whether to remove leading spaces at the beginning of each line.
              remove_leading_spaces = false,
              -- If gsub_pattern and gsub_repl are not empty, `string.gsub` will
              -- be called with `gsub_pattern` and `gsub_repl` on each line. Note
              -- that you should use Lua pattern instead of Vim regex pattern.
              -- The gsub calls happen after `trim_empty_lines`,
              -- `remove_leading_spaces`, and `replace_tab_by_space`, and before
              -- prepending and appending `open_code` and `end_code`.
              gsub_pattern = '',
              gsub_repl = '',
          },
          -- For a list containing only one string:
          when_single_line = {
              -- The prefixing code sent to the repl firstly.
              open_code = '',
              -- The suffixing code sent to the repl finally.
              end_code = '\r',
              -- the same as the specs of `when_multi_lines`
              gsub_pattern = '',
              gsub_repl = '',
          },
          os = {
              -- Some hacks for Windows. macOS and Linux users can simply ignore
              -- them. The default options are recommended for Windows user.
              windows = {
                  -- Join the lines with `\r` before sending to REPL.
                  join_lines_with_cr = true,
              },
          },
      }
      
      -- `yarepl` provides four builtin formatters that can be referenced by name:
      -- 1. 'bracketed_pasting' - Uses bracketed paste mode for modern REPLs
      -- 2. 'bracketed_pasting_no_final_new_line' - Same as above but without final newline
      -- 3. 'bracketed_pasting_delayed_cr': similar to `bracketed_pasting`, but use with `send_delayed_final_cr = true`
      -- 4. 'trim_empty_lines' - Trims empty lines from input
      
      -- You can also create custom formatters by calling `yarepl.formatter.factory`:
      
      yarepl.formatter.trim_empty_lines = yarepl.formatter.factory {
          when_multi_lines = {
              trim_empty_lines = true,
              remove_leading_spaces = false,
          },
      }
      
      yarepl.formatter.bracketed_pasting = yarepl.formatter.factory {
          when_multi_lines = {
              open_code = '\27[200~',
              end_code = '\27[201~\r',
              trim_empty_lines = false,
              remove_leading_spaces = false,
          },
      }
      
      
      metas = {
          claude_code = {
              cmd = 'claude',
              formatter = 'bracketed_pasting_delayed_cr',
              source_syntax = '@{{file}}',
              send_delayed_final_cr = true
          },
          ipython = {
              cmd = 'ipython',
              formatter = 'bracketed_pasting',
              send_delayed_final_cr = false  -- this is the default, can be omitted
          },
          -- yarepl provides builtin extension to use with codex.
          codex = require('yarepl.extensions.codex').create_codex_meta(),
      }
      
      
      local yarepl = require 'yarepl'
      
      yarepl.setup {
          metas = {
              radian = {
                  cmd = 'radian',
                  formatter = 'bracketed_pasting_no_final_new_line',
                  source_syntax = 'eval(parse(text = "{{file}}"))',
              },
          }
      }
      
      
      local yarepl = require 'yarepl'
      local python_source_func = function(str)
          local file = make_tmp_file(str)
          if not file then
              return
          end
      
          local cmd = string.format('exec(open("%s", "r").read())', file)
          return cmd
      end
      
      
      yarepl.setup {
          metas = {
              ipython = {
                  cmd = 'ipython',
                  formatter = 'bracketed_pasting',
                  source_syntax = python_source_func,
              },
          }
      }
      
      
      local keymap = vim.api.nvim_set_keymap
      local bufmap = vim.api.nvim_buf_set_keymap
      
      keymap('n', '<Leader>cs', '<Plug>(REPLStart-aichat)', {
          desc = 'Start an Aichat REPL',
      })
      keymap('n', '<Leader>cf', '<Plug>(REPLFocus-aichat)', {
          desc = 'Focus on Aichat REPL',
      })
      keymap('n', '<Leader>ch', '<Plug>(REPLHide-aichat)', {
          desc = 'Hide Aichat REPL',
      })
      keymap('v', '<Leader>cr', '<Plug>(REPLSendVisual-aichat)', {
          desc = 'Send visual region to Aichat',
      })
      keymap('v', '<Leader>cR', '<Plug>(REPLSourceVisual-aichat)', {
          desc = 'Source visual region to Aichat',
      })
      keymap('n', '<Leader>crr', '<Plug>(REPLSendLine-aichat)', {
          desc = 'Send lines to Aichat',
      })
      keymap('n', '<Leader>cr', '<Plug>(REPLSendOperator-aichat)', {
          desc = 'Send Operator to Aichat',
      })
      keymap('n', '<Leader>cr', '<Plug>(REPLSourceOperator-aichat)', {
          desc = 'Source Operator to Aichat',
      })
      keymap('n', '<Leader>ce', '<Plug>(REPLExec-aichat)', {
          desc = 'Execute command in aichat',
      })
      keymap('n', '<Leader>cq', '<Plug>(REPLClose-aichat)', {
          desc = 'Quit Aichat',
      })
      
      
      local ft_to_repl = {
          r = 'radian',
          R = 'radian',
          rmd = 'radian',
          quarto = 'radian',
          markdown = 'radian',
          python = 'ipython',
          sh = 'bash',
      }
      
      autocmd('FileType', {
          pattern = { 'quarto', 'markdown', 'markdown.pandoc', 'rmd', 'python', 'sh', 'REPL', 'r' },
          group = my_augroup,
          desc = 'set up REPL keymap',
          callback = function()
              local repl = ft_to_repl[vim.bo.filetype]
              repl = repl and ('-' .. repl) or ''
      
              bufmap(0, 'n', '<LocalLeader>rs', string.format('<Plug>(REPLStart%s)', repl), {
                  desc = 'Start an REPL',
              })
              bufmap(0, 'n', '<LocalLeader>rf', '<Plug>(REPLFocus)', {
                  desc = 'Focus on REPL',
              })
              bufmap(0, 'n', '<LocalLeader>rv', '<CMD>Telescope REPLShow<CR>', {
                  desc = 'View REPLs in telescope',
              })
              bufmap(0, 'n', '<LocalLeader>rh', '<Plug>(REPLHide)', {
                  desc = 'Hide REPL',
              })
              bufmap(0, 'v', '<LocalLeader>s', '<Plug>(REPLSendVisual)', {
                  desc = 'Send visual region to REPL',
              })
              bufmap(0, 'v', '<LocalLeader>S', '<Plug>(REPLSourceVisual)', {
                  desc = 'Source visual region to REPL',
              })
              bufmap(0, 'n', '<LocalLeader>ss', '<Plug>(REPLSendLine)', {
                  desc = 'Send line to REPL',
              })
              bufmap(0, 'n', '<LocalLeader>s', '<Plug>(REPLSendOperator)', {
                  desc = 'Send operator to REPL',
              })
              bufmap(0, 'n', '<LocalLeader>S', '<Plug>(REPLSourceOperator)', {
                  desc = 'Source operator to REPL',
              })
              bufmap(0, 'n', '<LocalLeader>re', '<Plug>(REPLExec)', {
                  desc = 'Execute command in REPL',
                  expr = true,
              })
              bufmap(0, 'n', '<LocalLeader>rq', '<Plug>(REPLClose)', {
                  desc = 'Quit REPL',
              })
              bufmap(0, 'n', '<LocalLeader>rc', '<CMD>REPLCleanup<CR>', {
                  desc = 'Clear REPLs.',
              })
              bufmap(0, 'n', '<LocalLeader>rS', '<CMD>REPLSwap<CR>', {
                  desc = 'Swap REPLs.',
              })
              bufmap(0, 'n', '<LocalLeader>r?', '<Plug>(REPLStart)', {
                  desc = 'Start an REPL from available REPL metas',
              })
              bufmap(0, 'n', '<LocalLeader>ra', '<CMD>REPLAttachBufferToREPL<CR>', {
                  desc = 'Attach current buffer to a REPL',
              })
              bufmap(0, 'n', '<LocalLeader>rd', '<CMD>REPLDetachBufferToREPL<CR>', {
                  desc = 'Detach current buffer to any REPL',
              })
          end,
      })
      
      
      
      vim.o.exrc = true
      
      
      vim.g.yarepl_ipython_paths = vim.g.yarepl_ipython_paths or {}
      local yarepl = require 'yarepl'
      
      require('yarepl').setup {
          metas = {
              ipython = {
                  cmd = function()
                      local cwd = vim.fn.getcwd()
                      if vim.g.yarepl_ipython_paths and vim.g.yarepl_ipython_paths[cwd] then
                          return vim.g.yarepl_ipython_paths[cwd]
                      else
                          return 'ipython'
                      end
                  end,
              },
          },
      }
      
      
      local cwd = vim.fn.getcwd()
      
      if vim.g.yarepl_ipython_paths then
          vim.g.yarepl_ipython_paths[cwd] = '~/mambaforge/envs/a-conda-env/bin/ipython'
      else
          vim.g.yarepl_ipython_paths = {
              [cwd] = '~/mambaforge/envs/a-conda-env/bin/ipython',
          }
      end
      
      
      metas = {
          ipy_tmux = {
              cmd = 'tmux attach -t ipython || tmux new -s ipython ipython',
              formatter = yarepl.formatter.bracketed_pasting,
          },
      }
      
      
      -- Recommended
      return {
          'milanglacier/yarepl.nvim',
          event = 'VeryLazy',
          config = function()
              -- add your configs here
          end,
      }
      
      -- Also works, but use with caution!
      return {
          'milanglacier/yarepl.nvim',
          keys = {
              { '<Leader>s', '<Plug>(REPLStart)', noremap = false, mode = 'n' },
              { '<LocalLeader>o', '<Plug>(REPLStart-ipython)', noremap = false, ft = 'python', mode = 'n' },
          },
          config = function()
              -- your config here
          end,
      }
      
    end,
  },
  {
    "Vigemus/iron.nvim",
    config = function()
      
        use {'Vigemus/iron.nvim'}
      
      
      local iron = require("iron.core")
      local view = require("iron.view")
      local common = require("iron.fts.common")
      
      iron.setup {
        config = {
          -- Whether a repl should be discarded or not
          scratch_repl = true,
          -- Your repl definitions come here
          repl_definition = {
            sh = {
              -- Can be a table or a function that
              -- returns a table (see below)
              command = {"zsh"}
            },
            python = {
              command = { "python3" },  -- or { "ipython", "--no-autoindent" }
              format = common.bracketed_paste_python,
              block_dividers = { "# %%", "#%%" },
              env = {PYTHON_BASIC_REPL = "1"} --this is needed for python3.13 and up.
            }
          },
          -- set the file type of the newly created repl to ft
          -- bufnr is the buffer id of the REPL and ft is the filetype of the 
          -- language being used for the REPL. 
          repl_filetype = function(bufnr, ft)
            return ft
            -- or return a string name such as the following
            -- return "iron"
          end,
          -- Send selections to the DAP repl if an nvim-dap session is running.
          dap_integration = true,
          -- How the repl window will be displayed
          -- See below for more information
          repl_open_cmd = view.bottom(40),
      
          -- repl_open_cmd can also be an array-style table so that multiple 
          -- repl_open_commands can be given.
          -- When repl_open_cmd is given as a table, the first command given will
          -- be the command that `IronRepl` initially toggles.
          -- Moreover, when repl_open_cmd is a table, each key will automatically
          -- be available as a keymap (see `keymaps` below) with the names 
          -- toggle_repl_with_cmd_1, ..., toggle_repl_with_cmd_k
          -- For example,
          -- 
          -- repl_open_cmd = {
          --   view.split.vertical.rightbelow("%40"), -- cmd_1: open a repl to the right
          --   view.split.rightbelow("%25")  -- cmd_2: open a repl below
          -- }
      
        },
        -- Iron doesn't set keymaps by default anymore.
        -- You can set them here or manually add keymaps to the functions in iron.core
        keymaps = {
          toggle_repl = "<space>rr", -- toggles the repl open and closed.
          -- If repl_open_command is a table as above, then the following keymaps are
          -- available
          -- toggle_repl_with_cmd_1 = "<space>rv",
          -- toggle_repl_with_cmd_2 = "<space>rh",
          restart_repl = "<space>rR", -- calls `IronRestart` to restart the repl
          send_motion = "<space>sc",
          visual_send = "<space>sc",
          send_file = "<space>sf",
          send_line = "<space>sl",
          send_paragraph = "<space>sp",
          send_until_cursor = "<space>su",
          send_mark = "<space>sm",
          send_code_block = "<space>sb",
          send_code_block_and_move = "<space>sn",
          mark_motion = "<space>mc",
          mark_visual = "<space>mc",
          remove_mark = "<space>md",
          cr = "<space>s<cr>",
          interrupt = "<space>s<space>",
          exit = "<space>sq",
          clear = "<space>cl",
        },
        -- If the highlight is on, you can change how it looks
        -- For the available options, check nvim_set_hl
        highlight = {
          italic = true
        },
        ignore_blank_lines = true, -- ignore blank lines when sending visual select lines
      }
      
      -- iron also has a list of commands, see :h iron-commands for all available commands
      vim.keymap.set('n', '<space>rf', '<cmd>IronFocus<cr>')
      vim.keymap.set('n', '<space>rh', '<cmd>IronHide<cr>')
      
      
      iron.setup{
        config = {
          repl_definition = {
            -- custom repl that loads the current file
            haskell = {
              command = function(meta)
                local filename = vim.api.nvim_buf_get_name(meta.current_bufnr)
                return { 'cabal', 'v2-repl', filename}
              end
            }
          },
        },
      }
      
      
      local view = require("iron.view")
      
      -- iron.setup {...
      
      -- One can always use the default commands from vim directly
      repl_open_cmd = "vertical botright 80 split"
      
      -- But iron provides some utility functions to allow you to declare that dynamically,
      -- based on editor size or custom logic, for example.
      
      -- Vertical 50 columns split
      -- Split has a metatable that allows you to set up the arguments in a "fluent" API
      -- you can write as you would write a vim command.
      -- It accepts:
      --   - vertical
      --   - leftabove/aboveleft
      --   - rightbelow/belowright
      --   - topleft
      --   - botright
      -- They'll return a metatable that allows you to set up the next argument
      -- or call it with a size parameter
      repl_open_cmd = view.split.vertical.botright(50)
      
      -- If the supplied number is a fraction between 1 and 0,
      -- it will be used as a proportion
      repl_open_cmd = view.split.vertical.botright(0.61903398875)
      
      -- The size parameter can be a number, a string or a function.
      -- When it's a *number*, it will be the size in rows/columns
      -- If it's a *string*, it requires a "%" sign at the end and is calculated
      -- as a percentage of the editor size
      -- If it's a *function*, it should return a number for the size of rows/columns
      
      repl_open_cmd = view.split("40%")
      
      -- You can supply custom logic
      -- to determine the size of your
      -- repl's window
      repl_open_cmd = view.split.topleft(function()
        if some_check then
          return vim.o.lines * 0.4
        end
        return 20
      end)
      
      -- An optional set of options can be given to the split function if one
      -- wants to configure the window behavior.
      -- Note that, by default `winfixwidth` and `winfixheight` are set
      -- to `true`. If you want to overwrite those values,
      -- you need to specify the keys in the option map as the example below
      
      repl_open_cmd = view.split("40%", {
        winfixwidth = false,
        winfixheight = false,
        -- any window-local configuration can be used here
        number = true
      })
      
      
      local view = require("iron.view")
      
      -- iron.setup {...
      
      -- The same size arguments are valid for float functions
      repl_open_cmd = view.top("10%")
      
      -- `view.center` takes either one or two arguments
      repl_open_cmd = view.center("30%", 20)
      
      -- If you supply only one, it will be used for both dimensions
      -- The function takes an argument to whether the orientation is vertical(true) or
      -- horizontal (false)
      repl_open_cmd = view.center(function(vertical)
      -- Useless function, but it will be called twice,
      -- once for each dimension (width, height)
        if vertical then
          return 50
        end
        return 20
      end)
      
      -- `view.offset` allows you to control both the size of each dimension and
      -- the distance of them from the top-left corner of the screen
      repl_open_cmd = view.offset{
        width = 60,
        height = vim.o.height * 0.75
        w_offset = 0,
        h_offset = "5%"
      }
      
      -- Some helper functions allow you to calculate the offset
      -- in relation to the size of the window.
      -- While all other sizing functions take only the orientation boolean (vertical or not),
      -- for offsets, the functions will also take the repl size in that dimension
      -- as argument. The helper functions then return a function that takes two arguments
      -- to calculate the offset
      repl_open_cmd = view.offset{
        width = 60,
        height = vim.o.height * 0.75
        -- `view.helpers.flip` will subtract the size of the REPL
        -- window from the total dimension, then apply an offset.
        -- Effectively, it flips the top/left to bottom/right orientation
        w_offset = view.helpers.flip(2),
        -- `view.helpers.proportion` allows you to apply a relative
        -- offset considering the REPL window size.
        -- for example, 0.5 will centralize the REPL in that dimension,
        -- 0 will pin it to the top/left and 1 will pin it to the bottom/right.
        h_offset = view.helpers.proportion(0.5)
      }
      
      -- Differently from `view.center`, all arguments are required
      -- and no defaults will be applied if something is missing.
      repl_open_cmd = view.offset{
        width = 60,
        height = vim.o.height * 0.75
        -- Since we know we're using this function in the width offset
        -- calculation, we can ignore the argument
        w_offset = function(_, repl_size)
          -- Ideally this function calculates a value based on something..
          return 42
        end,
        h_offset = view.helpers.flip(2)
      }
      
    end,
  },
  {
    "Civitasv/cmake-tools.nvim",
    config = function()
      
      local osys = require("cmake-tools.osys")
      require("cmake-tools").setup {
        cmake_command = "cmake", -- this is used to specify cmake command path
        ctest_command = "ctest", -- this is used to specify ctest command path
        cmake_use_preset = true,
        cmake_regenerate_on_save = true, -- auto generate when save CMakeLists.txt
        cmake_generate_options = { "-DCMAKE_EXPORT_COMPILE_COMMANDS=1" }, -- this will be passed when invoke `CMakeGenerate`
        cmake_build_options = {}, -- this will be passed when invoke `CMakeBuild`
        -- support macro expansion:
        --       ${kit}
        --       ${kitGenerator}
        --       ${variant:xx}
        cmake_build_directory = function()
          if osys.iswin32 then
            return "out\\${variant:buildType}"
          end
          return "out/${variant:buildType}"
        end, -- this is used to specify generate directory for cmake, allows macro expansion, can be a string or a function returning the string, relative to cwd.
        cmake_compile_commands_options = {
          action = "soft_link", -- available options: soft_link, copy, lsp, none
                                -- soft_link: this will automatically make a soft link from compile commands file to target
                                -- copy:      this will automatically copy compile commands file to target
                                -- lsp:       this will automatically set compile commands file location using lsp
                                -- none:      this will make this option ignored
          target = vim.loop.cwd() -- path to directory, this is used only if action == "soft_link" or action == "copy"
        },
        cmake_kits_path = nil, -- this is used to specify global cmake kits path, see CMakeKits for detailed usage
        cmake_variants_message = {
          short = { show = true }, -- whether to show short message
          long = { show = true, max_length = 40 }, -- whether to show long message
        },
        cmake_dap_configuration = { -- debug settings for cmake
          name = "cpp",
          type = "codelldb",
          request = "launch",
          stopOnEntry = false,
          runInTerminal = true,
          console = "integratedTerminal",
        },
        cmake_executor = { -- executor to use
          name = "quickfix", -- name of the executor
          opts = {}, -- the options the executor will get, possible values depend on the executor type. See `default_opts` for possible values.
          default_opts = { -- a list of default and possible values for executors
            quickfix = {
              show = "always", -- "always", "only_on_error"
              position = "belowright", -- "vertical", "horizontal", "leftabove", "aboveleft", "rightbelow", "belowright", "topleft", "botright", use `:h vertical` for example to see help on them
              size = 10,
              encoding = "utf-8", -- if encoding is not "utf-8", it will be converted to "utf-8" using `vim.fn.iconv`
              auto_close_when_success = true, -- typically, you can use it with the "always" option; it will auto-close the quickfix buffer if the execution is successful.
            },
            toggleterm = {
              direction = "float", -- 'vertical' | 'horizontal' | 'tab' | 'float'
              close_on_exit = false, -- whether close the terminal when exit
              auto_scroll = true, -- whether auto scroll to the bottom
              singleton = true, -- single instance, autocloses the opened one, if present
            },
            overseer = {
              new_task_opts = {
                  strategy = {
                      "toggleterm",
                      direction = "horizontal",
                      auto_scroll = true,
                      quit_on_exit = "success"
                  }
              }, -- options to pass into the `overseer.new_task` command
              on_new_task = function(task)
                  require("overseer").open(
                      { enter = false, direction = "right" }
                  )
              end,   -- a function that gets overseer.Task when it is created, before calling `task:start`
            },
            terminal = {
              name = "Main Terminal",
              prefix_name = "[CMakeTools]: ", -- This must be included and must be unique, otherwise the terminals will not work. Do not use a simple spacebar " ", or any generic name
              split_direction = "horizontal", -- "horizontal", "vertical"
              split_size = 11,
      
              -- Window handling
              single_terminal_per_instance = true, -- Single viewport, multiple windows
              single_terminal_per_tab = true, -- Single viewport per tab
              keep_terminal_static_location = true, -- Static location of the viewport if avialable
              auto_resize = true, -- Resize the terminal if it already exists
      
              -- Running Tasks
              start_insert = false, -- If you want to enter terminal with :startinsert upon using :CMakeRun
              focus = false, -- Focus on terminal when cmake task is launched.
              do_not_add_newline = false, -- Do not hit enter on the command inserted when using :CMakeRun, allowing a chance to review or modify the command before hitting enter.
            }, -- terminal executor uses the values in cmake_terminal
          },
        },
        cmake_runner = { -- runner to use
          name = "terminal", -- name of the runner
          opts = {}, -- the options the runner will get, possible values depend on the runner type. See `default_opts` for possible values.
          default_opts = { -- a list of default and possible values for runners
            quickfix = {
              show = "always", -- "always", "only_on_error"
              position = "belowright", -- "bottom", "top"
              size = 10,
              encoding = "utf-8",
              auto_close_when_success = true, -- typically, you can use it with the "always" option; it will auto-close the quickfix buffer if the execution is successful.
            },
            toggleterm = {
              direction = "float", -- 'vertical' | 'horizontal' | 'tab' | 'float'
              close_on_exit = false, -- whether close the terminal when exit
              auto_scroll = true, -- whether auto scroll to the bottom
              singleton = true, -- single instance, autocloses the opened one, if present
            },
            overseer = {
              new_task_opts = {
                  strategy = {
                      "toggleterm",
                      direction = "horizontal",
                      autos_croll = true,
                      quit_on_exit = "success"
                  }
              }, -- options to pass into the `overseer.new_task` command
              on_new_task = function(task)
              end,   -- a function that gets overseer.Task when it is created, before calling `task:start`
            },
            terminal = {
              name = "Main Terminal",
              prefix_name = "[CMakeTools]: ", -- This must be included and must be unique, otherwise the terminals will not work. Do not use a simple spacebar " ", or any generic name
              split_direction = "horizontal", -- "horizontal", "vertical"
              split_size = 11,
      
              -- Window handling
              single_terminal_per_instance = true, -- Single viewport, multiple windows
              single_terminal_per_tab = true, -- Single viewport per tab
              keep_terminal_static_location = true, -- Static location of the viewport if avialable
              auto_resize = true, -- Resize the terminal if it already exists
      
              -- Running Tasks
              start_insert = false, -- If you want to enter terminal with :startinsert upon using :CMakeRun
              focus = false, -- Focus on terminal when cmake task is launched.
              do_not_add_newline = false, -- Do not hit enter on the command inserted when using :CMakeRun, allowing a chance to review or modify the command before hitting enter.
            },
          },
        },
        cmake_notifications = {
          runner = { enabled = true },
          executor = { enabled = true },
          spinner = { "⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏" }, -- icons used for progress display
          refresh_rate_ms = 100, -- how often to iterate icons
        },
        cmake_virtual_text_support = true, -- Show the target related to current file using virtual text (at right corner)
        cmake_use_scratch_buffer = false, -- A buffer that shows what cmake-tools has done
      }
      
    end,
  },
  {
    "idanarye/nvim-moonicipal",
    config = function()
      
      require'moonicipal'.setup {
          file_prefix = '.my-username',
      
          -- Choose one of these, according to the one you use. Or don't set it and
          -- default to the less powerful `vim.ui.select()`.
          selection = 'moonicipal.selection.fzf-lua',
          selection = 'moonicipal.selection.telescope',
      
          -- Default values - you may change them
          task_actions = {
              add = '<M-a>',
              edit = '<M-e>',
          },
      }
      
      
      local moonicipal = require'moonicipal'
      local T = moonicipal.tasks_file()
      
      function T:build()
          |
      end
      
      
      local moonicipal = require'moonicipal'
      local T = moonicipal.tasks_file()
      
      function T:build()
          vim.cmd.make()
      end
      
    end,
  },
  {
    "MarcHamamji/runner.nvim",
    config = function()
      
        return require('packer').startup(function(use)
          use {
            'MarcHamamji/runner.nvim',
            requires = {
              'nvim-telescope/telescope.nvim',
              requires = { 'nvim-lua/plenary.nvim' }
            },
            config = function()
              require('runner').setup()
            end
          }
        end)
        
      
        require('lazy').setup({
          {
            'MarcHamamji/runner.nvim',
            dependencies = {
              'nvim-telescope/telescope.nvim',
              dependencies = { 'nvim-lua/plenary.nvim' }
            }, 
            config = function()
              require('runner').setup()
            end
          }
        })
        
      
        require('runner').run()
        require('runner').autorun()
        require('runner').autorun_stop()
      
        -- Can also be called with the buffer number where the code is:
        -- require('runner').run( <buffer_number> )
        -- require('runner').autorun( <buffer_number> )
      
        -- To set a mapping
        vim.keymap.set('n', '<leader><space>', require('runner').run)
        
      
        require('runner').setup({
          position = 'right', -- position of the terminal window when using the shell_handler
                              -- can be: top, left, right, bottom
                              -- will be overwritten when using the telescope mapping to open horizontally or vertically
      
          width = 80,         -- width of window when position is left or right
          height = 10,        -- height of window when position is top or bottom
      
          handlers = {} -- discussed in the next section
        })
        
      
        {
          ["filetype"] = handler
        }
        
      
        require('runner').setup({
          -- Other options
      
          handlers = {
            lua = function(bufnr)
              vim.print('Running lua file in buffer ' .. bufnr)
              -- Run the file here
            end
          }
        })
        
      
        require('runner').set_handler('lua', function(bufnr)
          vim.print('Running lua file in buffer ' .. bufnr)
          -- Run the file here
        end)
        
      
        local helper_name = require('runner.handlers.helpers').helper_name
        
      
          local shell_handler = require('runner.handlers.helpers').shell_handler
          require('runner').set_handler('rust', shell_handler('cargo run', true))
          
      
          local command_handler = require('runner.handlers.helpers').command_handler
          require('runner').set_handler('lua', command_handler('luafile %'))
          
      
          local choice = require('runner.handlers.helpers').choice
          require('runner').set_handler('rust', choice({
            ['Run'] = helpers.shell_handler('cargo run'),
            ['Test'] = helpers.shell_handler('cargo test'),
            ['Custom'] = helpers.shell_handler('cargo ', true),
          }))
          
    end,
  },
  {
    "google/executor.nvim",
    config = function()
      
      {
        "google/executor.nvim",
        dependencies = {
          "MunifTanjim/nui.nvim",
        },
        config = function()
          -- your setup here
        end,
      },
      
      
      require("executor").setup({})
      
      
      local executor = require("executor")
      
      executor.commands.reset()
      executor.commands.swap_to_split()
      executor.commands.swap_to_popup()
      executor.commands.show_detail()
      executor.commands.hide_detail()
      executor.commands.toggle_detail()
      executor.commands.set_command()
      executor.commands.run()
      executor.commands.run_with_new_command()
      executor.commands.show_presets()
      executor.commands.show_history()
      executor.commands.run_one_off(cmd)
      
      
      vim.api.nvim_set_keymap("n", "<leader>er", ":ExecutorRun<CR>", {})
      vim.api.nvim_set_keymap("n", "<leader>ev", ":ExecutorToggleDetail<CR>", {})
      
      
      local executor = require('executor')
      
      vim.keymap.set("n", "<leader>er", function()
        executor.commands.run()
      end)
      
      
      require('executor').setup({
       -- View details of the task run in a split, rather than a popup window.
       -- Set this to `false` to use a popup.
       use_split = true,
      
       -- Configure the split. These are ignored if you are using a popup.
       split = {
         -- One of "top", "right", "bottom" or "left"
         position = "right",
         -- The number of columns to take up. This sets the split to 1/4 of the
         -- space. If you're using the split at the top or bottom, you could also
         -- use `vim.o.lines` to set this relative to the height of the window.
         size = math.floor(vim.o.columns * 1/4)
       },
      
       -- Configure the popup. These are ignored if you are using a split.
       popup = {
         -- Sets the width of the popup to 3/5ths of the screen's width.
         width = math.floor(vim.o.columns * 3/5),
         -- Sets the height to almost full height, allowing for some padding.
         height = vim.o.lines - 20,
          -- Border styles
         border = {
            padding = {
              top = 2,
              bottom = 2,
              left = 3,
              right = 3,
            },
            style = "rounded",
         },
       },
       -- Filter output from commands. See *filtering_output* below for more
       output_filter = function(command, lines)
         return lines
       end,
      
       notifications = {
         -- Show a popup notification when a task is started.
         task_started = true,
         -- Show a popup notification when a task is completed.
         task_completed = true,
          -- Border styles
         border = {
            padding = {
              top = 0,
              bottom = 0,
              left = 1,
              right = 1,
            },
            style = "rounded",
         },
       },
       statusline = {
         prefix = "Executor: "
          icons = {
            in_progress = "…",
            failed = "✖ ",
            passed = "✓",
          },
       }
      })
      
      
      output_filter = function(command, lines)
        if command == "npm test" then
          local kept_lines = {}
          for _, line in ipairs(lines) do
            if string.substr(line, "foo") == nil then
              table.insert(kept_lines, line)
            end
          end
          return kept_lines
        end
      
        return lines
      end
      
      
      preset_commands = {
        ["executor.nvim"] = {
          "make test",
        },
      }
      
      
      preset_commands = {
        ["executor.nvim"] = {
          {
            cmd = function()
              -- Use bufnr 0 to use current buffer.
              local buf_name = vim.api.nvim_buf_get_name(0)
              return "echo 'Buffer name:'" .. buf_name
            end,
          },
        },
      }
      
      
      preset_commands = {
        ["executor.nvim"] = {
          { partial = true, cmd = "make test --filter="},
        },
      }
      
      
      vim.api.nvim_set_keymap("n", "<leader>b", ":ExecutorOneOff npm run build<CR>", {})
      
    end,
  },
  {
    "Zeioth/compiler.nvim",
    config = function()
      
      { -- This plugin
        "Zeioth/compiler.nvim",
        cmd = {"CompilerOpen", "CompilerToggleResults", "CompilerRedo"},
        dependencies = { "stevearc/overseer.nvim", "nvim-telescope/telescope.nvim" },
        opts = {},
      },
      { -- The task runner we use
        "stevearc/overseer.nvim",
        commit = "6271cab7ccc4ca840faa93f54440ffae3a3918bd",
        cmd = { "CompilerOpen", "CompilerToggleResults", "CompilerRedo" },
        opts = {
          task_list = {
            direction = "bottom",
            min_height = 25,
            max_height = 25,
            default_detail = 1
          },
        },
      },
      
      
      -- Open compiler
      vim.api.nvim_set_keymap('n', '<F6>', "<cmd>CompilerOpen<cr>", { noremap = true, silent = true })
      
      -- Redo last selected option
      vim.api.nvim_set_keymap('n', '<S-F6>',
           "<cmd>CompilerStop<cr>" -- (Optional, to dispose all tasks before redo)
        .. "<cmd>CompilerRedo<cr>",
       { noremap = true, silent = true })
      
      -- Toggle compiler results
      vim.api.nvim_set_keymap('n', '<S-F7>', "<cmd>CompilerToggleResults<cr>", { noremap = true, silent = true })
      
    end,
  },
  {
    "Zeioth/makeit.nvim",
    config = function()
      
      { -- This plugin
        "Zeioth/makeit.nvim",
        cmd = {"MakeitOpen", "MakeitToggleResults", "MakeitRedo"},
        dependencies = { "stevearc/overseer.nvim" },
        opts = {},
      },
      { -- The task runner we use
        "stevearc/overseer.nvim",
        commit = "400e762648b70397d0d315e5acaf0ff3597f2d8b",
        cmd = {"MakeitOpen", "MakeitToggleResults", "MakeitRedo"},
        opts = {
          task_list = {
            direction = "bottom",
            min_height = 25,
            max_height = 25,
            default_detail = 1
          },
        },
      },
      
    end,
  },
  {
    "jaytyrrell13/static.nvim",
    config = function()
      
      {
          'jaytyrrell13/static.nvim',
          opts = {},
          keys = {
              { '<leader>Sb', ':Static build<cr>' },
              { '<leader>Ss', ':Static serve<cr>' },
              { '<leader>Sp', ':Static prod<cr>' },
          },
      }
      
      
      use {
          'jaytyrrell13/static.nvim',
          config = function()
              require('static').setup()
          end
      }
      
      
      {
        strategy = 'basic',
      }
      
      
      {
          'L3MON4D3/LuaSnip',
          dependencies = {
              'jaytyrrell13/static.nvim',
          }
      }
      
      
      require('luasnip.loaders.from_vscode').lazy_load()
      
    end,
  },
  {
    "dasupradyumna/launch.nvim",
    config = function()
      
      -- LazySpec (plugin specification)
      -- return {
      {
          'dasupradyumna/launch.nvim',
          -- add below plugins as per user requirement
          dependencies = {
              'mfussenegger/nvim-dap',
              'rcarriga/nvim-notify',
          }
      }
      -- }
      
      
      -- inside setup function
      -- packer.startup(function(use)
      use {
          'dasupradyumna/launch.nvim',
          -- add below plugins as per user requirement
          requires = {
              'mfussenegger/nvim-dap',
              'rcarriga/nvim-notify',
          }
      }
      -- end)
      
      
      -- table of user-defined configuration options which override the plugin defaults
      local cfg = {} -- uses the plugin defaults
      
      -- independent setup (for vim-plug as well)
      require('launch').setup(cfg)
      
      -- for lazy.nvim
      return { 'dasupradyumna/launch.nvim', opts = cfg }
      
      -- for packer.nvim
      use { 'dasupradyumna/launch.nvim', config = function() require('launch').setup(cfg) end}
      
      
      -- PLUGIN DEFAULTS
      default_cfg = {
        -- debugger settings
        debug = {
          -- mapping from filetypes to debug adapter names as specified in `require('dap').adapters`
          -- `nil` implies that the filetypes themselves are used as the adapter names
          adapters = nil, ---@type table<string, string>
      
          -- disable all debugger related functionality
          disable = false, ---@type boolean
      
          -- custom debugger launcher function which receives the selected debug configuration as an
          -- argument; `nil` implies `require('dap').run` is used by default
          -- NOTE : users should ignore this unless they know what they are doing
          runner = nil, ---@type function
      
          -- table containing debug configuration template per filetype
          templates = nil,
        },
      
        -- task runner settings
        task = {
          -- whether to render the task output in a tabpage or a floating window, by default
          display = 'float', ---@type 'float' | 'tab'
      
          -- configuration options for floating window, see {config} in `:h nvim_open_win()`
          float_config = {
            relative = 'editor',
            border = 'rounded',
            title_pos = 'center',
            style = 'minimal',
          },
      
          -- custom user functions which will be executed before and/or after creating a floating
          -- window or a tabpage for a newly launched task
          hooks = {
            -- floating window hooks
            float = {
              pre = nil, ---@type function
              post = nil, ---@type function
            },
            -- tabpage hooks
            tab = {
              pre = nil, ---@type function
              post = nil, ---@type function
            },
          },
      
          -- whether to enter INSERT mode after launching task in a buffer
          insert_on_launch = false, ---@type boolean
      
          -- same fields as `TaskOptions` in "Task Configuration" subsection
          options = {
            -- set the default current working directory for all tasks
            cwd = nil, ---@type string|fun():string
      
            -- table with definitions of environment variables to be set for all tasks
            env = nil, ---@type table<string, string|number>
      
            -- table containing executable and command-line arguments to launch a shell process
            shell = nil, ---@type { exec: string, args: string[] }
          },
      
          -- custom task launcher function which receives the selected task configuration as an
          -- argument; `nil` implies `require('launch.task').runner` is used by default
          -- NOTE : users should ignore this unless they know what they are doing
          runner = nil, ---@type function
      
          -- config options for opening task in a terminal instance; see {opts} in `:h jobstart()`
          term = {
            clear_env = false,
          },
        },
      }
      
      
      -- config file
      return {
          task = {
              { --[[ TaskConfig1 ]] },
              { --[[ TaskConfig2 ]] },
          },
          debug = {
              { --[[ DebugConfig1 ]] },
              { --[[ DebugConfig2 ]] },
          },
          var = {
              InputVar1 = { --[[ InputVarConfig1 ]] },
              InputVar2 = { --[[ InputVarConfig2 ]] },
          },
      }
      
      
      local task_config = {
          name = '<config_name>',
          command = '<config_command>',
          args = { '<command_arg1>', '<command_arg2>' },
          display = 'float',
          options = {
              cwd = '<path_to_custom_cwd>', -- OR function() return <path_to_custom_cwd> end,
              env = {
                  STRING_VAR = 'hello_world',
                  NUMERIC_VAR = 42.42,
              },
              shell = {
                  exec = '<shell_executable>',
                  args = { '<shell_arg1>', '<shell_arg2>' },
              }
          },
      }
      
      return { task = { task_config } }
      
      
      local debug_config = {
          type = '<adapter_name>',
          -- OR
          -- filetype = '<target_ft>', -- filetype-adapter mapping can be specified in `setup()`
      
          request = 'launch',
          name = '<config_name>',
      
          -- Additional debugger-specific fields
          -- field1 = value1,
          -- field2 = value2,
      }
      
      return { debug = { debug_config } }
      
      
      return {
          task = {
              {
                  name = 'Test User Variables',
                  command = 'echo',
                  args = { '{@select_type}', '{@input_type}' },
              }
          },
          var = {
              select_type = {
                  type = 'select',
                  desc = 'selection type variable',
                  items = { '<item1>', '<item2>' }
              },
              input_type = {
                  type = 'input',
                  desc = 'input type variable',
                  default = '<default_value>',
              },
          }
      }
      
    end,
  },
  {
    "benlubas/molten-nvim",
    config = function()
      
      vim.keymap.set("n", "<localleader>mi", ":MoltenInit<CR>",
          { silent = true, desc = "Initialize the plugin" })
      vim.keymap.set("n", "<localleader>e", ":MoltenEvaluateOperator<CR>",
          { silent = true, desc = "run operator selection" })
      vim.keymap.set("n", "<localleader>rl", ":MoltenEvaluateLine<CR>",
          { silent = true, desc = "evaluate line" })
      vim.keymap.set("n", "<localleader>rr", ":MoltenReevaluateCell<CR>",
          { silent = true, desc = "re-evaluate cell" })
      vim.keymap.set("v", "<localleader>r", ":<C-u>MoltenEvaluateVisual<CR>gv",
          { silent = true, desc = "evaluate visual selection" })
      
      
      vim.keymap.set("n", "<localleader>rd", ":MoltenDelete<CR>",
          { silent = true, desc = "molten delete cell" })
      vim.keymap.set("n", "<localleader>oh", ":MoltenHideOutput<CR>",
          { silent = true, desc = "hide output" })
      vim.keymap.set("n", "<localleader>os", ":noautocmd MoltenEnterOutput<CR>",
          { silent = true, desc = "show/enter output" })
      
      
      require('molten.status').initialized() -- "Molten" or "" based on initialization information
      require('molten.status').kernels() -- "kernel1 kernel2" list of kernels attached to buffer or ""
      require('molten.status').all_kernels() -- same as kernels, but will show all kernels
      
      
      -- see :h nvim_set_hl for what to put in place of ...
      -- I would recommend using the `link` option to link the values to colors from your color scheme
      vim.api.nvim_set_hl(0, "MoltenOutputBorder", { ... })
      
      
      vim.api.nvim_create_autocmd("User", {
        pattern = "MoltenInitPost",
        callback = function()
          vim.keymap.set("v", "<localleader>r", ":<C-u>MoltenEvaluateVisual<CR>gv",
            { desc = "execute visual selection", buffer = true, silent = true })
          -- ... more mappings
        end,
      })
      
      
      -- ...
        callback = function(e)
          print("Kernel id: " .. e.data.kernel_id)
        end
      -- ...
      
      
      -- run lines 1 through 23 (inclusive):
      vim.fn.MoltenEvaluateRange(1, 23)
      
      -- run code starting with col 4 on line 1, and ending with the last col on line 3
      vim.fn.MoltenEvaluateRange(1, 3, 4, -1)
      
      
      -- run lines 1 through 23 (inclusive) with the python3 kernel
      vim.fn.MoltenEvaluateRange("python3", 1, 23)
      
      -- run code starting with col 4 on line 1, and ending with col 20 on line 3 with the R kernel
      vim.fn.MoltenEvaluateRange("ir", 1, 3, 4, 20)
      
      
      -- these are the same!
      vim.fn.MoltenUpdateOption("auto_open_output", true)
      vim.fn.MoltenUpdateOption("molten_auto_open_output", true)
      
      
      vim.fn.MoltenRunningKernels(true) -- list buf local kernel ids
      vim.fn.MoltenRunningKernels(false) -- list all kernel ids
      
      
      vim.fn.MoltenAvailableKernels()
      
      
      -- Creates a cell from line 5 to line 10 associated with the python3 kernel
      vim.fn.MoltenDefineCell(5, 10, 'python3')
      
    end,
  },
  {
    "bfredl/nvim-ipy",
  },
  {
    "pianocomposer321/officer.nvim",
    config = function()
      
      {
        "pianocomposer321/officer.nvim",
        dependencies = "stevearc/overseer.nvim",
        config = function()
          require("officer").setup {
            -- config
          }
        end,
      },
      
      
      require("officer").setup {
        create_mappings = true,
        components = { "user.track_history" },
      }
      
      
      vim.keymap.set("n", "<LEADER><CR>", require("user.overseer_util").restart_last_task)
      
      
      local util = require("user.overseer_util")
      
      return {
        desc = "Track files in a history so that the most recent can be restarted",
        constructor = function()
          return {
            on_start = function(_, task)
              util.register_task(task)
            end,
            on_dispose = function(_, task)
              util.unregister_task(task.id)
            end,
          }
        end,
      }
      
      
      local M = {}
      
      local task_history = {}
      local tasks = {}
      
      function M.register_task(task)
        tasks[task.id] = task
        table.insert(task_history, task.id)
      end
      
      function M.get_last_task()
        return tasks[task_history[#task_history]]
      end
      
      function M.restart_last_task()
        local task = M.get_last_task()
        if task then
          require("overseer").run_action(task, "restart")
        end
      end
      
      function M.unregister_task(task_id)
        tasks[task_id] = nil
        if task_history[#task_history] == task_id then
          task_history[#task_history] = nil
        end
      end
      
      return M
      
    end,
  },
  {
    "speelbarrow/spLauncher.nvim",
  },
  {
    "al1-ce/just.nvim",
    config = function()
      
      {
          "al1-ce/just.nvim",
          dependencies = {
              'nvim-lua/plenary.nvim', -- async jobs
              'nvim-telescope/telescope.nvim', -- task picker (optional)
              'rcarriga/nvim-notify', -- general notifications (optional)
              'j-hui/fidget.nvim', -- task progress (optional)
              'al1-ce/jsfunc.nvim', -- extension library
          },
          config = true
      }
      
      
      require("just").setup({
          fidget_message_limit = 32, -- limit for length of fidget progress message 
          play_sound = false, -- plays sound when task is finished or failed
          open_qf_on_error = true, -- opens quickfix when task fails
          open_qf_on_run = true, -- opens quickfix when running `run` task (`:JustRun`)
          open_qf_on_any = false; -- opens quickfix when running any task (overrides other open_qf options)
          telescope_borders = { -- borders for telescope window
              prompt = { "─", "│", " ", "│", "┌", "┐", "│", "│" }, 
              results = { "─", "│", "─", "│", "├", "┤", "┘", "└" },
              preview = { "─", "│", "─", "│", "┌", "┐", "┘", "└" }
          }
      })
      
    end,
  },
  {
    "niuiic/task.nvim",
    config = function()
      
      local split_win = require("task.output").use_split_win()
      
      ---@class task.Config
      ---@field cmd string
      ---@field args string[]
      ---@field options {env?: table<string, any>, cwd?: string, uid?: number, gid?: number, verbatim?: boolean, detached?: boolean, hide?: boolean} | nil
      
      ---@class task.Task
      ---@field name string
      ---@field is_enabled (fun(): boolean) | nil
      ---@field config fun(): task.Config
      ---@field on_err fun(output: string, write: fun(str), task_name: string) | fun(output: string, write: fun(str), task_name: string)[] | nil
      ---@field on_output fun(output: string, write: fun(str), task_name: string) | fun(output: string, write: fun(str), task_name: string)[] | nil
      ---@field on_exit fun(output: string, task_name: string) | fun(output: string, task_name: string)[] | nil
      
      ---@param task task.Task
      require("task").register({
      	name = "restart conatiner",
      	config = function()
      		return {
      			cmd = "sudo",
      			args = { "-S", "podman", "restart", "openresty" },
      		}
      	end,
      	on_err = function(output, write)
      		if string.match(output, "%[sudo%] password for.*") then
      			-- write to stdin
      			write("password\n")
      		end
      	end,
      	on_exit = {
      		require("task.output").notify_done,
      		split_win,
      	},
      })
      
      
      ---@param task_name string | nil
      require("task").launch()
      
      
      ---@param task_name string | nil
      ---@param output_method fun(output: string, task_name: string) | nil
      require("task").preview()
      
    end,
  },
  {
    "chrisgrieser/nvim-justice",
    config = function()
      
      -- lazy.nvim
      return { 
      	"chrisgrieser/nvim-justice"
      	-- optional, for streaming output and nicer parameter input
      	-- dependencies = "folke/snacks.nvim",
      }
      
      
      -- default settings
      require("justice").setup {
      	-- Defines how recipe modes are determined. For example, if a recipe has
      	-- "download" in the name, or if it has "streaming" or "curl" in the comment,
      	-- it will be considered a "streaming" recipe.
      	-- (strings are interpreted as lua patterns, thus `-` needs to be escaped as `%-`)
      	recipeModes = {
      		streaming = { -- useful for progress bars (requires `snacks.nvim`)
      			name = { "download" },
      			comment = { "streaming", "curl" }, -- comment contains "streaming" or "curl"
      		},
      		terminal = { -- useful for recipes with input
      			name = {},
      			comment = { "input", "terminal", "fzf" },
      		},
      		quickfix = {
      			name = { "%-qf$" }, -- name ending with "-qf"
      			comment = { "quickfix" },
      		},
      		ignore = { -- hides them from the nvim-justice selection window
      			name = {},
      			comment = {},
      		},
      	},
      	window = {
      		border = getBorder(), -- `vim.o.winborder` on nvim 0.11, otherwise "rounded"
      		recipeCommentMaxLen = 35,
      		keymaps = {
      			next = "<Tab>",
      			prev = "<S-Tab>",
      			runRecipeUnderCursor = "<CR>",
      			runFirstRecipe = "1",
      			closeWin = { "q", "<Esc>" },
      			showRecipe = "<Space>",
      			showVariables = "?",
      			dontUseForQuickKey = { "j", "k", "-", "_" },
      		},
      		highlightGroups = {
      			quickKey = "Keyword",
      			icons = "Function",
      		},
      		icons = {
      			just = "󰖷",
      			streaming = "ﲋ",
      			quickfix = "",
      			terminal = "",
      			ignore = "󰈉",
      			recipeParameters = "󰘎",
      		},
      	},
      	terminal = {
      		height = 10,
      	},
      }
      
      
      require("justice").select()
      
      
      require("justice").select({
      	justfile = "path/to/custom/justfile", -- passed to `--justfile=`
      })
      
    end,
  },
  {
    "pewpewnor/pilot.nvim",
    config = function()
      
      return {
          "pewpewnor/pilot.nvim",
          opts = {},
      }
      --or
      return {
          "pewpewnor/pilot.nvim",
          config = function()
              require("pilot").setup()
          end,
      }
      
      
      use {
          "pewpewnor/pilot.nvim",
          config = function()
              require("pilot").setup()
          end
      }
      
      
      {
          project_run_config_path = nil, -- string | nil -> by default equivalent to "{{pilot_data_path}}/projects/{{hash(cwd_path)}}.json"
          file_type_run_config_path = nil, -- string | nil -> by default equivalent to "{{pilot_data_path}}/filetypes/{{file_type}}.json"
          -- if there is only one command listed, should we immediately run the command?
          automatically_run_single_command = {
              project = true, -- boolean
              file_type = true, -- boolean
          },
          fallback_project_run_config = nil, -- (function that returns a string) | nil
          default_executor = nil, -- (function that accepts a string) | nil -> by default equivalent to pilot.nvim_new_tab_executor
          custom_locations = nil, -- (key/value table with the values being strings) | nil
      }
      
      
      local pilot = require("pilot")
      pilot.setup({
          -- grab the pilot configuration from the current working directory instead
          -- of automatically generating one
          project_run_config_path = "{{cwd_path}}/pilot.json",
          -- will be used instead if there is no project run configuration file
          -- at the path specified in the 'project_run_config_path' option
          fallback_project_run_config = function()
              -- you can customize this logic
              -- e.g. if the project has 'package-lock.json', then use our
              -- 'npm_project.json' as the project run configuration
              if vim.fn.filereadable(vim.fn.getcwd() .. "/package-lock.json") == 1 then
                  return  "{{pilot_data_path}}/npm_project.json"
              -- e.g. if the project has CMakeLists.txt, then we will use our
              -- 'cmake_project.json' as our project run configuration
              elseif vim.fn.filereadable(vim.fn.getcwd() .. "/CMakeLists.txt") == 1 then
                  return "/home/user/templates/cmake_project.json"
              end
          end,
          -- if location is not specified in JSON, then execute it on a new horizontal buffer
          default_executor = pilot.nvim_split_executor,
          -- define custom locations that can be used in any pilot run configuration
          custom_locations = {
              -- custom location that executes the command in a new tmux window
              tmux_new_window = function(command)
                  vim.fn.system("tmux new-window -d")
                  vim.fn.system("tmux send-keys -t +. '" .. command .. "' Enter")
              end,
          },
      })
      
      -- customize these keybindings to your liking
      vim.keymap.set("n", "<F10>", pilot.run_project)
      vim.keymap.set("n", "<F12>", pilot.run_file_type)
      vim.keymap.set("n", "<F11>", pilot.run_previous_task)
      vim.keymap.set("n", "<Leader><F10>", pilot.edit_project_run_config)
      vim.keymap.set("n", "<Leader><F12>", pilot.edit_file_type_run_config)
      
      -- example of creating vim user commands for pilot functions
      vim.api.nvim_create_user_command("PilotDeleteProjectRunConfig",
          pilot.delete_project_run_config, { nargs = 0, bar = false })
      vim.api.nvim_create_user_command("PilotDeleteFileTypeRunConfig",
          pilot.delete_file_type_run_config, { nargs = 0, bar = false })
      
      
      {
          default_executor = function(command)
              vim.fn.system(command)
          end
      }
      
    end,
  },
  {
    "folke/lazydev.nvim",
    config = function()
      
      return {
        {
          "folke/lazydev.nvim",
          ft = "lua", -- only load on lua files
          opts = {
            library = {
              -- See the configuration section for more details
              -- Load luvit types when the `vim.uv` word is found
              { path = "${3rd}/luv/library", words = { "vim%.uv" } },
            },
          },
        },
        { -- optional cmp completion source for require statements and module annotations
          "hrsh7th/nvim-cmp",
          opts = function(_, opts)
            opts.sources = opts.sources or {}
            table.insert(opts.sources, {
              name = "lazydev",
              group_index = 0, -- set group index to 0 to skip loading LuaLS completions
            })
          end,
        },
        { -- optional blink completion source for require statements and module annotations
          "saghen/blink.cmp",
          opts = {
            sources = {
              -- add lazydev to your completion providers
              default = { "lazydev", "lsp", "path", "snippets", "buffer" },
              providers = {
                lazydev = {
                  name = "LazyDev",
                  module = "lazydev.integrations.blink",
                  -- make lazydev completions top priority (see `:h blink.cmp`)
                  score_offset = 100,
                },
              },
            },
          },
        }
        -- { "folke/neodev.nvim", enabled = false }, -- make sure to uninstall or disable neodev.nvim
      }
      
      
      
      {
        "folke/lazydev.nvim",
        ft = "lua", -- only load on lua files
        opts = {
          library = {
            -- Library paths can be absolute
            "~/projects/my-awesome-lib",
            -- Or relative, which means they will be resolved from the plugin dir.
            "lazy.nvim",
            -- It can also be a table with trigger words / mods
            -- Only load luvit types when the `vim.uv` word is found
            { path = "${3rd}/luv/library", words = { "vim%.uv" } },
            -- always load the LazyVim library
            "LazyVim",
            -- Only load the lazyvim library when the `LazyVim` global is found
            { path = "LazyVim", words = { "LazyVim" } },
            -- Load the wezterm types when the `wezterm` module is required
            -- Needs `DrKJeff16/wezterm-types` to be installed
            { path = "wezterm-types", mods = { "wezterm" } },
            -- Load the xmake types when opening file named `xmake.lua`
            -- Needs `LelouchHe/xmake-luals-addon` to be installed
            { path = "xmake-luals-addon/library", files = { "xmake.lua" } },
          },
          -- always enable unless `vim.g.lazydev_enabled = false`
          -- This is the default
          enabled = function(root_dir)
            return vim.g.lazydev_enabled == nil and true or vim.g.lazydev_enabled
          end,
          -- disable when a .luarc.json file is found
          enabled = function(root_dir)
            return not vim.uv.fs_stat(root_dir .. "/.luarc.json")
          end,
        },
      },
      
      
      ---@alias lazydev.Library {path:string, words:string[], mods:string[]}
      ---@alias lazydev.Library.spec string|{path:string, words?:string[], mods?:string[]}
      ---@class lazydev.Config
      local defaults = {
        runtime = vim.env.VIMRUNTIME --[[@as string]],
        library = {}, ---@type lazydev.Library.spec[]
        integrations = {
          -- Fixes lspconfig's workspace management for LuaLS
          -- Only create a new workspace if the buffer is not part
          -- of an existing workspace or one of its libraries
          lspconfig = true,
          -- add the cmp source for completion of:
          -- `require "modname"`
          -- `---@module "modname"`
          cmp = true,
          -- same, but for Coq
          coq = false,
        },
        ---@type boolean|(fun(root:string):boolean?)
        enabled = function(root_dir)
            return vim.g.lazydev_enabled == nil and true or vim.g.lazydev_enabled
        end,
      }
      
    end,
  },
  {
    "nvim-neorocks/luarocks-tag-release",
  },
  {
    "svermeulen/vimpeccable",
    config = function()
      
      vim.cmd 'packadd paq-nvim'
      
      require 'paq' {
        {'savq/paq-nvim', opt = true};
        'morhetz/gruvbox';
        'svermeulen/vimpeccable'
      }
      
      vim.o.ignorecase = true
      vim.o.smartcase = true
      vim.o.incsearch = true
      
      vim.o.hidden = true
      
      vim.o.history = 5000
      
      vim.o.tabstop = 4
      vim.o.shiftwidth = vim.o.tabstop
      vim.g.mapleader = " "
      
      vim.cmd('colorscheme gruvbox')
      
      -- Note that we are using 'vimp' (not 'vim') below to add the maps
      -- vimp is shorthand for vimpeccable
      local vimp = require('vimp')
      
      vimp.nnoremap('<leader>hw', function()
        print('hello')
        print('world')
      end)
      
      -- Toggle line numbers
      vimp.nnoremap('<leader>n', function()
        vim.wo.number = not vim.wo.number
      end)
      
      -- Keep the cursor in place while joining lines
      vimp.nnoremap('J', 'mzJ`z')
      
      vimp.nnoremap('<leader>ev', ':vsplit ~/.config/nvim/init.lua<cr>')
      -- Or:
      -- vimp.nnoremap('<leader>ev', [[:vsplit ~/.config/nvim/init.lua<cr>]])
      -- Or:
      -- vimp.nnoremap('<leader>ev', function()
      --   vim.cmd('vsplit ~/.config/nvim/init.lua')
      -- end)
      
      vim.cmd('colorscheme gruvbox')
      
      
      -- Note that in lua we can represent strings either with quotes or with double square brackets
      vimp.nnoremap('<leader>hw', [[:echo 'hello world'<cr>]])
      
      vimp.nmap('<leader>c', '<plug>Commentary')
      vimp.xmap('<leader>c', '<plug>Commentary')
      
      -- Also note that we need to pass the options as a list instead of as seperate parameters
      -- Also note that unlike vimscript, the options are not surrounded with angle brackets
      vimp.nnoremap({'expr', 'silent'}, '<leader>1', [[:call g:DoCustomThing()<cr>]])
      
      -- Or, alternatively, implement DoCustomThing in lua instead:
      vimp.nnoremap({'expr', 'silent'}, '<leader>1', function()
          -- Add logic here
      end)
      
      
      vimp.bind('n', '<leader>hw', [[:echo 'hello world'<cr>]])
      
      -- plugs need to use rbind
      vimp.rbind('nx', '<leader>c', '<plug>Commentary')
      
      
      vimp.rbind('nx', {'<leader>c', 'gc'}, '<plug>Commentary')
      
      
      -- r = reload vimrc
      vimp.nnoremap('<leader>r', function()
        -- Remove all previously added vimpeccable maps
        vimp.unmap_all()
        -- Unload the lua namespace so that the next time require('config.X') is called
        -- it will reload the file
        require("config.util").unload_lua_namespace('config')
        -- Make sure all open buffers are saved
        vim.cmd('silent wa')
        -- Execute our vimrc lua file again to add back our maps
        dofile(vim.fn.stdpath('config') .. '/init.lua')
      
        print("Reloaded vimrc!")
      end)
      
      
      local M = {}
      
      M['unload_lua_namespace'] = function(prefix)
        local prefix_with_dot = prefix .. '.'
        for key, value in pairs(package.loaded) do
          if key == prefix or key:sub(1, #prefix_with_dot) == prefix_with_dot then
            package.loaded[key] = nil
          end
        end
      end
      
      return M
      
      
      vimp.bind('[e', ':move--<cr>')
      vimp.bind(']e', ':move+<cr>')
      
      
      vimp.bind({'repeatable'}, '[e', ':move--<cr>')
      vimp.bind({'repeatable'}, ']e', ':move+<cr>')
      
      
      vimp.bind('<leader>hw', function() print('hi!') end)
      
      
      vimp.bind({'override'}, '<leader>hw', function() print('hi!') end)
      
      
      vimp.bind('<leader>h', function() print('hi!') end)
      
      
      vimp.bind('<leader>ddb', function() print("Executed map!") end)
      
      
      vimp.add_chord_cancellations('n', '<leader>')
      
      
      vimp.nnoremap({'buffer'}, '<leader>t1', [[:echo 'buffer local map!'<cr>]])
      vimp.nnoremap({'buffer'}, '<leader>t2', [[:echo 'another buffer local map!'<cr>]])
      
      
      vimp.add_buffer_maps(function()
        vimp.nnoremap('<leader>t1', function() print('lua map!') end)
        vimp.nnoremap('<leader>t2', function() print('lua map two!') end)
      end)
      
      
      vimp.add_buffer_maps(bufferId, function()
        vimp.nnoremap('<leader>t1', function() print('lua map!') end)
        vimp.nnoremap('<leader>t2', function() print('lua map two!') end)
      end)
      
      
      vimp.map_command('SvOpenFileOnGithub', function()
        print("Todo - Open the URL on github for current file on current line")
      end)
      
      vimp.map_command('SvRename', function(newName)
        print("Todo - rename current file to " .. newName)
      end)
      
      
      vimp.map_command({ complete = 'lua' }, 'Lua', function(lua_expr)
        print(vim.inspect(lua_expr))
      end)
      
      
      -- Arguments: mode (optional)
      vimp.map_command("ShowAllMaps", function(...) 
        -- Use empty string as prefix to select all
        vimp.show_maps('', ...)
      end)
      
      -- Arguments: prefix (required), mode (optional)
      vimp.map_command("ShowMaps", function(...) 
        vimp.show_maps(...)
      end)
      
    end,
  },
  {
    "rafcamlet/nvim-luapad",
    config = function()
      
      require('luapad').init() -- same as Luapad command
      
      -- Creates a new luapad instance and attaches it to the current buffer.
      -- Optionally, you can pass a context table to it, the elements of which will be
      -- available during the evaluation as "global" variables.
      require('luapad').attach({
        context = { return_4 =  function() return 4 end }
      })
      
      -- Detaches current luapad instance from buffer, which just means turning it off. :)
      require('luapad').detach()
      
      -- Toggles luapad in current buffer.
      require('luapad').toggle({
        context = { return_4 =  function() return 4 end }
      })
      
      -- You can also create new luapad instance by yourself, which can be helpfull if you
      -- want to attach it to a buffer different than the current one.
      local buffer_handler = 5
      require('luapad.evaluator'):new {
        buf = buffer_handler,
        context = { a = 'asdf' }
      }:start()
      
      -- luapad/run offers a run function (same as the LuaRun command) but allows you
      -- to specify a context tbl
      require 'luapad.run'.run {
        context = {
          print = function(str) print(string.upper(str)) end
        }
      }
      
      -- If you turn off evaluation on change (and move) you can trigger it manualy by:
      local luapad = require('luapad.evaluator'):new{buf = vim.api.nvim_get_current_buf()}
      luapad:start()
      luapad:eval()
      
      -- You can always access current luapad instance by:
      local luapad = require 'luapad.state'.current()
      luapad:eval()
      
      -- ...or iterate through all instances
      for _, v in ipairs(require('luapad.state').instances) do
        v:eval()
      end
      
      
      require('luapad').setup {
        count_limit = 150000,
        error_indicator = false,
        eval_on_move = true,
        error_highlight = 'WarningMsg',
        split_orientation = 'horizontal',
        on_init = function()
          print 'Hello from Luapad!'
        end,
        context = {
          the_answer = 42,
          shout = function(str) return(string.upper(str) .. '!') end
        }
      }
      
    end,
  },
  {
    "nvim-lua/plenary.nvim",
    config = function()
      
      local async = require "plenary.async"
      
      
      local uv = vim.loop
      
      local read_file = function(path, callback)
        uv.fs_open(path, "r", 438, function(err, fd)
          assert(not err, err)
          uv.fs_fstat(fd, function(err, stat)
            assert(not err, err)
            uv.fs_read(fd, stat.size, 0, function(err, data)
              assert(not err, err)
              uv.fs_close(fd, function(err)
                assert(not err, err)
                callback(data)
              end)
            end)
          end)
        end)
      end
      
      
      local a = require "plenary.async"
      
      local read_file = function(path)
        local err, fd = a.uv.fs_open(path, "r", 438)
        assert(not err, err)
      
        local err, stat = a.uv.fs_fstat(fd)
        assert(not err, err)
      
        local err, data = a.uv.fs_read(fd, stat.size, 0)
        assert(not err, err)
      
        local err = a.uv.fs_close(fd)
        assert(not err, err)
      
        return data
      end
      
      
      local a = require'plenary.async'
      local tx, rx = a.control.channel.oneshot()
      
      a.run(function()
          local ret = long_running_fn()
          tx(ret)
      end)
      
      local ret = rx()
      
      
      local a = require'plenary.async'
      local sender, receiver = a.control.channel.mpsc()
      
      a.run(function()
        sender.send(10)
        sender.send(20)
      end)
      
      a.run(function()
        sender.send(30)
        sender.send(40)
      end)
      
      for _ = 1, 4 do
        local value = receiver.recv()
        print('received:', value)
      end
      
      
      local Job = require'plenary.job'
      
      Job:new({
        command = 'rg',
        args = { '--files' },
        cwd = '/usr/bin',
        env = { ['a'] = 'b' },
        on_exit = function(j, return_val)
          print(return_val)
          print(j:result())
        end,
      }):sync() -- or start()
      
      
      local scan = require'plenary.scandir'
      scan.scan_dir('.', { hidden = true, depth = 2 })
      
      
      local with = context_manager.with
      local open = context_manager.open
      
      local result = with(open("README.md"), function(reader)
        return reader:read()
      end)
      
      assert(result == "# plenary.nvim")
      
      
      return {
        extension = {
          -- extension = filetype
          -- example:
          ['jl'] = 'julia',
        },
        file_name = {
          -- special filenames, likes .bashrc
          -- we provide a decent amount
          -- name = filetype
          -- example:
          ['.bashrc'] = 'bash',
        },
        shebang = {
          -- Shebangs are supported as well. Currently we provide
          -- sh, bash, zsh, python, perl with different prefixes like
          -- /usr/bin, /bin/, /usr/bin/env, /bin/env
          -- shebang = filetype
          -- example:
          ['/usr/bin/node'] = 'javascript',
        }
      }
      
      
      require'plenary.profile'.start("profile.log")
      
      -- code to be profiled
      
      require'plenary.profile'.stop()
      
      
      local List = require 'plenary.collections.py_list'
      
      local myList = List { 9, 14, 32, 5 }
      
      for i, v in myList:iter() do
          print(i, v)
      end
      
      
    end,
  },
  {
    "nvim-lua/popup.nvim",
  },
  {
    "tjdevries/vlog.nvim",
    config = function()
      
      -- Provides both `print` style and `string.format` style logging
      log.info("I can pass", my_arg, "like I can for `print`")
      log.fmt_info("I can pass %s arguments like `string.format`", my_arg)
      
      -- Provides 
      log.trace(...)
      log.debug(...)
      log.info(...)
      log.warn(...)
      log.error(...)
      log.fatal(...)
      
      -- and the corresponding
      log.fmt_trace(...)
      log.fmt_debug(...)
      log.fmt_info(...)
      log.fmt_warn(...)
      log.fmt_error(...)
      log.fmt_fatal(...)
      
      
      local default_config = {
        -- Name of the plugin. Prepended to log messages
        plugin = 'vlog.nvim',
      
        -- Should print the output to neovim while running
        use_console = true,
      
        -- Should highlighting be used in console (using echohl)
        highlights = true,
      
        -- Should write to a file
        use_file = true,
      
        -- Any messages above this level will be logged.
        level = "trace",
      
        -- Level configuration
        modes = {
          { name = "trace", hl = "Comment", },
          { name = "debug", hl = "Comment", },
          { name = "info",  hl = "None", },
          { name = "warn",  hl = "WarningMsg", },
          { name = "error", hl = "ErrorMsg", },
          { name = "fatal", hl = "ErrorMsg", },
        },
      
        -- Can limit the number of decimals displayed for floats
        float_precision = 0.01,
      }
      
      
      local log = require('my_cool_plugin.log')
      
      log.info("Doing some logging")
      
      
      -- In my_plugin/log.lua
      return require('vlog').new {
          plugin = 'my_cool_plugin',
      }
      
      -- In my_plug/other_file.lua
      local log = require('my_plugin.log')
      
      log.info("Doing some logging stuff")
      
    end,
  },
  {
    "bfredl/nvim-luadev",
  },
  {
    "jbyuki/one-small-step-for-vimkind",
    config = function()
      
        {
          "mfussenegger/nvim-dap",
          dependencies = {
            "jbyuki/one-small-step-for-vimkind",
          },
          lazy = false,
          config = function()
            -- Put the suggested configuration here
          end,
        }
        
      
      local dap = require"dap"
      dap.configurations.lua = { 
        { 
          type = 'nlua', 
          request = 'attach',
          name = "Attach to running Neovim instance",
        }
      }
      
      dap.adapters.nlua = function(callback, config)
        callback({ type = 'server', host = config.host or "127.0.0.1", port = config.port or 8086 })
      end
      
      
      vim.keymap.set('n', '<leader>db', require"dap".toggle_breakpoint, { noremap = true })
      vim.keymap.set('n', '<leader>dc', require"dap".continue, { noremap = true })
      vim.keymap.set('n', '<leader>do', require"dap".step_over, { noremap = true })
      vim.keymap.set('n', '<leader>di', require"dap".step_into, { noremap = true })
      
      vim.keymap.set('n', '<leader>dl', function() 
        require"osv".launch({port = 8086}) 
      end, { noremap = true })
      
      vim.keymap.set('n', '<leader>dw', function()
        local widgets = require"dap.ui.widgets"
        widgets.hover()
      end)
      
      vim.keymap.set('n', '<leader>df', function()
        local widgets = require"dap.ui.widgets"
        widgets.centered_float(widgets.frames)
      end)
      
    end,
  },
  {
    "kkharji/sqlite.lua",
    config = function()
      
      use { "kkharji/sqlite.lua" }
      
    end,
  },
  {
    "MunifTanjim/nui.nvim",
    config = function()
      
      local Popup = require("nui.popup")
      local Layout = require("nui.layout")
      
      local popup_one, popup_two = Popup({
        enter = true,
        border = "single",
      }), Popup({
        border = "double",
      })
      
      local layout = Layout(
        {
          position = "50%",
          size = {
            width = 80,
            height = "60%",
          },
        },
        Layout.Box({
          Layout.Box(popup_one, { size = "40%" }),
          Layout.Box(popup_two, { size = "60%" }),
        }, { dir = "row" })
      )
      
      local current_dir = "row"
      
      popup_one:map("n", "r", function()
        if current_dir == "col" then
          layout:update(Layout.Box({
            Layout.Box(popup_one, { size = "40%" }),
            Layout.Box(popup_two, { size = "60%" }),
          }, { dir = "row" }))
      
          current_dir = "row"
        else
          layout:update(Layout.Box({
            Layout.Box(popup_two, { size = "60%" }),
            Layout.Box(popup_one, { size = "40%" }),
          }, { dir = "col" }))
      
          current_dir = "col"
        end
      end, {})
      
      layout:mount()
      
      
      local Popup = require("nui.popup")
      local event = require("nui.utils.autocmd").event
      
      local popup = Popup({
        enter = true,
        focusable = true,
        border = {
          style = "rounded",
        },
        position = "50%",
        size = {
          width = "80%",
          height = "60%",
        },
      })
      
      -- mount/open the component
      popup:mount()
      
      -- unmount component when cursor leaves buffer
      popup:on(event.BufLeave, function()
        popup:unmount()
      end)
      
      -- set content
      vim.api.nvim_buf_set_lines(popup.bufnr, 0, 1, false, { "Hello World" })
      
      
      local Input = require("nui.input")
      local event = require("nui.utils.autocmd").event
      
      local input = Input({
        position = "50%",
        size = {
          width = 20,
        },
        border = {
          style = "single",
          text = {
            top = "[Howdy?]",
            top_align = "center",
          },
        },
        win_options = {
          winhighlight = "Normal:Normal,FloatBorder:Normal",
        },
      }, {
        prompt = "> ",
        default_value = "Hello",
        on_close = function()
          print("Input Closed!")
        end,
        on_submit = function(value)
          print("Input Submitted: " .. value)
        end,
      })
      
      -- mount/open the component
      input:mount()
      
      -- unmount component when cursor leaves buffer
      input:on(event.BufLeave, function()
        input:unmount()
      end)
      
      
      local Menu = require("nui.menu")
      local event = require("nui.utils.autocmd").event
      
      local menu = Menu({
        position = "50%",
        size = {
          width = 25,
          height = 5,
        },
        border = {
          style = "single",
          text = {
            top = "[Choose-an-Element]",
            top_align = "center",
          },
        },
        win_options = {
          winhighlight = "Normal:Normal,FloatBorder:Normal",
        },
      }, {
        lines = {
          Menu.item("Hydrogen (H)"),
          Menu.item("Carbon (C)"),
          Menu.item("Nitrogen (N)"),
          Menu.separator("Noble-Gases", {
            char = "-",
            text_align = "right",
          }),
          Menu.item("Helium (He)"),
          Menu.item("Neon (Ne)"),
          Menu.item("Argon (Ar)"),
        },
        max_width = 20,
        keymap = {
          focus_next = { "j", "<Down>", "<Tab>" },
          focus_prev = { "k", "<Up>", "<S-Tab>" },
          close = { "<Esc>", "<C-c>" },
          submit = { "<CR>", "<Space>" },
        },
        on_close = function()
          print("Menu Closed!")
        end,
        on_submit = function(item)
          print("Menu Submitted: ", item.text)
        end,
      })
      
      -- mount the component
      menu:mount()
      
      
      local Split = require("nui.split")
      local event = require("nui.utils.autocmd").event
      
      local split = Split({
        relative = "editor",
        position = "bottom",
        size = "20%",
      })
      
      -- mount/open the component
      split:mount()
      
      -- unmount component when cursor leaves buffer
      split:on(event.BufLeave, function()
        split:unmount()
      end)
      
      
      local Timer = Popup:extend("Timer")
      
      function Timer:init(popup_options)
        local options = vim.tbl_deep_extend("force", popup_options or {}, {
          border = "double",
          focusable = false,
          position = { row = 0, col = "100%" },
          size = { width = 10, height = 1 },
          win_options = {
            winhighlight = "Normal:Normal,FloatBorder:SpecialChar",
          },
        })
      
        Timer.super.init(self, options)
      end
      
      function Timer:countdown(time, step, format)
        local function draw_content(text)
          local gap_width = 10 - vim.api.nvim_strwidth(text)
          vim.api.nvim_buf_set_lines(self.bufnr, 0, -1, false, {
            string.format(
              "%s%s%s",
              string.rep(" ", math.floor(gap_width / 2)),
              text,
              string.rep(" ", math.ceil(gap_width / 2))
            ),
          })
        end
      
        self:mount()
      
        local remaining_time = time
      
        draw_content(format(remaining_time))
      
        vim.fn.timer_start(step, function()
          remaining_time = remaining_time - step
      
          draw_content(format(remaining_time))
      
          if remaining_time <= 0 then
            self:unmount()
          end
        end, { ["repeat"] = math.ceil(remaining_time / step) })
      end
      
      local timer = Timer()
      
      timer:countdown(10000, 1000, function(time)
        return tostring(time / 1000) .. "s"
      end)
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-doc.md",
  },
  {
    "milisims/nvim-luaref",
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-test.md",
  },
  {
    "ray-x/guihua.lua",
    config = function()
      
       use {'ray-x/guihua.lua', run = 'cd lua/fzy && make'}
      
      
        -- default mapping
        maps = {
          close_view = '<C-e>',
          send_qf = '<C-q>',
          save = '<C-s>',
          jump_to_list = '<C-w>k',
          jump_to_preview = '<C-w>j',
          prev = '<C-p>',
          next = '<C-n>',
          pageup = '<C-b>',
          pagedown = '<C-f>',
          confirm = '<C-o>',
          split = '<C-s>',
          vsplit = '<C-v>',
          tabnew = '<C-t>',
        }
      
        -- default icons for panel
        -- will be tbl_deep_extend() if you override any of those
        local icons = {
          panel_icons = {
            section_separator = '─', --'',
            line_num_left = ':', --'',
            line_num_right = '', --',
      
            range_left = '', --'',
            range_right = '',
            inner_node = '', --├○',
            folded = '◉',
            unfolded = '○',
      
            outer_node = '', -- '╰○',
            bracket_left = '', -- ⟪',
            bracket_right = '', -- '⟫',
          },
          syntax_icons = {
            var = ' ', -- "👹", -- Vampaire
              method = 'ƒ ', --  "🍔", -- mac
              ['function'] = ' ', -- "🤣", -- Fun
              ['arrow_function'] = ' ', -- "🤣", -- Fun
                parameter = '', -- Pi
                  associated = '🤝',
            namespace = '🚀',
            type = ' ',
            field = '🏈',
            interface = '',
            module = '📦',
            flag = '🎏',
          }
        }
      
        --
        require('guihua.maps').setup({
        maps = {
          close_view = '<C-x>',
        }
        })
      
    end,
  },
  {
    "anuvyklack/animation.nvim",
    config = function()
      
      use { 'anuvyklack/animation.nvim', 
         requires = 'anuvyklack/middleclass'
      }
      
      
      local Animation = require('animation')
      local duration = 300 -- ms
      local fps = 30 -- frames per second
      local easing = require('animation.easing')
      
      local i = 0
      
      local function callback(fraction)
         i = i + 1
         print('frame ', i)
      end
      
      local animation = Animation(duration, fps, easing.line, callback)
      animation:run()
      
    end,
  },
  {
    "nfrid/treesitter-utils",
  },
  {
    "svermeulen/nvim-lusc",
    config = function()
      
      use { 'svermeulen/nvim-lusc' }
      
      
      require('nvim-lusc').setup()
      
      
      local lusc = require'lusc'
      
      -- <space>t to run this test
      vim.keymap.set('n', '<space>t', function()
        lusc.schedule(function()
          for i=5,1,-1 do
            vim.cmd("echom " .. tostring(i))
            lusc.await_sleep(1)
          end
        end)
      end)
      
      
      require('nvim-lusc').setup {
        wait_for_cancel_on_quit = true,
        on_completed = function(err)
          if err ~= nil then
            vim.notify("Lusc completed with errors. Details: " .. tostring(err))
          end
        end,
        enable_logging = false,
        log_handler = function(msg) vim.cmd("echom " .. msg) end,
        generate_debug_names = false, -- Adds extra debugging info when logging is enabled
      }
      
      
      -- <space>t to run this test
      vim.keymap.set('n', '<space>t', function()
        lusc.schedule(function()
          lusc.cancel_scope(function()
            for i=5,1,-1 do
              vim.cmd("echom " .. tostring(i))
              lusc.await_sleep(1)
            end
          end, { shielded = true })
        end)
      end)
      
    end,
  },
  {
    "gregorias/coop.nvim",
    config = function()
      
      {
        "gregorias/coop.nvim",
      }
      
      
      local coop = require("coop")
      local uv = require("coop.uv")
      
      --- Reads a file.
      ---
      ---@async
      ---@param path string
      ---@return string
      function readFileAsync(path)
        local err_open, fd = uv.fs_open(path, "r", 438)
        assert(err_open == nil)
        local err_fstat, stat = uv.fs_fstat(fd)
        assert(err_fstat == nil)
        local err_read, data = uv.fs_read(fd, stat.size, 0)
        assert(err_read == nil)
        local err_close = uv.fs_close(fd)
        assert(err_close == nil)
        return data
      end
      
      --- Read `foo.txt` and `bar.txt` concurrently.
      local foo_task = coop.spawn(readFileAsync, "foo.txt")
      local bar_task = coop.spawn(readFileAsync, "bar.txt")
      
      --- Wait 1s for both tasks to finish and print their results.
      print(foo_task:await(1000), bar_task:await(1000))
      
      
      --- Creates a task from a task function.
      ---
      ---@param task_function @async fun
      ---@return Coop.Task task
      task.create
      
      --- Resumes a task.
      ---
      ---@param task Coop.Task
      ---@param ...
      ---@return boolean success
      ---@return any ... results
      task.resume
      
      --- Yields from a task functions it’s in.
      ---
      --- Yield throws `error("cancelled")` if in a cancelled task.
      ---
      ---@async
      ---@param ...
      ---@return ...
      task.yield
      
      --- Returns the task’s status.
      ---
      ---@param task Coop.Task
      ---@return string "running" | "suspended" | "normal" | "dead"
      task.status
      
      --- Returns the running task.
      ---
      ---@return Coop.Task?
      task.running
      
      
      --- Cancels the task.
      ---
      --- The cancelled task will throw `error("cancelled")` in its yield.
      --- If you intercept cancellation, you need to unset the `cancelled` flag with
      --- with Task:unset_cancelled.
      ---
      --- `cancel` resumes the task. It’s like sending a cancellation signal that the task needs to
      --- handle.
      ---
      ---@param task Coop.Task the task to cancel
      ---@return boolean success
      ---@return any ... results
      function task.cancel(task)
        -- …
      end
      
      --- Unsets the cancellation flag.
      ---
      ---@param task Coop.Task
      function task.unset_cancelled(task)
        -- …
      end
      
      --- Returns whether the task is cancelled.
      ---
      ---@param task Coop.Task
      ---@return boolean is_cancelled
      function task.is_cancelled(task)
        -- …
      end
      
      
      -- Awaits task completion.
      function task.await(self, cb_or_timeout, interval)
      end
      
      -- task.await() is a task function that waits for the task finish and return a
      -- result
      result = task:await()
      
      -- task.await(cb) is a callback-based function that calls the callback once the
      -- task is finished.
      -- It doesn’t wait for the task.
      task:await(function(success, result) end)
      
      -- task.await(timeout, interval) is a blocking function that uses vim.wait to
      -- implement a busy-waiting loop.
      task:await(1000, 100) -- Wait for 1s for the task to finish. Check every 100ms
      
      --- Awaits task completion in a protected mode.
      ---
      --- This variant of await doesn’t rethrow errors.
      --- Instead it returns false, err_msg.
      ---
      ---@async
      ---@param self Coop.Task
      ---@return boolean success
      ---@return any ... results
      function task.pawait(self)
        -- …
      end
      
      
      local get_result_1 = coop.spawn(compute, 100)
      local get_result_2 = coop.spawn(compute, 200)
      local result = get_result_1()
      
      
      --- Runs tasks in the sequence concurrently.
      ---
      --- If all tasks are completed successfully, the result is an aggregate list of returned
      --- values. The order of result values corresponds to the order of tasks.
      ---
      --- The first raised exception is immediately propagated to the task that awaits on gather().
      --- Active tasks in the sequence won’t be cancelled and will continue to run.
      ---
      --- Cancelling the gather will cancel all tasks in the sequence.
      ---
      ---@async
      ---@param tasks Coop.Task[] the list of tasks.
      ---@return any ... results
      M.gather = function(tasks) end
      
      --- Protects a task function from being cancelled.
      ---
      --- The task function is executed in a new task.
      ---
      --- If no cancellation is taking place, `shield(tf, ...)` is equivalent to `tf(...)`.
      ---
      --- If the task wrapping `shield` is cancelled, the task function is allowed to complete.
      --- Afterwards `shield` throws the cancellation error.
      ---
      --- If it is desired to completely ignore cancellation, `shield` should be combined with `copcall`.
      ---
      ---@async
      ---@param tf async function The task function to protect.
      ---@param ... ... The arguments to pass to the task function.
      ---@return any ... The results of the task function.
      M.shield = function(tf, ...) end
      
      --- Creates a task function that times out after the given duration.
      ---
      --- If no timeout is taking place, `timeout(duration, tf, ...)` is equivalent to `tf(...)`.
      ---
      --- If a timeout happens, `timeout` throws `error("timeout")`.
      ---
      --- If the returned task function is cancelled, so is the wrapped task function.
      ---
      ---@async
      ---@param duration integer The duration in milliseconds.
      ---@param tf async function The task function to run.
      ---@param ... ... The arguments to pass to the task function.
      ---@return ... ... The results of the task function.
      M.timeout = function(duration, tf, ...) end
      
      --- Waits for any of the given tasks to complete.
      ---
      ---@async
      ---@param tasks Coop.Task[]
      ---@return Coop.Task done The first task that completed.
      ---@return Coop.Task[] done The remaining tasks.
      M.await_any = function(tasks) end
      
      --- Awaits all tasks in the list.
      ---
      ---@async
      ---@param tasks Coop.Task[]
      ---@return table results The results of the tasks.
      M.await_all = function(tasks) end
      
      --- Asynchronously iterates over the given awaitables and waits for each to complete.
      ---
      ---@async
      ---@param tasks Coop.Task[]
      M.as_completed = function(tasks) end
      
      
      local MpscQueue = require('coop.mpsc-queue').MpscQueue
      local q = MpscQueue.new()
      
      -- Asynchronously print whatever is provided to q.
      coop.spawn(function()
        while true do
          vim.print("Read: " .. q:pop())
        end
      end)
      
      -- Start two threads that will asynchronously get strings from two sources.
      coop.spawn(function()
        while true do
          q:push(read_string_from_user())
        end
      end)
      
      coop.spawn(function()
        while true do
          q:push(read_string_from_something_else())
        end
      end)
      
      
      local coop = require("coop")
      local subprocess = require("coop.subprocess")
      
      ---@async
      function pass_printf_to_cat()
        local printf = subprocess.spawn("printf", {
          args = { "Hello, world!" },
          stdio = { nil, subprocess.PIPE },
        })
        local cat = subprocess.spawn("cat", {
          stdio = { printf.stdout, subprocess.STREAM },
        })
        vim.print(cat.stdout:read_until_eof())
        printf:await()
        cat:await()
      end
      
      coop.spawn(pass_printf_to_cat)
      
      
      local coop = require("coop")
      local StreamReader = require('coop.uv-utils').StreamReader
      local StreamWriter = require('coop.uv-utils').StreamWriter
      
      local fds = vim.uv.pipe({ nonblock = true }, { nonblock = true })
      local sr = StreamReader.from_fd(fds.read)
      local sw = StreamWriter.from_fd(fds.write)
      
      local result = coop.spawn(function()
        sw:write("Hello, world!")
        sw:close()
        local data = sr:read_until_eof()
        sr:close()
        return data
      end).await(5000, 1)
      
      assert(result == "Hello, world!")
      
      
      --- This is a synchronous function.
      function main()
        local task = coop.spawn(...)
        -- Wait for 5 seconds and poll every 20 milliseconds.
        return task:await(5000, 20)
      end
      
    end,
  },
  {
    "CWood-sdf/banana.nvim",
    config = function()
      
      -- NOTE: This can go multiple directories down (eg dir1/dir2/<file>)
      local document = require("banana.instance").newInstance("<name>/<file>", "Window name")
      
      document:open()
      document:close()
      
      
      return {
        "CWood-sdf/banana.nvim",
        opts = {
          -- if set to false, then you must call require("banana").initTsParsers() somewhere else
          -- this allows you to remove treesitter as a dependency so that you can continue lazy loading it
          -- if set to true, then it auto creates the treesitter parsers and loads nvim-treesitter
          setupTs = true,
        },
        dependencies = {
            "nvim-treesitter/nvim-treesitter",
        },
      }
      
    end,
  },
  {
    "OXY2DEV/helpview.nvim",
    config = function()
      
      > {
      >     preview = {
      >         icon_provider = "internal", -- "mini" or "devicons"
      >     }
      > }
      > 
      
      -- For `plugins/helpview.lua` users.
      return {
          "OXY2DEV/helpview.nvim",
          lazy = false
      };
      
      
      -- For `plugins.lua` users.
      {
          "OXY2DEV/helpview.nvim",
          lazy = false
      },
      
      
      local MiniDeps = require("mini.deps");
      
      MiniDeps.add({
          source = "OXY2DEV/helpview.nvim"
      });
      
      
      return {
          "OXY2DEV/helpview.nvim",
          branch = "dev",
          lazy = false
      };
      
      
      --- Configuration for `helpview.nvim`.
      ---@class helpview.config
      ---
      --- Preview options.
      ---@field preview? helpview.preview
      ---
      --- Configuration options for vimdoc.
      ---@field vimdoc? helpview.vimdoc
      ---
      --- Custom highlight groups.
      ---@field highlight_groups? table[]
      ---
      --- Custom renderers
      ---@field renderers? { [string]: function }
      {
      	renderers = {},
      
      	preview = {
      		enable = true,
      		enable_hybrid_mode = true,
      
      		modes = { "n", "c", "no" },
      		hybrid_modes = {},
      		linewise_hybrid_mode = false,
      
      		filetypes = { "help" },
      		ignore_previews = {},
      		ignore_buftypes = {},
      		condition = nil,
      
      		max_buf_lines = 500,
      		draw_range = { 2 * vim.o.lines, 2 * vim.o.lines },
      		edit_range = { 0, 0 },
      
      		debounce = 150,
      		callbacks = {},
      
      		icon_provider = "internal",
      
      		splitview_winopts = { split = "right" },
      		preview_winopts = { width = math.floor(80) }
      	},
      
          vimdoc = {
              arguments = {},
              code_blocks = {},
              headings = {},
              highlight_groups = {},
              horizontal_rules = {},
              inline_codes = {},
              keycodes = {},
              modelines = {},
              notes = {},
              optionlinks = {},
              tags = {},
              taglinks = {},
              urls = {}
          }
      }
      
    end,
  },
  {
    "niuiic/omega.nvim",
    config = function()
      
      {"niuiic/omega.nvim", build = "cd rs && cargo build --release"}
      
    end,
  },
  {
    "2KAbhishek/utils.nvim",
    config = function()
      
      -- Lazy
      {
          'yourname/plugin.nvim',
          dependencies = {
              '2kabhishek/utils.nvim'
          },
      },
      
    end,
  },
  {
    "YaroSpace/lua-console.nvim",
    config = function()
      
      return {
        "yarospace/lua-console.nvim",
        lazy = true,
        keys = {
          { "`", desc = "Lua-console - toggle" },
          { "<Leader>`", desc = "Lua-console - attach to buffer" },
        },
        opts = {},
      }
      
      
      require('lua-console').setup { your_custom_options }
      
      
      opts = {
        buffer = {
          result_prefix = '=> ',
          save_path = vim.fn.stdpath('state') .. '/lua-console.lua',
          autosave = true, -- autosave on console hide / close
          load_on_start = true, -- load saved session on start
          preserve_context = true,  -- preserve results between evaluations
          strip_local = true, -- strip `local` from top-level variable declarations
          show_one_line_results = true, -- prints one line results, even if already shown as virtual text
          notify_result = false, -- notify result
          clear_before_eval = false, -- clear output below result prefix before evaluation of the whole buffer
          process_timeout = 2 * 1e5, -- number of instructions to process before timeout
        },
        window = {
          border = 'double', -- single|double|rounded
          height = 0.6, -- percentage of main window
        },
        mappings = {
          toggle = '`', -- toggle console
          attach = '<Leader>`', -- attach console to a buffer
          quit = 'q', -- close console
          eval = '<CR>', -- evaluate code
          eval_buffer = '<S-CR>', -- evaluate whole buffer
          kill_ps = '<Leader>K', -- kill evaluation process
          open = 'gf', -- open link
          messages = 'M', -- load Neovim messages
          save = 'S', -- save session
          load = 'L', -- load session
          resize_up = '<C-Up>', -- resize up
          resize_down = '<C-Down>', -- resize down
          help = '?' -- help
        },
      }
      
      
        require('lua-console').setup { 
          external_evaluators = {
            python = {
              cmd = { 'python3', '-c' },
              env = { PYTHONPATH = '~/projects' },
              timeout = 100000,
              formatter = function(result) do_something; return result end,
            },
          }
        }
        
      
        ---Formats the output of external evaluator
        ---@param result string[]
        ---@return string[]
        local function generic_formatter(result)
          local width = vim.o.columns
          local sep_start = ('='):rep(width)
          local sep_end = ('='):rep(width)
      
          table.insert(result, 1, sep_start)
          table.insert(result, sep_end)
      
          return result
        end
      
        local external_evaluators = {
          lang_prefix = '===',
          default_process_opts = {
            cwd = nil,
            env = { EMPTY = '' },
            clear_env = false,
            stdin = false,
            stdout = false,
            stderr = false,
            text = true,
            timeout = nil,
            detach = false,
            on_exit = nil,
          },
      
          ruby = {
            cmd = { 'ruby', '-e' },
            env = { RUBY_VERSION = '3.3.0' },
            code_prefix = '$stdout.sync = true;',
            formatter = generic_formatter,
          },
      
          racket = {
            cmd = { 'racket', '-e' },
            formatter = generic_formatter,
          },
        }
      
        return external_evaluators
        
    end,
  },
  {
    "DrKJeff16/wezterm-types",
    config = function()
      
      require('lazy').setup({
        spec = {
          {
            'folke/lazydev.nvim',
            ft = 'lua',
            dependencies = {
              {
                'DrKJeff16/wezterm-types',
                lazy = true,
                version = false, -- Get the latest version
              },
            },
            opts = {
              library = {
                -- Other library configs...
                { path = 'wezterm-types', mods = { 'wezterm' } },
              },
            },
          },
        },
      })
      
      
      > {
      >   {
      >     'folke/lazydev.nvim',
      >     ft = 'lua',
      >     dependencies = {
      >       {
      >         'DrKJeff16/wezterm-types',
      >         lazy = true,
      >         name = '<my_custom_name>', -- CUSTOM DIRECTORY NAME
      >         version = false, -- Get the latest version
      >       },
      >     },
      >     opts = {
      >       library = {
      >         -- Other library configs...
      >         { path = '<my_custom_name>', mods = { 'wezterm' } }, -- MAKE SURE TO MATCH THE PLUGIN DIRECTORY'S NAME
      >       },
      >     },
      >   },
      > }
      > 
      
      ---@type Wezterm
      local wezterm = require("wezterm")
      
      ---@type Config
      local config = wezterm.config_builder()
      
      -- Your configuration here with full type support
      config.window_decorations = "RESIZE|MACOS_FORCE_DISABLE_SHADOW"
      
      return config
      
    end,
  },
  {
    "Olical/aniseed",
  },
  {
    "Olical/nfnl",
    config = function()
      
      require("nfnl").setup({ compile_on_write = false })
      
    end,
  },
  {
    "Olical/conjure",
  },
  {
    "rktjmp/hotpot.nvim",
    config = function()
      
      -- and require it like normal in your lua file
      local neat = require('is_neat') -- compiled & cached on demand
      neat("fennel") -- => "fennel is neat!"
      
      
      -- ~/.config/nvim/init.lua
      -- Ensure lazy and hotpot are always installed
      local function ensure_installed(plugin, branch)
        local user, repo = string.match(plugin, "(.+)/(.+)")
        local repo_path = vim.fn.stdpath("data") .. "/lazy/" .. repo
        if not (vim.uv or vim.loop).fs_stat(repo_path) then
          vim.notify("Installing " .. plugin .. " " .. branch)
          local repo_url = "https://github.com/" .. plugin .. ".git"
          local out = vim.fn.system({
            "git",
            "clone",
            "--filter=blob:none",
            "--branch=" .. branch,
            repo_url,
            repo_path
          })
          if vim.v.shell_error ~= 0 then
            vim.api.nvim_echo({
              { "Failed to clone " .. plugin .. ":\n", "ErrorMsg" },
              { out, "WarningMsg" },
              { "\nPress any key to exit..." },
            }, true, {})
            vim.fn.getchar()
            os.exit(1)
          end
        end
        return repo_path
      end
      local lazy_path = ensure_installed("folke/lazy.nvim", "stable")
      local hotpot_path = ensure_installed("rktjmp/hotpot.nvim", "v0.14.8")
      -- As per Lazy's install instructions, but also include hotpot
      vim.opt.runtimepath:prepend({hotpot_path, lazy_path})
      
      -- You must call vim.loader.enable() before requiring hotpot unless you are
      -- passing {performance = {cache = false}} to Lazy.
      vim.loader.enable()
      
      require("hotpot") -- Optionally you may call require("hotpot").setup(...) here
      
      -- You must include Hotpot in your plugin list for it to function correctly.
      -- If you want to use Lazy's "structured" style, see the next code sample.
      local plugins = {"rktjmp/hotpot.nvim"}
      require("lazy").setup(plugins)
      
      -- Include the rest of your config. Your call to Lazy.setup does not have
      -- to be done in init.lua and could be in a required file.
      require("say-hello")
      
      
      -- ~/.config/nvim/.hotpot.lua
      
      -- By default, the Fennel compiler wont complain if unknown variables are
      -- referenced, we can force a compiler error so we don't try to run faulty code.
      local allowed_globals = {}
      for key, _ in pairs(_G) do
        table.insert(allowed_globals, key)
      end
      
      return {
        -- by default, build all fnl/ files into lua/
        build = true,
        -- remove stale lua/ files
        clean = true,
        compiler = {
          modules = {
            -- enforce unknown variable errors
            allowedGlobals = allowed_globals
          }
        }
      }
      
      
      -- .config/nvim/init.lua
      
      -- ...
      
      -- See Lazy's own documentation for details.
      require("lazy").setup({spec = {import = "plugins"}})
      
      
      -- ~/.config/nvim/.hotpot.lua
      local allowed_globals = {}
      for key, _ in pairs(_G) do
        table.insert(allowed_globals, key)
      end
      
      return {
        build = {
          {atomic = true, verbose = true},
          {"fnl/**/*macro*.fnl", false},
          -- put all lua files inside `.compiled/lua`, note we must still name the
          -- final directory lua/, due to how nvims RTP works.
          {"fnl/**/*.fnl", function(path)
            -- ~/.config/nvim/fnl/hello/there.fnl -> ~/.config/nvim/.compiled/lua/hello/there.lua
            return string.gsub(path, "/fnl/", "/.compiled/lua/")
          end},
          -- You may also compile a init.fnl file to init.lua
          {"init.fnl", true}
        },
        clean = {{".compiled/lua/**/*.lua", true}},
        compiler = {
          modules = {
            allowedGlobals = allowed_globals
          }
        }
      }
      
      
      -- ~/.config/nvim/init.lua
      local path_package = vim.fn.stdpath('data') .. '/site/'
      local function ensure_installed(plugin, branch)
        local user, repo = string.match(plugin, "(.+)/(.+)")
        local repo_path = path_package .. 'pack/deps/start/' .. repo
        if not (vim.uv or vim.loop).fs_stat(repo_path) then
          vim.notify("Installing " .. plugin .. " " .. branch)
          local repo_url = "https://github.com/" .. plugin
          local out = vim.fn.system({
            "git",
            "clone",
            "--filter=blob:none",
            "--branch=" .. branch,
            repo_url,
            repo_path
          })
          if vim.v.shell_error ~= 0 then
            vim.api.nvim_echo({
              { "Failed to clone " .. plugin .. ":\n", "ErrorMsg" },
              { out, "WarningMsg" },
              { "\nPress any key to exit..." },
            }, true, {})
            vim.fn.getchar()
            os.exit(1)
          end
          vim.cmd('packadd ' .. repo .. ' | helptags ALL')
          vim.cmd('echo "Installed `' .. repo ..'`" | redraw')
        end
      end
      
      ensure_installed("echasnovski/mini.nvim", "stable")
      ensure_installed("rktjmp/hotpot.nvim", "v0.14.8")
      
      require("hotpot") -- Optionally you may call require("hotpot").setup(...) here
      
      require("mini.deps").setup({path = {package = path_package}})
      MiniDeps.add({source = "echasnovski/mini.nvim", checkout = "stable"})
      MiniDeps.add({source = "rktjmp/hotpot.nvim", checkout = "v0.14.8"})
      
      -- Include the rest of your config
      require("say-hello")
      
      
      -- ~/.config/nvim/init.lua
      -- Likely you will have some code to ensure Rocks.nvim is installed here
      -- ...
      
      require("hotpot") -- optionally you may call require("hotpot").setup(...) here
      
      -- Include the rest of your config
      require("say-hello")
      
      
      -- and in ~/.config/nvim/init.lua
      local neat = require('is_neat')
      neat("fennel") -- => "fennel is neat!"
      
      
      require("hotpot").setup({
        enable_hotpot_diagnostics = true,
        compiler = {
          -- options passed to fennel.compile for modules, defaults to {}
          modules = {
            -- not default but recommended, align lua lines with fnl source
            -- for more debuggable errors, but less readable lua.
            -- correlate = true
          },
          -- options passed to fennel.compile for macros, defaults as shown
          macros = {
            env = "_COMPILER" -- MUST be set along with any other options
          },
          -- A function that accepts a string of fennel source and a table of
          -- of some information. Can be used to alter fennel code before it is
          -- compiled.
          preprocessor = nil
        }
      })
      
    end,
  },
  {
    "udayvir-singh/tangerine.nvim",
    config = function()
      
      -- ~/.config/nvim/plugin/0-tangerine.lua or ~/.config/nvim/init.lua
      
      -- pick your plugin manager
      local pack = "tangerine" or "packer" or "paq" or "lazy"
      
      local function bootstrap(url, ref)
          local name = url:gsub(".*/", "")
          local path
      
          if pack == "lazy" then
              path = vim.fn.stdpath("data") .. "/lazy/" .. name
              vim.opt.rtp:prepend(path)
          else
              path = vim.fn.stdpath("data") .. "/site/pack/".. pack .. "/start/" .. name
          end
      
          if vim.fn.isdirectory(path) == 0 then
              print(name .. ": installing in data dir...")
      
              vim.fn.system {"git", "clone", url, path}
              if ref then
                  vim.fn.system {"git", "-C", path, "checkout", ref}
              end
      
              vim.cmd "redraw"
              print(name .. ": finished installing")
          end
      end
      
      -- for stable version [recommended]
      bootstrap("https://github.com/udayvir-singh/tangerine.nvim", "v2.9")
      
      -- for git head
      bootstrap("https://github.com/udayvir-singh/tangerine.nvim")
      
      
      -- ~/.config/nvim/plugin/0-tangerine.lua
      
      require "tangerine".setup {}
      
      
      local nvim_dir = vim.fn.stdpath [[config]]
      
      {
          vimrc   = nvim_dir .. "/init.fnl",
          source  = nvim_dir .. "/fnl",
          target  = nvim_dir .. "/lua",
          rtpdirs = {},
      
          custom = {
              -- list of custom [source target] chunks, for example:
              -- {"~/.config/awesome/fnl", "~/.config/awesome/lua"}
          },
      
          compiler = {
              float   = true,     -- show output in floating window
              clean   = true,     -- delete stale lua files
              force   = false,    -- disable diffing (not recommended)
              verbose = true,     -- enable messages showing compiled files
      
              globals = vim.tbl_keys(_G), -- list of alowed globals in fennel code
      
              -- wrapper function that provides access to underlying fennel compiler
              -- useful if you want to modify fennel API or want to provide your own fennel compiler
              adviser = function (fennel)
                  -- for example, adding a custom macro path:
                  -- fennel["macro-path"] = fennel["macro-path"] .. ";/custom/path/?.fnl"
                  return fennel
              end,
      
              -- version of fennel to use, [ latest, 1-5-1, 1-5-0, 1-4-2, 1-4-1, 1-4-0, 1-3-1, 1-3-0, 1-2-1, 1-2-0, 1-1-0, 1-0-0 ]
              version = "latest",
      
              -- hooks for tangerine to compile on:
              -- "onsave" run every time you save fennel file in {source} dir
              -- "onload" run on VimEnter event
              -- "oninit" run before sourcing init.fnl [recommended than onload]
              hooks   = {}
          },
      
          eval = {
              float  = true,      -- show results in floating window
              luafmt = function() -- function that returns formatter with flags for peeked lua
                  -- optionally install lua-format by running `$ luarocks install --local --server=https://luarocks.org/dev luaformatter`
                  return {"~/.luarocks/bin/lua-format", "--column-limit", "80"}
              end,
      
              diagnostic = {
                  virtual = true,  -- show errors in virtual text
                  timeout = 10     -- how long should the error persist
              }
          },
      
          keymaps = {
              -- set them to <Nop> if you want to disable them
              eval_buffer = "gE",
              peek_buffer = "gL",
              goto_output = "gO",
              float = {
                  next    = "<C-K>",
                  prev    = "<C-J>",
                  kill    = "<Esc>",
                  close   = "<Enter>",
                  resizef = "<C-W>=",
                  resizeb = "<C-W>-"
              }
          },
      
          highlight = {
              float   = "Normal",
              success = "String",
              errors  = "DiagnosticError"
          },
      }
      
      
      {
          -- save fnl output in a separate dir, it gets automatically added to package.path
          target = vim.fn.stdpath [[data]] .. "/tangerine",
      
          -- compile files in &rtp
          rtpdirs = {
              "plugin",
              "colors",
              "$HOME/mydir" -- absolute paths are also supported
          },
      
          compiler = {
              -- disable popup showing compiled files
              verbose = false,
      
              -- compile every time you change fennel files or on entering vim
              hooks = {"onsave", "oninit"}
          }
      }
      
      
      require [[tangerine]].setup {
          compiler = {
              -- if you want to compile before loading init.fnl (recommended)
              hooks = {"oninit"}
      
              -- if you want to compile after VimEnter event has fired
              hooks = {"onenter"}
          }
      }
      
      
      require [[tangerine]].setup {
          target = "/path/to/your/dir"
      }
      
      
      bootstrap "https://github.com/lewis6991/impatient.nvim"
      
      require [[impatient]]
      
      require [[tangerine]].setup {...}
      
    end,
  },
  {
    "udayvir-singh/hibiscus.nvim",
    config = function()
      
      -- ~/.config/nvim/plugin/0-tangerine.lua or ~/.config/nvim/init.lua
      
      -- pick your plugin manager
      local pack = "tangerine" or "packer" or "paq" or "lazy"
      
      local function bootstrap(url, ref)
          local name = url:gsub(".*/", "")
          local path
      
          if pack == "lazy" then
              path = vim.fn.stdpath("data") .. "/lazy/" .. name
              vim.opt.rtp:prepend(path)
          else
              path = vim.fn.stdpath("data") .. "/site/pack/".. pack .. "/start/" .. name
          end
      
          if vim.fn.isdirectory(path) == 0 then
              print(name .. ": installing in data dir...")
      
              vim.fn.system {"git", "clone", url, path}
              if ref then
                  vim.fn.system {"git", "-C", path, "checkout", ref}
              end
      
              vim.cmd "redraw"
              print(name .. ": finished installing")
          end
      end
      
      -- for stable version [recommended]
      bootstrap("https://github.com/udayvir-singh/hibiscus.nvim", "v1.7")
      
      -- for git head
      bootstrap("https://github.com/udayvir-singh/hibiscus.nvim")
      
      
      vim.cmd("hi! link TSInclude Special")
      vim.cmd("hi! DiagnosticVirtualTextError guibg=NONE")
      vim.cmd("echo resolve(expand('~/path'))")
      vim.cmd("echo '" .. variable .. "'")
      
    end,
  },
  {
    "vuki656/package-info.nvim",
    config = function()
      
      vim.api.nvim_set_keymap(
          "n",
          "<leader>ns",
          "<cmd>lua require('package-info').show()<cr>",
          { silent = true, noremap = true }
      )
      
      
      vim.api.nvim_set_keymap(
          "n",
          "<leader>ns",
          "<cmd>lua require('package-info').show({ force = true })<cr>",
          { silent = true, noremap = true }
      )
      
      
      vim.api.nvim_set_keymap(
          "n",
          "<leader>nd",
          "<cmd>lua require('package-info').delete()<cr>",
          { silent = true, noremap = true }
      )
      
      
      vim.api.nvim_set_keymap(
          "n",
          "<leader>np",
          "<cmd>lua require('package-info').change_version()<cr>",
          { silent = true, noremap = true }
      )
      
      
      vim.api.nvim_set_keymap(
          "n",
          "<leader>ni",
          "<cmd>lua require('package-info').install()<cr>",
          { silent = true, noremap = true }
      )
      
      
      local package_info = require("package-info")
      
      -- Galaxyline
      section.left[10] = {
          PackageInfoStatus = {
              provider = function()
                  return package_info.get_status()
              end,
          },
      }
      
      -- Feline
      components.right.active[5] = {
          provider = function()
              return package_info.get_status()
          end,
          hl = {
              style = "bold",
          },
          left_sep = "  ",
          right_sep = " ",
      }
      
      
      use({
          "vuki656/package-info.nvim",
          requires = "MunifTanjim/nui.nvim",
      })
      
      
      require('package-info').setup()
      
      
      {
          -- Check `:help nvim_set_hl()` for more attributes.
          highlights = {
              up_to_date = { -- highlight for up to date dependency virtual text
                  fg = "#3C4048"
              },
              outdated = { -- highlight for outdated dependency virtual text
                  fg = "#d19a66"
              },
              invalid = { -- highlight for invalid dependency virtual text
                  fg = "#ee4b2b"
              },
          },
          icons = {
              enable = true, -- Whether to display icons
              style = {
                  up_to_date = "|  ", -- Icon for up to date dependencies
                  outdated = "|  ", -- Icon for outdated dependencies
                  invalid = "|  ", -- Icon for invalid dependencies
              },
          },
          notifications = true, -- Whether to display notifications when running commands
          autostart = true, -- Whether to autostart when `package.json` is opened
          hide_up_to_date = false, -- It hides up to date versions when displaying virtual text
          hide_unstable_versions = false, -- It hides unstable versions from version list e.g next-11.1.3-canary3
          -- Can be `npm`, `yarn`, or `pnpm`. Used for `delete`, `install` etc...
          -- The plugin will try to auto-detect the package manager based on
          -- `yarn.lock` or `package-lock.json`. If none are found it will use the
          -- provided one, if nothing is provided it will use `yarn`
          package_manager = 'yarn'
      }
      
      
      highlights = {
          up_to_date = {
              ctermfg = 237
          },
          outdated = {
              ctermfg = 173
          },
          invalid = {
              ctermfg = 196
              fg = "#ee4b2b" -- Set both cterm and fg
          }
      }
      
      
      require("package-info").setup({
        colors = {
          up_to_date = "#3C4048",
          outdated   = "#d19a66",
          invalid    = "#ee4b2b",
        },
      })
      
      
      
      require("package-info").setup({
        highlights = {
          up_to_date = { fg = "#3C4048" },
          outdated   = { fg = "#d19a66" },
          invalid    = { fg = "#ee4b2b" },
        },
      })
      
      
      -- Show dependency versions
      vim.keymap.set({ "n" }, "<LEADER>ns", require("package-info").show, { silent = true, noremap = true })
      
      -- Hide dependency versions
      vim.keymap.set({ "n" }, "<LEADER>nc", require("package-info").hide, { silent = true, noremap = true })
      
      -- Toggle dependency versions
      vim.keymap.set({ "n" }, "<LEADER>nt", require("package-info").toggle, { silent = true, noremap = true })
      
      -- Update dependency on the line
      vim.keymap.set({ "n" }, "<LEADER>nu", require("package-info").update, { silent = true, noremap = true })
      
      -- Delete dependency on the line
      vim.keymap.set({ "n" }, "<LEADER>nd", require("package-info").delete, { silent = true, noremap = true })
      
      -- Install a new dependency
      vim.keymap.set({ "n" }, "<LEADER>ni", require("package-info").install, { silent = true, noremap = true })
      
      -- Install a different dependency version
      vim.keymap.set({ "n" }, "<LEADER>np", require("package-info").change_version, { silent = true, noremap = true })
      
      
      require("telescope").setup({
          extensions = {
              package_info = {
                  -- Optional theme (the extension doesn't set a default theme)
                  theme = "ivy",
              },
          },
      })
      
      require("telescope").load_extension("package_info")
      
    end,
  },
  {
    "Saecki/crates.nvim",
    config = function()
      
      {
          'saecki/crates.nvim',
          tag = 'stable',
          config = function()
              require('crates').setup()
          end,
      }
      
      
      {
          'saecki/crates.nvim',
          config = function()
              require('crates').setup()
          end,
      }
      
      
      {
          'saecki/crates.nvim',
          event = { "BufRead Cargo.toml" },
          config = function()
              require('crates').setup()
          end,
      }
      
    end,
  },
  {
    "piersolenski/import.nvim",
    config = function()
      
      > { "piersolenski/import.nvim" }
      > 
      
      -- Lazy
      {
        'piersolenski/import.nvim',
        dependencies = {
          -- One of the following pickers is required:
          'nvim-telescope/telescope.nvim',
       -- 'folke/snacks.nvim',
       -- 'ibhagwan/fzf-lua',
        },
        opts = {
       picker = "telescope",
        },
        keys = {
          {
            "<leader>i",
            function()
              require("import").pick()
            end,
            desc = "Import",
          },
        },
      }
      
      
      {
        -- The picker to use
        picker = "telescope" | "snacks" | "fzf-lua",
        -- Imports can be added at a specified line whilst keeping the cursor in place
        insert_at_top = true,
        -- Optionally support additional languages or modify existing languages...
        custom_languages = {}
      }
      
      
      custom_languages = {
        {
          extensions = { "elm" },
          filetypes = { "elm" },
          regex = [[^import\s+([\w.]+)(?:\s+as\s+\w+)?(?:\s+exposing\s+.+)?]],
        }
      }
      
      
      custom_languages = {
        {
          filetypes = { "vue" },
          insert_at_line = function() 
            -- Insert before closing <script> tag instead of after the opening tag
            return vim.fn.search("</script>", "n") + 1
          end,
        }
      }
      
      
      custom_languages = {
        {
          filetypes = { "vue" },
          regex = [[^import\s+.*from\s+['\"](.+)['\"];?]], -- Custom regex
          insert_at_line = 2, -- Fixed line number
        }
      }
      
      
      require("import").pick()
      
    end,
  },
  {
    "Silletr/LazyDevHelper",
    config = function()
      
        use {
          'Silletr/LazyDevHelper',
          config = function()
            require("LazyDeveloperHelper")
          end
        }
      
      
      return {
          "Silletr/LazyDeveloperHelper",
          config = function ()
              require("LazyDeveloperHelper").setup()
          end
        }
      
    end,
  },
  {
    "mrloop/telescope-git-branch.nvim",
    config = function()
      
      {
          'mrloop/telescope-git-branch.nvim'
      }
      
      
      require('telescope').load_extension('git_branch')
      
      
      -- Search for the files with differences to default branch.
      vim.keymap.set({'n', 'v'}, '<leader>gf', function()
          require('git_branch').files()
      end)
      
    end,
  },
  {
    "f-person/git-blame.nvim",
    config = function()
      
      require('gitblame').setup {
           --Note how the `gitblame_` prefix is omitted in `setup`
          enabled = false,
      }
      
      
      return {
          "f-person/git-blame.nvim",
          -- load the plugin at startup
          event = "VeryLazy",
          -- Because of the keys part, you will be lazy loading this plugin.
          -- The plugin will only load once one of the keys is used.
          -- If you want to load the plugin at startup, add something like event = "VeryLazy",
          -- or lazy = false. One of both options will work.
          opts = {
              -- your configuration comes here
              -- for example
              enabled = true,  -- if you want to enable the plugin
              message_template = " <summary> • <date> • <author> • <<sha>>", -- template for the blame message, check the Message template section for more options
              date_format = "%m-%d-%Y %H:%M:%S", -- template for the date, check Date format section for more options
              virtual_text_column = 1,  -- virtual text start column, check Start virtual text at column section for more options
          },
       
      }
      
      
      vim.g.gitblame_use_blame_commit_file_urls = true
      
      
      vim.g.gitblame_remote_domains = {
          "git.sr.ht" = "sourcehut"
      }
      
      
      -- Lua
      local git_blame = require('gitblame')
      
      git_blame.is_blame_text_available() -- Returns a boolean value indicating whether blame message is available
      git_blame.get_current_blame_text() --  Returns a string with blame message
      
      
      -- Lua
      require('lua-timeago').set_language(require('lua-timeago/languages/hy'))
      
    end,
  },
  {
    "trevorhauter/gitportal.nvim",
    config = function()
      
      return { 'trevorhauter/gitportal.nvim' }
      
      
      use { 'trevorhauter/gitportal.nvim' }
      
      
      Plug 'trevorhauter/gitportal.nvim'
      
      
      {
          -- Permalink generation | Include current line in URL regardless of current mode
          always_include_current_line = false, -- bool
      
          -- Branch/commit handling when opening links in neovim
          switch_branch_or_commit_upon_ingestion = "always", -- "always" | "ask_first" | "never"
      
          -- Custom browser command (default: automatically determined by GitPortal)
          browser_command = nil, -- (override only if necessary, not recommended)
      
          -- Map of origin urls to git providers 
          -- (default: automatically determined by GitPortal, required for self hosted instances)
          -- Ex. {["origin_url"] = { provider = "gitlab", base_url = "https://customdomain.dev"}}
          git_provider_map = nil,
      }
      
      
      local gitportal = require("gitportal")
      
      gitportal.setup({
          always_include_current_line = true, -- Include the current line in permalinks by default
      })
      
      -- Key mappings for GitPortal functions:
      
      -- Opens the current file in your browser at the correct branch/commit.
      -- When in visual mode, selected lines are included in the permalink.
      vim.keymap.set("n", "<leader>gp", gitportal.open_file_in_browser)
      vim.keymap.set("v", "<leader>gp", gitportal.open_file_in_browser)
      
      -- Opens a Githost link directly in Neovim, optionally switching to the branch/commit.
      vim.keymap.set("n", "<leader>ig", gitportal.open_file_in_neovim)
      
      -- Generates and copies the permalink of your current file to your clipboard.
      -- When in visual mode, selected lines are included in the permalink.
      vim.keymap.set("n", "<leader>gc", gitportal.copy_link_to_clipboard)
      vim.keymap.set("v", "<leader>gc", gitportal.copy_link_to_clipboard)
      
      
      :GitPortal [action] -- browse_file (default) | open_link | copy_link_to_clipboard
      
    end,
  },
  {
    "lewis6991/gitsigns.nvim",
    config = function()
      
      require('gitsigns').setup {
        signs = {
          add          = { text = '┃' },
          change       = { text = '┃' },
          delete       = { text = '_' },
          topdelete    = { text = '‾' },
          changedelete = { text = '~' },
          untracked    = { text = '┆' },
        },
        signs_staged = {
          add          = { text = '┃' },
          change       = { text = '┃' },
          delete       = { text = '_' },
          topdelete    = { text = '‾' },
          changedelete = { text = '~' },
          untracked    = { text = '┆' },
        },
        signs_staged_enable = true,
        signcolumn = true,  -- Toggle with `:Gitsigns toggle_signs`
        numhl      = false, -- Toggle with `:Gitsigns toggle_numhl`
        linehl     = false, -- Toggle with `:Gitsigns toggle_linehl`
        word_diff  = false, -- Toggle with `:Gitsigns toggle_word_diff`
        watch_gitdir = {
          follow_files = true
        },
        auto_attach = true,
        attach_to_untracked = false,
        current_line_blame = false, -- Toggle with `:Gitsigns toggle_current_line_blame`
        current_line_blame_opts = {
          virt_text = true,
          virt_text_pos = 'eol', -- 'eol' | 'overlay' | 'right_align'
          delay = 1000,
          ignore_whitespace = false,
          virt_text_priority = 100,
          use_focus = true,
        },
        current_line_blame_formatter = '<author>, <author_time:%R> - <summary>',
        sign_priority = 6,
        update_debounce = 100,
        status_formatter = nil, -- Use default
        max_file_length = 40000, -- Disable if file is longer than this (in lines)
        preview_config = {
          -- Options passed to nvim_open_win
          style = 'minimal',
          relative = 'cursor',
          row = 0,
          col = 1
        },
      }
      
      
      require('gitsigns').setup{
        ...
        on_attach = function(bufnr)
          local gitsigns = require('gitsigns')
      
          local function map(mode, l, r, opts)
            opts = opts or {}
            opts.buffer = bufnr
            vim.keymap.set(mode, l, r, opts)
          end
      
          -- Navigation
          map('n', ']c', function()
            if vim.wo.diff then
              vim.cmd.normal({']c', bang = true})
            else
              gitsigns.nav_hunk('next')
            end
          end)
      
          map('n', '[c', function()
            if vim.wo.diff then
              vim.cmd.normal({'[c', bang = true})
            else
              gitsigns.nav_hunk('prev')
            end
          end)
      
          -- Actions
          map('n', '<leader>hs', gitsigns.stage_hunk)
          map('n', '<leader>hr', gitsigns.reset_hunk)
      
          map('v', '<leader>hs', function()
            gitsigns.stage_hunk({ vim.fn.line('.'), vim.fn.line('v') })
          end)
      
          map('v', '<leader>hr', function()
            gitsigns.reset_hunk({ vim.fn.line('.'), vim.fn.line('v') })
          end)
      
          map('n', '<leader>hS', gitsigns.stage_buffer)
          map('n', '<leader>hR', gitsigns.reset_buffer)
          map('n', '<leader>hp', gitsigns.preview_hunk)
          map('n', '<leader>hi', gitsigns.preview_hunk_inline)
      
          map('n', '<leader>hb', function()
            gitsigns.blame_line({ full = true })
          end)
      
          map('n', '<leader>hd', gitsigns.diffthis)
      
          map('n', '<leader>hD', function()
            gitsigns.diffthis('~')
          end)
      
          map('n', '<leader>hQ', function() gitsigns.setqflist('all') end)
          map('n', '<leader>hq', gitsigns.setqflist)
      
          -- Toggles
          map('n', '<leader>tb', gitsigns.toggle_current_line_blame)
          map('n', '<leader>tw', gitsigns.toggle_word_diff)
      
          -- Text object
          map({'o', 'x'}, 'ih', gitsigns.select_hunk)
        end
      }
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-diff.md",
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-git.md",
  },
  {
    "NeogitOrg/neogit",
    config = function()
      
      {
        "NeogitOrg/neogit",
        dependencies = {
          "nvim-lua/plenary.nvim",         -- required
          "sindrets/diffview.nvim",        -- optional - Diff integration
      
          -- Only one of these is needed.
          "nvim-telescope/telescope.nvim", -- optional
          "ibhagwan/fzf-lua",              -- optional
          "nvim-mini/mini.pick",           -- optional
          "folke/snacks.nvim",             -- optional
        },
      }
      
      
      local neogit = require("neogit")
      
      neogit.setup {
        -- Hides the hints at the top of the status buffer
        disable_hint = false,
        -- Disables changing the buffer highlights based on where the cursor is.
        disable_context_highlighting = false,
        -- Disables signs for sections/items/hunks
        disable_signs = false,
        -- Offer to force push when branches diverge
        prompt_force_push = true,
        -- Changes what mode the Commit Editor starts in. `true` will leave nvim in normal mode, `false` will change nvim to
        -- insert mode, and `"auto"` will change nvim to insert mode IF the commit message is empty, otherwise leaving it in
        -- normal mode.
        disable_insert_on_commit = "auto",
        -- When enabled, will watch the `.git/` directory for changes and refresh the status buffer in response to filesystem
        -- events.
        filewatcher = {
          interval = 1000,
          enabled = true,
        },
        -- "ascii"   is the graph the git CLI generates
        -- "unicode" is the graph like https://github.com/rbong/vim-flog
        -- "kitty"   is the graph like https://github.com/isakbm/gitgraph.nvim - use https://github.com/rbong/flog-symbols if you don't use Kitty
        graph_style = "ascii",
        -- Show relative date by default. When set, use `strftime` to display dates
        commit_date_format = nil,
        log_date_format = nil,
        -- Show message with spinning animation when a git command is running.
        process_spinner = false,
        -- Used to generate URL's for branch popup action "pull request", "open commit" and "open tree"
        git_services = {
          ["github.com"] = {
            pull_request = "https://github.com/${owner}/${repository}/compare/${branch_name}?expand=1",
            commit = "https://github.com/${owner}/${repository}/commit/${oid}",
            tree = "https://${host}/${owner}/${repository}/tree/${branch_name}",
          },
          ["bitbucket.org"] = {
            pull_request = "https://bitbucket.org/${owner}/${repository}/pull-requests/new?source=${branch_name}&t=1",
            commit = "https://bitbucket.org/${owner}/${repository}/commits/${oid}",
            tree = "https://bitbucket.org/${owner}/${repository}/branch/${branch_name}",
          },
          ["gitlab.com"] = {
            pull_request = "https://gitlab.com/${owner}/${repository}/merge_requests/new?merge_request[source_branch]=${branch_name}",
            commit = "https://gitlab.com/${owner}/${repository}/-/commit/${oid}",
            tree = "https://gitlab.com/${owner}/${repository}/-/tree/${branch_name}?ref_type=heads",
          },
          ["azure.com"] = {
            pull_request = "https://dev.azure.com/${owner}/_git/${repository}/pullrequestcreate?sourceRef=${branch_name}&targetRef=${target}",
            commit = "",
            tree = "",
          },
        },
        -- Allows a different telescope sorter. Defaults to 'fuzzy_with_index_bias'. The example below will use the native fzf
        -- sorter instead. By default, this function returns `nil`.
        telescope_sorter = function()
          return require("telescope").extensions.fzf.native_fzf_sorter()
        end,
        -- Persist the values of switches/options within and across sessions
        remember_settings = true,
        -- Scope persisted settings on a per-project basis
        use_per_project_settings = true,
        -- Table of settings to never persist. Uses format "Filetype--cli-value"
        ignored_settings = {},
        -- Configure highlight group features
        highlight = {
          italic = true,
          bold = true,
          underline = true
        },
        -- Set to false if you want to be responsible for creating _ALL_ keymappings
        use_default_keymaps = true,
        -- Neogit refreshes its internal state after specific events, which can be expensive depending on the repository size.
        -- Disabling `auto_refresh` will make it so you have to manually refresh the status after you open it.
        auto_refresh = true,
        -- Value used for `--sort` option for `git branch` command
        -- By default, branches will be sorted by commit date descending
        -- Flag description: https://git-scm.com/docs/git-branch#Documentation/git-branch.txt---sortltkeygt
        -- Sorting keys: https://git-scm.com/docs/git-for-each-ref#_options
        sort_branches = "-committerdate",
        -- Value passed to the `--<commit_order>-order` flag of the `git log` command
        -- Determines how commits are traversed and displayed in the log / graph:
        --   "topo"         topological order (parents always before children, good for graphs, slower on large repos)
        --   "date"         chronological order by commit date
        --   "author-date"  chronological order by author date
        --   ""             disable explicit ordering (fastest, recommended for very large repos)
        commit_order = "topo"
        -- Default for new branch name prompts
        initial_branch_name = "",
        -- Change the default way of opening neogit
        kind = "tab",
        -- Floating window style 
        floating = {
          relative = "editor",
          width = 0.8,
          height = 0.7,
          style = "minimal",
          border = "rounded",
        },
        -- Disable line numbers
        disable_line_numbers = true,
        -- Disable relative line numbers
        disable_relative_line_numbers = true,
        -- The time after which an output console is shown for slow running commands
        console_timeout = 2000,
        -- Automatically show console if a command takes more than console_timeout milliseconds
        auto_show_console = true,
        -- Automatically close the console if the process exits with a 0 (success) status
        auto_close_console = true,
        notification_icon = "󰊢",
        status = {
          show_head_commit_hash = true,
          recent_commit_count = 10,
          HEAD_padding = 10,
          HEAD_folded = false,
          mode_padding = 3,
          mode_text = {
            M = "modified",
            N = "new file",
            A = "added",
            D = "deleted",
            C = "copied",
            U = "updated",
            R = "renamed",
            DD = "unmerged",
            AU = "unmerged",
            UD = "unmerged",
            UA = "unmerged",
            DU = "unmerged",
            AA = "unmerged",
            UU = "unmerged",
            ["?"] = "",
          },
        },
        commit_editor = {
          kind = "tab",
          show_staged_diff = true,
          -- Accepted values:
          -- "split" to show the staged diff below the commit editor
          -- "vsplit" to show it to the right
          -- "split_above" Like :top split
          -- "vsplit_left" like :vsplit, but open to the left
          -- "auto" "vsplit" if window would have 80 cols, otherwise "split"
          staged_diff_split_kind = "split",
          spell_check = true,
        },
        commit_select_view = {
          kind = "tab",
        },
        commit_view = {
          kind = "vsplit",
          verify_commit = vim.fn.executable("gpg") == 1, -- Can be set to true or false, otherwise we try to find the binary
        },
        log_view = {
          kind = "tab",
        },
        rebase_editor = {
          kind = "auto",
        },
        reflog_view = {
          kind = "tab",
        },
        merge_editor = {
          kind = "auto",
        },
        preview_buffer = {
          kind = "floating_console",
        },
        popup = {
          kind = "split",
        },
        stash = {
          kind = "tab",
        },
        refs_view = {
          kind = "tab",
        },
        signs = {
          -- { CLOSED, OPENED }
          hunk = { "", "" },
          item = { ">", "v" },
          section = { ">", "v" },
        },
        -- Each Integration is auto-detected through plugin presence, however, it can be disabled by setting to `false`
        integrations = {
          -- If enabled, use telescope for menu selection rather than vim.ui.select.
          -- Allows multi-select and some things that vim.ui.select doesn't.
          telescope = nil,
          -- Neogit only provides inline diffs. If you want a more traditional way to look at diffs, you can use `diffview`.
          -- The diffview integration enables the diff popup.
          --
          -- Requires you to have `sindrets/diffview.nvim` installed.
          diffview = nil,
      
          -- If enabled, uses fzf-lua for menu selection. If the telescope integration
          -- is also selected then telescope is used instead
          -- Requires you to have `ibhagwan/fzf-lua` installed.
          fzf_lua = nil,
      
          -- If enabled, uses mini.pick for menu selection. If the telescope integration
          -- is also selected then telescope is used instead
          -- Requires you to have `echasnovski/mini.pick` installed.
          mini_pick = nil,
      
          -- If enabled, uses snacks.picker for menu selection. If the telescope integration
          -- is also selected then telescope is used instead
          -- Requires you to have `folke/snacks.nvim` installed.
          snacks = nil,
        },
        sections = {
          -- Reverting/Cherry Picking
          sequencer = {
            folded = false,
            hidden = false,
          },
          untracked = {
            folded = false,
            hidden = false,
          },
          unstaged = {
            folded = false,
            hidden = false,
          },
          staged = {
            folded = false,
            hidden = false,
          },
          stashes = {
            folded = true,
            hidden = false,
          },
          unpulled_upstream = {
            folded = true,
            hidden = false,
          },
          unmerged_upstream = {
            folded = false,
            hidden = false,
          },
          unpulled_pushRemote = {
            folded = true,
            hidden = false,
          },
          unmerged_pushRemote = {
            folded = false,
            hidden = false,
          },
          recent = {
            folded = true,
            hidden = false,
          },
          rebase = {
            folded = true,
            hidden = false,
          },
        },
        mappings = {
          commit_editor = {
            ["q"] = "Close",
            ["<c-c><c-c>"] = "Submit",
            ["<c-c><c-k>"] = "Abort",
            ["<m-p>"] = "PrevMessage",
            ["<m-n>"] = "NextMessage",
            ["<m-r>"] = "ResetMessage",
          },
          commit_editor_I = {
            ["<c-c><c-c>"] = "Submit",
            ["<c-c><c-k>"] = "Abort",
          },
          rebase_editor = {
            ["p"] = "Pick",
            ["r"] = "Reword",
            ["e"] = "Edit",
            ["s"] = "Squash",
            ["f"] = "Fixup",
            ["x"] = "Execute",
            ["d"] = "Drop",
            ["b"] = "Break",
            ["q"] = "Close",
            ["<cr>"] = "OpenCommit",
            ["gk"] = "MoveUp",
            ["gj"] = "MoveDown",
            ["<c-c><c-c>"] = "Submit",
            ["<c-c><c-k>"] = "Abort",
            ["[c"] = "OpenOrScrollUp",
            ["]c"] = "OpenOrScrollDown",
          },
          rebase_editor_I = {
            ["<c-c><c-c>"] = "Submit",
            ["<c-c><c-k>"] = "Abort",
          },
          finder = {
            ["<cr>"] = "Select",
            ["<c-c>"] = "Close",
            ["<esc>"] = "Close",
            ["<c-n>"] = "Next",
            ["<c-p>"] = "Previous",
            ["<down>"] = "Next",
            ["<up>"] = "Previous",
            ["<tab>"] = "InsertCompletion",
            ["<c-y>"] = "CopySelection",
            ["<space>"] = "MultiselectToggleNext",
            ["<s-space>"] = "MultiselectTogglePrevious",
            ["<c-j>"] = "NOP",
            ["<ScrollWheelDown>"] = "ScrollWheelDown",
            ["<ScrollWheelUp>"] = "ScrollWheelUp",
            ["<ScrollWheelLeft>"] = "NOP",
            ["<ScrollWheelRight>"] = "NOP",
            ["<LeftMouse>"] = "MouseClick",
            ["<2-LeftMouse>"] = "NOP",
          },
          -- Setting any of these to `false` will disable the mapping.
          popup = {
            ["?"] = "HelpPopup",
            ["A"] = "CherryPickPopup",
            ["d"] = "DiffPopup",
            ["M"] = "RemotePopup",
            ["P"] = "PushPopup",
            ["X"] = "ResetPopup",
            ["Z"] = "StashPopup",
            ["i"] = "IgnorePopup",
            ["t"] = "TagPopup",
            ["b"] = "BranchPopup",
            ["B"] = "BisectPopup",
            ["w"] = "WorktreePopup",
            ["c"] = "CommitPopup",
            ["f"] = "FetchPopup",
            ["l"] = "LogPopup",
            ["m"] = "MergePopup",
            ["p"] = "PullPopup",
            ["r"] = "RebasePopup",
            ["v"] = "RevertPopup",
          },
          status = {
            ["j"] = "MoveDown",
            ["k"] = "MoveUp",
            ["o"] = "OpenTree",
            ["q"] = "Close",
            ["I"] = "InitRepo",
            ["1"] = "Depth1",
            ["2"] = "Depth2",
            ["3"] = "Depth3",
            ["4"] = "Depth4",
            ["Q"] = "Command",
            ["<tab>"] = "Toggle",
            ["za"] = "Toggle",
            ["zo"] = "OpenFold",
            ["x"] = "Discard",
            ["s"] = "Stage",
            ["S"] = "StageUnstaged",
            ["<c-s>"] = "StageAll",
            ["u"] = "Unstage",
            ["K"] = "Untrack",
            ["U"] = "UnstageStaged",
            ["y"] = "ShowRefs",
            ["$"] = "CommandHistory",
            ["Y"] = "YankSelected",
            ["<c-r>"] = "RefreshBuffer",
            ["<cr>"] = "GoToFile",
            ["<s-cr>"] = "PeekFile",
            ["<c-v>"] = "VSplitOpen",
            ["<c-x>"] = "SplitOpen",
            ["<c-t>"] = "TabOpen",
            ["{"] = "GoToPreviousHunkHeader",
            ["}"] = "GoToNextHunkHeader",
            ["[c"] = "OpenOrScrollUp",
            ["]c"] = "OpenOrScrollDown",
            ["<c-k>"] = "PeekUp",
            ["<c-j>"] = "PeekDown",
            ["<c-n>"] = "NextSection",
            ["<c-p>"] = "PreviousSection",
          },
        },
      }
      
      
      local neogit = require('neogit')
      
      -- open using defaults
      neogit.open()
      
      -- open a specific popup
      neogit.open({ "commit" })
      
      -- open as a split
      neogit.open({ kind = "split" })
      
      -- open with different project
      neogit.open({ cwd = "~" })
      
    end,
  },
  {
    "tveskag/nvim-blame-line",
  },
  {
    "ruifm/gitlinker.nvim",
    config = function()
      
      require'gitlinker'.setup{
        opts = {
          action_callback = function(url)
            -- yank to unnamed register
            vim.api.nvim_command('let @" = \'' .. url .. '\'')
            -- copy to the system clipboard using OSC52
            vim.fn.OSCYankString(url)
          end,
        },
      }
      
    end,
  },
  {
    "linrongbin16/gitlinker.nvim",
    config = function()
      
      require("lazy").setup({
        {
          "linrongbin16/gitlinker.nvim",
          cmd = "GitLink",
          opts = {},
          keys = {
            { "<leader>gy", "<cmd>GitLink<cr>", mode = { "n", "v" }, desc = "Yank git link" },
            { "<leader>gY", "<cmd>GitLink!<cr>", mode = { "n", "v" }, desc = "Open git link" },
          },
        },
      })
      
      
      return require('pckr').add(
        {
          'linrongbin16/gitlinker.nvim',
          config = function()
            require('gitlinker').setup()
          end,
        };
      )
      
      
      --- @alias gitlinker.Linker {remote_url:string,protocol:string?,username:string?,password:string?,host:string,port:string?,org:string?,user:string?,repo:string,rev:string,file:string,lstart:integer,lend:integer,file_changed:boolean,default_branch:string?,current_branch:string?}
      --- @alias gitlinker.Router fun(lk:gitlinker.Linker):string?
      --- @alias gitlinker.Action fun(url:string):any
      --- @param opts {router_type:string?,router:gitlinker.Router?,action:gitlinker.Action?,lstart:integer?,lend:integer?,message:boolean?,highlight_duration:integer?,remote:string?,file:string?,rev:string?}?
      require("gitlinker").link(opts)
      
      
      function(lk:gitlinker.Linker):string?
      
      
      function(url:string):any
      
      
      require("gitlinker").link({
        action = function(url)
          print("generated url:" .. vim.inspect(url))
        end,
      })
      
      
      -- with vim command:
      
      -- browse
      vim.keymap.set(
        {"n", 'v'},
        "<leader>gl",
        "<cmd>GitLink<cr>",
        { silent = true, noremap = true, desc = "Yank git permlink" }
      )
      vim.keymap.set(
        {"n", 'v'},
        "<leader>gL",
        "<cmd>GitLink!<cr>",
        { silent = true, noremap = true, desc = "Open git permlink" }
      )
      -- blame
      vim.keymap.set(
        {"n", 'v'},
        "<leader>gb",
        "<cmd>GitLink blame<cr>",
        { silent = true, noremap = true, desc = "Yank git blame link" }
      )
      vim.keymap.set(
        {"n", 'v'},
        "<leader>gB",
        "<cmd>GitLink! blame<cr>",
        { silent = true, noremap = true, desc = "Open git blame link" }
      )
      -- default branch
      vim.keymap.set(
        {"n", 'v'},
        "<leader>gd",
        "<cmd>GitLink default_branch<cr>",
        { silent = true, noremap = true, desc = "Copy default branch link" }
      )
      vim.keymap.set(
        {"n", 'v'},
        "<leader>gD",
        "<cmd>GitLink! default_branch<cr>",
        { silent = true, noremap = true, desc = "Open default branch link" }
      )
      -- default branch
      vim.keymap.set(
        {"n", 'v'},
        "<leader>gc",
        "<cmd>GitLink current_branch<cr>",
        { silent = true, noremap = true, desc = "Copy current branch link" }
      )
      vim.keymap.set(
        {"n", 'v'},
        "<leader>gD",
        "<cmd>GitLink! current_branch<cr>",
        { silent = true, noremap = true, desc = "Open current branch link" }
      )
      
      
      -- with lua api:
      
      -- browse
      vim.keymap.set(
        {"n", 'v'},
        "<leader>gl",
        require("gitlinker").link,
        { silent = true, noremap = true, desc = "GitLink" }
      )
      vim.keymap.set(
        {"n", 'v'},
        "<leader>gL",
        function()
          require("gitlinker").link({ action = require("gitlinker.actions").system })
        end,
        { silent = true, noremap = true, desc = "GitLink!" }
      )
      -- blame
      vim.keymap.set(
        {"n", 'v'},
        "<leader>gb",
        function()
          require("gitlinker").link({ router_type = "blame" })
        end,
        { silent = true, noremap = true, desc = "GitLink blame" }
      )
      vim.keymap.set(
        {"n", 'v'},
        "<leader>gB",
        function()
          require("gitlinker").link({
            router_type = "blame",
            action = require("gitlinker.actions").system,
          })
        end,
        { silent = true, noremap = true, desc = "GitLink! blame" }
      )
      -- default branch
      vim.keymap.set(
        {"n", 'v'},
        "<leader>gd",
        function()
          require("gitlinker").link({ router_type = "default_branch" })
        end,
        { silent = true, noremap = true, desc = "GitLink default_branch" }
      )
      vim.keymap.set(
        {"n", 'v'},
        "<leader>gD",
        function()
          require("gitlinker").link({
            router_type = "default_branch",
            action = require("gitlinker.actions").system,
          })
        end,
        { silent = true, noremap = true, desc = "GitLink! default_branch" }
      )
      -- default branch
      vim.keymap.set(
        {"n", 'v'},
        "<leader>gc",
        function()
          require("gitlinker").link({ router_type = "current_branch" })
        end,
        { silent = true, noremap = true, desc = "GitLink current_branch" }
      )
      vim.keymap.set(
        {"n", 'v'},
        "<leader>gC",
        function()
          require("gitlinker").link({
            router_type = "current_branch",
            action = require("gitlinker.actions").system,
          })
        end,
        { silent = true, noremap = true, desc = "GitLink! current_branch" }
      )
      
      
      require('gitlinker').setup(opts)
      
      
      require("gitlinker").setup({
        router = {
          browse = {
            ["^github%.your%.host"] = "https://github.your.host/"
              .. "{_A.ORG}/"
              .. "{_A.REPO}/blob/"
              .. "{_A.REV}/"
              .. "{_A.FILE}"
              .. "?&lines={_A.LSTART}"
              .. "{_A.LEND > _A.LSTART and ('&lines-count=' .. _A.LEND - _A.LSTART + 1) or ''}",
          },
        },
      })
      
      
      --- @param s string
      --- @param t string
      local function string_endswith(s, t)
        return string.len(s) >= string.len(t) and string.sub(s, #s - #t + 1) == t
      end
      
      --- @param lk gitlinker.Linker
      local function your_router(lk)
        local builder = "https://"
        -- host
        builder = builder .. lk.host .. "/"
        -- org
        builder = builder .. lk.org .. "/"
        -- repo
        builder = builder
          .. (string_endswith(lk.repo, ".git") and lk.repo:sub(1, #lk.repo - 4) or lk.repo)
          .. "/"
        -- rev
        builder = lk.rev .. "/"
        -- file
        builder = builder
          .. lk.file
          .. (string_endswith(lk.file, ".md") and "?plain=1" or "")
        -- line range
        builder = builder .. string.format("&lines=%d", lk.lstart)
        if lk.lend > lk.lstart then
          builder = builder
            .. string.format("&lines-count=%d", lk.lend - lk.lstart + 1)
        end
        return builder
      end
      
      require("gitlinker").setup({
        router = {
          browse = {
            ["^github%.your%.host"] = your_router,
          },
        },
      })
      
      
      require('gitlinker').setup({
        router = {
          browse = {
            ["^github%.your%.host"] = require('gitlinker.routers').github_browse,
          },
          blame = {
            ["^github%.your%.host"] = require('gitlinker.routers').github_blame,
          },
        }
      })
      
      
      require("gitlinker").setup({
        router = {
          file_only = {
            ["^github%.com"] = "https://github.com/"
              .. "{_A.ORG}/"
              .. "{_A.REPO}/blob/"
              .. "{_A.REV}/"
              .. "{_A.FILE}"
          },
        },
      })
      
    end,
  },
  {
    "tanvirtin/vgit.nvim",
    config = function()
      
      use {
        'tanvirtin/vgit.nvim',
        requires = { 'nvim-lua/plenary.nvim', 'nvim-tree/nvim-web-devicons' },
        -- Lazy loading on 'VimEnter' event is necessary.
        event = 'VimEnter',
        config = function() require("vgit").setup() end,
      }
      
      
      {
        'tanvirtin/vgit.nvim',
        dependencies = { 'nvim-lua/plenary.nvim', 'nvim-tree/nvim-web-devicons' },
        -- Lazy loading on 'VimEnter' event is necessary.
        event = 'VimEnter',
        config = function() require("vgit").setup() end,
      }
      
      
      require('vgit').setup()
      
      
      require('vgit').setup({
        keymaps = {
          ['n <C-k>'] = function() require('vgit').hunk_up() end,
          {
            mode = 'n',
            key = '<C-j>',
            handler = 'hunk_down',
            desc = 'Go down in the direction of the hunk',
          }
          ['n <leader>gs'] = function() require('vgit').buffer_hunk_stage() end,
          ['n <leader>gr'] = function() require('vgit').buffer_hunk_reset() end,
          ['n <leader>gp'] = function() require('vgit').buffer_hunk_preview() end,
          ['n <leader>gb'] = 'buffer_blame_preview',
          ['n <leader>gf'] = function() require('vgit').buffer_diff_preview() end,
          ['n <leader>gh'] = function() require('vgit').buffer_history_preview() end,
          ['n <leader>gu'] = function() require('vgit').buffer_reset() end,
          ['n <leader>gd'] = function() require('vgit').project_diff_preview() end,
          ['n <leader>gx'] = function() require('vgit').toggle_diff_preference() end,
        },
        settings = {
          -- You can either allow corresponding mapping for existing hl, or re-define them yourself entirely.
          hls = {
            GitCount = 'Keyword',
            GitSymbol = 'CursorLineNr',
            GitTitle = 'Directory',
            GitSelected = 'QuickfixLine',
            GitBackground = 'Normal',
            GitAppBar = 'StatusLine',
            GitHeader = 'NormalFloat',
            GitFooter = 'NormalFloat',
            GitBorder = 'LineNr',
            GitLineNr = 'LineNr',
            GitComment = 'Comment',
            GitSignsAdd = {
              gui = nil,
              fg = '#d7ffaf',
              bg = nil,
              sp = nil,
              override = false,
            },
            GitSignsChange = {
              gui = nil,
              fg = '#7AA6DA',
              bg = nil,
              sp = nil,
              override = false,
            },
            GitSignsDelete = {
              gui = nil,
              fg = '#e95678',
              bg = nil,
              sp = nil,
              override = false,
            },
            GitSignsAddLn = 'DiffAdd',
            GitSignsDeleteLn = 'DiffDelete',
            GitWordAdd = {
              gui = nil,
              fg = nil,
              bg = '#5d7a22',
              sp = nil,
              override = false,
            },
            GitWordDelete = {
              gui = nil,
              fg = nil,
              bg = '#960f3d',
              sp = nil,
              override = false,
            },
            GitConflictCurrentMark = 'DiffAdd',
            GitConflictAncestorMark = 'Visual',
            GitConflictIncomingMark = 'DiffChange',
            GitConflictCurrent = 'DiffAdd',
            GitConflictAncestor = 'Visual',
            GitConflictMiddle = 'Visual',
            GitConflictIncoming = 'DiffChange',
          },
          live_blame = {
            enabled = true,
            format = function(blame, git_config)
              local config_author = git_config['user.name']
              local author = blame.author
              if config_author == author then
                author = 'You'
              end
              local time = os.difftime(os.time(), blame.author_time)
                / (60 * 60 * 24 * 30 * 12)
              local time_divisions = {
                { 1, 'years' },
                { 12, 'months' },
                { 30, 'days' },
                { 24, 'hours' },
                { 60, 'minutes' },
                { 60, 'seconds' },
              }
              local counter = 1
              local time_division = time_divisions[counter]
              local time_boundary = time_division[1]
              local time_postfix = time_division[2]
              while time < 1 and counter ~= #time_divisions do
                time_division = time_divisions[counter]
                time_boundary = time_division[1]
                time_postfix = time_division[2]
                time = time * time_boundary
                counter = counter + 1
              end
              local commit_message = blame.commit_message
              if not blame.committed then
                author = 'You'
                commit_message = 'Uncommitted changes'
                return string.format(' %s • %s', author, commit_message)
              end
              local max_commit_message_length = 255
              if #commit_message > max_commit_message_length then
                commit_message = commit_message:sub(1, max_commit_message_length) .. '...'
              end
              return string.format(
                ' %s, %s • %s',
                author,
                string.format(
                  '%s %s ago',
                  time >= 0 and math.floor(time + 0.5) or math.ceil(time - 0.5),
                  time_postfix
                ),
                commit_message
              )
            end,
          },
          live_gutter = {
            enabled = true,
            edge_navigation = true, -- This allows users to navigate within a hunk
          },
          scene = {
            diff_preference = 'unified', -- unified or split
            keymaps = {
              quit = 'q'
            }
          },
          diff_preview = {
            keymaps = {
              reset = 'r',
              buffer_stage = 'S',
              buffer_unstage = 'U',
              buffer_hunk_stage = 's',
              buffer_hunk_unstage = 'u',
              toggle_view = 't',
            },
          },
          project_diff_preview = {
            keymaps = {
              commit = 'C',
              buffer_stage = 's',
              buffer_unstage = 'u',
              buffer_hunk_stage = 'gs',
              buffer_hunk_unstage = 'gu',
              buffer_reset = 'r',
              stage_all = 'S',
              unstage_all = 'U',
              reset_all = 'R',
            },
          },
          project_stash_preview = {
            keymaps = {
              add = 'A',
              apply = 'a',
              pop = 'p',
              drop = 'd',
              clear = 'C'
            },
          },
          project_logs_preview = {
            keymaps = {
              previous = '-',
              next = '=',
            },
          },
          project_commit_preview = {
            keymaps = {
              save = 'S',
            },
          },
          signs = {
            priority = 10,
            definitions = {
              -- The sign definitions you provide will automatically be instantiated for you.
              GitConflictCurrentMark = {
                linehl = 'GitConflictCurrentMark',
                texthl = nil,
                numhl = nil,
                icon = nil,
                text = '',
              },
              GitConflictAncestorMark = {
                linehl = 'GitConflictAncestorMark',
                texthl = nil,
                numhl = nil,
                icon = nil,
                text = '',
              },
              GitConflictIncomingMark = {
                linehl = 'GitConflictIncomingMark',
                texthl = nil,
                numhl = nil,
                icon = nil,
                text = '',
              },
              GitConflictCurrent = {
                linehl = 'GitConflictCurrent',
                texthl = nil,
                numhl = nil,
                icon = nil,
                text = '',
              },
              GitConflictAncestor = {
                linehl = 'GitConflictAncestor',
                texthl = nil,
                numhl = nil,
                icon = nil,
                text = '',
              },
              GitConflictMiddle = {
                linehl = 'GitConflictMiddle',
                texthl = nil,
                numhl = nil,
                icon = nil,
                text = '',
              },
              GitConflictIncoming = {
                linehl = 'GitConflictIncoming',
                texthl = nil,
                numhl = nil,
                icon = nil,
                text = '',
              },
              GitSignsAddLn = {
                linehl = 'GitSignsAddLn',
                texthl = nil,
                numhl = nil,
                icon = nil,
                text = '',
              },
              GitSignsDeleteLn = {
                linehl = 'GitSignsDeleteLn',
                texthl = nil,
                numhl = nil,
                icon = nil,
                text = '',
              },
              GitSignsAdd = {
                texthl = 'GitSignsAdd',
                numhl = nil,
                icon = nil,
                linehl = nil,
                text = '┃',
              },
              GitSignsDelete = {
                texthl = 'GitSignsDelete',
                numhl = nil,
                icon = nil,
                linehl = nil,
                text = '┃',
              },
              GitSignsChange = {
                texthl = 'GitSignsChange',
                numhl = nil,
                icon = nil,
                linehl = nil,
                text = '┃',
              },
            },
            usage = {
              -- Please ensure these signs are defined.
              screen = {
                add = 'GitSignsAddLn',
                remove = 'GitSignsDeleteLn',
                conflict_current_mark = 'GitConflictCurrentMark',
                conflict_current = 'GitConflictCurrent',
                conflict_middle = 'GitConflictMiddle',
                conflict_incoming_mark = 'GitConflictIncomingMark',
                conflict_incoming = 'GitConflictIncoming',
                conflict_ancestor_mark = 'GitConflictAncestorMark',
                conflict_ancestor = 'GitConflictAncestor'
              },
              main = {
                add = 'GitSignsAdd',
                remove = 'GitSignsDelete',
                change = 'GitSignsChange',
              },
            },
          },
          symbols = {
            void = '⣿',
            open = '',
            close = '',
          },
        }
      })
      
    end,
  },
  {
    "sindrets/diffview.nvim",
    config = function()
      
      -- Packer
      use "sindrets/diffview.nvim" 
      
      
      -- Lua
      local actions = require("diffview.actions")
      
      require("diffview").setup({
        diff_binaries = false,    -- Show diffs for binaries
        enhanced_diff_hl = false, -- See |diffview-config-enhanced_diff_hl|
        git_cmd = { "git" },      -- The git executable followed by default args.
        hg_cmd = { "hg" },        -- The hg executable followed by default args.
        use_icons = true,         -- Requires nvim-web-devicons
        show_help_hints = true,   -- Show hints for how to open the help panel
        watch_index = true,       -- Update views and index buffers when the git index changes.
        icons = {                 -- Only applies when use_icons is true.
          folder_closed = "",
          folder_open = "",
        },
        signs = {
          fold_closed = "",
          fold_open = "",
          done = "✓",
        },
        view = {
          -- Configure the layout and behavior of different types of views.
          -- Available layouts:
          --  'diff1_plain'
          --    |'diff2_horizontal'
          --    |'diff2_vertical'
          --    |'diff3_horizontal'
          --    |'diff3_vertical'
          --    |'diff3_mixed'
          --    |'diff4_mixed'
          -- For more info, see |diffview-config-view.x.layout|.
          default = {
            -- Config for changed files, and staged files in diff views.
            layout = "diff2_horizontal",
            disable_diagnostics = false,  -- Temporarily disable diagnostics for diff buffers while in the view.
            winbar_info = false,          -- See |diffview-config-view.x.winbar_info|
          },
          merge_tool = {
            -- Config for conflicted files in diff views during a merge or rebase.
            layout = "diff3_horizontal",
            disable_diagnostics = true,   -- Temporarily disable diagnostics for diff buffers while in the view.
            winbar_info = true,           -- See |diffview-config-view.x.winbar_info|
          },
          file_history = {
            -- Config for changed files in file history views.
            layout = "diff2_horizontal",
            disable_diagnostics = false,  -- Temporarily disable diagnostics for diff buffers while in the view.
            winbar_info = false,          -- See |diffview-config-view.x.winbar_info|
          },
        },
        file_panel = {
          listing_style = "tree",             -- One of 'list' or 'tree'
          tree_options = {                    -- Only applies when listing_style is 'tree'
            flatten_dirs = true,              -- Flatten dirs that only contain one single dir
            folder_statuses = "only_folded",  -- One of 'never', 'only_folded' or 'always'.
          },
          win_config = {                      -- See |diffview-config-win_config|
            position = "left",
            width = 35,
            win_opts = {},
          },
        },
        file_history_panel = {
          log_options = {   -- See |diffview-config-log_options|
            git = {
              single_file = {
                diff_merges = "combined",
              },
              multi_file = {
                diff_merges = "first-parent",
              },
            },
            hg = {
              single_file = {},
              multi_file = {},
            },
          },
          win_config = {    -- See |diffview-config-win_config|
            position = "bottom",
            height = 16,
            win_opts = {},
          },
        },
        commit_log_panel = {
          win_config = {},  -- See |diffview-config-win_config|
        },
        default_args = {    -- Default args prepended to the arg-list for the listed commands
          DiffviewOpen = {},
          DiffviewFileHistory = {},
        },
        hooks = {},         -- See |diffview-config-hooks|
        keymaps = {
          disable_defaults = false, -- Disable the default keymaps
          view = {
            -- The `view` bindings are active in the diff buffers, only when the current
            -- tabpage is a Diffview.
            { "n", "<tab>",       actions.select_next_entry,              { desc = "Open the diff for the next file" } },
            { "n", "<s-tab>",     actions.select_prev_entry,              { desc = "Open the diff for the previous file" } },
            { "n", "[F",          actions.select_first_entry,             { desc = "Open the diff for the first file" } },
            { "n", "]F",          actions.select_last_entry,              { desc = "Open the diff for the last file" } },
            { "n", "gf",          actions.goto_file_edit,                 { desc = "Open the file in the previous tabpage" } },
            { "n", "<C-w><C-f>",  actions.goto_file_split,                { desc = "Open the file in a new split" } },
            { "n", "<C-w>gf",     actions.goto_file_tab,                  { desc = "Open the file in a new tabpage" } },
            { "n", "<leader>e",   actions.focus_files,                    { desc = "Bring focus to the file panel" } },
            { "n", "<leader>b",   actions.toggle_files,                   { desc = "Toggle the file panel." } },
            { "n", "g<C-x>",      actions.cycle_layout,                   { desc = "Cycle through available layouts." } },
            { "n", "[x",          actions.prev_conflict,                  { desc = "In the merge-tool: jump to the previous conflict" } },
            { "n", "]x",          actions.next_conflict,                  { desc = "In the merge-tool: jump to the next conflict" } },
            { "n", "<leader>co",  actions.conflict_choose("ours"),        { desc = "Choose the OURS version of a conflict" } },
            { "n", "<leader>ct",  actions.conflict_choose("theirs"),      { desc = "Choose the THEIRS version of a conflict" } },
            { "n", "<leader>cb",  actions.conflict_choose("base"),        { desc = "Choose the BASE version of a conflict" } },
            { "n", "<leader>ca",  actions.conflict_choose("all"),         { desc = "Choose all the versions of a conflict" } },
            { "n", "dx",          actions.conflict_choose("none"),        { desc = "Delete the conflict region" } },
            { "n", "<leader>cO",  actions.conflict_choose_all("ours"),    { desc = "Choose the OURS version of a conflict for the whole file" } },
            { "n", "<leader>cT",  actions.conflict_choose_all("theirs"),  { desc = "Choose the THEIRS version of a conflict for the whole file" } },
            { "n", "<leader>cB",  actions.conflict_choose_all("base"),    { desc = "Choose the BASE version of a conflict for the whole file" } },
            { "n", "<leader>cA",  actions.conflict_choose_all("all"),     { desc = "Choose all the versions of a conflict for the whole file" } },
            { "n", "dX",          actions.conflict_choose_all("none"),    { desc = "Delete the conflict region for the whole file" } },
          },
          diff1 = {
            -- Mappings in single window diff layouts
            { "n", "g?", actions.help({ "view", "diff1" }), { desc = "Open the help panel" } },
          },
          diff2 = {
            -- Mappings in 2-way diff layouts
            { "n", "g?", actions.help({ "view", "diff2" }), { desc = "Open the help panel" } },
          },
          diff3 = {
            -- Mappings in 3-way diff layouts
            { { "n", "x" }, "2do",  actions.diffget("ours"),            { desc = "Obtain the diff hunk from the OURS version of the file" } },
            { { "n", "x" }, "3do",  actions.diffget("theirs"),          { desc = "Obtain the diff hunk from the THEIRS version of the file" } },
            { "n",          "g?",   actions.help({ "view", "diff3" }),  { desc = "Open the help panel" } },
          },
          diff4 = {
            -- Mappings in 4-way diff layouts
            { { "n", "x" }, "1do",  actions.diffget("base"),            { desc = "Obtain the diff hunk from the BASE version of the file" } },
            { { "n", "x" }, "2do",  actions.diffget("ours"),            { desc = "Obtain the diff hunk from the OURS version of the file" } },
            { { "n", "x" }, "3do",  actions.diffget("theirs"),          { desc = "Obtain the diff hunk from the THEIRS version of the file" } },
            { "n",          "g?",   actions.help({ "view", "diff4" }),  { desc = "Open the help panel" } },
          },
          file_panel = {
            { "n", "j",              actions.next_entry,                     { desc = "Bring the cursor to the next file entry" } },
            { "n", "<down>",         actions.next_entry,                     { desc = "Bring the cursor to the next file entry" } },
            { "n", "k",              actions.prev_entry,                     { desc = "Bring the cursor to the previous file entry" } },
            { "n", "<up>",           actions.prev_entry,                     { desc = "Bring the cursor to the previous file entry" } },
            { "n", "<cr>",           actions.select_entry,                   { desc = "Open the diff for the selected entry" } },
            { "n", "o",              actions.select_entry,                   { desc = "Open the diff for the selected entry" } },
            { "n", "l",              actions.select_entry,                   { desc = "Open the diff for the selected entry" } },
            { "n", "<2-LeftMouse>",  actions.select_entry,                   { desc = "Open the diff for the selected entry" } },
            { "n", "-",              actions.toggle_stage_entry,             { desc = "Stage / unstage the selected entry" } },
            { "n", "s",              actions.toggle_stage_entry,             { desc = "Stage / unstage the selected entry" } },
            { "n", "S",              actions.stage_all,                      { desc = "Stage all entries" } },
            { "n", "U",              actions.unstage_all,                    { desc = "Unstage all entries" } },
            { "n", "X",              actions.restore_entry,                  { desc = "Restore entry to the state on the left side" } },
            { "n", "L",              actions.open_commit_log,                { desc = "Open the commit log panel" } },
            { "n", "zo",             actions.open_fold,                      { desc = "Expand fold" } },
            { "n", "h",              actions.close_fold,                     { desc = "Collapse fold" } },
            { "n", "zc",             actions.close_fold,                     { desc = "Collapse fold" } },
            { "n", "za",             actions.toggle_fold,                    { desc = "Toggle fold" } },
            { "n", "zR",             actions.open_all_folds,                 { desc = "Expand all folds" } },
            { "n", "zM",             actions.close_all_folds,                { desc = "Collapse all folds" } },
            { "n", "<c-b>",          actions.scroll_view(-0.25),             { desc = "Scroll the view up" } },
            { "n", "<c-f>",          actions.scroll_view(0.25),              { desc = "Scroll the view down" } },
            { "n", "<tab>",          actions.select_next_entry,              { desc = "Open the diff for the next file" } },
            { "n", "<s-tab>",        actions.select_prev_entry,              { desc = "Open the diff for the previous file" } },
            { "n", "[F",             actions.select_first_entry,             { desc = "Open the diff for the first file" } },
            { "n", "]F",             actions.select_last_entry,              { desc = "Open the diff for the last file" } },
            { "n", "gf",             actions.goto_file_edit,                 { desc = "Open the file in the previous tabpage" } },
            { "n", "<C-w><C-f>",     actions.goto_file_split,                { desc = "Open the file in a new split" } },
            { "n", "<C-w>gf",        actions.goto_file_tab,                  { desc = "Open the file in a new tabpage" } },
            { "n", "i",              actions.listing_style,                  { desc = "Toggle between 'list' and 'tree' views" } },
            { "n", "f",              actions.toggle_flatten_dirs,            { desc = "Flatten empty subdirectories in tree listing style" } },
            { "n", "R",              actions.refresh_files,                  { desc = "Update stats and entries in the file list" } },
            { "n", "<leader>e",      actions.focus_files,                    { desc = "Bring focus to the file panel" } },
            { "n", "<leader>b",      actions.toggle_files,                   { desc = "Toggle the file panel" } },
            { "n", "g<C-x>",         actions.cycle_layout,                   { desc = "Cycle available layouts" } },
            { "n", "[x",             actions.prev_conflict,                  { desc = "Go to the previous conflict" } },
            { "n", "]x",             actions.next_conflict,                  { desc = "Go to the next conflict" } },
            { "n", "g?",             actions.help("file_panel"),             { desc = "Open the help panel" } },
            { "n", "<leader>cO",     actions.conflict_choose_all("ours"),    { desc = "Choose the OURS version of a conflict for the whole file" } },
            { "n", "<leader>cT",     actions.conflict_choose_all("theirs"),  { desc = "Choose the THEIRS version of a conflict for the whole file" } },
            { "n", "<leader>cB",     actions.conflict_choose_all("base"),    { desc = "Choose the BASE version of a conflict for the whole file" } },
            { "n", "<leader>cA",     actions.conflict_choose_all("all"),     { desc = "Choose all the versions of a conflict for the whole file" } },
            { "n", "dX",             actions.conflict_choose_all("none"),    { desc = "Delete the conflict region for the whole file" } },
          },
          file_history_panel = {
            { "n", "g!",            actions.options,                     { desc = "Open the option panel" } },
            { "n", "<C-A-d>",       actions.open_in_diffview,            { desc = "Open the entry under the cursor in a diffview" } },
            { "n", "y",             actions.copy_hash,                   { desc = "Copy the commit hash of the entry under the cursor" } },
            { "n", "L",             actions.open_commit_log,             { desc = "Show commit details" } },
            { "n", "X",             actions.restore_entry,               { desc = "Restore file to the state from the selected entry" } },
            { "n", "zo",            actions.open_fold,                   { desc = "Expand fold" } },
            { "n", "zc",            actions.close_fold,                  { desc = "Collapse fold" } },
            { "n", "h",             actions.close_fold,                  { desc = "Collapse fold" } },
            { "n", "za",            actions.toggle_fold,                 { desc = "Toggle fold" } },
            { "n", "zR",            actions.open_all_folds,              { desc = "Expand all folds" } },
            { "n", "zM",            actions.close_all_folds,             { desc = "Collapse all folds" } },
            { "n", "j",             actions.next_entry,                  { desc = "Bring the cursor to the next file entry" } },
            { "n", "<down>",        actions.next_entry,                  { desc = "Bring the cursor to the next file entry" } },
            { "n", "k",             actions.prev_entry,                  { desc = "Bring the cursor to the previous file entry" } },
            { "n", "<up>",          actions.prev_entry,                  { desc = "Bring the cursor to the previous file entry" } },
            { "n", "<cr>",          actions.select_entry,                { desc = "Open the diff for the selected entry" } },
            { "n", "o",             actions.select_entry,                { desc = "Open the diff for the selected entry" } },
            { "n", "l",             actions.select_entry,                { desc = "Open the diff for the selected entry" } },
            { "n", "<2-LeftMouse>", actions.select_entry,                { desc = "Open the diff for the selected entry" } },
            { "n", "<c-b>",         actions.scroll_view(-0.25),          { desc = "Scroll the view up" } },
            { "n", "<c-f>",         actions.scroll_view(0.25),           { desc = "Scroll the view down" } },
            { "n", "<tab>",         actions.select_next_entry,           { desc = "Open the diff for the next file" } },
            { "n", "<s-tab>",       actions.select_prev_entry,           { desc = "Open the diff for the previous file" } },
            { "n", "[F",            actions.select_first_entry,          { desc = "Open the diff for the first file" } },
            { "n", "]F",            actions.select_last_entry,           { desc = "Open the diff for the last file" } },
            { "n", "gf",            actions.goto_file_edit,              { desc = "Open the file in the previous tabpage" } },
            { "n", "<C-w><C-f>",    actions.goto_file_split,             { desc = "Open the file in a new split" } },
            { "n", "<C-w>gf",       actions.goto_file_tab,               { desc = "Open the file in a new tabpage" } },
            { "n", "<leader>e",     actions.focus_files,                 { desc = "Bring focus to the file panel" } },
            { "n", "<leader>b",     actions.toggle_files,                { desc = "Toggle the file panel" } },
            { "n", "g<C-x>",        actions.cycle_layout,                { desc = "Cycle available layouts" } },
            { "n", "g?",            actions.help("file_history_panel"),  { desc = "Open the help panel" } },
          },
          option_panel = {
            { "n", "<tab>", actions.select_entry,          { desc = "Change the current option" } },
            { "n", "q",     actions.close,                 { desc = "Close the panel" } },
            { "n", "g?",    actions.help("option_panel"),  { desc = "Open the help panel" } },
          },
          help_panel = {
            { "n", "q",     actions.close,  { desc = "Close help menu" } },
            { "n", "<esc>", actions.close,  { desc = "Close help menu" } },
          },
        },
      })
      
      
      hooks = {
        diff_buf_read = function(bufnr)
          -- Change local options in diff buffers
          vim.opt_local.wrap = false
          vim.opt_local.list = false
          vim.opt_local.colorcolumn = { 80 }
        end,
        view_opened = function(view)
          print(
            ("A new %s was opened on tab page %d!")
            :format(view.class:name(), view.tabpage)
          )
        end,
      }
      
      
        view = {
          -- Vim command:
          ["a"] = "<Cmd>echom 'foo'<CR>",
          -- Lua function:
          ["b"] = function() print("bar") end,
        }
      
      
      view = {
        -- Normal and visual mode mapping to vim command:
        { { "n", "v" }, "<leader>a", "<Cmd>echom 'foo'<CR>", { silent = true } },
        -- Visual mode mapping to lua function:
        { "v", "<leader>b", function() print("bar") end, { nowait = true } },
      }
      
      
        view = {
          -- Disable the default normal mode mapping for `<tab>`:
          ["<tab>"] = false,
          -- Disable the default visual mode mapping for `gf`:
          { "x", "gf", false },
        }
      
    end,
  },
  {
    "kdheepak/lazygit.nvim",
    config = function()
      
      -- nvim v0.7.2
      use({
          "kdheepak/lazygit.nvim",
          -- optional for floating window border decoration
          requires = {
              "nvim-lua/plenary.nvim",
          },
      })
      
      
      -- nvim v0.8.0
      return {
          "kdheepak/lazygit.nvim",
          lazy = true,
          cmd = {
              "LazyGit",
              "LazyGitConfig",
              "LazyGitCurrentFile",
              "LazyGitFilter",
              "LazyGitFilterCurrentFile",
          },
          -- optional for floating window border decoration
          dependencies = {
              "nvim-lua/plenary.nvim",
          },
          -- setting the keybinding for LazyGit with 'keys' is recommended in
          -- order to load the plugin when the command is run for the first time
          keys = {
              { "<leader>lg", "<cmd>LazyGit<cr>", desc = "LazyGit" }
          }
      }
      
      
      vim.g.lazygit_floating_window_winblend = 0 -- transparency of floating window
      vim.g.lazygit_floating_window_scaling_factor = 0.9 -- scaling factor for floating window
      vim.g.lazygit_floating_window_border_chars = {'╭','─', '╮', '│', '╯','─', '╰', '│'} -- customize lazygit popup window border characters
      vim.g.lazygit_floating_window_use_plenary = 0 -- use plenary.nvim to manage floating window if available
      vim.g.lazygit_use_neovim_remote = 1 -- fallback to 0 if neovim-remote is not installed
      
      vim.g.lazygit_use_custom_config_file_path = 0 -- config file path is evaluated if this value is 1
      vim.g.lazygit_config_file_path = '' -- custom config file path
      -- OR
      vim.g.lazygit_config_file_path = {} -- table of custom config file paths
      
      vim.g.lazygit_on_exit_callback = nil -- optional function callback when exiting lazygit (useful for example to refresh some UI elements after lazy git has made some changes)
      
      
      -- nvim v0.7.2
      use({
          "kdheepak/lazygit.nvim",
          requires = {
              "nvim-telescope/telescope.nvim",
              "nvim-lua/plenary.nvim",
          },
          config = function()
              require("telescope").load_extension("lazygit")
          end,
      })
      
      
      -- nvim v0.8.0
      {
          "kdheepak/lazygit.nvim",
          lazy = false,
          cmd = {
              "LazyGit",
              "LazyGitConfig",
              "LazyGitCurrentFile",
              "LazyGitFilter",
              "LazyGitFilterCurrentFile",
          },
          -- optional for floating window border decoration
          dependencies = {
              "nvim-telescope/telescope.nvim",
              "nvim-lua/plenary.nvim",
          },
          config = function()
              require("telescope").load_extension("lazygit")
          end,
      }
      
      
      require('telescope').load_extension('lazygit')
      
      
      lua require("telescope").extensions.lazygit.lazygit()
      
    end,
  },
  {
    "AckslD/nvim-gfold.lua",
    config = function()
      
      use {
        "AckslD/nvim-gfold.lua",
        config = function()
          require('gfold').setup()
        end,
      }
      
      
      {
        -- base directory to look for repos
        -- defaults to home
        cwd = vim.fn.getenv('HOME'),
      
        -- if true, no error is shown if the call to gfold fails
        no_error = false,
      
        -- What symbols to use, for both picker and status
        status_symbols = {
          clean = '✔',
          unclean = '✘',
          unpushed = '',
          bare = '',
        },
      
        -- settings specific to the picker
        picker = {
          -- how to format an entry in the picker
          -- default will be something like:
          --   ✔ nvim-gfold.lua (/home/path/to/nvim-gfold.lua)
          format_item = function(repo)
            return string.format(
            '%s %s (%s)',
            require('gfold.settings').status_symbols[repo.status],
            repo.name,
            repo.path
            )
          end,
      
          -- what to do when selecting a repo
          -- by default changes cwd
          on_select = require('gfold.actions').change_cwd,
        },
      
        -- settings specific to the status(line)
        status = {
          -- if we should continuously update the summary
          enable = true,
      
          -- how long to wait in between querying repo statuses
          -- NOTE this is the time from the last process ran until starting it again
          -- so the interval will be whatever time it takes to run gfold plus this setting
          -- Default is 5 seconds but if for some reason you want this to be updated more frequently
          -- you can always make this value smaller.
          update_delay = 5000,
      
          -- What color of highlights to use
          -- Values are either:
          --   * string: a highlight group
          --   * table: eg `{fg = '#b8bb26'}`
          colors = {
            clean = {fg = '#b8bb26'},
            unclean = {fg = '#fb4934'},
            unpushed = {fg = '#fe8019'},
            bare = {fg = '#fabd2f'},
          },
      
          -- In which order to show the components of the summary
          order = {
            'clean',
            'unclean',
            'unpushed',
            'bare',
          },
        },
      }
      
      
      require('gfold').pick_repo(function(repo)
        return repo.status ~= 'clean'
      end)
      
      
      require('lualine').setup({
        ...
        sections = {
          ...
          lualine_x = {
            ...
            'gfold',
            ...
          },
          ...
        },
        ...
      })
      
      
      {
        unclean = <int>,
        clean = <int>,
        bare = <int>,
        unpushed = <int>,
      }
      
    end,
  },
  {
    "akinsho/git-conflict.nvim",
    config = function()
      
      -- packer.nvim
      use {'akinsho/git-conflict.nvim', tag = "*", config = function()
        require('git-conflict').setup()
      end}
      
      -- lazy.nvim
      {'akinsho/git-conflict.nvim', version = "*", config = true}
      
      
      {
        default_mappings = true, -- disable buffer local mapping created by this plugin
        default_commands = true, -- disable commands created by this plugin
        disable_diagnostics = false, -- This will disable the diagnostics in a buffer whilst it is conflicted
        list_opener = 'copen', -- command or function to open the conflicts list
        highlights = { -- They must have background color, otherwise the default color will be used
          incoming = 'DiffAdd',
          current = 'DiffText',
        }
      }
      
      
      vim.api.nvim_create_autocmd('User', {
        pattern = 'GitConflictDetected',
        callback = function()
          vim.notify('Conflict detected in '..vim.fn.expand('<afile>'))
          vim.keymap.set('n', 'cww', function()
            engage.conflict_buster()
            create_buffer_local_mappings()
          end)
        end
      })
      
      
      
      require'git-conflict'.setup {
        default_mappings = {
          ours = 'o',
          theirs = 't',
          none = '0',
          both = 'b',
          next = 'n',
          prev = 'p',
        },
      }
      
      
      vim.keymap.set('n', 'co', '<Plug>(git-conflict-ours)')
      vim.keymap.set('n', 'ct', '<Plug>(git-conflict-theirs)')
      vim.keymap.set('n', 'cb', '<Plug>(git-conflict-both)')
      vim.keymap.set('n', 'c0', '<Plug>(git-conflict-none)')
      vim.keymap.set('n', '[x', '<Plug>(git-conflict-prev-conflict)')
      vim.keymap.set('n', ']x', '<Plug>(git-conflict-next-conflict)')
      
    end,
  },
  {
    "aaronhallaert/advanced-git-search.nvim",
    config = function()
      
      {
          -- Browse command to open commits in browser. Default fugitive GBrowse.
          -- {commit_hash} is the placeholder for the commit hash.
          browse_command = "GBrowse {commit_hash}",
          -- when {commit_hash} is not provided, the commit will be appended to the specified command seperated by a space
          -- browse_command = "GBrowse",
          -- => both will result in calling `:GBrowse commit`
      
          -- fugitive or diffview
          diff_plugin = "fugitive",
          -- customize git in previewer
          -- e.g. flags such as { "--no-pager" }, or { "-c", "delta.side-by-side=false" }
          git_flags = {},
          -- customize git diff in previewer
          -- e.g. flags such as { "--raw" }
          git_diff_flags = {},
          git_log_flags = {},
          -- Show builtin git pickers when executing "show_custom_functions" or :AdvancedGitSearch
          show_builtin_git_pickers = false,
          entry_default_author_or_date = "author", -- one of "author", "date" or "both"
          keymaps = {
              -- following keymaps can be overridden
              toggle_date_author = "<C-w>",
              open_commit_in_browser = "<C-o>",
              copy_commit_hash = "<C-y>",
              show_entire_commit = "<C-e>",
          }
      
          -- Telescope layout setup
          telescope_theme = {
              function_name_1 = {
                  -- Theme options
              },
              function_name_2 = "dropdown"
              -- e.g. realistic example
              show_custom_functions = {
                  layout_config = { width = 0.4, height = 0.4 },
              },
      
          }
      }
      
      
      {
          "nvim-telescope/telescope.nvim",
          -- to show diff splits and open commits in browser
          "tpope/vim-fugitive",
          -- to open commits in browser with fugitive
          "tpope/vim-rhubarb",
          -- optional: to replace the diff from fugitive with diffview.nvim
          -- (fugitive is still needed to open in browser)
          -- "sindrets/diffview.nvim",
      }
      
      
      {
          "aaronhallaert/advanced-git-search.nvim",
          cmd = { "AdvancedGitSearch" },
          config = function()
              -- optional: setup telescope before loading the extension
              require("telescope").setup{
                  -- move this to the place where you call the telescope setup function
                  extensions = {
                      advanced_git_search = {
                              -- See Config
                          }
                  }
              }
      
              require("telescope").load_extension("advanced_git_search")
          end,
          dependencies = {
              --- See dependencies
          },
      }
      
      
      use({
          "aaronhallaert/advanced-git-search.nvim",
          config = function()
              -- optional: setup telescope before loading the extension
              require("telescope").setup{
                  -- move this to the place where you call the telescope setup function
                  extensions = {
                      advanced_git_search = {
                          -- Insert Config here
                      }
                  }
              }
      
              require("telescope").load_extension("advanced_git_search")
          end,
          requires = {
              -- Insert Dependencies here
          },
      })
      
      
      {
          "aaronhallaert/advanced-git-search.nvim",
          cmd = { "AdvancedGitSearch" },
          config = function()
              require("advanced_git_search.fzf").setup{
                  -- Insert Config here
              }
          end,
          dependencies = {
              -- Insert Dependencies here
          },
      }
      
      
      use({
          "aaronhallaert/advanced-git-search.nvim",
          config = function()
              require("advanced_git_search.fzf").setup{
                      -- Insert Config here
                  }
              }
          end,
          requires = {
              -- Insert Dependencies here
          },
      })
      
      
      {
          "aaronhallaert/advanced-git-search.nvim",
          cmd = { "AdvancedGitSearch" },
          config = function()
              require("advanced_git_search.snacks").setup{
                  -- Insert Config here
              }
          end,
          dependencies = {
            "folke/snacks.nvim"
          },
      }
      
      
      use({
          "aaronhallaert/advanced-git-search.nvim",
          config = function()
              require("advanced_git_search.snacks").setup{
                      -- Insert Config here
                  }
              }
          end,
          requires = {
              -- Insert Dependencies here
          },
      })
      
    end,
  },
  {
    "9seconds/repolink.nvim",
    config = function()
      
      {
        "9seconds/repolink.nvim",
        dependencies = {
          "nvim-lua/plenary.nvim"
        },
        cmd = {
          "RepoLink"
        },
      
        opts = {
          -- your configuration goes here.
          -- keep empty object if you are fine with defaults
        },
      }
      
      
      use {
        "9seconds/repolink.nvim",
        requires = {
          "nvim-lua/plenary.nvim"
        },
        opt = true,
        cmd = {
          "RepoLink"
        },
      
        config = function()
          require("repolink").setup({
            -- your configuration goes here.
            -- keep empty object if you are fine with defaults
          })
        end
      }
      
      
      {
        -- By default, repolink tries to create links with short commits
        -- like, 42dd21c instead of 42dd21cf54779c9175c4ff7450d91a9ad0387491
        -- If you like to have full commits, please enable this flag
        use_full_commit_hash = false,
      
        -- repolink takes remote URLs from git itself and can parse
        -- most common ones: from Github, Bitbucket, Sourcehut, Gitlab, Gitea, etc.
        -- but sometimes you can have a quite weird configuration, made with,
        -- for example, cgit, so the default one won't work for you.
        --
        -- If you provide this custom parser, it should be a function that
        -- parses a remote URL and returns a hostname and some data blob
        -- that could be used later, on URL building.
        --
        -- host parameter would be used to find out a function that is used
        -- to convert remote URL and repository data to an HTTP permalink
        --
        -- data parameter can be anything but you want to use the default URL
        -- builders, it should be a table of
        -- { user = "YOUR USER", project = "PROJECT NAME" }
        --
        -- Example of parser for git@github.com:9seconds/repolink.nvim.git URL:
        --
        --     function(remote_url)
        --         local host, user, project = string.match(
        --             remote_url,
        --             "^git@([^:]+):([^/]+)/(.+)%.git$")
        --         if host then
        --           return host, {
        --             user = user,
        --             project = project
        --           }
        --         end
        --     end
        custom_url_parser = nil,
      
        -- By default RepoLink just notifies about generated URL but if
        -- this setting is not nil, then URL could also be copied into
        -- a given register.
        --
        -- If you want to copy it into a register, run RepoLink! (with bang).
        bang_register = "+",
      
        -- repolink runs Git. Usually, it finishes quite fast but if you have a
        -- slow storage, like NFS, can take some time. This is a timeout
        -- after which repolink fails.
        timeout = 5000,
      
        -- a table of builders that maps a hostname to a function that builds URL.
        -- an example of such function (builder for GitHub):
        --
        --     function(args)
        --       local anchor = "L" .. tostring(args.start_line)
        --       if args.start_line ~= args.end_line then
        --         anchor = anchor .. "-L" .. tostring(args.end_line)
        --       end
        --
        --       return string.format(
        --         "https://github.com/%s/%s/blob/%s/%s#%s",
        --         args.host_data.user,
        --         args.host_data.project,
        --         args.commit_hash,
        --         args.path,
        --         anchor
        --       )
        --
        -- args is a table:
        --
        --    {
        --      start_line = 1
        --      end_line = 2,
        --      host = "github.com",
        --      host_data = {
        --        user = "9seconds",
        --        project = "repolink.nvim"
        --      },
        --      commit_hash = "42dd21c",
        --      path = "doc/repolink.txt",
        --    }
        url_builders = {
          ["github.com"] = require("repolink").url_builder_for_github("https://github.com"),
          ["bitbucket.org"] = require("repolink").url_builder_for_bitbucket("https://bitbucket.org"),
          ["gitlab.com"] = require("repolink").url_builder_for_gitlab("https://gitlab.com"),
          ["git.sr.ht"] = require("repolink").url_builder_for_sourcehut("https://git.sr.ht"),
        },
      }
      
      
      require("repolink").setup({
        use_full_commit_hash = true,
      })
      
      
      vim.keymap.set(
        {"n", "v"},
        "<leader>rl",
        "<cmd>RepoLink<cr>",
        { desc = "Generate HTTP permalink" })
      
    end,
  },
  {
    "chrisgrieser/nvim-tinygit",
    config = function()
      
      -- lazy.nvim
      { 
      	"chrisgrieser/nvim-tinygit",
      	-- dependencies = "nvim-telescope/telescope.nvim", -- only for interactive staging
      },
      
      -- packer
      use {
      	"chrisgrieser/nvim-tinygit",
      	-- requires = "nvim-telescope/telescope.nvim", -- only for interactive staging
      }
      
      
      -- default config
      require("tinygit").setup {
      	stage = { -- requires `telescope.nvim`
      		contextSize = 1, -- larger values "merge" hunks. 0 is not supported.
      		stagedIndicator = "󰐖",
      		keymaps = { -- insert & normal mode
      			stagingToggle = "<Space>", -- stage/unstage hunk
      			gotoHunk = "<CR>",
      			resetHunk = "<C-r>",
      		},
      		moveToNextHunkOnStagingToggle = false,
      
      		-- accepts the common telescope picker config
      		telescopeOpts = { 
      			layout_strategy = "horizontal",
      			layout_config = {
      				horizontal = {
      					preview_width = 0.65,
      					height = { 0.7, min = 20 },
      				},
      			},
      		},
      	},
      	commit = {
      		keepAbortedMsgSecs = 300,
      		border = getBorder(), -- `vim.o.winborder` on nvim 0.11, otherwise "rounded"
      		spellcheck = false, -- vim's builtin spellcheck
      		wrap = "hard", ---@type "hard"|"soft"|"none"
      		keymaps = {
      			normal = { abort = "q", confirm = "<CR>" },
      			insert = { confirm = "<C-CR>" },
      		},
      		subject = {
      			-- automatically apply formatting to the subject line
      			autoFormat = function(subject) ---@type nil|fun(subject: string): string
      				subject = subject:gsub("%.$", "") -- remove trailing dot https://commitlint.js.org/reference/rules.html#body-full-stop
      				return subject
      			end,
      
      			-- disallow commits that do not use an allowed type
      			enforceType = false,
      			-- stylua: ignore
      			types = {
      				"fix", "feat", "chore", "docs", "refactor", "build", "test",
      				"perf", "style", "revert", "ci", "break",
      			},
      		},
      		body = {
      			enforce = false,
      		},
      	},
      	push = {
      		preventPushingFixupCommits = true,
      		confirmationSound = true, -- currently macOS only, PRs welcome
      
      		-- If pushed commits contain references to issues, open them in the browser
      		-- (not used when force-pushing).
      		openReferencedIssues = false,
      	},
      	github = {
      		icons = {
      			openIssue = "🟢",
      			closedIssue = "🟣",
      			notPlannedIssue = "⚪",
      			openPR = "🟩",
      			mergedPR = "🟪",
      			draftPR = "⬜",
      			closedPR = "🟥",
      		},
      	},
      	history = {
      		diffPopup = {
      			width = 0.8, -- between 0-1
      			height = 0.8,
      			border = getBorder(), -- `vim.o.winborder` on nvim 0.11, otherwise "rounded"
      		},
      		autoUnshallowIfNeeded = false,
      	},
      	appearance = {
      		mainIcon = "󰊢",
      		backdrop = {
      			enabled = true,
      			blend = 40, -- 0-100
      		},
      	},
      	statusline = {
      		blame = {
      			ignoreAuthors = {}, -- hide component if from these authors (useful for bots)
      			hideAuthorNames = {}, -- show component, but hide names (useful for your own name)
      			maxMsgLen = 40,
      			icon = "ﰖ",
      		},
      		branchState = {
      			icons = {
      				ahead = "󰶣",
      				behind = "󰶡",
      				diverge = "󰃻",
      			},
      		},
      	},
      }
      
      
      require("tinygit").interactiveStaging()
      
      
      -- values shown are the defaults
      require("tinygit").smartCommit { pushIfClean = false, pullBeforePush = true }
      
      
      vim.keymap.set("n", "<leader>ga", function() require("tinygit").interactiveStaging() end, { desc = "git add" })
      vim.keymap.set("n", "<leader>gc", function() require("tinygit").smartCommit() end, { desc = "git commit" })
      vim.keymap.set("n", "<leader>gp", function() require("tinygit").push() end, { desc = "git push" })
      
      
      -- values shown are the defaults
      require("tinygit").amendOnlyMsg { forcePushIfDiverged = false }
      require("tinygit").amendNoEdit { forcePushIfDiverged = false, stageAllIfNothingStaged = true }
      
      
      -- values shown are the defaults
      require("tinygit").fixupCommit {
      	selectFromLastXCommits = 15,
      	autoRebase = false,
      }
      
      
      require("tinygit").undoLastCommitOrAmend()
      
      
      -- state: all|closed|open (default: all)
      -- type: all|issue|pr (default: all)
      require("tinygit").issuesAndPrs { type = "all", state = "all" }
      
      -- alternative: if the word under the cursor is of the form `#123`,
      -- open that issue/PR
      require("tinygit").openIssueUnderCursor()
      
      
      -- "file"|"repo"|"blame" (default: "file")
      require("tinygit").githubUrl("file")
      
      
      -- values shown are the defaults
      require("tinygit").push {
      	pullBefore = false,
      	forceWithLease = false,
      	createGitHubPr = false,
      }
      require("tinygit").createGitHubPr() -- to push before, use `.push { createGitHubPr = true }`
      
      
      require("tinygit").fileHistory()
      
      
      require("tinygit").stashPush()
      require("tinygit").stashPop()
      
      
      require("tinygit.statusline").blame()
      
      
      require("tinygit.statusline").branchState()
      
    end,
  },
  {
    "niuiic/git-log.nvim",
    config = function()
      
      require("git-log").check_log({
      	extra_args = {},
      	window_width_ratio = 0.6,
      	window_height_ratio = 0.8,
      	quit_key = "q",
      })
      
    end,
  },
  {
    "2KAbhishek/co-author.nvim",
    config = function()
      
      -- Lazy
      {
          '2kabhishek/co-author.nvim',
          dependencies = {
              'folke/snacks.nvim',
          },
          cmd = {'CoAuthor'},
      },
      
      -- Packer
      use '2kabhishek/co-author.nvim'
      
      
    end,
  },
  {
    "isak102/telescope-git-file-history.nvim",
    config = function()
      
      {
          "nvim-telescope/telescope.nvim",
          dependencies = {
              {
                  "isak102/telescope-git-file-history.nvim",
                  dependencies = {
                      "nvim-lua/plenary.nvim",
                      "tpope/vim-fugitive"
                  }
              }
          }
      }
      
      
      require("telescope").setup({
          -- Your telescope config here
      })
      
      require("telescope").load_extension("git_file_history")
      
      
      local gfh_actions = require("telescope").extensions.git_file_history.actions
      
      require("telescope").setup({
          -- The rest of your telescope config here
      
          extensions = {
              git_file_history = {
                  -- Keymaps inside the picker
                  mappings = {
                      i = {
                          ["<C-g>"] = gfh_actions.open_in_browser,
                      },
                      n = {
                          ["<C-g>"] = gfh_actions.open_in_browser,
                      },
                  },
      
                  -- The command to use for opening the browser (nil or string)
                  -- If nil, it will check if xdg-open, open, start, wslview are available, in that order.
                  browser_command = nil,
              },
          },
      })
      
      
      require("telescope").extensions.git_file_history.git_file_history()
      
    end,
  },
  {
    "moyiz/git-dev.nvim",
    config = function()
      
      {
        "moyiz/git-dev.nvim",
        event = "VeryLazy",
        opts = {},
      }
      
      
      {
        "moyiz/git-dev.nvim",
        lazy = true,
        cmd = {
          "GitDevClean",
          "GitDevCleanAll",
          "GitDevCloseBuffers",
          "GitDevOpen",
          "GitDevRecents",
          "GitDevToggleUI",
          "GitDevXDGHandle",
        },
        opts = {},
      }
      
      
      -- :GitDevOpen moyiz/git-dev.nvim
      require("git-dev").open("moyiz/git-dev.nvim")
      
      -- :GitDevOpen derailed/k9s {tag="v0.32.4"}
      require("git-dev").open("derailed/k9s", { tag = "v0.32.4" })
      
      -- :GitDevOpen echasnovski/mini.nvim {branch="stable"} {ephemeral=false}
      require("git-dev").open("echasnovski/mini.nvim", { branch = "stable "}, { ephemeral = false })
      
      -- :GitDevOpen https://git.savannah.gnu.org/git/bash.git {} {read_only=false}
      require("git-dev").open("https://git.savannah.gnu.org/git/bash.git", {}, { read_only = false })
      
      
      M.config = {
        -- Whether to delete an opened repository when nvim exits.
        -- If `true`, it will create an auto command for opened repositories
        -- to delete the local directory when nvim exists.
        ephemeral = true,
        -- Set buffers of opened repositories to be read-only and unmodifiable.
        read_only = true,
        -- Whether / how to CD into opened repository.
        ---@type "global"|"tab"|"window"|"none"
        cd_type = "global",
        -- The actual `open` behavior.
        ---@param dir string The path to the local repository.
        ---@param repo_uri string The URI that was used to clone this repository.
        ---@param selected_path? string A relative path to a file in this repository.
        opener = function(dir, repo_uri, selected_path)
          M.ui:print("Opening " .. repo_uri)
          local dest =
            vim.fn.fnameescape(selected_path and dir .. "/" .. selected_path or dir)
          vim.cmd("edit " .. dest)
        end,
        -- Location of cloned repositories. Should be dedicated for this purpose.
        repositories_dir = vim.fn.stdpath "cache" .. "/git-dev",
        -- Extend the builtin URL parsers.
        -- Should map domains to parse functions. See |parser.lua|.
        extra_domain_to_parser = nil,
        git = {
          -- Name / path of `git` command.
          command = "git",
          -- Default organization if none is specified.
          -- If given repository name does not contain '/' and `default_org` is
          -- not `nil` nor empty, it will be prepended to the given name.
          default_org = nil,
          -- Base URI to use when given repository name is scheme-less.
          base_uri_format = "https://github.com/%s.git",
          -- Arguments for `git clone`.
          -- Triggered when repository does not exist locally.
          -- It will clone submodules too, disable it if it is too slow.
          clone_args = "--jobs=2 --single-branch --recurse-submodules "
            .. "--shallow-submodules --progress",
          -- Arguments for `git fetch`.
          -- Triggered when repository already exists locally to refresh the local
          -- copy.
          fetch_args = "--jobs=2 --no-all --update-shallow -f --prune --no-tags",
          -- Arguments for `git checkout`.
          -- Triggered by `open` when a branch, tag or commit is given.
          checkout_args = "-f --recurse-submodules",
        },
        -- UI configuration.
        ui = {
          -- Whether to enable builtin output buffer or fallback to `vim.notify`.
          enabled = true,
          -- Auto-close window after repository was opened.
          auto_close = true,
          -- Delay window closing.
          close_after_ms = 3000,
          -- Window mode.
          ---@type "floating"|"split"
          mode = "floating",
          -- Window configuration for floating mode.
          -- See `:h nvim_open_win`.
          ---@type win_config
          floating_win_config = {
            title = "git-dev",
            title_pos = "center",
            anchor = "NE",
            style = "minimal",
            border = "rounded",
            relative = "editor",
            width = 79,
            height = 9,
            row = 1,
            col = vim.o.columns,
            noautocmd = true,
          },
          -- Window configuration for split mode.
          -- See `:h nvim_open_win`.
          ---@type win_config
          split_win_config = {
            split = "right",
            width = 79,
            noautocmd = true,
          },
        },
        -- History configuration.
        history = {
          -- Maximum number of records to keep in history.
          n = 32,
          -- Store file path.
          path = vim.fn.stdpath "data" .. "/git-dev/history.json",
        },
        -- Repository cleaning configuration.
        clean = {
          -- Close all related buffers.
          close_buffers = true,
          -- Whether to delete repository directory, keep it, or determine deletion
          -- by its current ephemeral setting.
          ---@type "always"|"never"|"current"
          delete_repo_dir = "current",
        },
        -- XDG handling of `nvim-getdev` URIs.
        -- Requires: `xdg-mime` and `xdg-open`.
        xdg_handler = {
          enabled = false,
          -- A location for the desktop entry.
          desktop_entry_path = vim.fs.normalize(
            vim.fn.stdpath "data" .. "/../applications/git-dev.desktop"
          ),
          -- Launcher script.
          script = {
            path = vim.fn.expand "~/.local/bin/git-dev-open",
            content = '#!/usr/bin/env sh\nnvim -c GitDevXDGHandle\\ "$@"',
          },
        },
        -- More verbosity.
        verbose = false,
      }
      
      
      require("git-dev").open("https://github.com/echasnovski/mini.nvim/blob/main/README.md")
      
      
      {
        branch = "main",
        repo_url = "https://github.com/echasnovski/mini.nvim.git",
        selected_path = "README.md",
        type = "http"
      }
      
      
      require("git-dev").open("https://gitlab.com/gitlab-org/code-creation/repository-x-ray/-/blob/acook/generic_docker_source_entry/cmd/scan/main.go")
      
      
      {
        branch = "acook/generic_docker_source_entry",
        repo_url = "https://gitlab.com/gitlab-org/code-creation/repository-x-ray.git",
        selected_path = "cmd/scan/main.go",
        type = "http"
      }
      
      
      {
        ...
        xdg_handler = {
          enabled = true,
        },
      }
      
      
      {
        "moyiz/git-dev.nvim",
        ...
        keys = {
          {
            "<leader>go",
            function()
              local repo = vim.fn.input "Repository name / URI: "
              if repo ~= "" then
                require("git-dev").open(repo)
              end
            end,
            desc = "[O]pen a remote git repository",
          }
        }
        ...
      }
      
      
      opts = {
        opener = function(dir, _, selected_path)
          -- vim.cmd("Oil " .. vim.fn.fnameescape(dir))
          vim.cmd("NvimTreeOpen " .. vim.fn.fnameescape(dir))
          if selected_path then
            vim.cmd("edit " .. selected_path)
          end
        end
      }
      
      
      opts = {
        opener = function(dir, _, selected_path)
          vim.cmd("Neotree " .. dir)
          if selected_path then
            vim.cmd("edit " .. selected_path)
          end
        end
      }
      
      
      opts = {
        cd_type = "tab",
        opener = function(dir, _, selected_path)
          vim.cmd "tabnew"
          vim.cmd("Neotree " .. dir)
          if selected_path then
            vim.cmd("edit " .. selected_path)
          end
        end
      }
      
      
      opts = {
        cd_type = "none",
        opener = function(_, repo_url)
           -- vim.cmd("!librewolf " .. repo_url)
           vim.cmd("!firefox " .. repo_url)
        end
      }
      
      
      -- Change default URI
      opts = {
        git = {
          base_uri_format = "https://git.home.arpa/%s.git",
        }
      }
      
      -- Open my own repositories by name with SSH.
      -- E.g. "git-dev.nvim" rather than "moyiz/git-dev.nvim"
      opts = {
        git = {
          default_org = "moyiz",
          base_uri_format = "git@github.com:%s.git",
        }
      }
      
      -- Enforce only full URIs (do not accept partial names).
      opts = {
        git = {
          base_uri_format = "%s"
        }
      }
      
      
      opts = {
        extra_domain_to_parser = {
          ["git.home.arpa"] = function(parser, text, _)
            text = text:gsub("https://([^/]+)/(.*)$", "ssh://git@%1:2222/%2")
            return parser:parse_gitea_like_url(text, "ssh://git@git.home.arpa:2222")
          end,
        },
      }
      
      
      {
        commit = "ef3fec4973042f0e0357a136d927fe2839350170",
        repo_url = "ssh://git@git.home.arpa:2222/homelab/k8s.git",
        selected_path = "apps/gitea/kustomization.yaml",
        type = "http"
      }
      
      
      {
        "moyiz/git-dev.nvim",
        ...
        keys = {
          {
            "<leader>gc",
            function()
              require("git-dev").close_buffers()
            end,
            mode = "n",
            desc = "[C]lose buffers of current repository",
          },
          {
            "<leader>gC",
            function()
              require("git-dev").clean()
            end,
            mode = "n",
            desc = "[C]lean current repository",
          },
        }
      }
      
      
    end,
  },
  {
    "SuperBo/fugit2.nvim",
    config = function()
      
      {
        'SuperBo/fugit2.nvim',
        build = false,
        opts = {
          width = 100,
        },
        dependencies = {
          'MunifTanjim/nui.nvim',
          'nvim-tree/nvim-web-devicons',
          'nvim-lua/plenary.nvim',
          {
            'chrisgrieser/nvim-tinygit', -- optional: for Github PR view
            dependencies = { 'stevearc/dressing.nvim' }
          },
        },
        cmd = { 'Fugit2', 'Fugit2Diff', 'Fugit2Graph' },
        keys = {
          { '<leader>F', mode = 'n', '<cmd>Fugit2<cr>' }
        }
      },
      
      
      {
        'SuperBo/fugit2.nvim',
        opts = {
          width = 70,
          external_diffview = true, -- tell fugit2 to use diffview.nvim instead of builtin implementation.
        },
        dependencies = {
          'MunifTanjim/nui.nvim',
          'nvim-tree/nvim-web-devicons',
          'nvim-lua/plenary.nvim',
          {
            'chrisgrieser/nvim-tinygit', -- optional: for Github PR view
            dependencies = { 'stevearc/dressing.nvim' }
          },
        },
        cmd = { 'Fugit2', 'Fugit2Blame', 'Fugit2Diff', 'Fugit2Graph' },
        keys = {
          { '<leader>F', mode = 'n', '<cmd>Fugit2<cr>' }
        }
      },
      {
        'sindrets/diffview.nvim',
        dependencies = { 'nvim-tree/nvim-web-devicons' },
        -- lazy, only load diffview by these commands
        cmd = {
          'DiffviewFileHistory', 'DiffviewOpen', 'DiffviewToggleFiles', 'DiffviewFocusFiles', 'DiffviewRefresh'
        }
      }
      
      
      ---@class Fugit2Config
      ---@field width integer|string Main popup width
      ---@field max_width integer|string Main popup popup width when expand patch view
      ---@field min_width integer File view width when expand patch view
      ---@field content_width File view content width
      ---@field height integer|string Main popup height
      ---@field show_patch boolean show patch for active file when open fugit2 main window
      ---@field libgit2_path string? path to libgit2 lib, default: "libgit2"
      ---@field gpgme_path string? path to gpgme lib, default: "gpgme"
      ---@field external_diffview boolean whether to use external diffview.nvim or Fugit2 implementation
      ---@field blame_priority integer priority of blame virtual text
      ---@field blame_info_width integer width of blame hunk detail popup
      ---@field blame_info_height integer height of blame hunk detail popup
      ---@field command_timeout integer timeout in milisecond of command like git pull / git push
      ---@field colorscheme string? custom color scheme override
      local opts = {
        width = 100,
        min_width = 50,
        content_width = 60,
        max_width = "80%",
        height = "60%",
        external_diffview = false,
        blame_priority = 1,
        blame_info_height = 10,
        blame_info_width = 60,
        show_patch = false,
        command_timeout = 15000,
      }
      
    end,
  },
  {
    "Yu-Leo/blame-column.nvim",
    config = function()
      
      {
          "Yu-Leo/blame-column.nvim",
          opts = {}, -- for default options. Refer to the configuration section for custom setup.
          cmd = "BlameColumnToggle",
      }
      
      
      local structurizers = require("blame-column.structurizers")
      local colorizers = require("blame-column.colorizers")
      local ci_formatters = require("blame-column.ci_formatters")
      local fci_openers = require("blame-column.fci_openers")
      
      ---@class blameColumn.OptsCommitInfo
      ---@field public enabled_from_blame boolean
      ---@field public formatter_fn function
      ---@field public colorizer_fn function
      ---@field public datetime_format string
      ---@field public max_width integer
      ---@field public window_opts table<string, any>
      ---@field public follow_cursor boolean
      local OptsCommitInfo = {}
      
      ---@class blameColumn.OptsFullCommitInfo
      ---@field public enabled_from_blame boolean
      ---@field public opener_fn function
      local OptsFullCommitInfo = {}
      
      ---@class blameColumn.Opts
      ---@field public side string
      ---@field public dynamic_width boolean
      ---@field public auto_width boolean
      ---@field public max_width integer
      ---@field public ignore_filetypes string[]
      ---@field public ignore_filenames string[]
      ---@field public window_opts table<string, any>
      ---@field public hl_by_fields boolean
      ---@field public time_based_bg_opts table<string, integer>
      ---@field public random_fg_opts table<string, integer>
      ---@field public datetime_format string
      ---@field public relative_dates boolean
      ---@field public structurizer_fn function
      ---@field public colorizer_fn function
      ---@field public commit_info blameColumn.OptsCommitInfo
      ---@field public full_commit_info blameColumn.OptsFullCommitInfo
      ---@field public mappings table<string, string>
      local defaults = {
          -- On which side of the window with the source buffer the git-blame window will be located.
          -- Available values: "left", "right"
          side = "left",
          -- true: calculate the width of the window based on the content
          -- false: fixed width == max_width
          dynamic_width = true,
          -- true: dynamically change the window width for different source buffers depending on the content
          -- false: do not change the width when changing the source buffer
          auto_width = true,
          -- If dynamic_width = true: the maximum width of the git-blame window. -1 == "unlimited"
          -- If dynamic_width = false: fixed width of the git-blame window. Must be positive number
          max_width = -1,
          -- Types of files for which git-blame window will not be opened
          ignore_filetypes = { "toggleterm", "NvimTree" },
          -- Names of files for which git-blame window will not be opened
          ignore_filenames = { "" },
          -- Options of git-blame window
          window_opts = {
              wrap = false,
              number = false,
              relativenumber = false,
              cursorline = false,
              signcolumn = "no",
              list = false,
          },
          -- false: use one hl group for the entire line
          -- true: use different hl groups for different line fields
          hl_by_fields = false,
          -- Options for colorizers.time_based_bg colorizer
          time_based_bg_opts = {
              hue = 215,
              saturation = 52,
              lightness_min = 10,
              lightness_max = 45,
          },
          -- Options for colorizers.random_fg colorizer
          random_fg_opts = {
              r_min = 100,
              r_max = 220,
              g_min = 100,
              g_max = 220,
              b_min = 100,
              b_max = 220,
          },
          -- Datetime format for commit's times
          datetime_format = "%d.%m.%Y",
          -- Enable or disable relative dates ("today", "yesterday")
          relative_dates = true,
          -- Defines the contents & hl groups of a string in git-blame window
          structurizer_fn = structurizers.colorized_date_author,
          -- Defines the coloring of a string in git-blame window
          colorizer_fn = colorizers.time_based_bg,
          -- Options for commit information pop-up window
          commit_info = {
              -- Enable or disable opening from the blame window
              enabled_from_blame = true,
              -- Defines the contents of pop-up window
              formatter_fn = ci_formatters.default_formatter,
              -- Defines the colors of pop-up window
              colorizer_fn = ci_formatters.default_colorizer,
              -- Datetime format for commit's times
              datetime_format = "%d.%m.%Y %H:%M:%S",
              -- The maximum width of the pop-up window. -1 == "unlimited"
              max_width = -1,
              -- Options of commit info pop-up window
              window_opts = {
                  border = "single",
                  wrap = false,
                  number = false,
                  relativenumber = false,
                  cursorline = false,
                  signcolumn = "no",
                  list = false,
              },
              -- If true, the pop-up window will follow the cursor and be redrawn for each line of git blame
              follow_cursor = true,
          },
          -- Options for full commit information in third-party plugin
          full_commit_info = {
              -- Enable or disable opening from the blame window
              enabled_from_blame = true,
              -- Defines the function that will be performed to open
              opener_fn = fci_openers.diffview,
          },
          mappings = {
              open_commit_info_from_blame = "K",
              close_commit_info_from_blame = "<ESC>",
              close_commit_info = "<ESC>",
              open_full_commit_info_from_blame = "L",
          },
      }
      
      
      ---@class blameColumn.StructurizerFn
      ---@param general_info blameColumn.GeneralInfo
      ---@param line_info blameColumn.LineInfo
      ---@return blameColumn.StructedLine
      local function structurizer_func(general_info, line_info)
          -- Your code
      end
      
      
      ---@class blameColumn.GeneralInfo
      ---@field public total_commits integer
      ---@field public max_lens table<string, integer>
      local GeneralInfo = {}
      
      ---@class blameColumn.LineInfo
      ---@field public full_hash string
      ---@field public hash string
      ---@field public is_modified boolean
      ---@field public orig_line integer
      ---@field public final_line integer
      ---@field public group_lines integer
      ---@field public line_number integer
      ---@field public filename string
      ---@field public summary string
      ---@field public author string
      ---@field public author_surname string
      ---@field public author_time integer
      ---@field public author_tz string
      ---@field public author_mail string
      ---@field public committer string
      ---@field public committer_surname string
      ---@field public committer_time integer
      ---@field public committer_tz string
      ---@field public committer_mail string
      ---@field public time_order integer
      local LineInfo = {}
      
      ---@class blameColumn.StructedLine
      ---@field public format string
      ---@field public fields blameColumn.LineField[]
      ---@field public hl? string
      local StructedLine = {}
      
      
      ---@class blameColumn.ColorizerFn
      ---@param general_info blameColumn.GeneralInfo
      ---@param line_info blameColumn.LineInfo
      ---@return vim.api.keyset.highlight
      local function colorizer_func(general_info, line_info)
          -- Your code
      end
      
      
      ---@class blameColumn.LineInfo
      ---@field public full_hash string
      ---@field public hash string
      ---@field public is_modified boolean
      ---@field public orig_line integer
      ---@field public final_line integer
      ---@field public group_lines integer
      ---@field public line_number integer
      ---@field public filename string
      ---@field public summary string
      ---@field public author string
      ---@field public author_surname string
      ---@field public author_time integer
      ---@field public author_tz string
      ---@field public author_mail string
      ---@field public committer string
      ---@field public committer_surname string
      ---@field public committer_time integer
      ---@field public committer_tz string
      ---@field public committer_mail string
      ---@field public time_order integer
      local LineInfo = {}
      
      ---@class blameColumn.GeneralInfo
      ---@field public total_commits integer
      ---@field public max_lens table<string, integer>
      local GeneralInfo = {}
      
      
      ---@param line_info blameColumn.LineInfo
      ---@param opts blameColumn.OptsCommitInfo
      ---@return table<string>
      M.formatter_fn = function(line_info, opts)
          -- Your code
      end
      
      
      ---@class blameColumn.LineInfo
      ---@field public full_hash string
      ---@field public hash string
      ---@field public is_modified boolean
      ---@field public orig_line integer
      ---@field public final_line integer
      ---@field public group_lines integer
      ---@field public line_number integer
      ---@field public filename string
      ---@field public summary string
      ---@field public author string
      ---@field public author_surname string
      ---@field public author_time integer
      ---@field public author_tz string
      ---@field public author_mail string
      ---@field public committer string
      ---@field public committer_surname string
      ---@field public committer_time integer
      ---@field public committer_tz string
      ---@field public committer_mail string
      ---@field public time_order integer
      local LineInfo = {}
      
      ---@class blameColumn.OptsCommitInfo
      ---@field public enabled_from_blame boolean
      ---@field public formatter_fn function
      ---@field public colorizer_fn function
      ---@field public datetime_format string
      ---@field public max_width integer
      ---@field public window_opts table<string, any>
      ---@field public follow_cursor boolean
      local OptsCommitInfo = {}
      
      
      ---@param bufnr integer
      M.colorizer_fn = function(bufnr)
          -- Your code
      end
      
      
      ---@param line_info blameColumn.LineInfo
      M.opener_fn = function(line_info)
          -- Your code
      end
      
      
      ---@class blameColumn.LineInfo
      ---@field public full_hash string
      ---@field public hash string
      ---@field public is_modified boolean
      ---@field public orig_line integer
      ---@field public final_line integer
      ---@field public group_lines integer
      ---@field public line_number integer
      ---@field public filename string
      ---@field public summary string
      ---@field public author string
      ---@field public author_surname string
      ---@field public author_time integer
      ---@field public author_tz string
      ---@field public author_mail string
      ---@field public committer string
      ---@field public committer_surname string
      ---@field public committer_time integer
      ---@field public committer_tz string
      ---@field public committer_mail string
      ---@field public time_order integer
      local LineInfo = {}
      
      
      -- Toggle git-blame window
      require("Yu-Leo/blame-column.nvim").toggle()
      
      
      vim.keymap.set("n", "<leader>gl", function()
        require("blame-column").toggle()
      end, { desc = "Git: toggle blame" })
      
    end,
  },
  {
    "yutkat/git-rebase-auto-diff.nvim",
    config = function()
      
      {
      	"yutkat/git-rebase-auto-diff.nvim",
      	ft = { "gitrebase" },
      	opts = {
      		size = vim.fn.float2nr(vim.o.lines * 0.5),
      		run_show = false,
      	},
      }
      
    end,
  },
  {
    "Kohei-Wada/yadm-git.nvim",
    config = function()
      
      use {
        'Kohei-Wada/yadm-git.nvim',
        config = function()
          require('yadm-git').setup({
            debug = true, -- Enable debug logging (default: false)
          })
        end,
      }
      
      
      -- init.lua or vimrc
      require('yadm-git').setup({
        debug = false,
      })
      
      
      return {
        "Kohei-Wada/yadm-git.nvim",
        lazy = false,
      }
      
      
      local is_active = require('yadm-git').is_active()
      if is_active then
        print("yadm-git is active")
      end
      
      
      local repo_path = require('yadm-git').get_yadm_repo_path()
      if repo_path then
        print("yadm repository is at: " .. repo_path)
      end
      
      
      local state = require('yadm-git').get_state()
      print("Active: " .. tostring(state.is_active))
      print("Repo path: " .. (state.yadm_repo_path or "none"))
      
    end,
  },
  {
    "axkirillov/unified.nvim",
    config = function()
      
      {
        'axkirillov/unified.nvim',
        opts = {
          -- your configuration comes here
        }
      }
      
      
      use {
        'axkirillov/unified.nvim',
        config = function()
          require('unified').setup({
            -- your configuration comes here
          })
        end
      }
      
      
      require('unified').setup({
        signs = {
          add = "│",
          delete = "│",
          change = "│",
        },
        highlights = {
          add = "DiffAdd",
          delete = "DiffDelete",
          change = "DiffChange",
        },
        line_symbols = {
          add = "+",
          delete = "-",
          change = "~",
        },
        auto_refresh = true, -- Whether to automatically refresh diff when buffer changes
      })
      
      
      vim.keymap.set('n', ']h', function() require('unified.navigation').next_hunk() end)
      vim.keymap.set('n', '[h', function() require('unified.navigation').previous_hunk() end)
      
    end,
  },
  {
    "StackInTheWild/headhunter.nvim",
    config = function()
      
      {
        "StackInTheWild/headhunter.nvim",
        lazy = true,
        opts = {
           register_keymaps = false, -- Disable internal keymaps if using lazy.nvim keys
        },
        keys = {
          { "]g", ":HeadhunterNext", desc = "Go to next Conflict" },
          { "[g", ":HeadhunterPrevious", desc = "Go to previous Conflict" },
          { "<leader>gh", ":HeadhunterTakeHead", desc = "Take changes from HEAD" },
          { "<leader>go", ":HeadhunterTakeOrigin", desc = "Take changes from origin" },
          { "<leader>gb", ":HeadhunterTakeBoth", desc = "Take both changes" },
        },
      }
      
    end,
  },
  {
    "pwntester/octo.nvim",
    config = function()
      
      use {
        'pwntester/octo.nvim',
        requires = {
          'nvim-lua/plenary.nvim',
          'nvim-telescope/telescope.nvim',
          -- OR 'ibhagwan/fzf-lua',
          -- OR 'folke/snacks.nvim',
          'nvim-tree/nvim-web-devicons',
        },
        config = function ()
          require"octo".setup()
        end
      }
      
      
      require"octo".setup({
        use_local_fs = false,                    -- use local files on right side of reviews
        enable_builtin = false,                  -- shows a list of builtin actions when no action is provided
        default_remote = {"upstream", "origin"}, -- order to try remotes
        default_merge_method = "commit",         -- default merge method which should be used for both `Octo pr merge` and merging from picker, could be `commit`, `rebase` or `squash`
        default_delete_branch = false,           -- whether to delete branch when merging pull request with either `Octo pr merge` or from picker (can be overridden with `delete`/`nodelete` argument to `Octo pr merge`)
        ssh_aliases = {},                        -- SSH aliases. e.g. `ssh_aliases = {["github.com-work"] = "github.com"}`. The key part will be interpreted as an anchored Lua pattern.
        picker = "telescope",                    -- or "fzf-lua" or "snacks"
        picker_config = {
          use_emojis = false,                    -- only used by "fzf-lua" picker for now
          mappings = {                           -- mappings for the pickers
            open_in_browser = { lhs = "<C-b>", desc = "open issue in browser" },
            copy_url = { lhs = "<C-y>", desc = "copy url to system clipboard" },
            copy_sha = { lhs = "<C-e>", desc = "copy commit SHA to system clipboard" },
            checkout_pr = { lhs = "<C-o>", desc = "checkout pull request" },
            merge_pr = { lhs = "<C-r>", desc = "merge pull request" },
          },
          snacks = {                                -- snacks specific config
            actions = {                             -- custom actions for specific snacks pickers (array of tables)
              issues = {                            -- actions for the issues picker
                -- { name = "my_issue_action", fn = function(picker, item) print("Issue action:", vim.inspect(item)) end, lhs = "<leader>a", desc = "My custom issue action" },
              },
              pull_requests = {                     -- actions for the pull requests picker
                -- { name = "my_pr_action", fn = function(picker, item) print("PR action:", vim.inspect(item)) end, lhs = "<leader>b", desc = "My custom PR action" },
              },
              notifications = {},                   -- actions for the notifications picker
              issue_templates = {},                 -- actions for the issue templates picker
              search = {},                          -- actions for the search picker
              -- ... add actions for other pickers as needed
            },
          },
        },
        comment_icon = "▎",                      -- comment marker
        outdated_icon = "󰅒 ",                    -- outdated indicator
        resolved_icon = " ",                    -- resolved indicator
        reaction_viewer_hint_icon = " ",        -- marker for user reactions
        commands = {},                           -- additional subcommands made available to `Octo` command
        users = "search",                        -- Users for assignees or reviewers. Values: "search" | "mentionable" | "assignable"
        user_icon = " ",                        -- user icon
        ghost_icon = "󰊠 ",                       -- ghost icon
        timeline_marker = " ",                  -- timeline marker
        timeline_indent = 2,                   -- timeline indentation
        use_timeline_icons = true,               -- toggle timeline icons
        timeline_icons = {                       -- the default icons based on timelineItems
          commit = "  ",
          label = "  ",
          reference = " ",
          connected = "  ",
          subissue = "  ",
          cross_reference = "  ",
          parent_issue = "  ",
          pinned = "  ",
          milestone = "  ",
          renamed = "  ",
          merged = { "  ", "OctoPurple" },
          closed = {
            closed = { "  ", "OctoRed" },
            completed = { "  ", "OctoPurple" },
            not_planned = { "  ", "OctoGrey" },
            duplicate = { "  ", "OctoGrey" },
          },
          reopened = { "  ", "OctoGreen" },
          assigned = "  ",
          review_requested = "  ",
        },
        right_bubble_delimiter = "",            -- bubble delimiter
        left_bubble_delimiter = "",             -- bubble delimiter
        github_hostname = "",                    -- GitHub Enterprise host
        snippet_context_lines = 4,               -- number or lines around commented lines
        gh_cmd = "gh",                           -- Command to use when calling Github CLI
        gh_env = {},                             -- extra environment variables to pass on to GitHub CLI, can be a table or function returning a table
        timeout = 5000,                          -- timeout for requests between the remote server
        default_to_projects_v2 = false,          -- use projects v2 for the `Octo card ...` command by default. Both legacy and v2 commands are available under `Octo cardlegacy ...` and `Octo cardv2 ...` respectively.
        ui = {
          use_signcolumn = false,                -- show "modified" marks on the sign column
          use_signstatus = true,                 -- show "modified" marks on the status column
        },
        issues = {
          order_by = {                           -- criteria to sort results of `Octo issue list`
            field = "CREATED_AT",                -- either COMMENTS, CREATED_AT or UPDATED_AT (https://docs.github.com/en/graphql/reference/enums#issueorderfield)
            direction = "DESC"                   -- either DESC or ASC (https://docs.github.com/en/graphql/reference/enums#orderdirection)
          }
        },
        reviews = {
          auto_show_threads = true,              -- automatically show comment threads on cursor move
          focus             = "right",           -- focus right buffer on diff open
        },
        runs = {
          icons = {
            pending = "🕖",
            in_progress = "🔄",
            failed = "❌",
            succeeded = "",
            skipped = "⏩",
            cancelled = "✖",
          },
        },
        pull_requests = {
          order_by = {                            -- criteria to sort the results of `Octo pr list`
            field = "CREATED_AT",                 -- either COMMENTS, CREATED_AT or UPDATED_AT (https://docs.github.com/en/graphql/reference/enums#issueorderfield)
            direction = "DESC"                    -- either DESC or ASC (https://docs.github.com/en/graphql/reference/enums#orderdirection)
          },
          always_select_remote_on_create = false, -- always give prompt to select base remote repo when creating PRs
          use_branch_name_as_title = false        -- sets branch name to be the name for the PR
        },
        notifications = {
          current_repo_only = false,             -- show notifications for current repo only
        },
        file_panel = {
          size = 10,                             -- changed files panel rows
          use_icons = true                       -- use web-devicons in file panel (if false, nvim-web-devicons does not need to be installed)
        },
        colors = {                               -- used for highlight groups (see Colors section below)
          white = "#ffffff",
          grey = "#2A354C",
          black = "#000000",
          red = "#fdb8c0",
          dark_red = "#da3633",
          green = "#acf2bd",
          dark_green = "#238636",
          yellow = "#d3c846",
          dark_yellow = "#735c0f",
          blue = "#58A6FF",
          dark_blue = "#0366d6",
          purple = "#6f42c1",
        },
        mappings_disable_default = false,        -- disable default mappings if true, but will still adapt user mappings
        mappings = {
          runs = {
            expand_step = { lhs = "o", desc = "expand workflow step" },
            open_in_browser = { lhs = "<C-b>", desc = "open workflow run in browser" },
            refresh = { lhs = "<C-r>", desc = "refresh workflow" },
            rerun = { lhs = "<C-o>", desc = "rerun workflow" },
            rerun_failed = { lhs = "<C-f>", desc = "rerun failed workflow" },
            cancel = { lhs = "<C-x>", desc = "cancel workflow" },
            copy_url = { lhs = "<C-y>", desc = "copy url to system clipboard" },
          },
          issue = {
            close_issue = { lhs = "<localleader>ic", desc = "close issue" },
            reopen_issue = { lhs = "<localleader>io", desc = "reopen issue" },
            list_issues = { lhs = "<localleader>il", desc = "list open issues on same repo" },
            reload = { lhs = "<C-r>", desc = "reload issue" },
            open_in_browser = { lhs = "<C-b>", desc = "open issue in browser" },
            copy_url = { lhs = "<C-y>", desc = "copy url to system clipboard" },
            add_assignee = { lhs = "<localleader>aa", desc = "add assignee" },
            remove_assignee = { lhs = "<localleader>ad", desc = "remove assignee" },
            create_label = { lhs = "<localleader>lc", desc = "create label" },
            add_label = { lhs = "<localleader>la", desc = "add label" },
            remove_label = { lhs = "<localleader>ld", desc = "remove label" },
            goto_issue = { lhs = "<localleader>gi", desc = "navigate to a local repo issue" },
            add_comment = { lhs = "<localleader>ca", desc = "add comment" },
            add_reply = { lhs = "<localleader>cr", desc = "add reply" },
            delete_comment = { lhs = "<localleader>cd", desc = "delete comment" },
            next_comment = { lhs = "]c", desc = "go to next comment" },
            prev_comment = { lhs = "[c", desc = "go to previous comment" },
            react_hooray = { lhs = "<localleader>rp", desc = "add/remove 🎉 reaction" },
            react_heart = { lhs = "<localleader>rh", desc = "add/remove ❤️ reaction" },
            react_eyes = { lhs = "<localleader>re", desc = "add/remove 👀 reaction" },
            react_thumbs_up = { lhs = "<localleader>r+", desc = "add/remove 👍 reaction" },
            react_thumbs_down = { lhs = "<localleader>r-", desc = "add/remove 👎 reaction" },
            react_rocket = { lhs = "<localleader>rr", desc = "add/remove 🚀 reaction" },
            react_laugh = { lhs = "<localleader>rl", desc = "add/remove 😄 reaction" },
            react_confused = { lhs = "<localleader>rc", desc = "add/remove 😕 reaction" },
          },
          pull_request = {
            checkout_pr = { lhs = "<localleader>po", desc = "checkout PR" },
            merge_pr = { lhs = "<localleader>pm", desc = "merge commit PR" },
            squash_and_merge_pr = { lhs = "<localleader>psm", desc = "squash and merge PR" },
            rebase_and_merge_pr = { lhs = "<localleader>prm", desc = "rebase and merge PR" },
            merge_pr_queue = { lhs = "<localleader>pq", desc = "merge commit PR and add to merge queue (Merge queue must be enabled in the repo)" },
            squash_and_merge_queue = { lhs = "<localleader>psq", desc = "squash and add to merge queue (Merge queue must be enabled in the repo)" },
            rebase_and_merge_queue = { lhs = "<localleader>prq", desc = "rebase and add to merge queue (Merge queue must be enabled in the repo)" },
            list_commits = { lhs = "<localleader>pc", desc = "list PR commits" },
            list_changed_files = { lhs = "<localleader>pf", desc = "list PR changed files" },
            show_pr_diff = { lhs = "<localleader>pd", desc = "show PR diff" },
            add_reviewer = { lhs = "<localleader>va", desc = "add reviewer" },
            remove_reviewer = { lhs = "<localleader>vd", desc = "remove reviewer request" },
            close_issue = { lhs = "<localleader>ic", desc = "close PR" },
            reopen_issue = { lhs = "<localleader>io", desc = "reopen PR" },
            list_issues = { lhs = "<localleader>il", desc = "list open issues on same repo" },
            reload = { lhs = "<C-r>", desc = "reload PR" },
            open_in_browser = { lhs = "<C-b>", desc = "open PR in browser" },
            copy_url = { lhs = "<C-y>", desc = "copy url to system clipboard" },
            goto_file = { lhs = "gf", desc = "go to file" },
            add_assignee = { lhs = "<localleader>aa", desc = "add assignee" },
            remove_assignee = { lhs = "<localleader>ad", desc = "remove assignee" },
            create_label = { lhs = "<localleader>lc", desc = "create label" },
            add_label = { lhs = "<localleader>la", desc = "add label" },
            remove_label = { lhs = "<localleader>ld", desc = "remove label" },
            goto_issue = { lhs = "<localleader>gi", desc = "navigate to a local repo issue" },
            add_comment = { lhs = "<localleader>ca", desc = "add comment" },
            add_reply = { lhs = "<localleader>cr", desc = "add reply" },
            delete_comment = { lhs = "<localleader>cd", desc = "delete comment" },
            next_comment = { lhs = "]c", desc = "go to next comment" },
            prev_comment = { lhs = "[c", desc = "go to previous comment" },
            react_hooray = { lhs = "<localleader>rp", desc = "add/remove 🎉 reaction" },
            react_heart = { lhs = "<localleader>rh", desc = "add/remove ❤️ reaction" },
            react_eyes = { lhs = "<localleader>re", desc = "add/remove 👀 reaction" },
            react_thumbs_up = { lhs = "<localleader>r+", desc = "add/remove 👍 reaction" },
            react_thumbs_down = { lhs = "<localleader>r-", desc = "add/remove 👎 reaction" },
            react_rocket = { lhs = "<localleader>rr", desc = "add/remove 🚀 reaction" },
            react_laugh = { lhs = "<localleader>rl", desc = "add/remove 😄 reaction" },
            react_confused = { lhs = "<localleader>rc", desc = "add/remove 😕 reaction" },
            review_start = { lhs = "<localleader>vs", desc = "start a review for the current PR" },
            review_resume = { lhs = "<localleader>vr", desc = "resume a pending review for the current PR" },
            resolve_thread = { lhs = "<localleader>rt", desc = "resolve PR thread" },
            unresolve_thread = { lhs = "<localleader>rT", desc = "unresolve PR thread" },
          },
          review_thread = {
            goto_issue = { lhs = "<localleader>gi", desc = "navigate to a local repo issue" },
            add_comment = { lhs = "<localleader>ca", desc = "add comment" },
            add_reply = { lhs = "<localleader>cr", desc = "add reply" },
            add_suggestion = { lhs = "<localleader>sa", desc = "add suggestion" },
            delete_comment = { lhs = "<localleader>cd", desc = "delete comment" },
            next_comment = { lhs = "]c", desc = "go to next comment" },
            prev_comment = { lhs = "[c", desc = "go to previous comment" },
            select_next_entry = { lhs = "]q", desc = "move to next changed file" },
            select_prev_entry = { lhs = "[q", desc = "move to previous changed file" },
            select_first_entry = { lhs = "[Q", desc = "move to first changed file" },
            select_last_entry = { lhs = "]Q", desc = "move to last changed file" },
            close_review_tab = { lhs = "<C-c>", desc = "close review tab" },
            react_hooray = { lhs = "<localleader>rp", desc = "add/remove 🎉 reaction" },
            react_heart = { lhs = "<localleader>rh", desc = "add/remove ❤️ reaction" },
            react_eyes = { lhs = "<localleader>re", desc = "add/remove 👀 reaction" },
            react_thumbs_up = { lhs = "<localleader>r+", desc = "add/remove 👍 reaction" },
            react_thumbs_down = { lhs = "<localleader>r-", desc = "add/remove 👎 reaction" },
            react_rocket = { lhs = "<localleader>rr", desc = "add/remove 🚀 reaction" },
            react_laugh = { lhs = "<localleader>rl", desc = "add/remove 😄 reaction" },
            react_confused = { lhs = "<localleader>rc", desc = "add/remove 😕 reaction" },
            resolve_thread = { lhs = "<localleader>rt", desc = "resolve PR thread" },
            unresolve_thread = { lhs = "<localleader>rT", desc = "unresolve PR thread" },
          },
          submit_win = {
            approve_review = { lhs = "<C-a>", desc = "approve review", mode = { "n", "i" } },
            comment_review = { lhs = "<C-m>", desc = "comment review", mode = { "n", "i" } },
            request_changes = { lhs = "<C-r>", desc = "request changes review", mode = { "n", "i" } },
            close_review_tab = { lhs = "<C-c>", desc = "close review tab", mode = { "n", "i" } },
          },
          review_diff = {
            submit_review = { lhs = "<localleader>vs", desc = "submit review" },
            discard_review = { lhs = "<localleader>vd", desc = "discard review" },
            add_review_comment = { lhs = "<localleader>ca", desc = "add a new review comment", mode = { "n", "x" } },
            add_review_suggestion = { lhs = "<localleader>sa", desc = "add a new review suggestion", mode = { "n", "x" } },
            focus_files = { lhs = "<localleader>e", desc = "move focus to changed file panel" },
            toggle_files = { lhs = "<localleader>b", desc = "hide/show changed files panel" },
            next_thread = { lhs = "]t", desc = "move to next thread" },
            prev_thread = { lhs = "[t", desc = "move to previous thread" },
            select_next_entry = { lhs = "]q", desc = "move to next changed file" },
            select_prev_entry = { lhs = "[q", desc = "move to previous changed file" },
            select_first_entry = { lhs = "[Q", desc = "move to first changed file" },
            select_last_entry = { lhs = "]Q", desc = "move to last changed file" },
            close_review_tab = { lhs = "<C-c>", desc = "close review tab" },
            toggle_viewed = { lhs = "<localleader><space>", desc = "toggle viewer viewed state" },
            goto_file = { lhs = "gf", desc = "go to file" },
          },
          file_panel = {
            submit_review = { lhs = "<localleader>vs", desc = "submit review" },
            discard_review = { lhs = "<localleader>vd", desc = "discard review" },
            next_entry = { lhs = "j", desc = "move to next changed file" },
            prev_entry = { lhs = "k", desc = "move to previous changed file" },
            select_entry = { lhs = "<cr>", desc = "show selected changed file diffs" },
            refresh_files = { lhs = "R", desc = "refresh changed files panel" },
            focus_files = { lhs = "<localleader>e", desc = "move focus to changed file panel" },
            toggle_files = { lhs = "<localleader>b", desc = "hide/show changed files panel" },
            select_next_entry = { lhs = "]q", desc = "move to next changed file" },
            select_prev_entry = { lhs = "[q", desc = "move to previous changed file" },
            select_first_entry = { lhs = "[Q", desc = "move to first changed file" },
            select_last_entry = { lhs = "]Q", desc = "move to last changed file" },
            close_review_tab = { lhs = "<C-c>", desc = "close review tab" },
            toggle_viewed = { lhs = "<localleader><space>", desc = "toggle viewer viewed state" },
          },
          notification = {
            read = { lhs = "<localleader>nr", desc = "mark notification as read" },
            done = { lhs = "<localleader>nd", desc = "mark notification as done" },
            unsubscribe = { lhs = "<localleader>nu", desc = "unsubscribe from notifications" },
          },
        },
      })
      
      
      require('octo').setup({
        ssh_aliases = {["<THE ALIAS YOU HAVE LISTED IN ~/.ssh/config>"] = "github.com"}
      })
      
      
      vim.treesitter.language.register('markdown', 'octo')
      
    end,
  },
  {
    "pwntester/codeql.nvim",
    config = function()
      
      {
        "pwntester/codeql.nvim",
        dependencies = {
          "MunifTanjim/nui.nvim",
          "nvim-lua/telescope.nvim",
          "kyazdani42/nvim-web-devicons",
          {
            's1n7ax/nvim-window-picker',
            version = 'v1.*',
            opts = {
              autoselect_one = true,
              include_current = false,
              filter_rules = {
                bo = {
                  filetype = {
                    "codeql_panel",
                    "codeql_explorer",
                    "qf",
                    "TelescopePrompt",
                    "TelescopeResults",
                    "notify",
                    "noice",
                    "NvimTree",
                    "neo-tree",
                  },
                  buftype = { 'terminal' },
                },
              },
              current_win_hl_color = '#e35e4f',
              other_win_hl_color = '#44cc41',
            },
          }
        },
        opts = {}
      }
      
      
      use {
        "pwntester/codeql.nvim",
        requires = {
          "MunifTanjim/nui.nvim",
          "nvim-lua/telescope.nvim",
          "kyazdani42/nvim-web-devicons",
          {
            's1n7ax/nvim-window-picker',
            tag = 'v1.*',
            config = function()
              require'window-picker'.setup({
                autoselect_one = true,
                include_current = false,
                filter_rules = {
                  bo = {
                    filetype = {
                      "codeql_panel",
                      "codeql_explorer",
                      "qf",
                      "TelescopePrompt",
                      "TelescopeResults",
                      "notify",
                      "noice",
                      "NvimTree",
                      "neo-tree",
                    },
                    buftype = { 'terminal' },
                  },
                },
                current_win_hl_color = '#e35e4f',
                other_win_hl_color = '#44cc41',
              })
            end,
          }
        },
        config = function()
          require("codeql").setup {}
        end
      }
      
      
      require("codeql").setup {
        results = {
          max_paths = 10,
          max_path_depth = nil,
        },
        panel = {
          width = 50,
          pos = "botright",
          group_by = "sink", -- "source"
          show_filename = true,
          long_filename = false,
          context_lines = 3,
        },
        max_ram = 32000,
        job_timeout = 15000,
        format_on_save = true,
        additional_packs = {
          "/Users/pwntester/codeql-home/codeql",
          "/Users/pwntester/codeql-home/codeql-go",
          "/Users/pwntester/codeql-home/codeql-ruby",
          "./codeql",
        },
        mappings = {
          run_query = { modes = { "n" }, lhs = "<space>qr", desc = "run query" },
          quick_eval = { modes = { "x", "n" }, lhs = "<space>qe", desc = "quick evaluate" },
          quick_eval_predicate = { modes = { "n" }, lhs = "<space>qp", desc = "quick evaluate enclosing predicate" },
        },
      }
      
      
      use 'neovim/nvim-lspconfig'
      
      
      local lspconfig = require'lspconfig'
      
      lspconfig.codeqlls.setup{
          on_attach = on_attach_callback;
          settings = {
              additional_packs = {'~/codeql-home/codeql-repo'};
          };
      }
      
      
      local function on_attach_callback(client, bufnr)
          api.nvim_buf_set_keymap(bufnr, "n", "gD", "<Cmd>lua show_diagnostics_details()<CR>", { silent = true; })
          api.nvim_buf_set_keymap(bufnr, "n", "gd", "<Cmd>lua vim.lsp.buf.definition()<CR>", { silent = true; })
          api.nvim_buf_set_keymap(bufnr, "n", "gi", "<Cmd>lua vim.lsp.buf.implementation()<CR>", { silent = true; })
          api.nvim_buf_set_keymap(bufnr, "n", "gK", "<Cmd>lua vim.lsp.buf.hover()<CR>", { silent = true; })
          api.nvim_buf_set_keymap(bufnr, "n", "gh", "<Cmd>lua vim.lsp.buf.signature_help()<CR>", { silent = true; })
          api.nvim_buf_set_keymap(bufnr, "n", "gr", "<Cmd>lua vim.lsp.buf.references()<CR>", { silent = true; })
          api.nvim_buf_set_keymap(bufnr, "n", "gF", "<Cmd>lua vim.lsp.buf.formatting()<CR>", { silent = true; })
          api.nvim_command [[autocmd CursorHold  <buffer> lua vim.lsp.buf.document_highlight()]]
          api.nvim_command [[autocmd CursorHoldI <buffer> lua vim.lsp.buf.document_highlight()]]
          api.nvim_command [[autocmd CursorMoved <buffer> lua vim.lsp.util.buf_clear_references()]]
      end
      
      local lspconfig = require'lspconfig'
      
      lspconfig.codeqlls.setup{
          on_attach = on_attach_callback;
          settings = {
              additional_packs = {'~/codeql-home/codeql-repo'};
          };
      }
      
    end,
  },
  {
    "ldelossa/gh.nvim",
    config = function()
      
      {
          "ldelossa/gh.nvim",
          dependencies = {
              {
              "ldelossa/litee.nvim",
              config = function()
                  require("litee.lib").setup()
              end,
              },
          },
          config = function()
              require("litee.gh").setup()
          end,
      }
      
      
      
      use {
          'ldelossa/gh.nvim',
          requires = { { 'ldelossa/litee.nvim' } }
        }
      
      
      require('litee.lib').setup()
      require('litee.gh').setup({
        -- deprecated, around for compatability for now.
        jump_mode   = "invoking",
        -- remap the arrow keys to resize any litee.nvim windows.
        map_resize_keys = false,
        -- do not map any keys inside any gh.nvim buffers.
        disable_keymaps = false,
        -- the icon set to use.
        icon_set = "default",
        -- any custom icons to use.
        icon_set_custom = nil,
        -- whether to register the @username and #issue_number omnifunc completion
        -- in buffers which start with .git/
        git_buffer_completion = true,
        -- defines keymaps in gh.nvim buffers.
        keymaps = {
            -- when inside a gh.nvim panel, this key will open a node if it has
            -- any futher functionality. for example, hitting <CR> on a commit node
            -- will open the commit's changed files in a new gh.nvim panel.
            open = "<CR>",
            -- when inside a gh.nvim panel, expand a collapsed node
            expand = "zo",
            -- when inside a gh.nvim panel, collpased and expanded node
            collapse = "zc",
            -- when cursor is over a "#1234" formatted issue or PR, open its details
            -- and comments in a new tab.
            goto_issue = "gd",
            -- show any details about a node, typically, this reveals commit messages
            -- and submitted review bodys.
            details = "d",
            -- inside a convo buffer, submit a comment
            submit_comment = "<C-s>",
            -- inside a convo buffer, when your cursor is ontop of a comment, open
            -- up a set of actions that can be performed.
            actions = "<C-a>",
            -- inside a thread convo buffer, resolve the thread.
            resolve_thread = "<C-r>",
            -- inside a gh.nvim panel, if possible, open the node's web URL in your
            -- browser. useful particularily for digging into external failed CI
            -- checks.
            goto_web = "gx"
        }
      })
      
      
      vim.cmd("FzfLua register_ui_select")
      
      
      local wk = require("which-key")
      wk.add {
        { '<leader>g', group = 'Git' },
        { '<leader>gh', group = 'Github' },
        { '<leader>ghc', group = 'Commits' },
        { '<leader>ghcc', '<cmd>GHCloseCommit<cr>', desc = 'Close' },
        { '<leader>ghce', '<cmd>GHExpandCommit<cr>', desc = 'Expand' },
        { '<leader>ghco', '<cmd>GHOpenToCommit<cr>', desc = 'Open To' },
        { '<leader>ghcp', '<cmd>GHPopOutCommit<cr>', desc = 'Pop Out' },
        { '<leader>ghcz', '<cmd>GHCollapseCommit<cr>', desc = 'Collapse' },
        { '<leader>ghi', group = 'Issues' },
        { '<leader>ghip', '<cmd>GHPreviewIssue<cr>', desc = 'Preview' },
        { '<leader>ghl', group = 'Litee' },
        { '<leader>ghlt', '<cmd>LTPanel<cr>', desc = 'Toggle Panel' },
        { '<leader>ghp', group = 'Pull Request' },
        { '<leader>ghpc', '<cmd>GHClosePR<cr>', desc = 'Close' },
        { '<leader>ghpd', '<cmd>GHPRDetails<cr>', desc = 'Details' },
        { '<leader>ghpe', '<cmd>GHExpandPR<cr>', desc = 'Expand' },
        { '<leader>ghpo', '<cmd>GHOpenPR<cr>', desc = 'Open' },
        { '<leader>ghpp', '<cmd>GHPopOutPR<cr>', desc = 'PopOut' },
        { '<leader>ghpr', '<cmd>GHRefreshPR<cr>', desc = 'Refresh' },
        { '<leader>ghpt', '<cmd>GHOpenToPR<cr>', desc = 'Open To' },
        { '<leader>ghpz', '<cmd>GHCollapsePR<cr>', desc = 'Collapse' },
        { '<leader>ghr', group = 'Review' },
        { '<leader>ghrb', '<cmd>GHStartReview<cr>', desc = 'Begin' },
        { '<leader>ghrc', '<cmd>GHCloseReview<cr>', desc = 'Close' },
        { '<leader>ghrd', '<cmd>GHDeleteReview<cr>', desc = 'Delete' },
        { '<leader>ghre', '<cmd>GHExpandReview<cr>', desc = 'Expand' },
        { '<leader>ghrs', '<cmd>GHSubmitReview<cr>', desc = 'Submit' },
        { '<leader>ghrz', '<cmd>GHCollapseReview<cr>', desc = 'Collapse' },
        { '<leader>ght', group = 'Threads' },
        { '<leader>ghtc', '<cmd>GHCreateThread<cr>', desc = 'Create' },
        { '<leader>ghtn', '<cmd>GHNextThread<cr>', desc = 'Next' },
        { '<leader>ghtt', '<cmd>GHToggleThread<cr>', desc = 'Toggle' },
      }
      
    end,
  },
  {
    "topaxi/pipeline.nvim",
    config = function()
      
      {
        'topaxi/pipeline.nvim',
        keys = {
          { '<leader>ci', '<cmd>Pipeline<cr>', desc = 'Open pipeline.nvim' },
        },
        -- optional, you can also install and use `yq` instead.
        build = 'make',
        ---@type pipeline.Config
        opts = {},
      },
      
      
      {
        --- The browser executable path to open workflow runs/jobs in
        browser = nil,
        --- Interval to refresh in seconds
        refresh_interval = 10,
        --- How much workflow runs and jobs should be indented
        indent = 2,
        providers = {
          github = {
            default_host = 'github.com',
            --- Mapping of names that should be renamed to resolvable hostnames
            --- names are something that you've used as a repository url,
            --- that can't be resolved by this plugin, like aliases from ssh config
            --- for example to resolve "gh" to "github.com"
            --- 
      
            --- resolve_host = function(host)
            ---   if host == "gl" then
            ---     return "gitlab.com"
            ---   end
            --- end
            --- 
      
      require('lualine').setup({
        sections = {
          lualine_a = {
            { 'pipeline' },
          },
        }
      })
      
      
      require('lualine').setup({
        sections = {
          lualine_a = {
            -- with default options
            { 'pipeline', icon = '' },
          },
        }
      })
      
    end,
  },
  {
    "rawnly/gist.nvim",
    config = function()
      
      return {
        {
          "Rawnly/gist.nvim",
          cmd = { "GistCreate", "GistCreateFromFile", "GistsList" },
          config = true
        },
        -- `GistsList` opens the selected gist in a terminal buffer,
        -- nvim-unception uses neovim remote rpc functionality to open the gist in an actual buffer
        -- and prevents neovim buffer inception
        {
          "samjwill/nvim-unception",
          lazy = false,
          init = function() vim.g.unception_block_while_host_edits = true end
        }
      }
      
      
      use {
        "rawnly/gist.nvim",
        config = function() require("gist").setup() end,
        -- `GistsList` opens the selected gif in a terminal buffer,
        -- this plugin uses neovim remote rpc functionality to open the gist in an actual buffer and not have buffer inception
        requires = { "samjwill/nvim-unception", setup = function() vim.g.unception_block_while_host_edits = true end }
      }
      
      
          require("gist").setup({
              private = false, -- All gists will be private, you won't be prompted again
              clipboard = "+", -- The registry to use for copying the Gist URL
              split_direction = "vertical", -- default: "vertical" - set window split orientation when opening a gist ("vertical" or "horizontal")
              gh_cmd = "gh"
              list = {
                  -- If there are multiple files in a gist you can scroll them,
                  -- with vim-like bindings n/p next previous
                  mappings = {
                      next_file = "<C-n>",
                      prev_file = "<C-p>"
                  }
              }
          })
      
    end,
  },
  {
    "2KAbhishek/octohub.nvim",
    config = function()
      
      -- Lazy nvim
      {
          '2kabhishek/octohub.nvim',
          cmd = { 'Octohub' },
          keys = { '<leader>goo' }, -- Add more bindings as needed
          dependencies = {
              '2kabhishek/utils.nvim',
              '2kabhishek/pickme.nvim',
          },
          -- Add your custom configs here, keep it blank for default configs (required)
          opts = {},
      },
      
      
      local octohub = require('octohub')
      
      octohub.setup({
          icons = { -- List of icons used by Octohub
              user = ' ',
              star = ' ', -- for more, check out config.lua
              contribution_icons = { '', '', '', '', '', '', '' }, -- Icons for different contribution levels
          }
          repos = {
              per_user_dir = true,          -- Create a directory for each user
              projects_dir = '~/Projects/', -- Directory where repositories are cloned
              sort_by = '',                 -- Sort repositories by various parameters
              repo_type = '',               -- Type of repositories to display
              language = '',                -- Repositories language filter
          },
          stats = {
              max_contributions = 50,       -- Max number of contributions per day to use for icon selection
              top_lang_count = 5,           -- Number of top languages to display in stats
              event_count = 5,              -- Number of activity events to show
              window_width = 90,            -- Width in percentage of the window to display stats
              window_height = 60,           -- Height in percentage of the window to display stats
              show_recent_activity = true,  -- Show recent activity in the stats window
              show_contributions = true,    -- Show contributions in the stats window
              show_repo_stats = true,       -- Show repository stats in the stats window
          },
          cache = {
              events = 3600 * 6,            -- Time in seconds to cache activity events
              contributions = 3600 * 6,     -- Time in seconds to cache contributions data
              repos = 3600 * 24 * 7,        -- Time in seconds to cache repositories
              username = 3600 * 24 * 7,     -- Time in seconds to cache username
              user = 3600 * 24 * 7,         -- Time in seconds to cache user data
          },
          add_default_keybindings = true,   -- Add default keybindings for the plugin
      })
      
      
      local telescope = require('telescope')
      
      telescope.load_extension('repos')
      
    end,
  },
  {
    "claydugo/browsher.nvim",
    config = function()
      
      {
        'claydugo/browsher.nvim',
        event = "VeryLazy",
        config = function()
          -- Specify empty to use below default options
          require('browsher').setup()
        end
      }
      
      
      require("browsher").setup({
          --- Default remote name (e.g., 'origin').
          default_remote = nil,
          --- Default branch name.
          default_branch = nil,
          --- Default pin type ('commit', 'branch', or 'tag').
          default_pin = "commit",
          --- Length of the commit hash to use in URLs. If nil, use full length. (40)
          commit_length = nil,
          --- Allow line numbers with uncommitted changes.
          allow_line_numbers_with_uncommitted_changes = false,
          --- Command to open URLs (e.g., 'firefox').
          --- If this is a single character, it will be interpreted as a vim register
          --- instead. For example, to copy the url to your OS clipboard instead of
          --- opening it inside an application, set `open_cmd` to `+` for unix systems,
          --- or `*` if you're on Windows.
          open_cmd = nil,
          --- Custom providers for building URLs.
          ---
          --- Each provider is a table with the following keys:
          --- - `url_template`: The URL template, where `%s` are placeholders.
          ---   The placeholders are, in order:
          ---   1. Remote URL
          ---   2. Branch or tag
          ---   3. Relative file path
          --- - `single_line_format`: Format string for a single line (e.g., `#L%d`).
          --- - `multi_line_format`: Format string for multiple lines (e.g., `#L%d-L%d`).
          ---
          --- Example:
          --- 
      
      -- Open from the latest commit, the recommended default operation
      vim.api.nvim_set_keymap('n', '<leader>b', '<cmd>Browsher commit<CR>', { noremap = true, silent = true })
      vim.api.nvim_set_keymap('v', '<leader>b', ":'<,'>Browsher commit<CR>gv", { noremap = true, silent = true })
      
      -- Open from the latest tag, for more human readable urls (with risk of outdated line numbers)
      vim.api.nvim_set_keymap('n', '<leader>B', '<cmd>Browsher tag<CR>', { noremap = true, silent = true })
      vim.api.nvim_set_keymap('v', '<leader>B', ":'<,'>Browsher tag<CR>gv", { noremap = true, silent = true })
      
    end,
  },
  {
    "comatory/gh-co.nvim",
  },
  {
    "harrisoncramer/GitLab.nvim",
    config = function()
      
      {
        "harrisoncramer/gitlab.nvim",
        dependencies = {
          "MunifTanjim/nui.nvim",
          "nvim-lua/plenary.nvim",
          "sindrets/diffview.nvim",
          "stevearc/dressing.nvim", -- Recommended but not required. Better UI for pickers.
          "nvim-tree/nvim-web-devicons", -- Recommended but not required. Icons in discussion tree.
        },
        build = function () require("gitlab.server").build(true) end, -- Builds the Go binary
        config = function()
          require("gitlab").setup()
        end,
      }
      
      
      {
        "harrisoncramer/gitlab.nvim",
        requires = {
          "MunifTanjim/nui.nvim",
          "nvim-lua/plenary.nvim",
          "sindrets/diffview.nvim",
          "stevearc/dressing.nvim", -- Recommended but not required. Better UI for pickers.
          "nvim-tree/nvim-web-devicons", -- Recommended but not required. Icons in discussion tree.
        },
        run = function() require("gitlab.server").build() end, -- Builds the Go binary
        config = function()
          require("diffview") -- We require some global state from diffview
          require("gitlab").setup()
        end,
      }
      
      
      require("gitlab").setup({
        auth_provider = function()
          return "my_token", "https://custom.gitlab.instance.url", nil
        end,
      }
      
    end,
  },
  {
    "HawkinsT/pathfinder.nvim",
    config = function()
      
      { 'HawkinsT/pathfinder.nvim' }
      
      
      Plug 'HawkinsT/pathfinder.nvim'
      
      
      require('pathfinder').setup({
      	-- Search behaviour
      	file_forward_limit = 0, -- Search from the cursor until the specified number of lines (for files)
      	url_forward_limit = 0, -- Search from the cursor until the specified number of lines (for URLs/repos/flakes)
      	scan_unenclosed_words = true, -- Include plain-text (non-delimited) file paths
      	use_column_numbers = true, -- Use both line and column numbers (if supplied) for cursor movements
      	open_mode = "edit", -- Open files in the current buffer (:edit), accepts string or function
          reuse_existing_window = true, -- If file is already open, go to its active window (don't reopen)
      	gF_count_behaviour = "nextfile", -- [count]gF will open the next file at line `count`
      	validate_urls = false, -- If true, require all url targets for next/prev_url() to resolve (slow)
      
      	-- File resolution settings
      	max_path_length = 4096, -- The maximum allowed length of any path to be scanned
      	associated_filetypes = {}, -- File extensions that should be tried (also see `suffixesadd`)
          url_providers = { -- List of software forges to try when resolving owner/repo links
      		"https://github.com/%s.git",
      	},
      	flake_providers = { -- List of Nix flake targets, e.g. github:owner/repo
      		github = "https://github.com/%s",
      		gitlab = "https://gitlab.com/%s",
      		sourcehut = "https://git.sr.ht/%s",
      	},
      	enclosure_pairs = { -- Define all file path delimiters to search between
      		["("] = ")",
      		["{"] = "}",
      		["["] = "]",
      		["<"] = ">",
      		['"'] = '"',
      		["'"] = "'",
      		["`"] = "`",
      	},
      	url_enclosure_pairs = nil, -- If set, this will supersede enclosure_pairs for URL picking
      	includeexpr = nil, -- Helper function to set `includeexpr`
      	ft_overrides = {}, -- Filetype-specific settings
      
      	-- User interaction
      	remap_default_keys = true, -- Remap `gf`, `gF`, and `<leader>gf` to Pathfinder's functions
      	offer_multiple_options = true, -- If multiple valid files with the same name are found, prompt for action
      	pick_from_all_windows = true, -- Provide `select_file()` and `select_file_line()` targets across all visible windows
      	selection_keys = { "a", "s", "d", "f", "j", "k", "l" }, -- Keys to use for selection in `select_file()` and `select_file_line()`
          tmux_mode = false, -- If true and in a tmux session, visual selection applies to the last active tmux pane
      })
      
      
      require('pathfinder').setup({
          ft_overrides = {
              lua = {
                  associated_filetypes = { ".lua", ".tl" },
                  enclosure_pairs = {
                      ["'"] = "'",
                      ['"'] = '"',
                      ['[['] = ']]',
                  },
                  includeexpr = "substitute(v:fname,'\\.\\w*','','')",
              },
          },
      })
      
      
      vim.api.nvim_set_hl(0, "PathfinderDim", { fg = "#808080", bg = "none" })
      vim.api.nvim_set_hl(0, "PathfinderHighlight", { fg = "#DDDDDD", bg = "none" })
      vim.api.nvim_set_hl(0, "PathfinderNumberHighlight", { fg = "#00FF00", bg = "none" })
      vim.api.nvim_set_hl(0, "PathfinderColumnHighlight", { fg = "#FFFF00", bg = "none" })
      vim.api.nvim_set_hl(0, "PathfinderNextKey", { fg = "#FF00FF", bg = "none" })
      vim.api.nvim_set_hl(0, "PathfinderFutureKeys", { fg = "#BB00AA", bg = "none" })
      
      
          vim.keymap.set('n', 'gf', require('pathfinder').gf)
          vim.keymap.set('n', 'gF', require('pathfinder').gF)
          vim.keymap.set('n', 'gx', require('pathfinder').gx)
          vim.keymap.set('n', '<leader>gf', require('pathfinder').select_file)
          vim.keymap.set('n', '<leader>gF', require('pathfinder').select_file_line)
          vim.keymap.set('n', '<leader>gx', require('pathfinder').select_url)
          vim.keymap.set("n", "<leader>h", require("pathfinder").hover_description, {
              desc = "Pathfinder: Hover",
              silent = true,
          })
          vim.keymap.set("n", "<leader>t", require("pathfinder").tmux_toggle, {
              desc = "Pathfinder: Toggle tmux Mode",
              silent = true,
          })
        
      
      {
          "nvim-lualine/lualine.nvim",
          dependencies = { "nvim-tree/nvim-web-devicons" },
          config = function()
              require("lualine").setup({
                  sections = {
                      lualine_a = {
                          -- If Pathfinder tmux_mode == true:
                          {
                              function()
                                  return "N-TMUX"
                              end,
                              cond = function()
                                  return require("pathfinder.config").config.tmux_mode
                                      and vim.fn.mode() == "n"
                              end,
                              color = { gui = "bold" },
                              padding = { left = 1, right = 1 },
                          },
                          -- Otherwise fall back to the built-in mode display:
                          {
                              "mode",
                              cond = function()
                                  return not (
                                      require("pathfinder.config").config.tmux_mode
                                      and vim.fn.mode() == "n"
                                  )
                              end,
                          },
                      },
                  },
              })
          end,
      },
      
    end,
  },
  {
    "tris203/precognition.nvim",
    config = function()
      
      
      return {
          "tris203/precognition.nvim",
          --event = "VeryLazy",
          opts = {
          -- startVisible = true,
          -- showBlankVirtLine = true,
          -- highlightColor = { link = "Comment" },
          -- hints = {
          --      Caret = { text = "^", prio = 2 },
          --      Dollar = { text = "$", prio = 1 },
          --      MatchingPair = { text = "%", prio = 5 },
          --      Zero = { text = "0", prio = 1 },
          --      w = { text = "w", prio = 10 },
          --      b = { text = "b", prio = 9 },
          --      e = { text = "e", prio = 8 },
          --      W = { text = "W", prio = 7 },
          --      B = { text = "B", prio = 6 },
          --      E = { text = "E", prio = 5 },
          -- },
          -- gutterHints = {
          --     G = { text = "G", prio = 10 },
          --     gg = { text = "gg", prio = 9 },
          --     PrevParagraph = { text = "{", prio = 8 },
          --     NextParagraph = { text = "}", prio = 8 },
          -- },
          -- disabled_fts = {
          --     "startify",
          -- },
          },
      }
      
      
      require("precognition").toggle()
      
      
      if require("precognition").toggle() then
          vim.notify("precognition on")
      else
          vim.notify("precognition off")
      end
      
      
      require("precognition").peek()
      
    end,
  },
  {
    "smoka7/hop.nvim",
    config = function()
      
      {
          'smoka7/hop.nvim',
          version = "*",
          opts = {
              keys = 'etovxqpdygfblzhckisuran'
          }
      }
      
      
      use {
        'smoka7/hop.nvim',
        tag = '*', -- optional but strongly recommended
        config = function()
          -- you can configure Hop the way you like here; see :h hop-config
          require'hop'.setup { keys = 'etovxqpdygfblzhckisuran' }
        end
      }
      
      
      -- place this in one of your configuration file(s)
      local hop = require('hop')
      local directions = require('hop.hint').HintDirection
      vim.keymap.set('', 'f', function()
        hop.hint_char1({ direction = directions.AFTER_CURSOR, current_line_only = true })
      end, {remap=true})
      vim.keymap.set('', 'F', function()
        hop.hint_char1({ direction = directions.BEFORE_CURSOR, current_line_only = true })
      end, {remap=true})
      vim.keymap.set('', 't', function()
        hop.hint_char1({ direction = directions.AFTER_CURSOR, current_line_only = true, hint_offset = -1 })
      end, {remap=true})
      vim.keymap.set('', 'T', function()
        hop.hint_char1({ direction = directions.BEFORE_CURSOR, current_line_only = true, hint_offset = 1 })
      end, {remap=true})
      
    end,
  },
  {
    "ggandor/lightspeed.nvim",
  },
  {
    "ggandor/leap.nvim",
    config = function()
      
      vim.keymap.set({'n', 'x', 'o'}, 's', '<Plug>(leap)')
      vim.keymap.set('n',             'S', '<Plug>(leap-from-window)')
      
      
      -- Exclude whitespace and the middle of alphabetic words from preview:
      --   foobar[baaz] = quux
      --   ^----^^^--^^-^-^--^
      require('leap').opts.preview_filter =
        function (ch0, ch1, ch2)
          return not (
            ch1:match('%s') or
            ch0:match('%a') and ch1:match('%a') and ch2:match('%a')
          )
        end
      
      
      require('leap').opts.equivalence_classes = { ' \t\r\n', '([{', ')]}', '\'"`' }
      
      
      require('leap.user').set_repeat_keys('<enter>', '<backspace>')
      
      
      vim.keymap.set({'x', 'o'}, 'R',  function ()
        require('leap.treesitter').select {
          -- To increase/decrease the selection in a clever-f-like manner,
          -- with the trigger key itself (vRRRRrr...). The default keys
          -- (<enter>/<backspace>) also work, so feel free to skip this.
          opts = require('leap.user').with_traversal_keys('R', 'r')
        }
      end)
      
      
      vim.keymap.set({'n', 'x', 'o'}, 'gs', function ()
        require('leap.remote').action()
      end)
      
      
      vim.keymap.set({'n', 'o'}, 'g/', function ()
        require('leap.remote').action { jumper = '/' }
      end)
      vim.keymap.set({'n', 'o'}, 'g?', function ()
        require('leap.remote').action { jumper = '?' }
      end)
      
      
      vim.api.nvim_create_autocmd('User', {
        pattern = 'RemoteOperationDone',
        group = vim.api.nvim_create_augroup('LeapRemote', {}),
        callback = function (event)
          -- Do not paste if some special register was in use.
          if vim.v.operator == 'y' and event.data.register == '"' then
            vim.cmd('normal! p')
          end
        end,
      })
      
      
      -- Trigger visual selection right away, so that you can `gs{leap}apy`:
      vim.keymap.set({'n', 'o'}, 'gs', function ()
        require('leap.remote').action { input = 'v' }
      end)
      
      
      
      -- Create remote versions of all a/i text objects by inserting `r`
      -- into the middle (`iw` becomes `irw`, etc.).
      do
        -- A trick to avoid having to create separate hardcoded mappings for
        -- each text object: when entering `ar`/`ir`, consume the next
        -- character, and create the input from that character concatenated to
        -- `a`/`i`.
        local remote_text_object = function (prefix)
           local ok, ch = pcall(vim.fn.getcharstr)  -- pcall for handling <C-c>
           if not ok or (ch == vim.keycode('<esc>')) then
             return
           end
           require('leap.remote').action { input = prefix .. ch }
        end
      
        for _, prefix in ipairs { 'a', 'i' } do
          vim.keymap.set({'x', 'o'}, prefix .. 'r', function ()
            remote_text_object(prefix)
          end)
        end
      end
      
      
      vim.keymap.set({'x', 'o'}, 'aa', function ()
        -- Force linewise selection.
        local V = vim.fn.mode(true):match('V') and '' or 'V'
        -- In any case, move horizontally, to trigger operations.
        local input = vim.v.count > 1 and (vim.v.count - 1 .. 'j') or 'hl'
        -- With `count=false` you can skip feeding count to the command
        -- automatically (we need -1 here, see above).
        require('leap.remote').action { input = V .. input, count = false }
      end)
      
      
      {
        ' \t\r\n', 'aäàáâãā', 'dḍ', 'eëéèêē', 'gǧğ', 'hḥḫ',
        'iïīíìîı', 'nñ', 'oō', 'sṣšß', 'tṭ', 'uúûüűū', 'zẓ'
      }
      
      
      local function remote_action ()
        require('leap').leap {
          target_windows = require('leap.user').get_focusable_windows(),
          action = function (target)
            local winid = target.wininfo.winid
            local lnum, col = unpack(target.pos)  -- 1/1-based indexing!
            -- ... do something at the given position ...
          end,
        }
      end
      
      
      require('leap').opts.safe_labels = {}
      
      
      require('leap').opts.labels = {}
      
      
      require('leap').opts.preview_filter = function () return false end
      
      
      -- `on_beacons` hooks into `beacons.light_up_beacons`, the function
      -- responsible for displaying stuff.
      require('leap').opts.on_beacons = function (targets, _, _)
        for _, t in ipairs(targets) do
          -- Overwrite the `offset` value in all beacons.
          -- target.beacon looks like: { <offset>, <extmark_opts> }
          if t.label and t.beacon then t.beacon[1] = 0 end
        end
      end
      
      
      vim.api.nvim_set_hl(0, 'LeapBackdrop', { link = 'Comment' })
      
      
      vim.api.nvim_create_autocmd('ColorScheme', {
        group = vim.api.nvim_create_augroup('LeapColorTweaks', {}),
        callback = function ()
          if vim.g.colors_name == 'bad_color_scheme' then
            -- Forces using the defaults: sets `IncSearch` for labels,
            -- `Search` for matches, removes `LeapBackdrop`, and updates the
            -- look of concealed labels.
            require('leap').init_hl(true)
          end
        end
      })
      
      
      vim.api.nvim_create_autocmd('CmdlineLeave', {
        group = vim.api.nvim_create_augroup('LeapOnSearch', {}),
        callback = function ()
          local ev = vim.v.event
          local is_search_cmd = (ev.cmdtype == '/') or (ev.cmdtype == '?')
          local cnt = vim.fn.searchcount().total
      
          if is_search_cmd and (not ev.abort) and (cnt > 1) then
            -- Allow CmdLineLeave-related chores to be completed before
            -- invoking Leap.
            vim.schedule(function ()
              -- We want "safe" labels, but no auto-jump (as the search
              -- command already does that), so just use `safe_labels`
              -- as `labels`, with n/N removed.
              local safe_labels = require('leap').opts.safe_labels
              if type(safe_labels) == 'string' then
                safe_labels = vim.fn.split(safe_labels, '\\zs')
              end
              local labels = vim.tbl_filter(function (l) return l:match('[^nN]') end,
                                            safe_labels)
              -- For `pattern` search, we never need to adjust conceallevel
              -- (no user input).
              local vim_opts = require('leap').opts.vim_opts
              vim_opts['wo.conceallevel'] = nil
      
              require('leap').leap {
                pattern = vim.fn.getreg('/'),  -- last search pattern
                target_windows = { vim.fn.win_getid() },
                opts = { safe_labels = '', labels = labels, vim_opts = vim_opts, }
              }
            end)
          end
        end,
      })
      
      
      do
        local function leap_search (key, is_reverse)
          local cmdline_mode = vim.fn.mode(true):match('^c')
          if cmdline_mode then
            -- Finish the search command.
            vim.api.nvim_feedkeys(vim.keycode('<enter>'), 't', false)
          end
          if vim.fn.searchcount().total < 1 then
            return
          end
          -- Activate again if `:nohlsearch` has been used (Normal/Visual mode).
          vim.go.hlsearch = vim.go.hlsearch
      
          -- Allow the search command to complete its chores before
          -- invoking Leap (Command-line mode).
          vim.schedule(function ()
            local leap = require('leap')
            -- Allow traversing with the trigger key.
            local next_target = vim.deepcopy(leap.opts.keys.next_target)
            if type(next_target) == 'string' then
              next_target = { next_target }
            end
            table.insert(next_target, key)
      
            leap.leap {
              pattern = vim.fn.getreg('/'),
              -- If you always want to go forward/backward with the given key,
              -- regardless of the previous search direction, just set this to
              -- `is_reverse`.
              backward = (is_reverse and vim.v.searchforward == 1)
                         or (not is_reverse and vim.v.searchforward == 0),
              opts = {
                keys = { next_target = next_target },
                -- Auto-jumping to the second match would be confusing without
                -- 'incsearch'.
                safe_labels = (cmdline_mode and not vim.o.incsearch) and ''
                  -- Keep n/N usable in any case.
                  or vim.tbl_filter(function (l) return l:match('[^nN]') end,
                                    leap.opts.safe_labels),
              }
            }
            -- You might want to switch off the highlights after leaping.
            -- vim.cmd('nohlsearch')
          end)
        end
      
        vim.keymap.set({'n', 'x', 'o', 'c'}, '<c-s>', function ()
          leap_search('<c-s>', false)
        end, { desc = 'Leap to search matches' })
      
        vim.keymap.set({'n', 'x', 'o', 'c'}, '<c-q>', function ()
          leap_search('<c-q>', true)
        end, { desc = 'Leap to search matches (reverse)' })
      end
      
      
      do
        -- Returns an argument table for `leap()`, tailored for f/t-motions.
        local function as_ft (key_specific_args)
          local common_args = {
            inputlen = 1,
            inclusive_op = true,
            -- To limit search scope to the current line:
            -- pattern = function (pat) return '\\%.l'..pat end,
            opts = {
              labels = {},  -- force autojump
              safe_labels = vim.fn.mode(1):match('o') and {} or nil,  -- [1]
              case_sensitive = true,                                  -- [2]
            },
          }
          return vim.tbl_deep_extend('keep', common_args, key_specific_args)
        end
      
        local clever = require('leap.user').with_traversal_keys       -- [3]
        local clever_f = clever('f', 'F')
        local clever_t = clever('t', 'T')
      
        for key, args in pairs {
          f = { opts = clever_f, },
          F = { backward = true, opts = clever_f },
          t = { offset = -1, opts = clever_t },
          T = { backward = true, offset = 1, opts = clever_t },
        } do
          vim.keymap.set({'n', 'x', 'o'}, key, function ()
            require('leap').leap(as_ft(args))
          end)
        end
      end
      
      ------------------------------------------------------------------------
      -- [1] Match the modes here for which you don't want to use labels
      --     (`:h mode()`, `:h lua-pattern`).
      -- [2] For 1-char search, you might want to aim for precision instead of
      --     typing comfort, to get as many direct jumps as possible.
      -- [3] This helper function makes it easier to set "clever-f"-like
      --     functionality (https://github.com/rhysd/clever-f.vim), returning
      --     an `opts` table derived from the defaults, where:
      --     * the given keys are added to `keys.next_target` and
      --       `keys.prev_target`
      --     * the forward key is used as the first label in `safe_labels`
      --     * the backward (reverse) key is removed from `safe_labels`
      
      
      vim.keymap.set({'n', 'x', 'o'}, '|', function ()
        local _, l, c = unpack(vim.fn.getpos('.'))
        -- Some Vim regex magic follows:
        local pattern =
          '\\v'
             -- Skip 3-3 lines around the cursor (`:help /\%l`).
          .. "(%<"..(math.max(1,l-3)).."l" .. '|' .. "%>"..(l+3).."l)"
             -- Cursor column or EOL before the cursor (`:help /\%c`).
          .. "(%"..c.."v" .. '|' .. "%<"..c.."v$)"
      
        require('leap').leap {
          pattern = pattern,
          target_windows = { vim.fn.win_getid() },
          opts = { safe_labels = '' }
        }
      end)
      
      
      local function get_targets (buf, picker)
        local scroller = require('telescope.pickers.scroller')
        local wininfo = vim.fn.getwininfo(picker.results_win)[1]
        local bottom = wininfo.botline - 2  -- skip the current row
        local top = math.max(
          scroller.top(picker.sorting_strategy,
                       picker.max_results,
                       picker.manager:num_results()),
          wininfo.topline - 1
        )
        local targets = {}
        for lnum = bottom, top, -1 do
          table.insert(targets, { wininfo = wininfo, pos = { lnum + 1, 1 } })
        end
        return targets
      end
      
      local function pick_with_leap (buf)
        local picker = require('telescope.actions.state').get_current_picker(buf)
        require('leap').leap {
          targets = get_targets(buf, picker),
          action = function (target)
            picker:set_selection(target.pos[1] - 1)
            require('telescope.actions').select_default(buf)
          end,
        }
      end
      
      require('telescope').setup {
        defaults = {
          mappings = {
            i = { ['<a-p>'] = pick_with_leap },
          }
        }
      }
      
    end,
  },
  {
    "ggandor/flit.nvim",
    config = function()
      
      require('flit').setup {
        keys = { f = 'f', F = 'F', t = 't', T = 'T' },
        -- A string like "nv", "nvo", "o", etc.
        labeled_modes = "v",
        -- Repeat with the trigger key itself.
        clever_repeat = true,
        multiline = true,
        -- Like `leap`s similar argument (call-specific overrides).
        -- E.g.: opts = { equivalence_classes = {} }
        opts = {}
      }
      
    end,
  },
  {
    "ggandor/leap-spooky.nvim",
    config = function()
      
      require('leap-spooky').setup {
        -- Additional text objects, to be merged with the default ones.
        -- E.g.: {'iq', 'aq'}
        extra_text_objects = nil,
        -- Mappings will be generated corresponding to all native text objects,
        -- like: (ir|ar|iR|aR|im|am|iM|aM){obj}.
        -- Special line objects will also be added, by repeating the affixes.
        -- E.g. `yrr<leap>` and `ymm<leap>` will yank a line in the current
        -- window.
        affixes = {
          -- The cursor moves to the targeted object, and stays there.
          magnetic = { window = 'm', cross_window = 'M' },
          -- The operation is executed seemingly remotely (the cursor boomerangs
          -- back afterwards).
          remote = { window = 'r', cross_window = 'R' },
        },
        -- Defines text objects like `riw`, `raw`, etc., instead of
        -- targets.vim-style `irw`, `arw`. (Note: prefix is forced if a custom
        -- text object does not start with "a" or "i".)
        prefix = false,
        -- The yanked text will automatically be pasted at the cursor position
        -- if the unnamed register is in use.
        paste_on_remote_yank = false,
      }
      
      
      require('leap').leap {
        target_windows = { vim.fn.win_getid() }
        action = require('leap-spooky').spooky_action(
          function () return "viw" end,
          { keeppos = true, on_exit = (vim.v.operator == 'y') and 'p', },
        ),
      }
      
    end,
  },
  {
    "rasulomaroff/telepath.nvim",
    config = function()
      
      {
        'rasulomaroff/telepath.nvim',
        dependencies = 'ggandor/leap.nvim',
        -- there's no sence in using lazy loading since telepath won't load the main module
        -- until you actually use mappings
        lazy = false,
        config = function()
          require('telepath').use_default_mappings()
        end
      }
      
      
      {
        'rasulomaroff/telepath.nvim',
        dependencies = 'ggandor/leap.nvim',
        keys = {
          -- you can use your own keys
          { 'r', function() require('telepath').remote { restore = true } end, mode = 'o' },
          { 'R', function() require('telepath').remote { restore = true, recursive = true } end, mode = 'o' },
          { 'm', function() require('telepath').remote() end, mode = 'o' },
          { 'M', function() require('telepath').remote { recursive = true } end, mode = 'o' }
        }
      }
      
      
      require('telepath').remote {
        restore = false,
        recursive = false,
        jumplist = true,
        -- only restore other windows, but not the source one
        window_restore = { source = false, rest = 'view' },
        remap = {
          y = true, -- just put `true` to use a remapped version
          d = 'x' -- you can remap it to use another key that should do the same operation, but with additional side-effects
        },
        hooks = {
          restore_pre = function(data)
            if true then
              data.fn.cancel_restoration()
            end
          end
        }
      }
      
      
      vim.api.nvim_create_autocmd('User', {
        pattern = 'TelepathEnter',
        callback = function(args)
          -- here's the data that's passed to each user command/hook
          vim.print(args.data)
        end
      })
      
      
      {
        opts: {
          action: {
            count: number,
            register: string,
            operator: string,
            regtype: string,
            remap?: string
          },
          restore: boolean,
          window_restore: {
            source: 'view' | 'cursor' | false,
            rest: 'view' | 'cursor' | false
          },
          recursive: boolean,
          jumplist: boolean
        },
        -- this field is only passed to `TelepathWindowRestorePre` and `TelepathRestorePre` commands
        fn: {
          -- only passed to `TelepathWindowRestorePre` command
          cancel_window_restoration: fun(),
          -- only passed to `TelepathRestorePre` command
          cancel_restoration: fun()
        }
      }
      
      
      require('telepath').use_default_mappings()
      
      
      require('telepath').use_default_mappings { overwrite = true }
      
      
      -- you can pass  the `overwrite` property here as well
      require('telepath').use_default_mappings { keys = { 'r', 'm' } }
      
      
      vim.keymap.set('o', 'r', function()
        require('telepath').remote {
          -- options
        }
      end, { desc = 'Remote action' })
      
    end,
  },
  {
    "folke/flash.nvim",
    config = function()
      
      {
        "folke/flash.nvim",
        event = "VeryLazy",
        ---@type Flash.Config
        opts = {},
        -- stylua: ignore
        keys = {
          { "s", mode = { "n", "x", "o" }, function() require("flash").jump() end, desc = "Flash" },
          { "S", mode = { "n", "x", "o" }, function() require("flash").treesitter() end, desc = "Flash Treesitter" },
          { "r", mode = "o", function() require("flash").remote() end, desc = "Remote Flash" },
          { "R", mode = { "o", "x" }, function() require("flash").treesitter_search() end, desc = "Treesitter Search" },
          { "<c-s>", mode = { "c" }, function() require("flash").toggle() end, desc = "Toggle Flash Search" },
        },
      }
      
      
      {
        -- labels = "abcdefghijklmnopqrstuvwxyz",
        labels = "asdfghjklqwertyuiopzxcvbnm",
        search = {
          -- search/jump in all windows
          multi_window = true,
          -- search direction
          forward = true,
          -- when `false`, find only matches in the given direction
          wrap = true,
          ---@type Flash.Pattern.Mode
          -- Each mode will take ignorecase and smartcase into account.
          -- * exact: exact match
          -- * search: regular search
          -- * fuzzy: fuzzy search
          -- * fun(str): custom function that returns a pattern
          --   For example, to only match at the beginning of a word:
          --   mode = function(str)
          --     return "\\<" .. str
          --   end,
          mode = "exact",
          -- behave like `incsearch`
          incremental = false,
          -- Excluded filetypes and custom window filters
          ---@type (string|fun(win:window))[]
          exclude = {
            "notify",
            "cmp_menu",
            "noice",
            "flash_prompt",
            function(win)
              -- exclude non-focusable windows
              return not vim.api.nvim_win_get_config(win).focusable
            end,
          },
          -- Optional trigger character that needs to be typed before
          -- a jump label can be used. It's NOT recommended to set this,
          -- unless you know what you're doing
          trigger = "",
          -- max pattern length. If the pattern length is equal to this
          -- labels will no longer be skipped. When it exceeds this length
          -- it will either end in a jump or terminate the search
          max_length = false, ---@type number|false
        },
        jump = {
          -- save location in the jumplist
          jumplist = true,
          -- jump position
          pos = "start", ---@type "start" | "end" | "range"
          -- add pattern to search history
          history = false,
          -- add pattern to search register
          register = false,
          -- clear highlight after jump
          nohlsearch = false,
          -- automatically jump when there is only one match
          autojump = false,
          -- You can force inclusive/exclusive jumps by setting the
          -- `inclusive` option. By default it will be automatically
          -- set based on the mode.
          inclusive = nil, ---@type boolean?
          -- jump position offset. Not used for range jumps.
          -- 0: default
          -- 1: when pos == "end" and pos < current position
          offset = nil, ---@type number
        },
        label = {
          -- allow uppercase labels
          uppercase = true,
          -- add any labels with the correct case here, that you want to exclude
          exclude = "",
          -- add a label for the first match in the current window.
          -- you can always jump to the first match with `<CR>`
          current = true,
          -- show the label after the match
          after = true, ---@type boolean|number[]
          -- show the label before the match
          before = false, ---@type boolean|number[]
          -- position of the label extmark
          style = "overlay", ---@type "eol" | "overlay" | "right_align" | "inline"
          -- flash tries to re-use labels that were already assigned to a position,
          -- when typing more characters. By default only lower-case labels are re-used.
          reuse = "lowercase", ---@type "lowercase" | "all" | "none"
          -- for the current window, label targets closer to the cursor first
          distance = true,
          -- minimum pattern length to show labels
          -- Ignored for custom labelers.
          min_pattern_length = 0,
          -- Enable this to use rainbow colors to highlight labels
          -- Can be useful for visualizing Treesitter ranges.
          rainbow = {
            enabled = false,
            -- number between 1 and 9
            shade = 5,
          },
          -- With `format`, you can change how the label is rendered.
          -- Should return a list of `[text, highlight]` tuples.
          ---@class Flash.Format
          ---@field state Flash.State
          ---@field match Flash.Match
          ---@field hl_group string
          ---@field after boolean
          ---@type fun(opts:Flash.Format): string[][]
          format = function(opts)
            return { { opts.match.label, opts.hl_group } }
          end,
        },
        highlight = {
          -- show a backdrop with hl FlashBackdrop
          backdrop = true,
          -- Highlight the search matches
          matches = true,
          -- extmark priority
          priority = 5000,
          groups = {
            match = "FlashMatch",
            current = "FlashCurrent",
            backdrop = "FlashBackdrop",
            label = "FlashLabel",
          },
        },
        -- action to perform when picking a label.
        -- defaults to the jumping logic depending on the mode.
        ---@type fun(match:Flash.Match, state:Flash.State)|nil
        action = nil,
        -- initial pattern to use when opening flash
        pattern = "",
        -- When `true`, flash will try to continue the last search
        continue = false,
        -- Set config to a function to dynamically change the config
        config = nil, ---@type fun(opts:Flash.Config)|nil
        -- You can override the default options for a specific mode.
        -- Use it with `require("flash").jump({mode = "forward"})`
        ---@type table<string, Flash.Config>
        modes = {
          -- options used when flash is activated through
          -- a regular search with `/` or `?`
          search = {
            -- when `true`, flash will be activated during regular search by default.
            -- You can always toggle when searching with `require("flash").toggle()`
            enabled = false,
            highlight = { backdrop = false },
            jump = { history = true, register = true, nohlsearch = true },
            search = {
              -- `forward` will be automatically set to the search direction
              -- `mode` is always set to `search`
              -- `incremental` is set to `true` when `incsearch` is enabled
            },
          },
          -- options used when flash is activated through
          -- `f`, `F`, `t`, `T`, `;` and `,` motions
          char = {
            enabled = true,
            -- dynamic configuration for ftFT motions
            config = function(opts)
              -- autohide flash when in operator-pending mode
              opts.autohide = opts.autohide or (vim.fn.mode(true):find("no") and vim.v.operator == "y")
      
              -- disable jump labels when not enabled, when using a count,
              -- or when recording/executing registers
              opts.jump_labels = opts.jump_labels
                and vim.v.count == 0
                and vim.fn.reg_executing() == ""
                and vim.fn.reg_recording() == ""
      
              -- Show jump labels only in operator-pending mode
              -- opts.jump_labels = vim.v.count == 0 and vim.fn.mode(true):find("o")
            end,
            -- hide after jump when not using jump labels
            autohide = false,
            -- show jump labels
            jump_labels = false,
            -- set to `false` to use the current line only
            multi_line = true,
            -- When using jump labels, don't use these keys
            -- This allows using those keys directly after the motion
            label = { exclude = "hjkliardc" },
            -- by default all keymaps are enabled, but you can disable some of them,
            -- by removing them from the list.
            -- If you rather use another key, you can map them
            -- to something else, e.g., { [";"] = "L", [","] = H }
            keys = { "f", "F", "t", "T", ";", "," },
            ---@alias Flash.CharActions table<string, "next" | "prev" | "right" | "left">
            -- The direction for `prev` and `next` is determined by the motion.
            -- `left` and `right` are always left and right.
            char_actions = function(motion)
              return {
                [";"] = "next", -- set to `right` to always go right
                [","] = "prev", -- set to `left` to always go left
                -- clever-f style
                [motion:lower()] = "next",
                [motion:upper()] = "prev",
                -- jump2d style: same case goes next, opposite case goes prev
                -- [motion] = "next",
                -- [motion:match("%l") and motion:upper() or motion:lower()] = "prev",
              }
            end,
            search = { wrap = false },
            highlight = { backdrop = true },
            jump = {
              register = false,
              -- when using jump labels, set to 'true' to automatically jump
              -- or execute a motion when there is only one match
              autojump = false,
            },
          },
          -- options used for treesitter selections
          -- `require("flash").treesitter()`
          treesitter = {
            labels = "abcdefghijklmnopqrstuvwxyz",
            jump = { pos = "range", autojump = true },
            search = { incremental = false },
            label = { before = true, after = true, style = "inline" },
            highlight = {
              backdrop = false,
              matches = false,
            },
          },
          treesitter_search = {
            jump = { pos = "range" },
            search = { multi_window = true, wrap = true, incremental = false },
            remote_op = { restore = true },
            label = { before = true, after = true, style = "inline" },
          },
          -- options used for remote flash
          remote = {
            remote_op = { restore = true, motion = true },
          },
        },
        -- options for the floating window that shows the prompt,
        -- for regular jumps
        -- `require("flash").prompt()` is always available to get the prompt text
        prompt = {
          enabled = true,
          prefix = { { "⚡", "FlashPromptIcon" } },
          win_config = {
            relative = "editor",
            width = 1, -- when <=1 it's a percentage of the editor width
            height = 1,
            row = -1, -- when negative it's an offset from the bottom
            col = 0, -- when negative it's an offset from the right
            zindex = 1000,
          },
        },
        -- options for remote operator pending mode
        remote_op = {
          -- restore window views and cursor position
          -- after doing a remote operation
          restore = false,
          -- For `jump.pos = "range"`, this setting is ignored.
          -- `true`: always enter a new motion when doing a remote operation
          -- `false`: use the window's cursor position and jump target
          -- `nil`: act as `true` for remote windows, `false` for the current window
          motion = false,
        },
      }
      
      
          require("flash").jump({
            remote_op = {
              restore = true,
              motion = true,
            },
          })
          
      
          require("flash").jump({
            remote_op = {
              restore = true,
              motion = nil,
            },
          })
          
      
      require("flash").jump({
        search = { forward = true, wrap = false, multi_window = false },
      })
      
      
      require("flash").jump({
        search = { forward = false, wrap = false, multi_window = false },
      })
      
      
      require("flash").jump({
        action = function(match, state)
          vim.api.nvim_win_call(match.win, function()
            vim.api.nvim_win_set_cursor(match.win, match.pos)
            vim.diagnostic.open_float()
          end)
          state:restore()
        end,
      })
      
      -- More advanced example that also highlights diagnostics:
      require("flash").jump({
        matcher = function(win)
          ---@param diag Diagnostic
          return vim.tbl_map(function(diag)
            return {
              pos = { diag.lnum + 1, diag.col },
              end_pos = { diag.end_lnum + 1, diag.end_col - 1 },
            }
          end, vim.diagnostic.get(vim.api.nvim_win_get_buf(win)))
        end,
        action = function(match, state)
          vim.api.nvim_win_call(match.win, function()
            vim.api.nvim_win_set_cursor(match.win, match.pos)
            vim.diagnostic.open_float()
          end)
          state:restore()
        end,
      })
      
      
      require("flash").jump({
        search = {
          mode = function(str)
            return "\\<" .. str
          end,
        },
      })
      
      
      require("flash").jump({
        pattern = vim.fn.expand("<cword>"),
      })
      
      
      require("flash").jump({
        search = { mode = "search", max_length = 0 },
        label = { after = { 0, 0 } },
        pattern = "^"
      })
      
      
      require("flash").jump({
        pattern = ".", -- initialize pattern with any char
        search = {
          mode = function(pattern)
            -- remove leading dot
            if pattern:sub(1, 1) == "." then
              pattern = pattern:sub(2)
            end
            -- return word pattern and proper skip pattern
            return ([[\<%s\w*\>]]):format(pattern), ([[\<%s]]):format(pattern)
          end,
        },
        -- select the range
        jump = { pos = "range" },
      })
      
      
      {
        modes = {
          char = {
            jump_labels = true
          }
        }
      }
      
      
      vim.keymap.set({"n", "x", "o"}, "<c-space>", function()
        require("flash").treesitter({
          actions = {
            ["<c-space>"] = "next",
            ["<BS>"] = "prev"
          }
        })
      end, { desc = "Treesitter incremental selection" })
      
      
      {
          "nvim-telescope/telescope.nvim",
          optional = true,
          opts = function(_, opts)
            local function flash(prompt_bufnr)
              require("flash").jump({
                pattern = "^",
                label = { after = { 0, 0 } },
                search = {
                  mode = "search",
                  exclude = {
                    function(win)
                      return vim.bo[vim.api.nvim_win_get_buf(win)].filetype ~= "TelescopeResults"
                    end,
                  },
                },
                action = function(match)
                  local picker = require("telescope.actions.state").get_current_picker(prompt_bufnr)
                  picker:set_selection(match.pos[1] - 1)
                end,
              })
            end
            opts.defaults = vim.tbl_deep_extend("force", opts.defaults or {}, {
              mappings = {
                n = { s = flash },
                i = { ["<c-s>"] = flash },
              },
            })
          end,
        }
      
      
      {
          "folke/snacks.nvim",
          opts = {
            picker = {
              win = {
                input = {
                  keys = {
                    ["<a-s>"] = { "flash", mode = { "n", "i" } },
                    ["s"] = { "flash" },
                  },
                },
              },
              actions = {
                flash = function(picker)
                  require("flash").jump({
                    pattern = "^",
                    label = { after = { 0, 0 } },
                    search = {
                      mode = "search",
                      exclude = {
                        function(win)
                          return vim.bo[vim.api.nvim_win_get_buf(win)].filetype ~= "snacks_picker_list"
                        end,
                      },
                    },
                    action = function(match)
                      local idx = picker.list:row2idx(match.pos[1])
                      picker.list:_move(idx, true, true)
                    end,
                  })
                end,
              },
            },
          },
        }
      
      
      require("flash").jump({continue = true})
      
      
      local Flash = require("flash")
      
      ---@param opts Flash.Format
      local function format(opts)
        -- always show first and second label
        return {
          { opts.match.label1, "FlashMatch" },
          { opts.match.label2, "FlashLabel" },
        }
      end
      
      Flash.jump({
        search = { mode = "search" },
        label = { after = false, before = { 0, 0 }, uppercase = false, format = format },
        pattern = [[\<]],
        action = function(match, state)
          state:hide()
          Flash.jump({
            search = { max_length = 0 },
            highlight = { matches = false },
            label = { format = format },
            matcher = function(win)
              -- limit matches to the current label
              return vim.tbl_filter(function(m)
                return m.label == match.label and m.win == win
              end, state.results)
            end,
            labeler = function(matches)
              for _, m in ipairs(matches) do
                m.label = m.label2 -- use the second label
              end
            end,
          })
        end,
        labeler = function(matches, state)
          local labels = state:labels()
          for m, match in ipairs(matches) do
            match.label1 = labels[math.floor((m - 1) / #labels) + 1]
            match.label2 = labels[(m - 1) % #labels + 1]
            match.label = match.label1
          end
        end,
      })
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-jump.md",
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-jump2d.md",
  },
  {
    "rlane/pounce.nvim",
    config = function()
      
      local map = vim.keymap.set
      map("n", "s", function() require'pounce'.pounce { } end)
      map("n", "S", function() require'pounce'.pounce { do_repeat = true } end)
      map("x", "s", function() require'pounce'.pounce { } end)
      map("o", "gs", function() require'pounce'.pounce { } end)
      map("n", "S", function() require'pounce'.pounce { input = {reg="/"} } end)
      
      
      require'pounce'.pounce{
          do_repeat = true|false -- to reuse the last pounce search
          input = string|table -- a string to initialize the input, or a table:
          input = {
              reg = string -- the name of a vim register to use as the input (:h registers)
              expand = string -- an expression passed to vim.fn.expand (:h expand())
          }
      }
      
      
      require'pounce'.setup{
        accept_keys = "JFKDLSAHGNUVRBYTMICEOXWPQZ",
        accept_best_key = "<enter>",
        multi_window = true,
        debug = false,
      }
      
    end,
  },
  {
    "xiaoshihou514/squirrel.nvim",
    config = function()
      
      -- jump to start of any node on the current line
      vim.keymap.set({ "n", "x" }, "gaa", require("squirrel.hop").hop_linewise)
      -- jump to start of any visible node
      vim.keymap.set({ "n", "x" }, "ga", require("squirrel.hop").hop)
      -- jump to end of any node on the current line
      vim.keymap.set({ "n", "x" }, "gee", function()
          require("squirrel.hop").hop_linewise({
              head = false,
              tail = true,
          })
      end)
      -- jump to end of any visible node
      vim.keymap.set({ "n", "x" }, "ge", function()
          require("squirrel.hop").hop({
              head = false,
              tail = true,
          })
      end)
      
      
      require("squirrel.hop").hop_linewise({ head = true, tail = true })
      
    end,
  },
  {
    "abecodes/tabout.nvim",
    config = function()
      
      -- Lua
      use {
        'abecodes/tabout.nvim',
        config = function()
          require('tabout').setup {
          tabkey = '<Tab>', -- key to trigger tabout, set to an empty string to disable
          backwards_tabkey = '<S-Tab>', -- key to trigger backwards tabout, set to an empty string to disable
          act_as_tab = true, -- shift content if tab out is not possible
          act_as_shift_tab = false, -- reverse shift content if tab out is not possible (if your keyboard/terminal supports <S-Tab>)
          default_tab = '<C-t>', -- shift default action (only at the beginning of a line, otherwise <TAB> is used)
          default_shift_tab = '<C-d>', -- reverse shift default action,
          enable_backwards = true, -- well ...
          completion = true, -- if the tabkey is used in a completion pum
          tabouts = {
            {open = "'", close = "'"},
            {open = '"', close = '"'},
            {open = '`', close = '`'},
            {open = '(', close = ')'},
            {open = '[', close = ']'},
            {open = '{', close = '}'}
          },
          ignore_beginning = true, --[[ if the cursor is at the beginning of a filled element it will rather tab out than shift the content ]]
          exclude = {} -- tabout will ignore these filetypes
      }
        end,
      	wants = {'nvim-treesitter'}, -- (optional) or require if not used so far
      	after = {'nvim-cmp'} -- if a completion plugin is using tabs load it before
      }
      
      
      -- Lua
      return {
        {
          'abecodes/tabout.nvim',
          lazy = false,
          config = function()
            require('tabout').setup {
              tabkey = '<Tab>', -- key to trigger tabout, set to an empty string to disable
              backwards_tabkey = '<S-Tab>', -- key to trigger backwards tabout, set to an empty string to disable
              act_as_tab = true, -- shift content if tab out is not possible
              act_as_shift_tab = false, -- reverse shift content if tab out is not possible (if your keyboard/terminal supports <S-Tab>)
              default_tab = '<C-t>', -- shift default action (only at the beginning of a line, otherwise <TAB> is used)
              default_shift_tab = '<C-d>', -- reverse shift default action,
              enable_backwards = true, -- well ...
              completion = false, -- if the tabkey is used in a completion pum
              tabouts = {
                { open = "'", close = "'" },
                { open = '"', close = '"' },
                { open = '`', close = '`' },
                { open = '(', close = ')' },
                { open = '[', close = ']' },
                { open = '{', close = '}' }
              },
              ignore_beginning = true, --[[ if the cursor is at the beginning of a filled element it will rather tab out than shift the content ]]
              exclude = {} -- tabout will ignore these filetypes
            }
          end,
          dependencies = { -- These are optional
            "nvim-treesitter/nvim-treesitter",
            "L3MON4D3/LuaSnip",
            "hrsh7th/nvim-cmp"
          },
          opt = true,  -- Set this to true if the plugin is optional
          event = 'InsertCharPre', -- Set the event to 'InsertCharPre' for better compatibility
          priority = 1000,
        },
        {
          "L3MON4D3/LuaSnip",
          keys = function()
            -- Disable default tab keybinding in LuaSnip
            return {}
          end,
        },
      }
      
      
      
      -- default
      tabkey = '<Tab>'
      
      
      -- default
      backwards_tabkey = '<S-Tab>'
      
      
      -- default
      act_as_tab = true
      
      
      -- default
      act_as_shift_tab = false
      
      
      -- default
      default_tab = '<C-t>'
      
      
      -- default
      default_shift_tab = '<C-d>'
      
      
      -- default
      enable_backwards = true
      
      
      -- default
      completion = true
      
      
      -- default
      tabouts = {
        {open = "'", close = "'"},
        {open = '"', close = '"'},
        {open = '`', close = '`'},
        {open = '(', close = ')'},
        {open = '[', close = ']'},
        {open = '{', close = '}'}
      }
      
      
      -- default
      ignore_beginning = true
      
      
      require("tabout").setup({
        tabkey = "",
        backwards_tabkey = "",
      })
      
      local function replace_keycodes(str)
        return vim.api.nvim_replace_termcodes(str, true, true, false)
      end
      
      function _G.tab_binding()
        if vim.fn.pumvisible() ~= 0 then
          return replace_keycodes("<C-n>")
        elseif vim.fn["vsnip#available"](1) ~= 0 then
          return replace_keycodes("<Plug>(vsnip-expand-or-jump)")
        else
          return replace_keycodes("<Plug>(Tabout)")
        end
      end
      
      function _G.s_tab_binding()
        if vim.fn.pumvisible() ~= 0 then
          return replace_keycodes("<C-p>")
        elseif vim.fn["vsnip#jumpable"](-1) ~= 0 then
          return replace_keycodes("<Plug>(vsnip-jump-prev)")
        else
          return replace_keycodes("<Plug>(TaboutBack)")
        end
      end
      
      vim.api.nvim_set_keymap("i", "<Tab>", "v:lua.tab_binding()", {expr = true})
      vim.api.nvim_set_keymap("i", "<S-Tab>", "v:lua.s_tab_binding()", {expr = true})
      
      
      ['<Tab>'] = function(fallback)
          if cmp.visible() then
            cmp.select_next_item()
          elseif luasnip.expand_or_jumpable() then
            vim.fn.feedkeys(vim.api.nvim_replace_termcodes('<Plug>luasnip-expand-or-jump', true, true, false), '')
          else
            fallback()
          end
        end,
        ['<S-Tab>'] = function(fallback)
          if cmp.visible() then
            cmp.select_prev_item()
          elseif luasnip.jumpable(-1) then
            vim.fn.feedkeys(vim.api.nvim_replace_termcodes('<Plug>luasnip-jump-prev', true, true, false), '')
          else
            fallback()
          end
        end,
      
      
      ["<Tab>"] = function(fallback)
        if cmp.visible() then
          -- cmp.select_next_item()
          cmp.confirm(
            {
              behavior = cmp.ConfirmBehavior.Insert,
              select = true
            }
          )
        elseif vim.fn["vsnip#available"](1) ~= 0 then
          vim.fn.feedkeys(vim.api.nvim_replace_termcodes("<Plug>(vsnip-expand-or-jump)", true, true, true), "")
        else
          fallback()
        end
      end,
      ["<S-Tab>"] = function(fallback)
        if cmp.visible() then
          cmp.select_prev_item()
        elseif vim.fn["vsnip#available"](1) ~= 0 then
          vim.fn.feedkeys(vim.api.nvim_replace_termcodes("<Plug>(vsnip-jump-prev)", true, true, true), "")
        else
          fallback()
        end
      end,
      
      
      -- A multiline tabout setup could look like this
      vim.api.nvim_set_keymap('i', '<A-x>', "<Plug>(TaboutMulti)", {silent = true})
      vim.api.nvim_set_keymap('i', '<A-z>', "<Plug>(TaboutBackMulti)", {silent = true})
      
      
      -- Using hooks
      vim.api.nvim_create_autocmd("User", {
        pattern = "TaboutAfter",
        callback = --[[ your function or command here ]],
      })
      
    end,
  },
  {
    "roobert/tabtree.nvim",
    config = function()
      
        {
          "roobert/tabtree.nvim",
          config = function()
            require("tabtree").setup()
          end,
        },
      
      
        {
          "roobert/tabtree.nvim",
          config = function()
            require("tabtree").setup({
              -- print the capture group name when executing next/previous
              --debug = true,
      
              -- disable key bindings
              --key_bindings_disabled = true,
      
              key_bindings = {
                next = "<Tab>",
                previous = "<S-Tab>",
              },
      
              -- use :InspectTree to discover the (capture group)
              -- @capture_name can be anything
              language_configs = {
                python = {
                  target_query = [[
                    (string) @string_capture
                    (interpolation) @interpolation_capture
                    (parameters) @parameters_capture
                    (argument_list) @argument_list_capture
                  ]],
                  -- experimental feature, to move the cursor in certain situations like when handling python f-strings
                  offsets = {
                    string_start_capture = 1,
                  },
                },
              },
      
              default_config = {
                target_query = [[
                    (string) @string_capture
                    (interpolation) @interpolation_capture
                    (parameters) @parameters_capture
                    (argument_list) @argument_list_capture
                ]],
                offsets = {},
              }
            })
          end,
        },
      
    end,
  },
  {
    "woosaaahh/sj.nvim",
    config = function()
      
      local sj = require("sj")
      sj.setup()
      
      vim.keymap.set("n", "s", sj.run)
      vim.keymap.set("n", "<A-,>", sj.prev_match)
      vim.keymap.set("n", "<A-;>", sj.next_match)
      vim.keymap.set("n", "<localleader>s", sj.redo)
      
      
      local config = {
        auto_jump = false, -- if true, automatically jump on the sole match
        forward_search = true, -- if true, the search will be done from top to bottom
        highlights_timeout = 0, -- if > 0, wait for 'updatetime' + N ms to clear hightlights (sj.prev_match/sj.next_match)
        inclusive = false, -- if true, the jump target will be included with 'operator-pending' keymaps
        max_pattern_length = 0, -- if > 0, wait for a label after N characters
        pattern = "", -- predefined pattern to use at the start of a search
        pattern_type = "vim", -- how to interpret the pattern (lua_plain, lua, vim, vim_very_magic)
        preserve_highlights = true, -- if true, create an autocmd to preserve highlights when switching colorscheme
        prompt_prefix = "", -- if set, the string will be used as a prefix in the command line
        relative_labels = false, -- if true, labels are ordered from the cursor position, not from the top of the buffer
        search_scope = "visible_lines", -- (current_line, visible_lines_above, visible_lines_below, visible_lines, buffer)
        select_window = false, -- if true, ask for a window to jump to before starting the search
        separator = ":", -- character used to split the user input in <pattern> and <label> (can be empty)
        stop_on_fail = true, -- if true, the search will stop when a search fails (no matches)
        update_search_register = false, -- if true, update the search register with the last used pattern
        use_last_pattern = false, -- if true, reuse the last pattern for next calls
        use_overlay = true, -- if true, apply an overlay to better identify labels and matches
        wrap_jumps = vim.o.wrapscan, -- if true, wrap the jumps when focusing previous or next label
      
        --- keymaps used during the search
        keymaps = { 
          cancel = "<Esc>", -- cancel the search
          validate = "<CR>", -- jump to the focused match
          prev_match = "<A-,>", -- focus the previous match
          next_match = "<A-;>", -- focus the next match
          prev_pattern = "<C-p>", -- select the previous pattern while searching
          next_pattern = "<C-n>", -- select the next pattern while searching
          ---
          delete_prev_char = "<BS>", -- delete the previous character
          delete_prev_word = "<C-w>", -- delete the previous word
          delete_pattern = "<C-u>", -- delete the whole pattern
          restore_pattern = "<A-BS>", -- restore the pattern to the last version having matches
          ---
          send_to_qflist = "<A-q>", --- send the search results to the quickfix list
        },
      
        --- labels used for each matches. (one-character strings only)
        -- stylua: ignore
        labels = {
          "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
          "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
          "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
          "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
          "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ",", ";", "!",
        },
      }
      
      
      local sj = require("sj")
      local sj_cache = require("sj.cache")
      
      --- Configuration ------------------------------------------------------------------------
      
      sj.setup({
        prompt_prefix = "/",
      
        -- stylua: ignore
        highlights = {
          SjFocusedLabel = { bold = false, italic = false, fg = "#FFFFFF", bg = "#C000C0", },
          SjLabel =        { bold = true , italic = false, fg = "#000000", bg = "#5AA5DE", },
          SjLimitReached = { bold = true , italic = false, fg = "#000000", bg = "#DE945A", },
          SjMatches =      { bold = false, italic = false, fg = "#DDDDDD", bg = "#005080", },
          SjNoMatches =    { bold = false, italic = false, fg = "#DE945A",                 },
          SjOverlay =      { bold = false, italic = false, fg = "#345576",                 },
        },
      
        keymaps = {
          send_to_qflist = "<C-q>", --- send search result to the quickfix list
        },
      })
      
      --- Keymaps ------------------------------------------------------------------------------
      
      vim.keymap.set("n", "!", function()
      	sj.run({ select_window = true })
      end)
      
      vim.keymap.set("n", "<A-!>", function()
      	sj.select_window()
      end)
      
      --- visible lines -------------------------------------
      
      vim.keymap.set({ "n", "o", "x" }, "S", function()
        vim.fn.setpos("''", vim.fn.getpos("."))
        sj.run({
          forward_search = false,
        })
      end)
      
      vim.keymap.set({ "n", "o", "x" }, "s", function()
        vim.fn.setpos("''", vim.fn.getpos("."))
        sj.run()
      end)
      
      vim.keymap.set("n", "<localleader>c", function()
        sj.run({
          max_pattern_length = 1,
          pattern_type = "lua_plain",
        })
      end)
      
      --- buffer --------------------------------------------
      
      vim.keymap.set("n", "gS", function()
        vim.fn.setpos("''", vim.fn.getpos("."))
        sj.run({
          forward_search = false,
          search_scope = "buffer",
          update_search_register = true,
        })
      end)
      
      vim.keymap.set("n", "gs", function()
        vim.fn.setpos("''", vim.fn.getpos("."))
        sj.run({
          search_scope = "buffer",
          update_search_register = true,
        })
      end)
      
      --- current line --------------------------------------
      
      vim.keymap.set({ "n", "o", "x" }, "<localleader>l", function()
        sj.run({
          auto_jump = true,
          max_pattern_length = 1,
          pattern_type = "lua_plain",
          search_scope = "current_line",
          use_overlay = false,
        })
      end)
      
      vim.keymap.set("o", "f", function()
      	sj.run({
      		auto_jump = true,
      		forward_search = true,
      		inclusive = true,
      		max_pattern_length = 1,
      		pattern_type = "lua_plain",
      		search_scope = "current_line", -- works with other scopes
      		use_overlay = false,
      	})
      end)
      
      vim.keymap.set("o", "F", function()
      	sj.run({
      		auto_jump = true,
      		forward_search = false,
      		inclusive = true,
      		max_pattern_length = 1,
      		pattern_type = "lua_plain",
      		search_scope = "current_line", -- works with other scopes
      		use_overlay = false,
      	})
      end)
      
      vim.keymap.set("o", "t", function()
      	sj.run({
      		auto_jump = true,
      		forward_search = true,
      		inclusive = false,
      		max_pattern_length = 1,
      		pattern_type = "lua_plain",
      		search_scope = "current_line", -- works with other scopes
      		use_overlay = false,
      	})
      end)
      
      vim.keymap.set("o", "T", function()
      	sj.run({
      		auto_jump = true,
      		forward_search = false,
      		inclusive = false,
      		max_pattern_length = 1,
      		pattern_type = "lua_plain",
      		search_scope = "current_line", -- works with other scopes
      		use_overlay = false,
      	})
      end)
      
      --- prev/next match -----------------------------------
      
      vim.keymap.set("n", "<A-,>", function()
        sj.prev_match()
        if sj_cache.options.search_scope:match("^buffer") then
          vim.cmd("normal! zzzv")
        end
      end)
      
      vim.keymap.set("n", "<A-;>", function()
        sj.next_match()
        if sj_cache.options.search_scope:match("^buffer") then
          vim.cmd("normal! zzzv")
        end
      end)
      
      --- redo ----------------------------------------------
      
      vim.keymap.set("n", "<localleader>a", function()
        local relative_labels = sj_cache.options.relative_labels
        sj.redo({
          relative_labels = false,
          max_pattern_length = 1,
        })
        sj_cache.options.relative_labels = relative_labels
      end)
      
      vim.keymap.set("n", "<localleader>s", function()
        sj.redo({
          relative_labels = true,
          max_pattern_length = 1,
        })
      end)
      
    end,
  },
  {
    "Weissle/easy-action",
    config = function()
      
      use {
        'Weissle/easy-action',
        requires = {
          {
            "kevinhwang91/promise-async",
            module = { "async" },
          }
        }
      }
      
      
      -- Below setting is default and you don't need to copy it. You may just require("easy-action").setup({})
      require("easy-action").setup({
        -- These chars can show up any times in your action input.
        free_chars = "0123456789",
        -- These chars can show up no more than twice in action input.
        limited_chars = "iafFtT",
        -- Cancel action.
        terminate_char = "<ESC>",
        -- all action contains `key` will be replaced by `value`. For example yib -> yi(
        remap = {
          ib = "i(",
          ab = "a(",
        },
        -- Default jump provider
        jump_provider = "hop",
        jump_provider_config = {
          hop = {
            action_select = {
              char1 = {
                -- action ends with any char of options will use HopChar1MW command.
                options = "(){}[]<>`'\"",
                cmd = "HopChar1MW",
                feed = function(action)
                  return string.sub(action, #action)
                end,
              },
              line = {
                -- action ends with any char of options will use HopLineMW command.
                options = "yd",
                cmd = "HopLineMW",
              },
              -- Default command.
              default = "HopChar2MW",
            },
          },
          leap = {
            action_select = {
              default = function()
                require("leap").leap({ target_windows = require("leap.util").get_enterable_windows() })
              end,
            },
          },
        },
        -- Just make sure they are greater than 0. Usually 1 is all right.
        jump_back_delay_ms = 1,
        feed_delay_ms = 1,
      })
      
      
      require("easy-action").setup({
        jump_provider = "other_jump_plugin_name",
        jump_provider_config = {
          other_jump_plugin_name = function(action)
            -- Your will get the action which is going to be executed. And you can choose your jump command. 
            -- It can be string, then easy-action will do vim.cmd(ret).
            -- It can be function, then easy-action will call ret().
            -- It can be table, {cmd = string|function, feed = string}, then easy-action will execute this cmd and feed the `feed`.
          end
        }
      })
      
      
      local opts = { silent=true, remap=false }
      -- trigger easy-action.
      vim.keymap.set("n","<leader>e", "<cmd>BasicEasyAction<cr>", opts)
      
      -- To insert something and jump back after you leave the insert mode
      vim.keymap.set("n","<leader>ei", function()
        require("easy-action").base_easy_action("i", nil, "InsertLeave")
      end, opts)
      
      -- run :h base_easy_action() to see more details about the base_easy_action.
      
      
    end,
  },
  {
    "cbochs/portal.nvim",
    config = function()
      
      vim.keymap.set("n", "<leader>o", "<cmd>Portal jumplist backward<cr>")
      vim.keymap.set("n", "<leader>i", "<cmd>Portal jumplist forward<cr>")
      
      
      {
          "cbochs/portal.nvim",
          -- Optional dependencies
          dependencies = {
              "cbochs/grapple.nvim",
              "ThePrimeagen/harpoon"
          },
      }
      
      
      use {
          "cbochs/portal.nvim",
          -- Optional dependencies
          requires = {
              "cbochs/grapple.nvim",
              "ThePrimeagen/harpoon"
          },
      }
      
      
      require("portal").setup({
          ---@type "debug" | "info" | "warn" | "error"
          log_level = "warn",
      
          ---The base filter applied to every search.
          ---@type Portal.SearchPredicate | nil
          filter = nil,
      
          ---The maximum number of results for any search.
          ---@type integer | nil
          max_results = nil,
      
          ---The maximum number of items that can be searched.
          ---@type integer
          lookback = 100,
      
          ---An ordered list of keys for labelling portals.
          ---Labels will be applied in order, or to match slotted results.
          ---@type string[]
          labels = { "j", "k", "h", "l" },
      
          ---Select the first portal when there is only one result.
          select_first = false,
      
          ---Keys used for exiting portal selection. Disable with [{key}] = false
          ---to `false`.
          ---@type table<string, boolean>
          escape = {
              ["<esc>"] = true,
          },
      
          ---The raw window options used for the portal window
          window_options = {
              relative = "cursor",
              width = 80,
              height = 3,
              col = 2,
              focusable = false,
              border = "single",
              noautocmd = true,
          },
      })
      
      
      -- Open a default search for the changelist
      require("portal.builtin").changelist.tunnel()
      
      
      -- Open a default search for grapples's tags
      require("portal.builtin").grapple.tunnel()
      
      
      -- Open a default search for harpoon's marks
      require("portal.builtin").harpoon.tunnel()
      
      
      -- Open a default search for the jumplist
      require("portal.builtin").jumplist.tunnel()
      
      -- Open a queried search for the jumplist going backwards (<c-o>)
      -- Query for two jumps:
      -- 1. A jump that is in the same buffer as the current buffer
      -- 2. A jump that is in a buffer that has been modified
      require("portal.builtin").jumplist.tunnel_backward({
          slots = {
              function(value) return value.buffer == vim.fn.bufnr() end,
              function(value) return vim.api.nvim_buf_get_option(value.buffer, "modified") end,
          }
      })
      
      -- Open a filtered search for the jumplist going forwards (<c-i>)
      -- Filters the results based on whether the buffer has been tagged
      -- by grapple.nvim or not. Return a maximum of two results.
      require("portal.builtin").jumplist.tunnel_forward({
          max_results = 2,
          filter = function(value)
              return require("grapple").exists({ buffer = value.buffer })
          end,
      })
      
      
      -- Open portals for the quickfix list (from the top)
      require("portal.builtin").quickfix.tunnel()
      
      
      -- Run a simple filtered search over the jumplist
      local query = require("portal.builtin").jumplist.query()
      require("portal").tunnel(query)
      
      
      -- Search both the jumplist and quickfix list
      require("portal").tunnel({
          require("portal.builtin").jumplist.query({ max_results = 1 })
          require("portal.builtin").quickfix.query({ max_results = 1 }),
      })
      
      
      -- Return the results of a query over the jumplist and quickfix list
      local results = require("portal").search({
          require("portal.builtin").jumplist.query()
          require("portal.builtin").quickfix.query(),
      })
      
      -- Select the first location from the list of results
      results[1]:select()
      
      
      -- Return the results of a query over the jumplist and quickfix list
      local query = require("portal.builtin").jumplist.query()
      local results = require("portal").search(query)
      local windows = require("portal").portals(results)
      
      -- Open the portal windows
      require("portal").open(windows)
      
      -- Select the first location from the list of portal windows
      windows[1]:select()
      
      -- Close the portal windows
      require("portal").close(windows)
      
      
      -- Filter for results that are in the same buffer
      require("portal.builtin").jumplist({
          filter = function(v) return v.buffer == vim.fn.bufnr() end
      })
      
      -- Filter for results that are in a modified buffer
      require("portal.builtin").quickfix({
          filter = function(v) return vim.api.nvim_buf_get_option(v.buffer, "modified") end
      })
      
      -- Filter for buffers that have been tagged by grapple.nvim
      require("portal.builtin").quickfix({
          filter = function(v) return require("grapple").exists({ buffer = v.buffer }) end
      })
      
      -- Filter for results that are in some "root" directory
      require("portal.builtin").jumplist({
          filter = function(v)
              local root_files = vim.fs.find({ ".git" }, { upward = true })
              if #root_files > 0 then
                  local root_dir = vim.fs.dirname(root_files[1])
                  local file_path = vim.api.nvim_buf_get_name(v.buffer)
                  return string.find(file_path, root_dir, 1, true) ~= nil
              end
              return true
          end
      })
      
      
      -- Try to match one result where the buffer is different than the
      -- current buffer
      require("portal.builtin").jumplist({
          slots = function(v) return v.buffer ~= vim.fn.bufnr() end
      })
      
      -- Try to match two results where the buffer is different than the
      -- current buffer
      require("portal.builtin").jumplist({
          slots = {
              function(v) return v.buffer ~= vim.fn.bufnr() end,
              function(v) return v.buffer ~= vim.fn.bufnr() end,
          }
      })
      
      
      local Iterator = require("portal.iterator")
      
      -- Print all values in a list
      local iter = Iterator:new({ 1, 2, 3})
      for i, v in iter:iter() do
          print(v)
      end
      
      -- Create the list { 7, 8, 9 }
      Iterator:new({ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 })
          :start_at(7)
          :take(3)
          :collect()
      
      -- Create the list { 2, 4, 6, 8, 10 }
      Iterator:new({ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 })
          :filter(function(v) return v % 2 == 0 end)
          :collect()
      
      -- Create the table { a = 1, b = 2 }
      Iterator:new({ "a", "b" })
          :map(function(v, i) return { v, i } end)
          :collect_table()
      
      -- Create a filtered and mapped table { 4, 6 }
      Iterator:new({ 1, 2, 3})
          :filter(function(v) return v > 1 end)
          :map(function(v) return v * 2 end)
          :collect()
      
      -- Create the same filtered and mapped table { 4, 6 }
      Iterator:new({ 1, 2, 3 })
          :map(function(v) if v > 1 then return v * 2 end end)
          :collect()
      
      -- Create the repeated list { 1, 1, 1 }
      Iterator:rrepeat(1)
          :take(3)
          :collect()
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-bracketed.md",
  },
  {
    "liangxianzhe/nap.nvim",
    config = function()
      
      operators = {
          ["a"] = {
            next = { rhs = "<cmd>tabnext<cr>", opts = { desc = "Next tab" } },
            prev = { rhs = "<cmd>tabprevious<cr>", opts = { desc = "Prev tab" } },
          },
          ["A"] = {
            next = { rhs = "<cmd>tablast<cr>", opts = { desc = "Last tab" } },
            prev = { rhs = "<cmd>tabfirst<cr>", opts = { desc = "First tab" } },
          },
          ["b"] = {
            next = { rhs = "<cmd>bnext<cr>", opts = { desc = "Next buffer" } },
            prev = { rhs = "<cmd>bprevious<cr>", opts = { desc = "Prev buffer" } },
          },
          ["B"] = {
            next = { rhs = "<cmd>blast<cr>", opts = { desc = "Last buffer" } },
            prev = { rhs = "<cmd>bfirst<cr>", opts = { desc = "First buffer" } },
          },
          ["d"] = {
            next = { rhs = vim.diagnostic.goto_next, opts = { desc = "Next diagnostic" } },
            prev = { rhs = vim.diagnostic.goto_prev, opts = { desc = "Prev diagnostic" } },
            mode = { "n", "v", "o" }
          },
          ["e"] = {
            next = { rhs = "g;", opts = { desc = "Older edit (change-list) item" } },
            prev = { rhs = "g,", opts = { desc = "Newer edit (change-list) item" } }
          },
          ["f"] = {
            next = { rhs = M.next_file, opts = { desc = "Next file" } },
            prev = { rhs = M.prev_file, opts = { desc = "Prev file" } },
          },
          ["F"] = {
            next = { rhs = M.last_file, opts = { desc = "Last file" } },
            prev = { rhs = M.first_file, opts = { desc = "First file" } },
          },
          ["l"] = {
            next = { rhs = "<cmd>lnext<cr>", opts = { desc = "Next loclist item" } },
            prev = { rhs = "<cmd>lprevious<cr>", opts = { desc = "Prev loclist item" } }
          },
          ["L"] = {
            next = { rhs = "<cmd>llast<cr>", opts = { desc = "Last loclist item" } },
            prev = { rhs = "<cmd>lfirst<cr>", opts = { desc = "First loclist item" } }
          },
          ["<C-l>"] = {
            next = { rhs = "<cmd>lnfile<cr>", opts = { desc = "Next loclist item in different file" } },
            prev = { rhs = "<cmd>lpfile<cr>", opts = { desc = "Prev loclist item in different file" } }
          },
          ["<M-l>"] = {
            next = { rhs = "<cmd>lnewer<cr>", opts = { desc = "Next loclist list" } },
            prev = { rhs = "<cmd>lolder<cr>", opts = { desc = "Prev loclist list" } }
          },
          ["q"] = {
            next = { rhs = "<cmd>cnext<cr>", opts = { desc = "Next quickfix item" } },
            prev = { rhs = "<cmd>cprevious<cr>", opts = { desc = "Prev quickfix item" } }
          },
          ["Q"] = {
            next = { rhs = "<cmd>clast<cr>", opts = { desc = "Last quickfix item" } },
            prev = { rhs = "<cmd>cfirst<cr>", opts = { desc = "First quickfix item" } }
          },
          ["<C-q>"] = {
            next = { rhs = "<cmd>cnfile<cr>", opts = { desc = "Next quickfix item in different file" } },
            prev = { rhs = "<cmd>cpfile<cr>", opts = { desc = "Prev quickfix item in different file" } }
          },
          ["<M-q>"] = {
            next = { rhs = "<cmd>cnewer<cr>", opts = { desc = "Next quickfix list" } },
            prev = { rhs = "<cmd>colder<cr>", opts = { desc = "Prev quickfix list" } }
          },
          ["s"] = {
            next = { rhs = "]s", opts = { desc = "Next spell error" } },
            prev = { rhs = "[s", opts = { desc = "Prev spell error" } },
            mode = { "n", "v", "o" },
          },
          ["t"] = {
            next = { rhs = "<cmd>tnext<cr>", opts = { desc = "Next tag" } },
            prev = { rhs = "<cmd>tprevious<cr>", opts = { desc = "Prev tag" } }
          },
          ["T"] = {
            next = { rhs = "<cmd>tlast<cr>", opts = { desc = "Last tag" } },
            prev = { rhs = "<cmd>tfirst<cr>", opts = { desc = "First tag" } }
          },
          ["<C-t>"] = {
            next = { rhs = "<cmd>ptnext<cr>", opts = { desc = "Next tag in previous window" } },
            prev = { rhs = "<cmd>ptprevious<cr>", opts = { desc = "Prev tag in previous window" } }
          },
          ["z"] = {
            next = { rhs = "zj", opts = { desc = "Next fold" } },
            prev = { rhs = "zk", opts = { desc = "Prev fold" } },
            mode = { "n", "v", "o" },
          },
          ["'"] = {
            next = { rhs = "]`", opts = { desc = "Next lowercase mark" } },
            prev = { rhs = "[`", opts = { desc = "Prev lowercase mark" } }
          },
      
      
      require("nap").map("o", {
        next = { rhs = "<cmd>AerialNext<cr>", opts = { desc = "Next outline symbol" } },
        prev = { rhs = "<cmd>AerialPrev<cr>", opts = { desc = "Prev outline symbol" } },
        mode = { "n", "v", "o" },
      })
      
      
      -- The provided implementation falls back to ]c [c in diff mode.
      require("nap").map('c', require("nap").gitsigns())
      
      
      require("nap").map('o', require("nap").aerial())
      
      
      require("nap").map('r', require("nap").illuminate())
      
      
      require("nap").setup({
          next_prefix = "]",
          prev_prefix = "[",
          next_repeat = "<c-n>",
          prev_repeat = "<c-p>",
          -- to exclude some keys from the default
          exclude_default_operators = {"a", "A"},
          -- to add custom keys
          operators = {
              ...
          },
      })
      
    end,
  },
  {
    "chrisgrieser/nvim-spider",
    config = function()
      
      -- positions vim's `w` will move to
      local myVariableName = FOO_BAR_BAZ
      --    ^              ^ ^
      
      -- positions spider's `w` will move to
      local myVariableName = FOO_BAR_BAZ
      --    ^ ^       ^    ^ ^   ^   ^
      
      
      foo == bar .. "baz"
      --  ^      ^    significant punctuation
      
      foo:find("a")
      -- ^    ^  ^  insignificant punctuation
      
      
      -- positions vim's `w` will move to
      if foo:find("%d") and foo == bar then print("[foo] has" .. bar) end
      -- ^  ^^   ^  ^^  ^   ^   ^  ^   ^    ^    ^  ^  ^ ^  ^ ^  ^  ^ ^  -> 21
      
      -- positions spider's `w` will move to
      if foo:find("%d") and foo == bar then print("[foo] has" .. bar) end
      -- ^   ^      ^   ^   ^   ^  ^   ^    ^       ^    ^    ^  ^    ^  -> 14
      
      
      -- packer
      use { "chrisgrieser/nvim-spider" }
      
      -- lazy.nvim
      { "chrisgrieser/nvim-spider", lazy = true },
      
      -- vim-plug
      Plug("chrisgrieser/nvim-spider")
      
      
      vim.keymap.set({ "n", "o", "x" }, "w", "<cmd>lua require('spider').motion('w')<CR>")
      vim.keymap.set({ "n", "o", "x" }, "e", "<cmd>lua require('spider').motion('e')<CR>")
      vim.keymap.set({ "n", "o", "x" }, "b", "<cmd>lua require('spider').motion('b')<CR>")
      
      -- OR: lazy-load on keystroke (lazy.nvim)
      {
      	"chrisgrieser/nvim-spider",
      	keys = {
      		{ "w", "<cmd>lua require('spider').motion('w')<CR>", mode = { "n", "o", "x" } },
      		{ "e", "<cmd>lua require('spider').motion('e')<CR>", mode = { "n", "o", "x" } },
      		{ "b", "<cmd>lua require('spider').motion('b')<CR>", mode = { "n", "o", "x" } },
      	},
      },
      
      
      -- default values
      require("spider").setup {
      	skipInsignificantPunctuation = true,
      	consistentOperatorPending = false, -- see the README for details
      	subwordMovement = true,
      	customPatterns = {}, -- see the README for details
      }
      
      
      require("spider").motion("w", { skipInsignificantPunctuation = false })
      
      
      -- The motion stops only at numbers.
      require("spider").motion("w", {
      	customPatterns = { "%d+" },
      })
      
      -- The motion stops at any occurrence of the ltters "A" or "C", in addition 
      -- to spider's default behavior.
      require("spider").motion("w", {
      	customPatterns = {
      		patterns = { "A", "C" },
      		overrideDefault = false,
      	},
      })
      
      -- The motion stops at the next declaration of a javascript variable.
      -- (The `e` motion combined with the `.` matching any character in
      -- lua patterns ensures that you stop at beginning of the variable name.)
      require("spider").motion("e", {
      	customPatterns = { "const .", "let .", "var ." },
      })
      
      
      -- packer
      { "chrisgrieser/nvim-spider", rocks = "luautf8" }
      
      -- lazy.nvim
      {
          "chrisgrieser/nvim-spider",
          lazy = true,
          dependencies = {
          	"theHamsta/nvim_rocks",
          	build = "pip3 install --user hererocks && python3 -mhererocks . -j2.1.0-beta3 -r3.0.0 && cp nvim_rocks.lua lua",
          	config = function() require("nvim_rocks").ensure_installed("luautf8") end,
          },
      },
      
      
      vim.keymap.set("o", "w", "<cmd>lua require('spider').motion('w')<CR>")
      vim.keymap.set("n", "cw", "ce", { remap = true })
      
      -- OR in one mapping
      vim.keymap.set("n", "cw", "c<cmd>lua require('spider').motion('e')<CR>")
      
      
      foo bar
      --  ^
      baz
      
      
          foo
      --  ^
      bar
      
      
      vim.keymap.set("i", "<C-f>", "<Esc>l<cmd>lua require('spider').motion('w')<CR>i")
      vim.keymap.set("i", "<C-b>", "<Esc><cmd>lua require('spider').motion('b')<CR>i")
      
    end,
  },
  {
    "gsuuon/tshjkl.nvim",
  },
  {
    "backdround/neowords.nvim",
    config = function()
      
      -- Ignore anything except sub words!
      local CamelCase = "snake_UPPER_MIXEDCase" .. "1234"
      --    ^    ^       ^     ^     ^    ^         ^
      
      
      local neowords = require("neowords")
      local p = neowords.pattern_presets
      
      local subword_hops = neowords.get_word_hops(
        p.snake_case,
        p.camel_case,
        p.upper_case,
        p.number,
        p.hex_color
      )
      
      vim.keymap.set({ "n", "x", "o" }, "w", subword_hops.forward_start)
      vim.keymap.set({ "n", "x", "o" }, "e", subword_hops.forward_end)
      vim.keymap.set({ "n", "x", "o" }, "b", subword_hops.backward_start)
      vim.keymap.set({ "n", "x", "o" }, "ge", subword_hops.backward_end)
      
      
      -- Ignore anything except big words!
      local CamelCase = "snake_UPPER_MIXEDCase" .. "1234" .. "dashed-case"
      --    ^            ^                          ^         ^
      
      
      local neowords = require("neowords")
      local p = neowords.pattern_presets
      
      local bigword_hops = neowords.get_word_hops(
        p.any_word,
        p.hex_color
      )
      
      vim.keymap.set({ "n", "x", "o" }, "w", bigword_hops.forward_start)
      vim.keymap.set({ "n", "x", "o" }, "e", bigword_hops.forward_end)
      vim.keymap.set({ "n", "x", "o" }, "b", bigword_hops.backward_start)
      vim.keymap.set({ "n", "x", "o" }, "ge", bigword_hops.backward_end)
      
      
      -- Jump over subwords, dots and commas!
      error("Unable to " .. description .. ": " .. error_message, 2)
      --     ^      ^    ^  ^           ^       ^  ^     ^      ^ ^
      
      
      local neowords = require("neowords")
      local p = neowords.pattern_presets
      
      local hops = neowords.get_word_hops(
        p.snake_case,
        p.camel_case,
        p.upper_case,
        p.number,
        p.hex_color,
        "\\v\\.+",
        "\\v,+"
      )
      
      vim.keymap.set({ "n", "x", "o" }, "w", hops.forward_start)
      vim.keymap.set({ "n", "x", "o" }, "e", hops.forward_end)
      vim.keymap.set({ "n", "x", "o" }, "b", hops.backward_start)
      vim.keymap.set({ "n", "x", "o" }, "ge", hops.backward_end)
      
      
      -- Ignore anything except number and color words!
      local CamelCase = "99 snake_UPPER_MIXEDCase" .. "1234" .. "dashed-case"
      --                 ^                             ^
      local my_cool_color = "#E3B8EF"
      --                     ^
      
      
      local neowords = require("neowords")
      local p = neowords.pattern_presets
      
      local hops = neowords.get_word_hops(
        p.number,
        p.hex_color
      )
      
      vim.keymap.set({ "n", "x", "o" }, "w", hops.forward_start)
      vim.keymap.set({ "n", "x", "o" }, "e", hops.forward_end)
      vim.keymap.set({ "n", "x", "o" }, "b", hops.backward_start)
      vim.keymap.set({ "n", "x", "o" }, "ge", hops.backward_end)
      
      
      local neowords = require("neowords")
      local presets = neowords.pattern_presets
      
      local hops = neowords.get_word_hops(
        -- Vim-patterns or pattern presets separated by commas.
        -- Check `:magic` and onwards for patterns overview.
        "\\v[[:lower:]]+",
        presets.number
      )
      
      vim.keymap.set({ "n", "x", "o" }, "w", hops.forward_start)
      vim.keymap.set({ "n", "x", "o" }, "e", hops.forward_end)
      vim.keymap.set({ "n", "x", "o" }, "b", hops.backward_start)
      vim.keymap.set({ "n", "x", "o" }, "ge", hops.backward_end)
      
    end,
  },
  {
    "backdround/improved-ft.nvim",
    config = function()
      
      local ft = require("improved-ft")
      ft.setup({
        -- Maps default f/F/t/T/;/, keys.
        -- default: false
        use_default_mappings = true,
      
        -- Ignores case of the given characters.
        -- default: false
        ignore_char_case = true,
      
        -- Takes a last hop direction into account during repetition hops
        -- default: false
        use_relative_repetition = true,
      
        -- Uses direction-relative offsets during repetition hops.
        -- default: false
        use_relative_repetition_offsets = true,
      })
      
      
      local map = function(key, fn, description)
        vim.keymap.set({ "n", "x", "o" }, key, fn, {
          desc = description,
          expr = true,
        })
      end
      
      map("f", ft.hop_forward_to_char, "Hop forward to a given char")
      map("F", ft.hop_backward_to_char, "Hop backward to a given char")
      
      map("t", ft.hop_forward_to_pre_char, "Hop forward before a given char")
      map("T", ft.hop_backward_to_pre_char, "Hop backward before a given char")
      
      map(";", ft.repeat_forward, "Repeat hop forward to a last given char")
      map(",", ft.repeat_backward, "Repeat hop backward to a last given char")
      
      
      local map = function(key, fn, description)
        vim.keymap.set({ "n", "x", "o" }, key, fn, {
          desc = description,
          expr = true,
        })
      end
      
      map("s", ft.hop_forward_to_post_char, "Hop forward after a given char")
      map("S", ft.hop_backward_to_post_char, "Hop backward after a given char")
      
      
      
      local imap = function(key, fn, description)
        vim.keymap.set("i", key, fn, {
          desc = description,
          expr = true,
        })
      end
      
      imap("<M-f>", ft.hop_forward_to_char, "Hop forward to a given char")
      imap("<M-F>", ft.hop_backward_to_char, "Hop forward to a given char")
      
      imap("<M-t>", ft.hop_forward_to_pre_char, "Hop forward before a given char")
      imap("<M-T>", ft.hop_backward_to_pre_char, "Hop forward before a given char")
      
      imap("<M-;>", ft.repeat_forward, "Repeat hop forward to a last given char")
      imap("<M-,>", ft.repeat_backward, "Repeat hop backward to a last given char")
      
    end,
  },
  {
    "jinh0/eyeliner.nvim",
    config = function()
      
      use 'jinh0/eyeliner.nvim'
      
      
      {
        'jinh0/eyeliner.nvim',
        config = function()
          require'eyeliner'.setup {
            -- show highlights only after keypress
            highlight_on_key = true,
      
            -- dim all other characters if set to true (recommended!)
            dim = false,             
      
            -- set the maximum number of characters eyeliner.nvim will check from
            -- your current cursor position; this is useful if you are dealing with
            -- large files: see https://github.com/jinh0/eyeliner.nvim/issues/41
            max_length = 9999,
      
            -- filetypes for which eyeliner should be disabled;
            -- e.g., to disable on help files:
            -- disabled_filetypes = {"help"}
            disabled_filetypes = {},
      
            -- buftypes for which eyeliner should be disabled
            -- e.g., disabled_buftypes = {"nofile"}
            disabled_buftypes = {},
      
            -- add eyeliner to f/F/t/T keymaps;
            -- see section on advanced configuration for more information
            default_keymaps = true,
          }
        end
      }
      
      
      use {
        'jinh0/eyeliner.nvim',
        config = function()
          require'eyeliner'.setup {
            highlight_on_key = true
          }
        end
      }
      
      
      require'eyeliner'.setup {
        highlight_on_key = true, -- this must be set to true for dimming to work!
        dim = true,
      }
      
      
      vim.api.nvim_set_hl(0, 'EyelinerPrimary', { bold = true, underline = true })
      vim.api.nvim_set_hl(0, 'EyelinerSecondary', { underline = true })
      
      
      vim.api.nvim_set_hl(0, 'EyelinerPrimary', { fg='#000000', bold = true, underline = true })
      vim.api.nvim_set_hl(0, 'EyelinerSecondary', { fg='#ffffff', underline = true })
      
      
      vim.api.nvim_create_autocmd('ColorScheme', {
        pattern = '*',
        callback = function()
          vim.api.nvim_set_hl(0, 'EyelinerPrimary', { bold = true, underline = true })
        end,
      })
      
      
      require'eyeliner'.setup {
        highlight_on_key = true,
        default_keymaps = false
      }
      
      
      require("eyeliner").highlight({ forward = true })
      
      
      vim.g.clever_f_not_overwrites_standard_mappings = 1
      
      vim.keymap.set(
        {"n", "x", "o"},
        "f",
        function() 
          require("eyeliner").highlight({ forward = true })
          return "<Plug>(clever-f-f)"
        end,
        {expr = true}
      )
      
      
      vim.keymap.set(
        {"n", "x", "o"},
        "x",
        function()
      
          -- Eyeliner only adds highlights, nothing else
          require("eyeliner").highlight({ forward = true })
      
      
          -- Replicating `f` functionality:
          -- Note: this doesn't work with the dot command
      
          -- Get a character from the user
          local char = vim.fn.getcharstr()
      
          -- For repeated calls, e.g., `3f`
          local cnt = vim.v.count1
          while cnt > 0 do
            -- vim's builtin search function
            vim.fn.search(char, "", vim.fn.line("."))
            cnt = cnt - 1
          end
      
           -- Optional: Set charsearch for repeats using ; and ,
           vim.fn.setcharsearch({ char = char, forward = 1, ["until"] = 0 })
        end
      )
      
    end,
  },
  {
    "Mr-LLLLL/treesitter-outer",
  },
  {
    "DanilaMihailov/beacon.nvim",
    config = function()
      
      { 'danilamihailov/beacon.nvim' } -- lazy calls setup() by itself
      
      
       {
        enabled = true, --- (boolean | fun():boolean) check if enabled
        speed = 2, --- integer speed at wich animation goes
        width = 40, --- integer width of the beacon window
        winblend = 70, --- integer starting transparency of beacon window :h winblend
        fps = 60, --- integer how smooth the animation going to be
        min_jump = 10, --- integer what is considered a jump. Number of lines
        cursor_events = { 'CursorMoved' }, -- table<string> what events trigger check for cursor moves
        window_events = { 'WinEnter', 'FocusGained' }, -- table<string> what events trigger cursor highlight
        highlight = { bg = 'white', ctermbg = 15 }, -- vim.api.keyset.highlight table passed to vim.api.nvim_set_hl
      }
      
      
      vim.api.nvim_set_hl(0, 'Beacon', { bg = 'white' })
      
    end,
  },
  {
    "aaronik/Treewalker.nvim",
    config = function()
      
      {
        'aaronik/treewalker.nvim',
      
        -- optional (see below for detailed options)
        opts = { ... }
      }
      
      
      use {
        'aaronik/treewalker.nvim',
      
        -- optional (see below for detailed options)
        setup = function()
            require('treewalker').setup({ ... })
        end
      }
      
      
      -- The defaults:
      {
        -- Whether to briefly highlight the node after jumping to it
        highlight = true,
      
        -- How long should above highlight last (in ms)
        highlight_duration = 250,
      
        -- The color of the above highlight. Must be a valid vim highlight group.
        -- (see :h highlight-group for options)
        highlight_group = 'CursorLine',
      
        -- Whether to create a visual selection after a movement to a node.
        -- If true, highlight is disabled and a visual selection is made in
        -- its place.
        select = false,
      
        -- Whether to use vim.notify to warn when there are missing parsers or incorrect options
        notifications = true,
      
        -- Whether the plugin adds movements to the jumplist -- true | false | 'left'
        --  true: All movements more than 1 line are added to the jumplist. This is the default,
        --        and is meant to cover most use cases. It's modeled on how { and } natively add
        --        to the jumplist.
        --  false: Treewalker does not add to the jumplist at all
        --  "left": Treewalker only adds :Treewalker Left to the jumplist. This is usually the most
        --          likely one to be confusing, so it has its own mode.
        jumplist = true,
      }
      
      
      -- movement
      vim.keymap.set({ 'n', 'v' }, '<C-k>', '<cmd>Treewalker Up<cr>', { silent = true })
      vim.keymap.set({ 'n', 'v' }, '<C-j>', '<cmd>Treewalker Down<cr>', { silent = true })
      vim.keymap.set({ 'n', 'v' }, '<C-h>', '<cmd>Treewalker Left<cr>', { silent = true })
      vim.keymap.set({ 'n', 'v' }, '<C-l>', '<cmd>Treewalker Right<cr>', { silent = true })
      
      -- swapping
      vim.keymap.set('n', '<C-S-k>', '<cmd>Treewalker SwapUp<cr>', { silent = true })
      vim.keymap.set('n', '<C-S-j>', '<cmd>Treewalker SwapDown<cr>', { silent = true })
      vim.keymap.set('n', '<C-S-h>', '<cmd>Treewalker SwapLeft<cr>', { silent = true })
      vim.keymap.set('n', '<C-S-l>', '<cmd>Treewalker SwapRight<cr>', { silent = true })
      
    end,
  },
  {
    "timseriakov/spamguard.nvim",
    config = function()
      
      return {
        "timseriakov/spamguard.nvim",
        event = "VeryLazy",
        config = function()
          local spamguard = require("spamguard")
          spamguard.setup({
            keys = {
              j = { threshold = 9, suggestion = "use s / f instead of spamming jjjj 😎" },
              k = { threshold = 9, suggestion = "try { of ( instead of spamming kkkk 😎" },
              h = { threshold = 9, suggestion = "use b / 0 / ^ instead of spamming hhhh  😎" },
              l = { threshold = 9, suggestion = "try w / e / f — it's faster! 😎" },
              w = { threshold = 8, suggestion = "use s / f — more precise and quicker! 😎" },
            },
          })
          vim.schedule(function()
            spamguard.enable()
          end)
        end,
      }
      
      
      vim.b.disable_spamguard = true
      
    end,
  },
  {
    "millerjason/neovimacs.nvim",
    config = function()
      
      {
         "millerjason/neovimacs.nvim",
      }
      
      
      {
         "millerjason/neovimacs.nvim",
         opts = {
           VM_Enabled = true,
           VM_StartInsert = false, -- Start in normal (not insert) mode
         },
      }
      
    end,
  },
  {
    "mfussenegger/nvim-treehopper",
  },
  {
    "ziontee113/syntax-tree-surfer",
    config = function()
      
      use "ziontee113/syntax-tree-surfer"
      
      
      -- Syntax Tree Surfer
      local opts = {noremap = true, silent = true}
      
      -- Normal Mode Swapping:
      -- Swap The Master Node relative to the cursor with it's siblings, Dot Repeatable
      vim.keymap.set("n", "vU", function()
      	vim.opt.opfunc = "v:lua.STSSwapUpNormal_Dot"
      	return "g@l"
      end, { silent = true, expr = true })
      vim.keymap.set("n", "vD", function()
      	vim.opt.opfunc = "v:lua.STSSwapDownNormal_Dot"
      	return "g@l"
      end, { silent = true, expr = true })
      
      -- Swap Current Node at the Cursor with it's siblings, Dot Repeatable
      vim.keymap.set("n", "vd", function()
      	vim.opt.opfunc = "v:lua.STSSwapCurrentNodeNextNormal_Dot"
      	return "g@l"
      end, { silent = true, expr = true })
      vim.keymap.set("n", "vu", function()
      	vim.opt.opfunc = "v:lua.STSSwapCurrentNodePrevNormal_Dot"
      	return "g@l"
      end, { silent = true, expr = true })
      
      --> If the mappings above don't work, use these instead (no dot repeatable)
      -- vim.keymap.set("n", "vd", '<cmd>STSSwapCurrentNodeNextNormal<cr>', opts)
      -- vim.keymap.set("n", "vu", '<cmd>STSSwapCurrentNodePrevNormal<cr>', opts)
      -- vim.keymap.set("n", "vD", '<cmd>STSSwapDownNormal<cr>', opts)
      -- vim.keymap.set("n", "vU", '<cmd>STSSwapUpNormal<cr>', opts)
      
      -- Visual Selection from Normal Mode
      vim.keymap.set("n", "vx", '<cmd>STSSelectMasterNode<cr>', opts)
      vim.keymap.set("n", "vn", '<cmd>STSSelectCurrentNode<cr>', opts)
      
      -- Select Nodes in Visual Mode
      vim.keymap.set("x", "J", '<cmd>STSSelectNextSiblingNode<cr>', opts)
      vim.keymap.set("x", "K", '<cmd>STSSelectPrevSiblingNode<cr>', opts)
      vim.keymap.set("x", "H", '<cmd>STSSelectParentNode<cr>', opts)
      vim.keymap.set("x", "L", '<cmd>STSSelectChildNode<cr>', opts)
      
      -- Swapping Nodes in Visual Mode
      vim.keymap.set("x", "<A-j>", '<cmd>STSSwapNextVisual<cr>', opts)
      vim.keymap.set("x", "<A-k>", '<cmd>STSSwapPrevVisual<cr>', opts)
      
      
      lua require("syntax-tree-surfer").go_to_top_node_and_execute_commands(false, { "normal! O", "normal! O", "startinsert" })<cr>
      
      
      -- Syntax Tree Surfer V2 Mappings
      -- Targeted Jump with virtual_text
      local sts = require("syntax-tree-surfer")
      vim.keymap.set("n", "gv", function() -- only jump to variable_declarations
      	sts.targeted_jump({ "variable_declaration" })
      end, opts)
      vim.keymap.set("n", "gfu", function() -- only jump to functions
      	sts.targeted_jump({ "function", "arrrow_function", "function_definition" })
        --> In this example, the Lua language schema uses "function",
        --  when the Python language uses "function_definition"
        --  we include both, so this keymap will work on both languages
      end, opts)
      vim.keymap.set("n", "gif", function() -- only jump to if_statements
      	sts.targeted_jump({ "if_statement" })
      end, opts)
      vim.keymap.set("n", "gfo", function() -- only jump to for_statements
      	sts.targeted_jump({ "for_statement" })
      end, opts)
      vim.keymap.set("n", "gj", function() -- jump to all that you specify
      	sts.targeted_jump({
      		"function",
      	  "if_statement",
      		"else_clause",
      		"else_statement",
      		"elseif_statement",
      		"for_statement",
      		"while_statement",
      		"switch_statement",
      	})
      end, opts)
      
      -------------------------------
      -- filtered_jump --
      -- "default" means that you jump to the default_desired_types or your lastest jump types
      vim.keymap.set("n", "<A-n>", function()
      	sts.filtered_jump("default", true) --> true means jump forward
      end, opts)
      vim.keymap.set("n", "<A-p>", function()
      	sts.filtered_jump("default", false) --> false means jump backwards
      end, opts)
      
      -- non-default jump --> custom desired_types
      vim.keymap.set("n", "your_keymap", function()
      	sts.filtered_jump({
      		"if_statement",
      		"else_clause",
      		"else_statement",
      	}, true) --> true means jump forward
      end, opts)
      vim.keymap.set("n", "your_keymap", function()
      	sts.filtered_jump({
      		"if_statement",
      		"else_clause",
      		"else_statement",
      	}, false) --> false means jump backwards
      end, opts)
      
      -------------------------------
      -- jump with limited targets --
      -- jump to sibling nodes only
      vim.keymap.set("n", "-", function()
      	sts.filtered_jump({
      		"if_statement",
      		"else_clause",
      		"else_statement",
      	}, false, { destination = "siblings" })
      end, opts)
      vim.keymap.set("n", "=", function()
      	sts.filtered_jump({ "if_statement", "else_clause", "else_statement" }, true, { destination = "siblings" })
      end, opts)
      
      -- jump to parent or child nodes only
      vim.keymap.set("n", "_", function()
      	sts.filtered_jump({
      		"if_statement",
      		"else_clause",
      		"else_statement",
      	}, false, { destination = "parent" })
      end, opts)
      vim.keymap.set("n", "+", function()
      	sts.filtered_jump({
      		"if_statement",
      		"else_clause",
      		"else_statement",
      	}, true, { destination = "children" })
      end, opts)
      
      -- Setup Function example:
      -- These are the default options:
      require("syntax-tree-surfer").setup({
      	highlight_group = "STS_highlight",
      	disable_no_instance_found_report = false,
      	default_desired_types = {
      		"function",
      		"arrow_function",
      		"function_definition",
      		"if_statement",
      		"else_clause",
      		"else_statement",
      		"elseif_statement",
      		"for_statement",
      		"while_statement",
      		"switch_statement",
      	},
      	left_hand_side = "fdsawervcxqtzb",
      	right_hand_side = "jkl;oiu.,mpy/n",
      	icon_dictionary = {
      		["if_statement"] = "",
      		["else_clause"] = "",
      		["else_statement"] = "",
      		["elseif_statement"] = "",
      		["for_statement"] = "ﭜ",
      		["while_statement"] = "ﯩ",
      		["switch_statement"] = "ﳟ",
      		["function"] = "",
      		["function_definition"] = "",
      		["variable_declaration"] = "",
      	},
      })
      
      
      -- Holds a node, or swaps the held node
      vim.keymap.set("n", "gnh", "<cmd>STSSwapOrHold<cr>", opts)
      -- Same for visual
      vim.keymap.set("x", "gnh", "<cmd>STSSwapOrHoldVisual<cr>", opts)
      
      
      require("syntax-tree-surfer").hold_or_swap(true) -- param is_visual boolean
      require("syntax-tree-surfer").clear_held_node()
      
    end,
  },
  {
    "drybalka/tree-climber.nvim",
  },
  {
    "atusy/treemonkey.nvim",
    config = function()
      
      vim.keymap.set({"x", "o"}, "m", function()
        require("treemonkey").select({
          ignore_injections = false,
          highlight = { backdrop = "Comment" }
        })
      end)
      
      
      {
        "https://github.com/atusy/treemonkey.nvim",
        init = function()
          vim.keymap.set({"x", "o"}, "m", function()
            require("treemonkey").select({ ignore_injections = false })
          end)
        end
      }
      
    end,
  },
  {
    "kiyoon/treesitter-indent-object.nvim",
    config = function()
      
        {
          "kiyoon/treesitter-indent-object.nvim",
          keys = {
            {
              "ai",
              function() require'treesitter_indent_object.textobj'.select_indent_outer() end,
              mode = {"x", "o"},
              desc = "Select context-aware indent (outer)",
            },
            {
              "aI",
              function() require'treesitter_indent_object.textobj'.select_indent_outer(true) end,
              mode = {"x", "o"},
              desc = "Select context-aware indent (outer, line-wise)",
            },
            {
              "ii",
              function() require'treesitter_indent_object.textobj'.select_indent_inner() end,
              mode = {"x", "o"},
              desc = "Select context-aware indent (inner, partial range)",
            },
            {
              "iI",
              function() require'treesitter_indent_object.textobj'.select_indent_inner(true, 'V') end,
              mode = {"x", "o"},
              desc = "Select context-aware indent (inner, entire range) in line-wise visual mode",
            },
          },
        },
        {
          "lukas-reineke/indent-blankline.nvim",
          tag = "v2.20.8",  -- Use v2
          event = "BufReadPost",
          config = function()
            vim.opt.list = true
            require("indent_blankline").setup {
              space_char_blankline = " ",
              show_current_context = true,
              show_current_context_start = true,
            }
          end,
        },
      
      
      -- init.lua
      require("packer").startup(function()
        use "nvim-treesitter/nvim-treesitter"
        use "lukas-reineke/indent-blankline.nvim"  -- optional
        use "kiyoon/treesitter-indent-object.nvim"
      end)
      
      
      require("indent_blankline").setup {
          show_current_context = true,
          show_current_context_start = true,
      }
      
      -- Actually, no setup is required, but
      -- if setup comes after the indent_blankline,
      -- it will try to follow the pattern matching options
      -- used in indent_blankline
      require("treesitter_indent_object").setup()
      
      
      -- select context-aware indent
      vim.keymap.set({"x", "o"}, "ai", function() require'treesitter_indent_object.textobj'.select_indent_outer() end)
      -- ensure selecting entire line (or just use Vai)
      vim.keymap.set({"x", "o"}, "aI", function() require'treesitter_indent_object.textobj'.select_indent_outer(true) end)
      -- select inner block (only if block, only else block, etc.)
      vim.keymap.set({"x", "o"}, "ii", function() require'treesitter_indent_object.textobj'.select_indent_inner() end)
      -- select entire inner range (including if, else, etc.) in line-wise visual mode
      vim.keymap.set({"x", "o"}, "iI", function() require'treesitter_indent_object.textobj'.select_indent_inner(true, 'V') end)
      
      
      {
        "aI",
        function()
          require'treesitter_indent_object.textobj'.select_indent_outer(true, 'V')
          require'treesitter_indent_object.refiner'.include_surrounding_empty_lines()
        end,
        mode = { "x", "o" },
      },
      
    end,
  },
  {
    "sontungexpt/bim.nvim",
    config = function()
      
      {
        "sontungexpt/bim.nvim",
        event = "InsertEnter",
        config = function()
          require("bim").setup()
        end
      }
      
    end,
  },
  {
    "TheLazyCat00/racer-nvim",
    config = function()
      
      {
          "TheLazyCat00/racer-nvim",
      
          -- if you want to keep the defaults, do opts = {}
          -- if opts is nil, lazy.nvim does not load the plugin
          opts = {
              triggers = {
      
                  -- first element: key used to go backwards
                  -- last element: key used to go forwards
                  {"[", "]"},
                  {"F", "f"}
              },
      
              -- allow other plugins to take over for certain keys
              -- this is useful for plugins like flash.nvim or leap.nvim
              -- keys specified here have to be also specified in the triggers section
              -- this example is for flash.nvim
              external = {
                  ["f"] = require("flash.plugins.char").next,
                  ["F"] = require("flash.plugins.char").prev,
              }
          }
      
          -- racer-nvim does not automatically configure the keymaps
          -- this is a design choice because this makes it more customizable
          keys = {
              {";", "<cmd>lua require('racer-nvim').prev()<CR>", mode = {"n", "x"}, desc = "Repeat previous"},
              {",", "<cmd>lua require('racer-nvim').next()<CR>", mode = {"n", "x"}, desc = "Repeat next"},
          }
      }
      
      
      {
          triggers = {
              {"[", "]"}
          },
          external = {}
      }
      
    end,
  },
  {
    "folke/which-key.nvim",
    config = function()
      
      {
        "folke/which-key.nvim",
        event = "VeryLazy",
        opts = {
          -- your configuration comes here
          -- or leave it empty to use the default settings
          -- refer to the configuration section below
        },
        keys = {
          {
            "<leader>?",
            function()
              require("which-key").show({ global = false })
            end,
            desc = "Buffer Local Keymaps (which-key)",
          },
        },
      }
      
      
      ---@class wk.Opts
      local defaults = {
        ---@type false | "classic" | "modern" | "helix"
        preset = "classic",
        -- Delay before showing the popup. Can be a number or a function that returns a number.
        ---@type number | fun(ctx: { keys: string, mode: string, plugin?: string }):number
        delay = function(ctx)
          return ctx.plugin and 0 or 200
        end,
        ---@param mapping wk.Mapping
        filter = function(mapping)
          -- example to exclude mappings without a description
          -- return mapping.desc and mapping.desc ~= ""
          return true
        end,
        --- You can add any mappings here, or use `require('which-key').add()` later
        ---@type wk.Spec
        spec = {},
        -- show a warning when issues were detected with your mappings
        notify = true,
        -- Which-key automatically sets up triggers for your mappings.
        -- But you can disable this and setup the triggers manually.
        -- Check the docs for more info.
        ---@type wk.Spec
        triggers = {
          { "<auto>", mode = "nxso" },
        },
        -- Start hidden and wait for a key to be pressed before showing the popup
        -- Only used by enabled xo mapping modes.
        ---@param ctx { mode: string, operator: string }
        defer = function(ctx)
          return ctx.mode == "V" or ctx.mode == "<C-V>"
        end,
        plugins = {
          marks = true, -- shows a list of your marks on ' and `
          registers = true, -- shows your registers on " in NORMAL or <C-r> in INSERT mode
          -- the presets plugin, adds help for a bunch of default keybindings in Neovim
          -- No actual key bindings are created
          spelling = {
            enabled = true, -- enabling this will show WhichKey when pressing z= to select spelling suggestions
            suggestions = 20, -- how many suggestions should be shown in the list?
          },
          presets = {
            operators = true, -- adds help for operators like d, y, ...
            motions = true, -- adds help for motions
            text_objects = true, -- help for text objects triggered after entering an operator
            windows = true, -- default bindings on <c-w>
            nav = true, -- misc bindings to work with windows
            z = true, -- bindings for folds, spelling and others prefixed with z
            g = true, -- bindings for prefixed with g
          },
        },
        ---@type wk.Win.opts
        win = {
          -- don't allow the popup to overlap with the cursor
          no_overlap = true,
          -- width = 1,
          -- height = { min = 4, max = 25 },
          -- col = 0,
          -- row = math.huge,
          -- border = "none",
          padding = { 1, 2 }, -- extra window padding [top/bottom, right/left]
          title = true,
          title_pos = "center",
          zindex = 1000,
          -- Additional vim.wo and vim.bo options
          bo = {},
          wo = {
            -- winblend = 10, -- value between 0-100 0 for fully opaque and 100 for fully transparent
          },
        },
        layout = {
          width = { min = 20 }, -- min and max width of the columns
          spacing = 3, -- spacing between columns
        },
        keys = {
          scroll_down = "<c-d>", -- binding to scroll down inside the popup
          scroll_up = "<c-u>", -- binding to scroll up inside the popup
        },
        ---@type (string|wk.Sorter)[]
        --- Mappings are sorted using configured sorters and natural sort of the keys
        --- Available sorters:
        --- * local: buffer-local mappings first
        --- * order: order of the items (Used by plugins like marks / registers)
        --- * group: groups last
        --- * alphanum: alpha-numerical first
        --- * mod: special modifier keys last
        --- * manual: the order the mappings were added
        --- * case: lower-case first
        sort = { "local", "order", "group", "alphanum", "mod" },
        ---@type number|fun(node: wk.Node):boolean?
        expand = 0, -- expand groups when <= n mappings
        -- expand = function(node)
        --   return not node.desc -- expand all nodes without a description
        -- end,
        -- Functions/Lua Patterns for formatting the labels
        ---@type table<string, ({[1]:string, [2]:string}|fun(str:string):string)[]>
        replace = {
          key = {
            function(key)
              return require("which-key.view").format(key)
            end,
            -- { "<Space>", "SPC" },
          },
          desc = {
            { "<Plug>%(?(.*)%)?", "%1" },
            { "^%+", "" },
            { "<[cC]md>", "" },
            { "<[cC][rR]>", "" },
            { "<[sS]ilent>", "" },
            { "^lua%s+", "" },
            { "^call%s+", "" },
            { "^:%s*", "" },
          },
        },
        icons = {
          breadcrumb = "»", -- symbol used in the command line area that shows your active key combo
          separator = "➜", -- symbol used between a key and it's label
          group = "+", -- symbol prepended to a group
          ellipsis = "…",
          -- set to false to disable all mapping icons,
          -- both those explicitly added in a mapping
          -- and those from rules
          mappings = true,
          --- See `lua/which-key/icons.lua` for more details
          --- Set to `false` to disable keymap icons from rules
          ---@type wk.IconRule[]|false
          rules = {},
          -- use the highlights from mini.icons
          -- When `false`, it will use `WhichKeyIcon` instead
          colors = true,
          -- used by key format
          keys = {
            Up = " ",
            Down = " ",
            Left = " ",
            Right = " ",
            C = "󰘴 ",
            M = "󰘵 ",
            D = "󰘳 ",
            S = "󰘶 ",
            CR = "󰌑 ",
            Esc = "󱊷 ",
            ScrollWheelDown = "󱕐 ",
            ScrollWheelUp = "󱕑 ",
            NL = "󰌑 ",
            BS = "󰁮",
            Space = "󱁐 ",
            Tab = "󰌒 ",
            F1 = "󱊫",
            F2 = "󱊬",
            F3 = "󱊭",
            F4 = "󱊮",
            F5 = "󱊯",
            F6 = "󱊰",
            F7 = "󱊱",
            F8 = "󱊲",
            F9 = "󱊳",
            F10 = "󱊴",
            F11 = "󱊵",
            F12 = "󱊶",
          },
        },
        show_help = true, -- show a help message in the command line for using WhichKey
        show_keys = true, -- show the currently pressed key and its label as a message in the command line
        -- disable WhichKey for certain buf types and file types.
        disable = {
          ft = {},
          bt = {},
        },
        debug = false, -- enable wk.log in the current directory
      }
      
      
      local wk = require("which-key")
      wk.add({
        { "<leader>f", group = "file" }, -- group
        { "<leader>ff", "<cmd>Telescope find_files<cr>", desc = "Find File", mode = "n" },
        { "<leader>fb", function() print("hello") end, desc = "Foobar" },
        { "<leader>fn", desc = "New File" },
        { "<leader>f1", hidden = true }, -- hide this keymap
        { "<leader>w", proxy = "<c-w>", group = "windows" }, -- proxy to window mappings
        { "<leader>b", group = "buffers", expand = function()
            return require("which-key.extras").expand.buf()
          end
        },
        {
          -- Nested mappings are allowed and can be added in any order
          -- Most attributes can be inherited or overridden on any level
          -- There's no limit to the depth of nesting
          mode = { "n", "v" }, -- NORMAL and VISUAL mode
          { "<leader>q", "<cmd>q<cr>", desc = "Quit" }, -- no need to specify mode since it's inherited
          { "<leader>w", "<cmd>w<cr>", desc = "Write" },
        }
      })
      
      
      >  triggers = {
      >    { "<auto>", mode = "nixsotc" },
      >    { "a", mode = { "n", "v" } },
      >  }
      > 
      
      >  triggers = {
      >    { "<leader>", mode = { "n", "v" } },
      >  }
      > 
      
      > ---@param ctx { mode: string, operator: string }
      > defer = function(ctx)
      >   if vim.list_contains({ "d", "y" }, ctx.operator) then
      >     return true
      >   end
      >   return vim.list_contains({ "<C-V>", "V" }, ctx.mode)
      > end,
      > 
      
      -- Show hydra mode for changing windows
      require("which-key").show({
        keys = "<c-w>",
        loop = true, -- this will keep the popup open until you hit <esc>
      })
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-clue.md",
  },
  {
    "mrjones2014/legendary.nvim",
    config = function()
      
      -- to use a version
      {
        'mrjones2014/legendary.nvim',
        version = 'v2.13.9',
        -- since legendary.nvim handles all your keymaps/commands,
        -- its recommended to load legendary.nvim before other plugins
        priority = 10000,
        lazy = false,
        -- sqlite is only needed if you want to use frecency sorting
        -- dependencies = { 'kkharji/sqlite.lua' }
      }
      -- or, to get rolling updates
      {
        'mrjones2014/legendary.nvim',
        -- since legendary.nvim handles all your keymaps/commands,
        -- its recommended to load legendary.nvim before other plugins
        priority = 10000,
        lazy = false,
        -- sqlite is only needed if you want to use frecency sorting
        -- dependencies = { 'kkharji/sqlite.lua' }
      }
      
      
      -- in a plugin spec:
      {
        'folke/flash.nvim',
        keys = {
          {
            's',
            function()
              require('flash').jump()
            end,
            mode = { 'n', 'x', 'o' },
            desc = 'Jump forwards',
          },
          {
            'S',
            function()
              require('flash').jump({ search = { forward = false } })
            end,
            mode = { 'n', 'x', 'o' },
            desc = 'Jump backwards',
          },
        },
      }
      
      -- where you set up legendary.nvim
      -- now the keymaps from the `flash.nvim` plugin spec will be automatically loaded
      require('legendary').setup({ extensions = { lazy_nvim = true } })
      
      
      require('legendary').setup({
        keymaps = {
          -- map keys to a command
          { '<leader>ff', ':Telescope find_files', description = 'Find files' },
          -- map keys to a function
          {
            '<leader>h',
            function()
              print('hello world!')
            end,
            description = 'Say hello',
          },
          -- Set options used during keymap creation
          { '<leader>s', ':SomeCommand<CR>', description = 'Non-silent keymap', opts = { silent = true } },
          -- create keymaps with different implementations per-mode
          {
            '<leader>c',
            { n = ':LinewiseCommentToggle<CR>', x = ":'<,'>BlockwiseCommentToggle<CR>" },
            description = 'Toggle comment',
          },
          -- create item groups to create sub-menus in the finder
          -- note that only keymaps, commands, and functions
          -- can be added to item groups
          {
            -- groups with same itemgroup will be merged
            itemgroup = 'short ID',
            description = 'A submenu of items...',
            icon = '',
            keymaps = {
              -- more keymaps here
            },
          },
          -- in-place filters, see :h legendary-tables or ./doc/table_structures/README.md
          { '<leader>m', description = 'Preview markdown', filters = { ft = 'markdown' } },
        },
        commands = {
          -- easily create user commands
          {
            ':SayHello',
            function()
              print('hello world!')
            end,
            description = 'Say hello as a command',
          },
          {
            -- groups with same itemgroup will be merged
            itemgroup = 'short ID',
            -- don't need to copy the other group data because
            -- it will be merged with the one from the keymaps table
            commands = {
              -- more commands here
            },
          },
          -- in-place filters, see :h legendary-tables or ./doc/table_structures/README.md
          { ':Glow', description = 'Preview markdown', filters = { ft = 'markdown' } },
        },
        funcs = {
          -- Make arbitrary Lua functions that can be executed via the item finder
          {
            function()
              doSomeStuff()
            end,
            description = 'Do some stuff with a Lua function!',
          },
          {
            -- groups with same itemgroup will be merged
            itemgroup = 'short ID',
            -- don't need to copy the other group data because
            -- it will be merged with the one from the keymaps table
            funcs = {
              -- more funcs here
            },
          },
        },
        autocmds = {
          -- Create autocmds and augroups
          { 'BufWritePre', vim.lsp.buf.format, description = 'Format on save' },
          {
            name = 'MyAugroup',
            clear = true,
            -- autocmds here
          },
        },
        -- load extensions
        extensions = {
          -- automatically load keymaps from lazy.nvim's `keys` option
          lazy_nvim = true,
          -- load keymaps and commands from nvim-tree.lua
          nvim_tree = true,
          -- load commands from smart-splits.nvim
          -- and create keymaps, see :h legendary-extensions-smart-splits.nvim
          smart_splits = {
            directions = { 'h', 'j', 'k', 'l' },
            mods = {
              move = '<C>',
              resize = '<M>',
            },
          },
          -- load commands from op.nvim
          op_nvim = true,
          -- load keymaps from diffview.nvim
          diffview = true,
        },
      })
      
      
      {
        -- pass a list of filter functions or a single filter function with
        -- the signature `function(item, context): boolean`
        -- (see below for `context` definition)
        -- several filter functions are provided for convenience
        -- see ./doc/FILTERS.md for a list
        filters = {},
        -- pass a function with the signature `function(item, mode): string[]`
        -- returning a list of strings where each string is one column
        -- use this to override the configured formatter for just one call
        formatter = nil,
        -- pass a string, or a function that returns a string
        -- to customize the select prompt for the current call
        select_prompt = nil,
      }
      
      
      {
        buf = number, -- buffer ID
        buftype = string,
        filetype = string,
        mode = string, -- the mode that the UI was triggered from
        cursor_pos = table, -- { row, col }
        marks = table, -- visual mode marks, if applicable; { line, col, line, col }
      }
      
      
      require('legendary').setup({
        -- Initial keymaps to bind, can also be a function that returns the list
        keymaps = {},
        -- Initial commands to bind, can also be a function that returns the list
        commands = {},
        -- Initial augroups/autocmds to bind, can also be a function that returns the list
        autocmds = {},
        -- Initial functions to bind, can also be a function that returns the list
        funcs = {},
        -- Initial item groups to bind,
        -- note that item groups can also
        -- be under keymaps, commands, autocmds, or funcs;
        -- can also be a function that returns the list
        itemgroups = {},
        -- default opts to merge with the `opts` table
        -- of each individual item
        default_opts = {
          -- for example, { silent = true, remap = false }
          keymaps = {},
          -- for example, { args = '?', bang = true }
          commands = {},
          -- for example, { buf = 0, once = true }
          autocmds = {},
        },
        -- Customize the prompt that appears on your vim.ui.select() handler
        -- Can be a string or a function that returns a string.
        select_prompt = ' legendary.nvim ',
        -- Character to use to separate columns in the UI
        col_separator_char = '│',
        -- Optionally pass a custom formatter function. This function
        -- receives the item as a parameter and the mode that legendary
        -- was triggered from (e.g. `function(item, mode): string[]`)
        -- and must return a table of non-nil string values for display.
        -- It must return the same number of values for each item to work correctly.
        -- The values will be used as column values when formatted.
        -- See function `default_format(item)` in
        -- `lua/legendary/ui/format.lua` to see default implementation.
        default_item_formatter = nil,
        -- Customize icons used by the default item formatter
        icons = {
          -- keymap items list the modes in which the keymap applies
          -- by default, you can show an icon instead by setting this to
          -- a non-nil icon
          keymap = nil,
          command = '',
          fn = '󰡱',
          itemgroup = '',
        },
        -- Include builtins by default, set to false to disable
        include_builtin = true,
        -- Include the commands that legendary.nvim creates itself
        -- in the legend by default, set to false to disable
        include_legendary_cmds = true,
        -- Options for list sorting. Note that fuzzy-finders will still
        -- do their own sorting. For telescope.nvim, you can set it to use
        -- `require('telescope.sorters').fuzzy_with_index_bias({})` when
        -- triggered via `legendary.nvim`. Example config for `dressing.nvim`:
        --
        -- require('dressing').setup({
        --  select = {
        --    get_config = function(opts)
        --      if opts.kind == 'legendary.nvim' then
        --        return {
        --          telescope = {
        --            sorter = require('telescope.sorters').fuzzy_with_index_bias({})
        --          }
        --        }
        --      else
        --        return {}
        --      end
        --    end
        --  }
        -- })
        sort = {
          -- put most recently selected item first, this works
          -- both within global and item group lists
          most_recent_first = true,
          -- sort user-defined items before built-in items
          user_items_first = true,
          -- sort the specified item type before other item types,
          -- value must be one of: 'keymap', 'command', 'autocmd', 'group', nil
          item_type_bias = nil,
          -- settings for frecency sorting.
          -- https://en.wikipedia.org/wiki/Frecency
          -- Set `frecency = false` to disable.
          -- this feature requires sqlite.lua (https://github.com/kkharji/sqlite.lua)
          -- and will be automatically disabled if sqlite is not available.
          -- NOTE: THIS TAKES PRECEDENCE OVER OTHER SORT OPTIONS!
          frecency = {
            -- the directory to store the database in
            db_root = string.format('%s/legendary/', vim.fn.stdpath('data')),
            -- the maximum number of timestamps for a single item
            -- to store in the database
            max_timestamps = 10,
          },
        },
        lazy_nvim = {
          -- Automatically register keymaps that are defined on lazy.nvim plugin specs
          -- using the `keys = {}` property.
          auto_register = false,
        },
        which_key = {
          -- Automatically add which-key tables to legendary
          -- see ./doc/WHICH_KEY.md for more details
          auto_register = false,
          -- you can put which-key.nvim tables here,
          -- or alternatively have them auto-register,
          -- see ./doc/WHICH_KEY.md
          mappings = {},
          opts = {},
          -- controls whether legendary.nvim actually binds they keymaps,
          -- or if you want to let which-key.nvim handle the bindings.
          -- if not passed, true by default
          do_binding = true,
          -- controls whether to use legendary.nvim item groups
          -- matching your which-key.nvim groups; if false, all keymaps
          -- are added at toplevel instead of in a group.
          use_groups = true,
        },
        -- Which extensions to load; no extensions are loaded by default.
        -- Setting the plugin name to `false` disables loading the extension.
        -- Setting it to any other value will attempt to load the extension,
        -- and pass the value as an argument to the extension, which should
        -- be a single function. Extensions are modules under `legendary.extensions.*`
        -- which return a single function, which is responsible for loading and
        -- initializing the extension.
        extensions = {
          nvim_tree = false,
          smart_splits = false,
          op_nvim = false,
          diffview = false,
        },
        scratchpad = {
          -- How to open the scratchpad buffer,
          -- 'current' for current window, 'float'
          -- for floating window
          view = 'float',
          -- How to show the results of evaluated Lua code.
          -- 'print' for `print(result)`, 'float' for a floating window.
          results_view = 'float',
          -- Border style for floating windows related to the scratchpad
          float_border = 'rounded',
          -- Whether to restore scratchpad contents from a cache file
          keep_contents = true,
        },
        -- Directory used for caches
        cache_path = string.format('%s/legendary/', vim.fn.stdpath('cache')),
        -- Log level, one of 'trace', 'debug', 'info', 'warn', 'error', 'fatal'
        log_level = 'info',
      })
      
    end,
  },
  {
    "Iron-E/nvim-cartographer",
    config = function()
      
      -- This is how you map with the Neovim API
      vim.api.nvim_set_keymap('n', 'gr', '<Cmd>lua vim.lsp.buf.references()<CR>', {noremap=true, silent=true})
      
      -- This is how you do that with `nvim-cartographer`
      map.n.nore.silent['gr'] = '<Cmd>lua vim.lsp.buf.references()<CR>'
      
      
      local fn = vim.fn
      
      local install_path = fn.stdpath('data')..'/site/pack/packer/opt/packer.nvim'
      
      if not vim.loop.fs_stat(fn.glob(install_path)) then
      	os.execute('git clone https://github.com/wbthomason/packer.nvim '..install_path)
      end
      
      vim.api.nvim_command 'packadd packer.nvim'
      
      return require('packer').startup {function(use)
      	use {'wbthomason/packer.nvim', opt=true}
      	use 'Iron-E/nvim-cartographer'
      end}
      
      
      local map = require 'cartographer'
      
      
      assert(vim.deep_equal(map.n.nore.silent.unique, map.silent.n.unique.nore))
      
      
      -- `:map` 'gt' in normal mode to searching for symbol references with the LSP
      map.n.nore.silent.unique['gr'] = '<Cmd>lua vim.lsp.buf.references()<CR>'
      
      
      local nnoremap = require('cartographer').n.nore.silent
      
      -- Only buffer sets map to current buffer
      nnoremap.buffer['gr'] = '<Cmd>lua vim.lsp.buf.references()<CR>'
      
      -- You can specify bufnr like <bufer=n>
      -- This keymap will be set for buffer 3
      nnoremap.buffer3['gr'] = '<Cmd>lua vim.lsp.buf.references()<CR>'
      
      
      local map = require 'cartographer'
      map:hook(function(buffer, mode, lhs, rhs, opts)
      	-- setup which-key, etc
      	print(vim.inspect(lhs)..' was mapped to '..vim.inspect(rhs))
      end)
      map['zxpp'] = vim.lsp.buf.definition
      
      
      local map = require 'cartographer'
      
      local function float_term()
      	local buffer = vim.api.nvim_create_buf(false, true)
      	local window = vim.api.nvim_open_win(buffer, true,
      	{
      		relative = 'cursor',
      		height = math.floor(vim.go.lines / 2),
      		width = math.floor(vim.go.columns / 2),
      		col = 0,
      		row = 0,
      	})
      	vim.api.nvim_command 'terminal'
      end
      
      map.n.nore.silent['<Tab>'] = float_term
      
      
      -- Map `gr` to LSP symbol references in 'x' and 'n' modes.
      map.n.x.nore.expr['<Tab>'] = 'pumvisible() ? "\\<C-n>" : check_backspace() ? "\\<Tab>" : compe#complete()'
      
      
      -- `:unmap` 'zfo' in `x` mode
      map.x['zfo'] = nil
      
    end,
  },
  {
    "LionC/nest.nvim",
    config = function()
      
      use { 'LionC/nest.nvim' }
      
      
      local nest = require('nest')
      
      nest.applyKeymaps {
          -- Remove silent from ; : mapping, so that : shows up in command mode
          { ';', ':' , options = { silent = false } },
          { ':', ';' },
      
          -- Prefix  every nested keymap with <leader>
          { '<leader>', {
              -- Prefix every nested keymap with f (meaning actually <leader>f here)
              { 'f', {
                  { 'f', '<cmd>Telescope find_files<cr>' },
                  -- This will actually map <leader>fl
                  { 'l', '<cmd>Telescope live_grep<cr>' },
                  -- Prefix every nested keymap with g (meaning actually <leader>fg here)
                  { 'g', {
                      { 'b', '<cmd>Telescope git_branches<cr>' },
                      -- This will actually map <leader>fgc
                      { 'c', '<cmd>Telescope git_commits<cr>' },
                      { 's', '<cmd>Telescope git_status<cr>' },
                  }},
              }},
      
              -- Lua functions can be right side values instead of key sequences
              { 'l', {
                  { 'c', vim.lsp.buf.code_actions },
                  { 'r', vim.lsp.buf.rename },
                  { 's', vim.lsp.buf.signature_help },
                  { 'h', vim.lsp.buf.hover },
              }},
          }},
      
          -- Use insert mode for all nested keymaps
          { mode = 'i', {
              { 'jk', '<Esc>' },
      
              -- Set <expr> option for all nested keymaps
              { options = { expr = true }, {
                  { '<cr>',       'compe#confirm("<CR>")' },
                  -- This is equivalent to viml `:inoremap <C-Space> <expr>compe#complete()`
                  { '<C-Space>',  'compe#complete()' },
              }},
      
              -- Buffer `true` sets keymaps only for the current buffer
              { '<C-', buffer = true, {
                  { 'h>', '<left>' },
                  { 'l>', '<right>' },
                  -- You can also set bindings for a specific buffer
                  { 'o>', '<Esc>o', buffer = 2 },
              }},
          }},
      
          -- Keymaps can be defined for multiple modes at once
          { 'H', '^', mode = 'nv' },
      }
      
      
      local nest = require('nest')
      
      nest.defaults.options = {
          noremap = false,
      }
      
      
      {
          mode = 'n',
          prefix = '',
          buffer = false,
          options = {
              noremap = true,
              silent = true,
          },
      }
      
      
      { 'inputsequence', 'outputsequence' }
      
      
      { 'inputsequence', someLuaFunction }
      
      
      { 'inputprefix', keymapConfig }
      
      
      {
          keymapConfig,
          keymapConfig,
          keymapConfig
          -- ...
      }
      
    end,
  },
  {
    "slugbyte/unruly-worker.nvim",
    config = function()
       
      local unruly_textobjects = require("unruly-worker.external.textobjects")
      require("nvim-treesitter.configs").setup({
          textobjects = {
              select = {
                  keymaps = unruly_textobjects.select_keymaps,
                  -- rest of config...
              },
              move = {
                  goto_next_start = unruly_textobjects.move_goto_next_start,
                  goto_previous_start = unruly_textobjects.move_goto_previous_start,
                  goto_next_end = unruly_textobjects.move_goto_next_end,
                  goto_previous_end = unruly_textobjects.move_goto_previous_end,
                  -- rest of config...
              },
          },
      })
      
    end,
  },
  {
    "FeiyouG/commander.nvim",
    config = function()
      
      use {
        "FeiyouG/commander.nvim",
        requires = { "nvim-telescope/telescope.nvim" }
      }
      
      
      return {
        "FeiyouG/commander.nvim",
        dependencies = { "nvim-telescope/telescope.nvim" }
      }
      
      
      -- Add a new command
      require("commander").add({
        {
          desc = "Open commander",
          cmd = require("commander").show,
          keys = { "n", "<Leader>fc" },
        }
      })
      -- Show commander and select the command by pressing "<leader>fc"
      
      
      require("commander").setup({
          ...
      })
      
      
      
      {
        -- Specify what components are shown in the prompt;
        -- Order matters, and components may repeat
        components = {
          "DESC",
          "KEYS",
          "CMD",
          "CAT",
        },
      
        -- Specify by what components the commands is sorted
        -- Order does not matter
        sort_by = {
          "DESC",
          "KEYS",
          "CMD",
          "CAT",
        },
      
        -- Change the separator used to separate each component
        separator = " ",
      
        -- When set to true,
        -- The desc component will be populated with cmd if desc is empty or missing.
        auto_replace_desc_with_cmd = true,
      
        -- Default title of the prompt
        prompt_title = "Commander",
      
        integration = {
          telescope = {
            -- Set to true to use telescope instead of vim.ui.select for the UI
            enable = false,
            -- Can be any builtin or custom telescope theme
            theme = require("telescope.themes").commander
          },
          lazy = {
            -- Set to true to automatically add all key bindings set through lazy.nvim
            enable = false,
            -- Set to true to use plugin name as category for each keybinding added from lazy.nvim
            set_plugin_name_as_cat = false
          }
        }
      }
      
      
      -- Plugin Manager: lazy.nvim
      return {
        "FeiyouG/commander.nvim",
        dependencies = {
          "nvim-telescope/telescope.nvim",
        },
        keys = {
          { "<leader>f",  "<CMD>Telescope commander<CR>", mode = "n" },
          { "<leader>fc", "<CMD>Telescope commander<CR>", mode = "n" }
        },
        config = function()
          require("commander").setup({
            components = {
              "DESC",
              "KEYS",
              "CAT",
            },
            sort_by = {
              "DESC",
              "KEYS",
              "CAT",
              "CMD"
            },
            integration = {
              telescope = {
                enable = true,
              },
              lazy = {
                enable = true,
                set_plugin_name_as_cat = true
              }
            }
          })
        end,
      }
      
      
      local commander = require("commander")
      
      commander.add({
        {
          desc = "Search inside current buffer",
          cmd = "<CMD>Telescope current_buffer_fuzzy_find<CR>",
          keys = { "n", "<leader>fl" },
        },  {
          -- If desc is not provided, cmd is used to replace descirption by default
          -- You can change this behavior in setup()
          cmd = "<CMD>Telescope find_files<CR>",
          keys = { "n", "<leader>ff" },
        }, {
          -- If keys are not provided, no keymaps will be displayed nor set
          desc = "Find hidden files",
          cmd = "<CMD>Telescope find_files hidden=true<CR>",
        }, {
          -- You can specify multiple keys for the same cmd ...
          desc = "Show document symbols",
          cmd = "<CMD>Telescope lsp_document_symbols<CR>",
          keys = {
            {"n", "<leader>ss", { noremap = true } },
            {"n", "<leader>ssd", { noremap = true } },
          },
        }, {
          -- ... and for different modes
          desc = "Show function signaure (hover)",
          cmd = "<CMD>lua vim.lsp.buf.hover()<CR>",
          keys = {
            {{"n", "x"}, "K", silent_noremap },
            {"i", "<C-k>" },
          }
        }, {
          -- You can pass in a key sequences as if you would type them in nvim
          desc = "My favorite key sequence",
          cmd = "A  -- Add a comment at the end of a line",
          keys = {"n", "<leader>Ac" }
        }, {
          -- You can also pass in a lua functions as cmd
          -- NOTE: binding lua funciton to a keymap requires nvim >= 0.7
          desc = "Run lua function",
          cmd = function() print("ANONYMOUS LUA FUNCTION") end,
          keys = {"n", "<leader>alf" },
        }, {
          -- If no cmd is specified, then this entry will be ignored
          desc = "lsp run linter",
          keys = {"n", "<leader>sf" },
        }
      })
      
      
      local commander = require("commander")
      
      -- The keymaps of the following commands will be key (if any)
      -- But the commands won't be shown when you call `require("commander").show()`
      commander.add({
        {
          desc = "Find files",
          cmd = "<CMR>telescope find_files<CR>",
          keys = { "n", "<leader>ff", { noremap = true } },
        }, {
          -- If keys is not specified, then this enery is ignored
          -- since there is no keymaps to set
          desc = "Search inside current buffer",
          cmd = "<CMD>Telescope current_buffer_fuzzy_find<CR>",
        }
      }, {
        show = false
      })
      
      -- The following commands will be shown in the prompt,
      -- But the keymaps will not be registered;
      -- This is helpful if you already registered the keymap somewhere else
      -- and want to avoid set the exact keymap twice
      commander.add({
        {
          -- If keys are specified,
          -- then they will still show up in commander but won't be set
          desc = "Find hidden files",
          cmd = "<CMD>Telescope find_files hidden=true<CR>",
          keys = { "n", "<leader>f.f" },
        }, {
          desc = "Show document symbols",
          cmd = "<CMD>Telescope lsp_document_symbols<CR>",
        }, {
          -- Since `show` is set to `true` in this command,
          -- It overwrites the opts and this keymap will still be set
          desc = "LSP code actions",
          cmd = "<CMD>Telescope lsp_code_actions<CR>",
          keys = { "n", "<leader>sa" },
          show = true
        }
      }, {
          show = false
      })
      
      
      
      require("commander").setup({
        ...
        integration = {
          ...
          telescope = {
            enable = true,
            -- Optional, you can use any telescope supported theme
            theme = require("telescope.themes").commander
          }
        }
      })
      
      
      -- The same as require("commander").show()
      Telescope commander
      
      -- The same as require("commander").show({ filter = { mode = "i" } })
      Telescope commander filter mode=i
      
      -- The same as require("commander").show({ filter = { mode = "i", cat = "git" } })
      Telescope commander filter mode=i cat=git
      
      
      require("commander").setup({
        ...
        integration = {
          ...
          lazy = {
              enable = true
          }
        }
      })
      
      
          {
            "mzlogin/vim-markdown-toc",
      
            ft = { "markdown" },
      
            cmd = { "GenTocGFM" },
      
            -- This command will be added to commander automatically
            commander = {
              {
                cmd = "<CMD>GenTocGFM<CR>",
                desc = "Generate table of contents (GFM)",
              }
            },
      
            config = function() ... end,
          }
          
    end,
  },
  {
    "nvimtools/hydra.nvim",
    config = function()
      
      {
          "nvimtools/hydra.nvim",
          config = function()
              -- create hydras in here
          end
      }
      
      
      local Hydra = require("hydra")
      Hydra({
          -- string? only used in auto-generated hint
          name = "Hydra's name",
      
          -- string | string[] modes where the hydra exists, same as `vim.keymap.set()` accepts
          mode = "n",
      
          -- string? key required to activate the hydra, when excluded, you can use
          -- Hydra:activate()
          body = "<leader>o",
      
          -- these are explained below
          hint = [[ ... ]],
          config = { ... },
          heads = { ... },
      })
      
      
      config = {
          -- see :h hydra-heads
          exit = false, -- set the default exit value for each head in the hydra
      
          -- decides what to do when a key which doesn't belong to any head is pressed
          --   nil: hydra exits and foreign key behaves normally, as if the hydra wasn't active
          --   "warn": hydra stays active, issues a warning and doesn't run the foreign key
          --   "run": hydra stays active, runs the foreign key
          foreign_keys = nil,
      
          -- see `:h hydra-colors`
          color = "red", -- "red" | "amaranth" | "teal" | "pink"
      
          -- define a hydra for the given buffer, pass `true` for current buf
          buffer = nil,
      
          -- when true, summon the hydra after pressing only the `body` keys. Normally a head is
          -- required
          invoke_on_body = false,
      
          -- description used for the body keymap when `invoke_on_body` is true
          desc = nil, -- when nil, "[Hydra] .. name" is used
      
          -- see :h hydra-hooks
          on_enter = nil, -- called when the hydra is activated
          on_exit = nil, -- called before the hydra is deactivated
          on_key = nil, -- called after every hydra head
      
          -- timeout after which the hydra is automatically disabled. Calling any head
          -- will refresh the timeout
          --   true: timeout set to value of 'timeoutlen' (:h 'timeoutlen')
          --   5000: set to desired number of milliseconds
          timeout = false, -- by default hydras wait forever
      
          -- see :h hydra-hint-hint-configuration
          hint = false,
      }
      
      
      require('hydra').setup({
          debug = false,
          exit = false,
          foreign_keys = nil,
          color = "red",
          timeout = false,
          invoke_on_body = false,
          hint = {
              show_name = true,
              position = { "bottom" },
              offset = 0,
              float_opts = { },
          },
          on_enter = nil,
          on_exit = nil,
          on_key = nil,
      })
      
      
      Hydra({
          hint = [[ some multiline string ]]
      })
      
      
      Hydra({
          config = {
              -- either a table like below, or `false` to disable the hint
              hint = {
                  -- "window" | "cmdline" | "statusline" | "statuslinemanual"
                  --   "window": show hint in a floating window
                  --   "cmdline": show hint in the echo area
                  --   "statusline": show auto-generated hint in the status line
                  --   "statuslinemanual": Do not show a hint, but return a custom status
                  --                       line hint from require("hydra.statusline").get_hint()
                  type = "window", -- defaults to "window" if `hint` is passed to the hydra
                                   -- otherwise defaults to "cmdline"
      
                  -- set the position of the hint window. one of:
                  --    top-left   |   top    |  top-right
                  --  -------------+----------+--------------
                  --   middle-left |  middle  | middle-right
                  --  -------------+----------+--------------
                  --   bottom-left |  bottom  | bottom-right
                  position = "bottom",
      
                  -- Offset of the floating window from the nearest editor border
                  offset = 0,
      
                  -- options passed to `nvim_open_win()`, see :h nvim_open_win()
                  -- Lets you set border, header, footer, etc etc.
                  float_opts = {
                      -- row, col, height, width, relative, and anchor should not be
                      -- overridden
                      style = "minimal",
                      focusable = false,
                      noautocmd = true,
                  },
      
                  -- show the hydras name (or "HYDRA:" if not given a name), at the
                  -- beginning of an auto-generated hint
                  show_name = true,
                  
                  -- if set to true, this will prevent the hydra's hint window from displaying
                  -- immediately.
                  -- Note: you can still show the window manually by calling Hydra.hint:show()
                  -- and manually close it with Hydra.hint:close()
                  hide_on_load = false,
      
                  -- Table from function names to function. Functions should return
                  -- a string. These functions can be used in hints with %{func_name}
                  -- more in :h hydra-hint
                  funcs = {},
              }
          }
      })
      
      
      { head, rhs, opts }
      
      
      opts = {
          -- "When the hydra hides, this head does not stick out"
          -- Private heads are unreachable outside of the hydra state.
          private = false,
      
          -- When true, stops the hydra after executing this head
          -- NOTE:
          --   - All exit heads are private
          --   - If no exit head is specified, esc is set by default
          exit = false,
      
          -- Like exit, but stops the hydra BEFORE executing the command
          exit_before = false,
      
          -- when set to false, config.on_key isn't run after this head
          ok_key = true,
      
          -- string | false - value shown in auto-generated hint. When false, this key
          -- doesn't show up in the auto-generated hint
          desc = nil,
      
          -- same as the builtin map options
          expr = false, -- :h :map-expression
          silent = false, -- :h :map-silent
      
          -- \/ For Pink Hydras only \/ --
      
          -- allows binding a key which will immediately perform its action and not wait
          -- `timeoutlen` for a possible continuation
          nowait = false,
      
          -- Override `mode` for this head
          mode = "n",
      }
      
      
      config = {
          on_enter = function()
             print('Hydra enter')
             vim.bo.modifiable = false -- temporarily set `nomodifiable` while Hydra is active
          end,
          on_exit = function()
             print('Hydra exit')
             -- No need to set modifiable back here
          end
      }
      
      
        cmd("vsplit") == "<Cmd>vsplit<CR>"
        
    end,
  },
  {
    "anuvyklack/keymap-amend.nvim",
    config = function()
      
      local keymap = vim.keymap
      keymap.amend = require('keymap-amend')
      
      keymap.amend(mode, lhs, function(original)
          -- your custom logic
          original() -- execute the original 'lhs' mapping
      end, opts)
      
      
      use 'anuvyklack/keymap-amend.nvim'
      
      
      local keymap = vim.keymap
      keymap.amend = require('keymap-amend')
      
      keymap.amend('n', 'k', function(original)
         print('k key is amended!')
         original()
      end)
      
      
      local keymap = vim.keymap
      keymap.amend = require('keymap-amend')
      
      keymap.amend('n', '<Esc>', function(original)
         if vim.v.hlsearch and vim.v.hlsearch == 1 then
            vim.cmd('nohlsearch')
         end
         original()
      end, { desc = 'disable search highlight' })
      
      
      use 'mg979/vim-visual-multi'
      use { 'gbprod/yanky.nvim',
         after = 'vim-visual-multi',
         config = function() require('yanky').setup() end
      }
      
      keymap.amend('n', '<C-p>', function(original)
         if yanky.can_cycle() then
            yanky.cycle(-1)
         else
            original()
         end
      end)
      
      keymap.amend('n', '<C-n>', function(original)
         if yanky.can_cycle() then
            yanky.cycle(1)
         else
            original()
         end
      end, { desc = 'yank-ring + multiple-cursors' })
      
    end,
  },
  {
    "max397574/better-escape.nvim",
  },
  {
    "TheBlob42/houdini.nvim",
    config = function()
      
      {
          'TheBlob42/houdini.nvim',
          config = function()
              require('houdini').setup()
          end
      }
      
      
      -- default settings
      require('houdini').setup {
          mappings = { 'jk' },
          timeout = vim.o.timeoutlen,
          check_modified = true,
          excluded_filetypes = {},
          escape_sequences = {
              ['i']    = '<BS><BS><ESC>',
              ['ic']   = '<BS><BS><ESC>',
              ['ix']   = '<BS><BS><ESC>',
              ['R']    = '<BS><BS><RIGHT><ESC>',
              ['Rc']   = '<BS><BS><ESC>',
              ['Rx']   = '<BS><BS><ESC>',
              ['Rv']   = '<BS><BS><RIGHT><ESC>',
              ['Rvc']  = '<BS><BS><ESC>',
              ['Rvx']  = '<BS><BS><ESC>',
              ['v']    = escape_and_undo,
              ['vs']   = escape_and_undo,
              ['V']    = escape_and_undo,
              ['Vs']   = escape_and_undo,
              ['^V']   = escape_and_undo,
              ['^Vs']  = escape_and_undo,
              ['no']   = escape_and_undo,
              ['nov']  = escape_and_undo,
              ['noV']  = escape_and_undo,
              ['no^V'] = escape_and_undo,
              ['s']  = '<BS><BS><ESC>:u! | call histdel("cmd", -1) | echo ""<CR>',
              ['S']  = '<BS><BS><ESC>:u! | call histdel("cmd", -1) | echo ""<CR>',
              ['^S'] = '<BS><BS><ESC>:u! | call histdel("cmd", -1) | echo ""<CR>',
              ['t'] = '<BS><BS><C-\\><C-n>',
              ['c'] = '<BS><BS><C-c>',
          },
      }
      
      
      require('houdini').setup {
          mappings = { 'jk', 'AA', 'II' },
          escape_sequences = {
              ['i'] = function(char_one, char_two, pos, tick)
                  local seq = char_one..char_two
      
                  if seq == 'AA' then
                      -- jump to the end of the line in insert mode
                      return '<BS><BS><End>'
                  end
      
                  if seq == 'II' then
                      -- jump to the beginning of the line in insert mode
                      return '<BS><BS><Home>'
                  end
      
                  -- you can also deactivate houdini for certain
                  -- occasions by simply returning an empty string
                  if vim.opt.filetype:get() == 'TelescopePrompt' then
                      return ''
                  end
      
                  return '<BS><BS><ESC>'
              end,
              -- set the sequence of a specific mode to `false`
              -- in order to completely disable houdini for this mode
              ['c'] = false,
          },
      }
      
    end,
  },
  {
    "Nexmean/caskey.nvim",
    config = function()
      
      {
        "Nexmean/caskey.nvim",
        dependencies = {
          "folke/which-key.nvim", -- optional, only if you want which-key integration
        },
      }
      
      
      use {
        "Nexmean/caskey.nvim",
        requires = {
          "folke/which-key.nvim", -- optional, only if you want which-key integration
        },
      }
      
      
      -- user/mappings.lua
      local ck = require("caskey")
      
      return {
        -- options are inherits so you can define most regular at the top of keymaps config
        mode = {"n", "v"},
      
        -- Simple keymap with `caskey.cmd` helper and mode override
        ["<Esc>"] = {act = ck.cmd "noh", desc = "no highlight", mode = "n"},
      
        -- group keymaps to reuse options or just for config structuring
        {
          mode = {"i", "t", "c"},
      
          ["<C-a>"] = {act = "<Home>"  , desc = "Beginning of line"},
          ["<C-e>"] = {act = "<End>"   , desc = "End of line"},
          ["<C-f>"] = {act = "<Right>" , desc = "Move forward"},
          ["<C-b>"] = {act = "<Left>"  , desc = "Move back"},
          -- override options
          ["<C-d>"] = {act = "<Delete>", desc = "Delete next character", mode = {"i", "c"}},
        },
      
        -- structure your keymaps as a tree and define which-key prefixes
        ["<leader>t"] = {
          name = "tabs",
      
          n = {act = ck.cmd "tabnew"                            , desc = "new tab"},
          x = {act = ck.cmd "tabclose"                          , desc = "close tab"},
          t = {act = ck.cmd "Telescope telescope-tabs list_tabs", desc = "list tabs"},
        },
      
        -- define buffer local keymaps
        ["q"] = {
          act = ck.cmd "close",
          desc = "close window",
          when = {
            ck.ft "Outline",
            ck.bt {"quickfix", "help"},
            -- that is equivalent to:
            {
              event = "FileType",
              pattern = "Outline",
            },
            {
              event = "BufWinEnter",
              condition = function ()
                return vim.tbl_contains({"quickfix", "help"}, vim.o.buftype)
              end
            }
          },
        },
      
        -- use functions as config bodies
        ["<leader>h"] = function ()
          local gs = require("gitsigns")
      
          return {
            name = "hunk",
      
            mode = "n",
      
            -- Sometimes there aren't events which describe that you need to setup buffer local mappings.
            -- For such cases you can use custom events.
            -- Caskey provides api for emitting them:
            --   -- nvim/lua/user/plugins/gitsigns.lua
            --   ...
            --   on_attach = function (bufnr)
            --     require("caskey").emit("Gitsigns", bufnr)
            --   end
            --   ...
            -- 
            -- And then you can use `ck.emit` to describe when to setup mappings
            when = ck.emitted "Gitsigns",
      
            s = {act = gs.stage_hunk     , desc = "stage hunk"},
            r = {act = gs.reset_hunk     , desc = "rest hunk"},
            S = {act = gs.stage_buffer   , desc = "stage buffer"},
            u = {act = gs.undo_stage_hunk, desc = "unstage hunk"},
            d = {act = gs.preview_hunk   , desc = "preview hunk"} ,
            b = {act = gs.blame_line     , desc = "blame line"},
          }
        end,
      
        {
          mode = "n",
          when = "LspAttach",
          ["gd"] = {act = ck.cmd "Telescope lsp_definitions", desc = "lsp definition"},
          ["<C-s>"] = {
            act = ck.cmd "SymbolsOutline",
            desc = "toggle outline",
            -- extend mode or buffer local configuration
            mode_extend = "v",
            when_extend = ck.ft "Outline",
          },
        },
      }
      
      
      require("caskey").setup(require("user.mappings"))
      
      
      require("caskey.wk").setup(require("user.mappings"))
      
    end,
  },
  {
    "Wansmer/langmapper.nvim",
    config = function()
      
      return {
        'Wansmer/langmapper.nvim',
        lazy = false,
        priority = 1, -- High priority is needed if you will use `autoremap()`
        config = function()
          require('langmapper').setup({--[[ your config ]]})
        end,
      }
      
      
      use({
        'Wansmer/langmapper.nvim',
        config = function()
          require('langmapper').setup({--[[ your config ]]})
        end,
      })
      
      
      -- code
      require('langmapper').automapping({ global = true, buffer = true })
      -- end of init.lua
      
      
      local function escape(str)
        -- You need to escape these characters to work correctly
        local escape_chars = [[;,."|\]]
        return vim.fn.escape(str, escape_chars)
      end
      
      -- Recommended to use lua template string
      local en = [[`qwertyuiop[]asdfghjkl;'zxcvbnm]]
      local ru = [[ёйцукенгшщзхъфывапролджэячсмить]]
      local en_shift = [[~QWERTYUIOP{}ASDFGHJKL:"ZXCVBNM<>]]
      local ru_shift = [[ËЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ]]
      
      vim.opt.langmap = vim.fn.join({
          -- | `to` should be first     | `from` should be second
          escape(ru_shift) .. ';' .. escape(en_shift),
          escape(ru) .. ';' .. escape(en),
      }, ',')
      
      
      local default_config = {
        ---@type boolean Add mapping for every CTRL+ binding or not.
        map_all_ctrl = true,
        ---@type string[] Modes to `map_all_ctrl`
        ---Here and below each mode must be specified, even if some of them extend others.
        ---E.g., 'v' includes 'x' and 's', but must be listed separate.
        ctrl_map_modes = { 'n', 'o', 'i', 'c', 't', 'v' },
        ---@type boolean Wrap all keymap's functions (nvim_set_keymap etc)
        hack_keymap = true,
        ---@type string[] Usually you don't want insert mode commands to be translated when hacking.
        ---This does not affect normal wrapper functions, such as `langmapper.map`
        disable_hack_modes = { 'i' },
        ---@type table Modes whose mappings will be checked during automapping.
        automapping_modes = { 'n', 'v', 'x', 's' },
        ---@type string Standart English layout (on Mac, It may be different in your case.)
        default_layout = [[ABCDEFGHIJKLMNOPQRSTUVWXYZ<>:"{}~abcdefghijklmnopqrstuvwxyz,.;'[]`]],
        ---@type string[] Names of layouts. If empty, will handle all configured layouts.
        use_layouts = {},
        ---@type table Fallback layouts
        ---Custom description builder:
        ---  old_desc - original description,
        ---  method - 'translate' (map translated lhs) or 'feedkeys' (call `nvim_feedkeys` with original lhs)
        ---  lhs - original left-hand side for translation
        ---should return new description as a string. If error is occurs or non-string is returned, original builder with `LM ()` prefix will use
        ---@type nil|function(old_desc, method, lhs): string
        custom_desc = nil,
        layouts = {
          ---@type table Fallback layout item. Name of key is a name of language
          ru = {
            ---@type string Name of your second keyboard layout in system.
            ---It should be the same as result string of `get_current_layout_id()`
            id = 'com.apple.keylayout.RussianWin',
            ---@type string Fallback layout to translate. Should be same length as default layout
            layout = 'ФИСВУАПРШОЛДЬТЩЗЙКЫЕГМЦЧНЯБЮЖЭХЪËфисвуапршолдьтщзйкыегмцчнябюжэхъё',
            ---@type string if you need to specify default layout for this fallback layout
            default_layout = nil,
          },
        },
        os = {
          -- Darwin - Mac OS, the result of `vim.loop.os_uname().sysname`
          Darwin = {
            ---Function for getting current keyboard layout on your OS
            ---Should return string with id of layout
            ---@return string
            get_current_layout_id = function()
              local cmd = 'im-select'
              if vim.fn.executable(cmd) then
                local output = vim.split(vim.trim(vim.fn.system(cmd)), '\n')
                return output[#output]
              end
            end,
          },
        },
      }
      
      
      -- this function completely repeats contract of vim.keymap.set
      local map = require('langmapper').map
      
      map('n', '<Leader>e', '<Cmd>Neotree toggle focus<Cr>')
      
      
      -- Neo-tree config.
      -- It will return a table with 'translated' keys and same values.
      local map = require('langmapper.utils')
      local window_mappings = mapper.trans_dict({
        ['o'] = 'open',
        ['sg'] = 'split_with_window_picker',
        ['<leader>d'] = 'copy',
      })
      
      
      local langmapper = require('langmapper')
      
      langmapper.map(...)
      langmapper.automapping(...)
      -- etc
      
      
      ---@param opts {global=boolean|nil, buffer=boolean|nil}
      function M.automapping(opts)
      
      
      ---@param mode string|table Same mode short names as |nvim_set_keymap()|
      ---@param lhs string Left-hand side |{lhs}| of the mapping.
      ---@param rhs string|function Right-hand side |{rhs}| of the mapping. Can also be a Lua function.
      ---@param opts table|nil A table of |:map-arguments|.
      function M.map(mode, lhs, rhs, opts)
      
      ---@param mode string|table Same mode short names as |nvim_set_keymap()|
      ---@param lhs string Left-hand side |{lhs}| of the mapping.
      ---@param opts table|nil A table of optional arguments:
      ---  - buffer: (number or boolean) Remove a mapping from the given buffer.
      ---  When "true" or 0, use the current buffer.
      function M.del(mode, lhs, opts)
      
      
      local langmapper = require("langmapper")
      langmapper.setup()
      langmapper.hack_get_keymap()
      
      
      -- When you don't need some mapping to be translated. For example, I don't translate `jk`.
      `original_set_keymap()` -- vim.api.nvim_set_keymap
      `original_buf_set_keymap() -- vim.api.nvim_buf_set_keymap
      `original_del_keymap()` -- vim.api.nvim_del_keymap
      `original_buf_del_keymap()` -- vim.api.nvim_buf_del_keymap
      `put_back_keymap()` -- Set original functions back
      
      
      `wrap_nvim_set_keymap()`
      `wrap_nvim_del_keymap()`
      `wrap_nvim_buf_set_keymap()`
      `wrap_nvim_buf_del_keymap()`
      
      
      ---@param lhs string Left-hand side |{lhs}| of the mapping.
      ---@param to_lang string Name of layout or 'default' if need translating back to English layout
      ---@param from_lang? string Name of layout.
      ---@return string
      function M.translate_keycode(lhs, to_lang, from_lang)
      
      
      local utils = require('langmapper.utils')
      local keycode = '<leader>gh'
      local tr_keycode = utils.translate_keycode(keycode, 'ru') -- '<leader>пр'
      
      
      ---@param dict table Dict-like table
      ---@return table
      function M.trans_dict(dict)
      
      
      local keycode_dict = { ['s'] = false, ['<leader>'] = { ['d'] = 'copy' }, ['<S-TAB>'] = 'prev_source' }
      local result = utils.trans_dict(keycode_dict)
      -- {
      --   ['s'] = false,
      --   ['ы'] = false,
      --   ['<leader>'] = {
      --     ['d'] = 'copy',
      --     ['в'] = 'copy',
      --   },
      --   ['<S-TAB>'] = 'prev_source',
      -- }
      
      
      ---@param dict table Dict-like table
      ---@return table
      function M.trans_list(dict)
      
      
      local keycode_list = { '<leader>d', 'ab', '<S-Tab>' }
      local translated = utils.trans_list(keycode_list)
      -- { '<leader>d', 'ab', '<S-Tab>', '<leader>в', 'фи' }
      
    end,
  },
  {
    "tris203/hawtkeys.nvim",
    config = function()
      
      
      return {
          "tris203/hawtkeys.nvim",
          dependencies = {
              "nvim-lua/plenary.nvim",
              "nvim-treesitter/nvim-treesitter",
          },
          config = {
              -- an empty table will work for default config
              --- if you use functions, or whichkey, or lazy to map keys
              --- then please see the API below for options
          },
      }
      
      
      return {
          leader = " ", -- the key you want to use as the leader, default is space
          homerow = 2, -- the row you want to use as the homerow, default is 2
          powerFingers = { 2, 3, 6, 7 }, -- the fingers you want to use as the powerfingers, default is {2,3,6,7}
          keyboardLayout = "qwerty", -- the keyboard layout you use, default is qwerty
          customMaps = {
              --- EG local map = vim.api
              --- map.nvim_set_keymap('n', '<leader>1', '<cmd>echo 1')
              {
                  ["map.nvim_set_keymap"] = { --name of the expression
                      modeIndex = "1", -- the position of the mode setting
                      lhsIndex = "2", -- the position of the lhs setting
                      rhsIndex = "3", -- the position of the rhs setting
                      optsIndex = "4", -- the position of the index table
                      method = "dot_index_expression", -- if the function name contains a dot
                  },
              },
              --- EG local map2 = vim.api.nvim_set_keymap
              ["map2"] = { --name of the function
                  modeIndex = 1, --if you use a custom function with a fixed value, eg normRemap, then this can be a fixed mode eg 'n'
                  lhsIndex = 2,
                  rhsIndex = 3,
                  optsIndex = 4,
                  method = "function_call",
              },
              -- If you use whichkey.register with an alias eg wk.register
              ["wk.register"] = {
                  method = "which_key",
              },
              -- If you use lazy.nvim's keys property to configure keymaps in your plugins
              ["lazy"] = {
                  method = "lazy",
              },
          },
          highlights = { -- these are the highlight used in search mode
              HawtkeysMatchGreat = { fg = "green", bold = true },
              HawtkeysMatchGood = { fg = "green"},
              HawtkeysMatchOk = { fg = "yellow" },
              HawtkeysMatchBad = { fg = "red" },
          },
      }
      
    end,
  },
  {
    "mawkler/demicolon.nvim",
    config = function()
      
      -- Diagnostics
      local function diagnostic_jump(count, severity)
        return function()
          vim.diagnostic.jump({ count = count, severity = severity })
        end
      end
      
      local map, nxo = vim.keymap.set, { 'n', 'x', 'o' }
      local severity = vim.diagnostic.severity
      local error, warn, info, hint = severity.ERROR, severity.WARN, severity.INFO, severity.HINT
      
      map(nxo, ']e', diagnostic_jump(1, error), { desc = 'Next error' })
      map(nxo, '[e', diagnostic_jump(-1, error), { desc = 'Previous error' })
      
      map(nxo, ']w', diagnostic_jump(1, warn), { desc = 'Next warning' })
      map(nxo, '[w', diagnostic_jump(-1, warn), { desc = 'Previous warning' })
      
      map(nxo, ']i', diagnostic_jump(1, info), { desc = 'Next info' })
      map(nxo, '[i', diagnostic_jump(1, info), { desc = 'Previous info' })
      
      map(nxo, ']h', diagnostic_jump(1, hint), { desc = 'Next hint' })
      map(nxo, '[h', diagnostic_jump(-1, hint), { desc = 'Previous hint' })
      
      -- Gitsigns (from its README):
      local map = vim.keymap.set
      map('n', ']c', function()
        if vim.wo.diff then
          vim.cmd.normal({ ']c', bang = true })
        else
          gitsigns.nav_hunk('next')
        end
      end)
      
      map('n', '[c', function()
        if vim.wo.diff then
          vim.cmd.normal({ '[c', bang = true })
        else
          gitsigns.nav_hunk('prev')
        end
      end)
      
      -- Neotest
      local map, nxo = vim.keymap.set, { 'n', 'x', 'o' }
      
      local function neotest_jump(direction, status)
        return function()
          require('neotest').jump[direction]({ status = status })
        end
      end
      
      map(nxo, ']t', neotest_jump('next'), { desc = 'Next test' })
      map(nxo, '[t', neotest_jump('prev'), { desc = 'Previous test' })
      map(nxo, ']T', neotest_jump('next', 'failed'), { desc = 'Next failed test' })
      map(nxo, '[T', neotest_jump('prev', 'failed'), { desc = 'Previous failed test' })
      
      
      {
        'mawkler/demicolon.nvim',
        dependencies = {
          'nvim-treesitter/nvim-treesitter',
          'nvim-treesitter/nvim-treesitter-textobjects',
        },
        opts = {}
      }
      
      
      opts = {
        -- Create default keymaps
        keymaps = {
          -- Create t/T/f/F key mappings
          horizontal_motions = true,
          -- Create ; and , key mappings. Set it to 'stateless', 'stateful', or false to
          -- not create any mappings. 'stateless' means that ;/, move right/left.
          -- 'stateful' means that ;/, will remember the direction of the original
          -- jump, and `,` inverts that direction (Neovim's default behaviour).
          repeat_motions = 'stateless',
          -- Keys that shouldn't be repeatable (because aren't motions), excluding the prefix `]`/`[`
          -- If you have custom motions that use one of these, make sure to remove that key from here
          disabled_keys = { 'p', 'I', 'A', 'f', 'i' },
        },
      }
      
      
      require('demicolon').setup({
        keymaps = {
          repeat_motions = false, -- Don't create ; and , keymaps
        },
      })
      
      local map, nxo = vim.keymap.set, { 'n', 'x', 'o' }
      
      -- Stateless: always forward/backward
      map(nxo, 'n', require('demicolon.repeat_jump').forward)
      map(nxo, 'N', require('demicolon.repeat_jump').backward)
      
      -- Or, stateful (remember the original motion’s direction)
      -- map(nxo, 'n', require('demicolon.repeat_jump').next)
      -- map(nxo, 'N', require('demicolon.repeat_jump').prev)
      
      
      return {
        'jinh0/eyeliner.nvim',
        -- keys = { 't', 'f', 'T', 'F' }, -- Uncomment this to lazy load eyeliner.nvim
        config = function()
          require('eyeliner').setup({
            highlight_on_key = true,
            default_keymaps = false,
            dim = true, -- Optional
          })
      
          local function eyeliner_jump(key)
            local forward = vim.list_contains({ 't', 'f' }, key)
            return function()
              require('eyeliner').highlight({ forward = forward })
              return require('demicolon.jump').horizontal_jump(key)()
            end
          end
      
          local nxo = { 'n', 'x', 'o' }
          local opts = { expr = true }
      
          vim.keymap.set(nxo, 'f', eyeliner_jump('f'), opts)
          vim.keymap.set(nxo, 'F', eyeliner_jump('F'), opts)
          vim.keymap.set(nxo, 't', eyeliner_jump('t'), opts)
          vim.keymap.set(nxo, 'T', eyeliner_jump('T'), opts)
        end,
      }
      
      
      require('lazy').setup({
        {
          'nvim-treesitter/nvim-treesitter-textobjects',
          dependencies = 'nvim-treesitter/nvim-treesitter',
          build = ':TSUpdate',
          config = function()
            require('nvim-treesitter.configs').setup({
              ensure_installed = 'all',
              textobjects = {
                move = {
                  enable = true,
                  goto_next_start = {
                    [']f'] = '@function.outer',
                    [']a'] = '@argument.outer',
                    [']m'] = '@method.outer',
                    -- ...
                  },
                  goto_previous_start = {
                    ['[f'] = '@function.outer',
                    ['[a'] = '@argument.outer',
                    ['[m'] = '@method.outer',
                    -- ...
                  },
                },
              },
            })
          end,
        },
        {
          'jinh0/eyeliner.nvim',
          keys = { 't', 'f', 'T', 'F' },
          config = function()
            require('eyeliner').setup({
              highlight_on_key = true,
              dim = true,
              default_keymaps = false,
            })
      
            local function eyeliner_jump(key)
              local forward = vim.list_contains({ 't', 'f' }, key)
              return function()
                require('eyeliner').highlight({ forward = forward })
                return require('demicolon.jump').horizontal_jump(key)()
              end
            end
      
            local map, nxo, opts = vim.keymap.set, { 'n', 'x', 'o' }, { expr = true }
      
            map(nxo, 'f', eyeliner_jump('f'), opts)
            map(nxo, 'F', eyeliner_jump('F'), opts)
            map(nxo, 't', eyeliner_jump('t'), opts)
            map(nxo, 'T', eyeliner_jump('T'), opts)
          end,
        },
        {
          'mawkler/demicolon.nvim',
          dependencies = {
            'nvim-treesitter/nvim-treesitter',
            'nvim-treesitter/nvim-treesitter-textobjects',
          },
          opts = {
            keymaps = {
              horizontal_motions = false,
              -- `f` is removed from this table because we have mapped it to
              -- `@function.outer` with nvim-treesitter-textobjects
              disabled_keys = { 'p', 'I', 'A', 'i' },
            },
          },
        },
      })
      
    end,
  },
  {
    "debugloop/layers.nvim",
    config = function()
      
      {
        "debugloop/layers.nvim",
        opts = {}, -- see :help Layers.config
      },
      
      
      {
        "mfussenegger/nvim-dap",
        dependencies = {
          {
            "debugloop/layers.nvim",
            opts = {},
          },
        },
        keys = {
          {
            "<leader>d",
            function()
              local dap = require("dap")
              if dap.session() ~= nil then
                DEBUG_MODE:activate()
                return
              end
              dap.continue()
            end,
            desc = "launch debugger",
          },
        },
        opts = { ... }
        config = function(_, opts)
          local dap = require("dap")
          -- do the setup you'd do anyway for your language of choice
          dap.adapters = opts.adapters
          dap.configurations = opts.configurations
          -- this is where the example starts
          DEBUG_MODE = Layers.mode.new() -- global, accessible from anywhere
          DEBUG_MODE:auto_show_help()
          -- this actually relates to the next example, but it is most convenient to add here
          DEBUG_MODE:add_hook(function(_)
            vim.cmd("redrawstatus") -- update status line when toggled
          end)
          -- nvim-dap hooks
          dap.listeners.after.event_initialized["debug_mode"] = function()
            DEBUG_MODE:activate()
          end
          dap.listeners.before.event_terminated["debug_mode"] = function()
            DEBUG_MODE:deactivate()
          end
          dap.listeners.before.event_exited["debug_mode"] = function()
            DEBUG_MODE:deactivate()
          end
          -- map our custom mode keymaps
          DEBUG_MODE:keymaps({
            n = {
              {
                "s",
                function()
                  dap.step_over()
                end,
                { desc = "step forward" },
              },
              {
                "c",
                function()
                  dap.continue()
                end,
                { desc = "continue" },
              },
              { -- this acts as a way to leave debug mode without quitting the debugger
                "<esc>",
                function()
                  DEBUG_MODE:deactivate()
                end,
                { desc = "exit" },
              },
              -- and so on...
            },
          })
      }
      
      
      {
        "echasnovski/mini.statusline",
        dependencies = {
          {
            "debugloop/layers.nvim",
            opts = {},
          },
        },
        opts = {
          content = {
            active = function() -- this is the default, see :help MiniStatusline-example-content
              local mode, mode_hl = MiniStatusline.section_mode({ trunc_width = 120 })
              local git           = MiniStatusline.section_git({ trunc_width = 40 })
              local diff          = MiniStatusline.section_diff({ trunc_width = 75 })
              local diagnostics   = MiniStatusline.section_diagnostics({ trunc_width = 75 })
              local lsp           = MiniStatusline.section_lsp({ trunc_width = 75 })
              local filename      = MiniStatusline.section_filename({ trunc_width = 140 })
              local fileinfo      = MiniStatusline.section_fileinfo({ trunc_width = 120 })
              local location      = MiniStatusline.section_location({ trunc_width = 75 })
              local search        = MiniStatusline.section_searchcount({ trunc_width = 75 })
      
              -- this if statement is the only non-default thing in here
              if DEBUG_MODE ~= nil and DEBUG_MODE:active() then
                mode = "DEBUG"
                mode_hl = "Substitute"
              end
      
              return MiniStatusline.combine_groups({
                { hl = mode_hl,                  strings = { mode } },
                { hl = 'MiniStatuslineDevinfo',  strings = { git, diff, diagnostics, lsp } },
                '%<', -- Mark general truncate point
                { hl = 'MiniStatuslineFilename', strings = { filename } },
                '%=', -- End left alignment
                { hl = 'MiniStatuslineFileinfo', strings = { fileinfo } },
                { hl = mode_hl,                  strings = { search, location } },
              })
            end
          },
        },
      },
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-keymap.md",
  },
  {
    "notomo/gesture.nvim",
    config = function()
      
      vim.opt.mouse = "a"
      vim.opt.mousemoveevent = true
      
      vim.keymap.set("n", "<LeftDrag>", [[<Cmd>lua require("gesture").draw()<CR>]], { silent = true })
      vim.keymap.set("n", "<LeftRelease>", [[<Cmd>lua require("gesture").finish()<CR>]], { silent = true })
      
      -- or if you would like to use right click
      vim.keymap.set("n", "<RightMouse>", [[<Nop>]])
      vim.keymap.set("n", "<RightDrag>", [[<Cmd>lua require("gesture").draw()<CR>]], { silent = true })
      vim.keymap.set("n", "<RightRelease>", [[<Cmd>lua require("gesture").finish()<CR>]], { silent = true })
      
      local gesture = require("gesture")
      gesture.register({
        name = "scroll to bottom",
        inputs = { gesture.up(), gesture.down() },
        action = "normal! G",
      })
      gesture.register({
        name = "next tab",
        inputs = { gesture.right() },
        action = "tabnext",
      })
      gesture.register({
        name = "previous tab",
        inputs = { gesture.left() },
        action = function(_) -- also can use callable
          vim.cmd.tabprevious()
        end,
      })
      gesture.register({
        name = "go back",
        inputs = { gesture.right(), gesture.left() },
        -- map to `<C-o>` keycode
        action = function()
          vim.api.nvim_feedkeys(vim.keycode("<C-o>"), "n", true)
        end,
      })
      gesture.register({
        name = "close gesture traced windows",
        match = function(ctx)
          local last_input = ctx.inputs[#ctx.inputs]
          return last_input and last_input.direction == "UP"
        end,
        can_match = function(ctx)
          local first_input = ctx.inputs[1]
          return first_input and first_input.direction == "RIGHT"
        end,
        action = function(ctx)
          table.sort(ctx.window_ids, function(a, b)
            return a > b
          end)
          for _, window_id in ipairs(ctx.window_ids) do
            if vim.api.nvim_win_is_valid(window_id) then
              vim.api.nvim_win_close(window_id, false)
            end
          end
        end,
      })
      
    end,
  },
  {
    "karb94/neoscroll.nvim",
    config = function()
      
          return {
            "karb94/neoscroll.nvim",
            opts = {},
          }
          
      
      require('neoscroll').setup({
        mappings = {                 -- Keys to be mapped to their corresponding default scrolling animation
          '<C-u>', '<C-d>',
          '<C-b>', '<C-f>',
          '<C-y>', '<C-e>',
          'zt', 'zz', 'zb',
        },
        hide_cursor = true,          -- Hide cursor while scrolling
        stop_eof = true,             -- Stop at <EOF> when scrolling downwards
        respect_scrolloff = false,   -- Stop scrolling when the cursor reaches the scrolloff margin of the file
        cursor_scrolls_alone = true, -- The cursor will keep on scrolling even if the window cannot scroll further
        duration_multiplier = 1.0,   -- Global duration multiplier
        easing = 'linear',           -- Default easing function
        pre_hook = nil,              -- Function to run before the scrolling animation starts
        post_hook = nil,             -- Function to run after the scrolling animation ends
        performance_mode = false,    -- Disable "Performance Mode" on all buffers.
        ignored_events = {           -- Events ignored while scrolling
            'WinScrolled', 'CursorMoved'
        },
      })
      
      
      require('neoscroll').setup({ mappings = {'<C-u>', '<C-d>', '<C-b>', '<C-f>'} })
      
      
      require('neoscroll').setup({ mappings = {} })
      
      
      neoscroll = require('neoscroll')
      local keymap = {
        ["<C-u>"] = function() neoscroll.ctrl_u({ duration = 250 }) end;
        ["<C-d>"] = function() neoscroll.ctrl_d({ duration = 250 }) end;
        ["<C-b>"] = function() neoscroll.ctrl_b({ duration = 450 }) end;
        ["<C-f>"] = function() neoscroll.ctrl_f({ duration = 450 }) end;
        ["<C-y>"] = function() neoscroll.scroll(-0.1, { move_cursor=false; duration = 100 }) end;
        ["<C-e>"] = function() neoscroll.scroll(0.1, { move_cursor=false; duration = 100 }) end;
        ["zt"]    = function() neoscroll.zt({ half_win_duration = 250 }) end;
        ["zz"]    = function() neoscroll.zz({ half_win_duration = 250 }) end;
        ["zb"]    = function() neoscroll.zb({ half_win_duration = 250 }) end;
      }
      local modes = { 'n', 'v', 'x' }
      for key, func in pairs(keymap) do
        vim.keymap.set(modes, key, func)
      end
      
      
      neoscroll = require('neoscroll')
      neoscroll.setup({
        -- Default easing function used in any animation where
        -- the `easing` argument has not been explicitly supplied
        easing = "quadratic"
      })
      local keymap = {
        -- Use the "sine" easing function
        ["<C-u>"] = function() neoscroll.ctrl_u({ duration = 250; easing = 'sine' }) end;
        ["<C-d>"] = function() neoscroll.ctrl_d({ duration = 250; easing = 'sine' }) end;
        -- Use the "circular" easing function
        ["<C-b>"] = function() neoscroll.ctrl_b({ duration = 450; easing = 'circular' }) end;
        ["<C-f>"] = function() neoscroll.ctrl_f({ duration = 450; easing = 'circular' }) end;
        -- When no value is passed the `easing` option supplied in `setup()` is used
        ["<C-y>"] = function() neoscroll.scroll(-0.1, { move_cursor=false; duration = 100 }) end;
        ["<C-e>"] = function() neoscroll.scroll(0.1, { move_cursor=false; duration = 100 }) end;
      }
      local modes = { 'n', 'v', 'x' }
      for key, func in pairs(keymap) do
          vim.keymap.set(modes, key, func)
      end
      
      
      require('neoscroll').setup({
        pre_hook = function(info) if info == "cursorline" then vim.wo.cursorline = false end end,
        post_hook = function(info) if info == "cursorline" then vim.wo.cursorline = true end end
      })
      local keymap = {
        ["<C-u>"] = function() neoscroll.ctrl_u({ duration = 250; info = 'cursorline' }) end;
        ["<C-d>"] = function() neoscroll.ctrl_d({ duration = 250; info = 'cursorline' }) end;
      }
      local modes = { 'n', 'v', 'x' }
      for key, func in pairs(keymap) do
        vim.keymap.set(modes, key, func)
      end
      
    end,
  },
  {
    "declancm/cinnamon.nvim",
    config = function()
      
      {
        "declancm/cinnamon.nvim",
        version = "*", -- use latest release
        opts = {
          -- change default options here
        },
      }
      
      
      ---@class CinnamonOptions
      return {
          -- Disable the plugin
          disabled = false,
      
          keymaps = {
              -- Enable the provided 'basic' keymaps
              basic = false,
              -- Enable the provided 'extra' keymaps
              extra = false,
          },
          
          ---@class ScrollOptions
          options = {
              -- The scrolling mode
              -- `cursor`: animate cursor and window scrolling for any movement
              -- `window`: animate window scrolling ONLY when the cursor moves out of view
              mode = "cursor",
      
              -- Only animate scrolling if a count is provided
              count_only = false,
      
              -- Delay between each movement step (in ms)
              delay = 5,
      
              max_delta = {
                  -- Maximum distance for line movements before scroll
                  -- animation is skipped. Set to `false` to disable
                  line = false,
                  -- Maximum distance for column movements before scroll
                  -- animation is skipped. Set to `false` to disable
                  column = false,
                  -- Maximum duration for a movement (in ms). Automatically scales the
                  -- delay and step size
                  time = 1000,
              },
      
              step_size = {
                  -- Number of cursor/window lines moved per step
                  vertical = 1,
                  -- Number of cursor/window columns moved per step
                  horizontal = 2,
              },
      
              -- Optional post-movement callback. Not called if the movement is interrupted
              callback = function() end,
          },
      }
      
      
      require("cinnamon").setup {
          -- Enable all provided keymaps
          keymaps = {
              basic = true,
              extra = true,
          },
          -- Only scroll the window
          options = { mode = "window" },
      }
      
      
          require("cinnamon").scroll("<C-]>")
          
      
          require("cinnamon").scroll(":keepjumps normal! <C-]>")
          
      
          require("cinnamon").scroll(function()
              vim.lsp.buf.definition({ loclist = true })
          end)
          
      
          require("cinnamon").scroll("<C-]>", { mode = "window" })
          
      
      local cinnamon = require("cinnamon")
      
      cinnamon.setup()
      
      -- Centered scrolling:
      vim.keymap.set("n", "<C-U>", function() cinnamon.scroll("<C-U>zz") end)
      vim.keymap.set("n", "<C-D>", function() cinnamon.scroll("<C-D>zz") end)
      
      -- LSP:
      vim.keymap.set("n", "gd", function() cinnamon.scroll(vim.lsp.buf.definition) end)
      vim.keymap.set("n", "gD", function() cinnamon.scroll(vim.lsp.buf.declaration) end)
      
      -- Flash.nvim integration:
      local flash = require("flash")
      local jump = require("flash.jump")
      
      flash.setup({
        action = function(match, state)
          cinnamon.scroll(function()
            jump.jump(match, state)
            jump.on_jump(state)
          end)
        end,
      })
      
      
      -- Disable scrolling for help buffers
      vim.api.nvim_create_autocmd("FileType", {
          pattern = "help",
          callback = function() vim.b.cinnamon_disable = true end,
      })
      
    end,
  },
  {
    "nkakouros-original/scrollofffraction.nvim",
    config = function()
      
      {
        'nkakouros-original/scrollofffraction.nvim',
        lazy = true
      }
      
      
      use {
        'nkakouros-original/scrollofffraction.nvim',
        config = function()
          require('scrollofffraction.nvim').setup()
        end
      }
      
      
      require('scrollofffraction.nvim').setup({
        -- Configuration options
      })
      
      
      {
        'nkakouros-original/scrollofffraction.nvim',
        lazy = true,
        opts = {
          -- Configuration options
        }
      }
      
      
      require('scrollofffraction.nvim').setup({
        scrolloff_fraction = 0.3,
        scrolloff_absolute_filetypes = { 'qf', 'markdown' },
        scrolloff_absolute_value = 5
      })
      
    end,
  },
  {
    "niuiic/scroll.nvim",
    config = function()
      
      local keys = {
      	{
      		"<C-d>",
      		function()
      			local screen_h = vim.opt.lines:get() - vim.opt.cmdheight:get()
      			local target_lnum = vim.api.nvim_win_get_cursor(0)[1] + screen_h / 2
      			local step = screen_h / 2 / 50
      			step = step >= 1 and step or 1
      
      			require("scroll").scroll(target_lnum, function(current_line, target_line)
      				local fold_end = vim.fn.foldclosedend(current_line)
      
      				-- if current_line is not in a fold
      				if fold_end < 0 then
      					return {
      						-- cursor position in next step
      						next_line = current_line + step,
      						-- delay 10ms for next step
      						delay = 10,
      					}
      				end
      
      				local fold_start = vim.fn.foldclosed(current_line)
      
      				return {
      					next_line = fold_end + 1,
      					delay = 10,
      					-- when current_line is in a fold, you may want to regard it as one line, then you need to change the target_line
      					target_line = target_line + fold_end - fold_start,
      				}
      			end)
      		end,
      		desc = "scroll down",
      		mode = { "n", "x" },
      	},
      	{
      		"<C-u>",
      		function()
      			local screen_h = vim.opt.lines:get() - vim.opt.cmdheight:get()
      			local target_lnum = vim.api.nvim_win_get_cursor(0)[1] - screen_h / 2
      			local step = screen_h / 2 / 50
      			if step < 1 then
      				step = 1
      			end
      
      			require("scroll").scroll(target_lnum, function(current_line, target_line)
      				local fold_end = vim.fn.foldclosedend(current_line)
      				if fold_end > 0 then
      					local fold_start = vim.fn.foldclosed(current_line)
      
      					return {
      						next_line = fold_start - 1,
      						delay = 10,
      						target_line = target_line - fold_end + fold_start,
      					}
      				end
      
      				return {
      					next_line = current_line - step,
      					delay = 10,
      				}
      			end)
      		end,
      		desc = "scroll up",
      		mode = { "n", "x" },
      	},
      }
      
    end,
  },
  {
    "rlychrisg/keepcursor.nvim",
    config = function()
      
      {"rlychrisg/keepcursor.nvim"},
      
      
          {
              "rlychrisg/keepcursor.nvim",
              opts = {
                      enabled_on_start_v = "none", -- options are "top", "middle" and "bottom".
                      enabled_on_start_h = "none" -- options are "left" and "right".
                  }
          },
      
      
      vim.api.nvim_set_keymap('n', '<leader>zt', ':ToggleCursorTop<CR>',
      { noremap = true, silent = true, desc = "KeepCursor: keep cursor positioned at top on cursor move" })
      
      vim.api.nvim_set_keymap('n', '<leader>zb', ':ToggleCursorBot 2<CR>', -- optional argument, temporarily sets scroll off to 2
      { noremap = true, silent = true, desc = "KeepCursor: keep cursor positioned at bottom on cursor move" })
      
      vim.api.nvim_set_keymap('n', '<leader>zz', ':ToggleCursorMid<CR>',
      { noremap = true, silent = true, desc = "KeepCursor: keep cursor positioned at middle on cursor move" })
      
      vim.api.nvim_set_keymap('n', '<leader>ze', ':ToggleCursorRight 30<CR>', -- optional argument, temporarily sets side scroll off to 30
      { noremap = true, silent = true, desc = "KeepCursor: keep cursor positioned to the right on cursor move" })
      
      vim.api.nvim_set_keymap('n', '<leader>zs', ':ToggleCursorLeft<CR>',
      { noremap = true, silent = true, desc = "KeepCursor: keep cursor positioned to the left on cursor move" })
      
      
      
      require('lualine').setup {
          sections = {
              lualine_a = {'mode'},
              lualine_b = {'branch', 'diff', 'diagnostics'},
              lualine_c = {},
              lualine_x = {
                  'encoding', 'fileformat', 'filetype',
                  -- if adding options, create a new lua table within the lualine_x table
                  {
                      require('keepcursor').KeepCursorStatus,
                      color = { fg = 'Normal' },
                      cond = function ()
                          -- this is a variable used inside keepcursor to track the state of currently enabled functions
                          if _G.KeepCursorAt ~= nil then
                              return true
                          end
                      end
                  }
              },
              lualine_y = {'progress'},
              lualine_z = {'location'}
          },
      }
      
      
    end,
  },
  {
    "Xuyuanp/scrollbar.nvim",
    config = function()
      
      {
          'Xuyuanp/scrollbar.nvim',
          -- no setup required
          init = function()
              local group_id = vim.api.nvim_create_augroup('scrollbar_init', { clear = true })
      
              vim.api.nvim_create_autocmd({ 'BufEnter', 'WinScrolled', 'WinResized' }, {
                  group = group_id,
                  desc = 'Show or refresh scrollbar',
                  pattern = { '*' },
                  callback = function()
                      require('scrollbar').show()
                  end,
              })
          end,
      },
      
    end,
  },
  {
    "dstein64/nvim-scrollview",
    config = function()
      
      require('scrollview').setup({
        excluded_filetypes = {'nerdtree'},
        current_only = true,
        base = 'buffer',
        column = 80,
        signs_on_startup = {'all'},
        diagnostics_severities = {vim.diagnostic.severity.ERROR}
      })
      
      
      vim.g.scrollview_excluded_filetypes = {'nerdtree'},
      vim.g.scrollview_current_only = true,
      vim.g.scrollview_base = 'buffer',
      vim.g.scrollview_column = 80,
      vim.g.scrollview_signs_on_startup = {'all'},
      vim.g.scrollview_diagnostics_severities = {vim.diagnostic.severity.ERROR}
      
    end,
  },
  {
    "petertriho/nvim-scrollbar",
    config = function()
      
      use("petertriho/nvim-scrollbar")
      
      
      require("scrollbar").setup()
      
      
      
      use {
        "kevinhwang91/nvim-hlslens",
        config = function()
          -- require('hlslens').setup() is not required
          require("scrollbar.handlers.search").setup({
              -- hlslens config overrides
          })
        end,
      }
      
      
      use {
        "kevinhwang91/nvim-hlslens",
        config = function()
          require("hlslens").setup({
             build_position_cb = function(plist, _, _, _)
                  require("scrollbar.handlers.search").handler.show(plist.start_pos)
             end,
          })
      
          vim.cmd([[
              augroup scrollbar_search_hide
                  autocmd!
                  autocmd CmdlineLeave : lua require('scrollbar.handlers.search').handler.hide()
              augroup END
          ]])
        end,
      }
      
      
      require("scrollbar.handlers.search").setup({
          override_lens = function() end,
      })
      
      
      use {
        "lewis6991/gitsigns.nvim",
        config = function()
          require('gitsigns').setup()
          require("scrollbar.handlers.gitsigns").setup()
        end
      }
      
      
      require("scrollbar").setup({
          show = true,
          show_in_active_only = false,
          set_highlights = true,
          folds = 1000, -- handle folds, set to number to disable folds if no. of lines in buffer exceeds this
          max_lines = false, -- disables if no. of lines in buffer exceeds this
          hide_if_all_visible = false, -- Hides everything if all lines are visible
          throttle_ms = 100,
          handle = {
              text = " ",
              blend = 30, -- Integer between 0 and 100. 0 for fully opaque and 100 to full transparent. Defaults to 30.
              color = nil,
              color_nr = nil, -- cterm
              highlight = "CursorColumn",
              hide_if_all_visible = true, -- Hides handle if all lines are visible
          },
          marks = {
              Cursor = {
                  text = "•",
                  priority = 0,
                  gui = nil,
                  color = nil,
                  cterm = nil,
                  color_nr = nil, -- cterm
                  highlight = "Normal",
              },
              Search = {
                  text = { "-", "=" },
                  priority = 1,
                  gui = nil,
                  color = nil,
                  cterm = nil,
                  color_nr = nil, -- cterm
                  highlight = "Search",
              },
              Error = {
                  text = { "-", "=" },
                  priority = 2,
                  gui = nil,
                  color = nil,
                  cterm = nil,
                  color_nr = nil, -- cterm
                  highlight = "DiagnosticVirtualTextError",
              },
              Warn = {
                  text = { "-", "=" },
                  priority = 3,
                  gui = nil,
                  color = nil,
                  cterm = nil,
                  color_nr = nil, -- cterm
                  highlight = "DiagnosticVirtualTextWarn",
              },
              Info = {
                  text = { "-", "=" },
                  priority = 4,
                  gui = nil,
                  color = nil,
                  cterm = nil,
                  color_nr = nil, -- cterm
                  highlight = "DiagnosticVirtualTextInfo",
              },
              Hint = {
                  text = { "-", "=" },
                  priority = 5,
                  gui = nil,
                  color = nil,
                  cterm = nil,
                  color_nr = nil, -- cterm
                  highlight = "DiagnosticVirtualTextHint",
              },
              Misc = {
                  text = { "-", "=" },
                  priority = 6,
                  gui = nil,
                  color = nil,
                  cterm = nil,
                  color_nr = nil, -- cterm
                  highlight = "Normal",
              },
              GitAdd = {
                  text = "┆",
                  priority = 7,
                  gui = nil,
                  color = nil,
                  cterm = nil,
                  color_nr = nil, -- cterm
                  highlight = "GitSignsAdd",
              },
              GitChange = {
                  text = "┆",
                  priority = 7,
                  gui = nil,
                  color = nil,
                  cterm = nil,
                  color_nr = nil, -- cterm
                  highlight = "GitSignsChange",
              },
              GitDelete = {
                  text = "▁",
                  priority = 7,
                  gui = nil,
                  color = nil,
                  cterm = nil,
                  color_nr = nil, -- cterm
                  highlight = "GitSignsDelete",
              },
          },
          excluded_buftypes = {
              "terminal",
          },
          excluded_filetypes = {
              "blink-cmp-menu",
              "dropbar_menu",
              "dropbar_menu_fzf",
              "DressingInput",
              "cmp_docs",
              "cmp_menu",
              "noice",
              "prompt",
              "TelescopePrompt",
          },
          autocmd = {
              render = {
                  "BufWinEnter",
                  "TabEnter",
                  "TermEnter",
                  "WinEnter",
                  "CmdwinLeave",
                  "TextChanged",
                  "VimResized",
                  "WinScrolled",
              },
              clear = {
                  "BufWinLeave",
                  "TabLeave",
                  "TermLeave",
                  "WinLeave",
              },
          },
          handlers = {
              cursor = true,
              diagnostic = true,
              gitsigns = false, -- Requires gitsigns
              handle = true,
              search = false, -- Requires hlslens
              ale = false, -- Requires ALE
          },
      })
      
      
      local colors = require("tokyonight.colors").setup()
      
      require("scrollbar").setup({
          handle = {
              color = colors.bg_highlight,
          },
          marks = {
              Search = { color = colors.orange },
              Error = { color = colors.error },
              Warn = { color = colors.warning },
              Info = { color = colors.info },
              Hint = { color = colors.hint },
              Misc = { color = colors.purple },
          }
      })
      
      
      require("scrollbar.handlers").register(name, handler_function)
      
      
      require("scrollbar.handlers").register("my_marks", function(bufnr)
          return {
              { line = 0 },
              { line = 1, text = "x", type = "Warn" },
              { line = 2, type = "Error" }
          }
      end)
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-map.md",
  },
  {
    "gorbit99/codewindow.nvim",
    config = function()
      
      use {
        'gorbit99/codewindow.nvim',
        config = function()
          local codewindow = require('codewindow')
          codewindow.setup()
          codewindow.apply_default_keybinds()
        end,
      }
      
      
      {
        active_in_terminals = false, -- Should the minimap activate for terminal buffers
        auto_enable = false, -- Automatically open the minimap when entering a (non-excluded) buffer (accepts a table of filetypes)
        exclude_filetypes = { 'help' }, -- Choose certain filetypes to not show minimap on
        max_minimap_height = nil, -- The maximum height the minimap can take (including borders)
        max_lines = nil, -- If auto_enable is true, don't open the minimap for buffers which have more than this many lines.
        minimap_width = 20, -- The width of the text part of the minimap
        use_lsp = true, -- Use the builtin LSP to show errors and warnings
        use_treesitter = true, -- Use nvim-treesitter to highlight the code
        use_git = true, -- Show small dots to indicate git additions and deletions
        width_multiplier = 4, -- How many characters one dot represents
        z_index = 1, -- The z-index the floating window will be on
        show_cursor = true, -- Show the cursor position in the minimap
        screen_bounds = 'lines' -- How the visible area is displayed, "lines": lines above and below, "background": background color
        window_border = 'single' -- The border style of the floating window (accepts all usual options)
        relative = 'win' -- What will be the minimap be placed relative to, "win": the current window, "editor": the entire editor
        events = { 'TextChanged', 'InsertLeave', 'DiagnosticChanged', 'FileWritePost' } -- Events that update the code window
      }
      
      
      codewindow.open_minimap()
      codewindow.close_minimap()
      codewindow.toggle_minimap()
      codewindow.toggle_focus()
      
      
      CodewindowBorder -- the border highlight
      CodewindowBackground -- the background highlight
      CodewindowWarn -- the color of the warning dots
      CodewindowError -- the color of the error dots
      CodewindowAddition -- the color of the addition git sign
      CodewindowDeletion -- the color of the deletion git sign
      CodewindowUnderline -- the color of the underlines on the minimap
      CodewindowBoundsBackground -- the color of the background on the minimap
      
      -- Example
      vim.api.nvim_set_hl(0, 'CodewindowBorder', {fg = '#ffff00'})
      
    end,
  },
  {
    "lewis6991/satellite.nvim",
    config = function()
      
      require('satellite').setup {
        current_only = false,
        winblend = 50,
        zindex = 40,
        excluded_filetypes = {},
        width = 2,
        handlers = {
          cursor = {
            enable = true,
            -- Supports any number of symbols
            symbols = { '⎺', '⎻', '⎼', '⎽' }
            -- symbols = { '⎻', '⎼' }
            -- Highlights:
            -- - SatelliteCursor (default links to NonText
          },
          search = {
            enable = true,
            -- Highlights:
            -- - SatelliteSearch (default links to Search)
            -- - SatelliteSearchCurrent (default links to SearchCurrent)
          },
          diagnostic = {
            enable = true,
            signs = {'-', '=', '≡'},
            min_severity = vim.diagnostic.severity.HINT,
            -- Highlights:
            -- - SatelliteDiagnosticError (default links to DiagnosticError)
            -- - SatelliteDiagnosticWarn (default links to DiagnosticWarn)
            -- - SatelliteDiagnosticInfo (default links to DiagnosticInfo)
            -- - SatelliteDiagnosticHint (default links to DiagnosticHint)
          },
          gitsigns = {
            enable = true,
            signs = { -- can only be a single character (multibyte is okay)
              add = "│",
              change = "│",
              delete = "-",
            },
            -- Highlights:
            -- SatelliteGitSignsAdd (default links to GitSignsAdd)
            -- SatelliteGitSignsChange (default links to GitSignsChange)
            -- SatelliteGitSignsDelete (default links to GitSignsDelete)
          },
          marks = {
            enable = true,
            show_builtins = false, -- shows the builtin marks like [ ] < >
            key = 'm'
            -- Highlights:
            -- SatelliteMark (default links to Normal)
          },
          quickfix = {
            signs = { '-', '=', '≡' },
            -- Highlights:
            -- SatelliteQuickfix (default links to WarningMsg)
          }
        },
      }
      
    end,
  },
  {
    "TheLazyCat00/replace-nvim",
    config = function()
      
      return {
          "TheLazyCat00/replace-nvim",
          opts = {},
          keys = {
              {
                  "t",
                  function() return require('replace-nvim').replace(true) end,
                  mode = { "n", "x" },
                  expr = true, -- ⚠️ set expr to true
                  desc = "Replace with clipboard",
              },
          },
      }
      
    end,
  },
  {
    "wurli/split.nvim",
  },
  {
    "csessh/stopinsert.nvim",
    config = function()
      
      -- lazy.nvim
      {
          "csessh/stopinsert.nvim",
          event = { "InsertEnter" }, -- lazy load
          dependencies = {
              -- "hrsh7th/nvim-cmp",
              "saghen/blink.cmp",
          },
          opts = {
              -- Configuration options (see Configuration section below for details)
              idle_time_ms = 5000, -- Maximum time (in milliseconds) before you are forced out of Insert mode
              show_popup_msg = true, -- Enable/disable popup message
              clear_popup_ms = 5000, -- Maximum time (in milliseconds) for which the popup message hangs around
              disabled_filetypes = { -- List of filetypes to exclude the effect of this plugin.
                  "TelescopePrompt",
                  "checkhealth",
                  "help",
                  "lspinfo",
                  "mason",
                  "neo%-tree*",
              },
              guard_func = function() -- Optional function that returns a boolean. If true, prevents stopinsert.
                -- return require('cmp').visible_docs()
                return require("blink.cmp").is_documentation_visible()
              end,
          }
      },
      
      
      require("stopinsert").setup()
      
    end,
  },
  {
    "windwp/nvim-ts-autotag",
    config = function()
      
      require('nvim-ts-autotag').setup({
        opts = {
          -- Defaults
          enable_close = true, -- Auto close tags
          enable_rename = true, -- Auto rename pairs of tags
          enable_close_on_slash = false -- Auto close on trailing </
        },
        -- Also override individual filetype configs, these take priority.
        -- Empty by default, useful if one of the "opts" global settings
        -- doesn't work well in a specific filetype
        per_filetype = {
          ["html"] = {
            enable_close = false
          }
        }
      })
      
      
      require('nvim-ts-autotag').setup({
        aliases = {
          ["your language here"] = "html",
        }
      })
      
      -- or
      local TagConfigs = require("nvim-ts-autotag.config.init")
      TagConfigs:add_alias("your language here", "html")
      
      
      local TagConfigs = require("nvim-ts-autotag.config.init")
      TagConfigs:update(TagConfigs:get("xml"):override("xml", {
          start_tag_pattern = { "STag" },
          end_tag_pattern = { "ETag" },
      }))
      
      
      vim.lsp.handlers['textDocument/publishDiagnostics'] = vim.lsp.with(
          vim.lsp.diagnostic.on_publish_diagnostics,
          {
              underline = true,
              virtual_text = {
                  spacing = 5,
                  severity_limit = 'Warning',
              },
              update_in_insert = true,
          }
      )
      
    end,
  },
  {
    "windwp/nvim-autopairs",
    config = function()
      
      {
          'windwp/nvim-autopairs',
          event = "InsertEnter",
          config = true
          -- use opts = {} for passing setup options
          -- this is equivalent to setup({}) function
      }
      
      
      use {
          "windwp/nvim-autopairs",
          event = "InsertEnter",
          config = function()
              require("nvim-autopairs").setup {}
          end
      }
      
      
      local handlers = require('nvim-autopairs.completion.handlers')
      
      cmp.event:on(
        'confirm_done',
        cmp_autopairs.on_confirm_done({
          filetypes = {
            -- "*" is a alias to all filetypes
            ["*"] = {
              ["("] = {
                kind = {
                  cmp.lsp.CompletionItemKind.Function,
                  cmp.lsp.CompletionItemKind.Method,
                },
                handler = handlers["*"]
              }
            },
            lua = {
              ["("] = {
                kind = {
                  cmp.lsp.CompletionItemKind.Function,
                  cmp.lsp.CompletionItemKind.Method
                },
                ---@param char string
                ---@param item table item completion
                ---@param bufnr number buffer number
                ---@param rules table
                ---@param commit_character table<string>
                handler = function(char, item, bufnr, rules, commit_character)
                  -- Your handler function. Inspect with print(vim.inspect{char, item, bufnr, rules, commit_character})
                end
              }
            },
            -- Disable for tex
            tex = false
          }
        })
      )
      
      
      -- add option map_cr
      npairs.setup({ map_cr = true })
      
      
      local npairs = require("nvim-autopairs")
      local Rule = require('nvim-autopairs.rule')
      
      npairs.setup({
          check_ts = true,
          ts_config = {
              lua = {'string'},-- it will not add a pair on that treesitter node
              javascript = {'template_string'},
              java = false,-- don't check treesitter on java
          }
      })
      
      local ts_conds = require('nvim-autopairs.ts-conds')
      
      
      -- press % => %% only while inside a comment or string
      npairs.add_rules({
        Rule("%", "%", "lua")
          :with_pair(ts_conds.is_ts_node({'string','comment'})),
        Rule("$", "$", "lua")
          :with_pair(ts_conds.is_not_ts_node({'function'}))
      })
      
      
      -- remove add single quote on filetype scheme or lisp
      require("nvim-autopairs").get_rules("'")[1].not_filetypes = { "scheme", "lisp" }
      require("nvim-autopairs").get_rules("'")[1]:with_pair(cond.not_after_text("["))
      
      
      -- put this to setup function and press <a-e> to use fast_wrap
      npairs.setup({
          fast_wrap = {},
      })
      
      -- change default fast_wrap
      npairs.setup({
          fast_wrap = {
            map = '<M-e>',
            chars = { '{', '[', '(', '"', "'" },
            pattern = [=[[%'%"%>%]%)%}%,]]=],
            end_key = '$',
            before_key = 'h',
            after_key = 'l',
            cursor_pos_before = true,
            keys = 'qwertyuiopzxcvbnmasdfghjkl',
            manual_position = true,
            highlight = 'Search',
            highlight_grey='Comment'
          },
      })
      
    end,
  },
  {
    "ZhiyuanLck/smart-pairs",
    config = function()
      
      use {'ZhiyuanLck/smart-pairs', event = 'InsertEnter', config = function() require('pairs'):setup() end}
      
      
        pairs = {
          ['*'] = {
            {'(', ')'},
            {'[', ']'},
            {'{', '}'},
            {"'", "'"},
            {'"', '"'},
          },
          lua = {
            {'(', ')', {ignore = {'%(', '%)', '%%'}}},
            {'[', ']', {ignore = {'%[', '%]', '%%'}}},
            {'{', '}', {ignore = {'%{', '%}', '%%'}}},
          },
          python = {
            {"'", "'", {triplet = true}},
            {'"', '"', {triplet = true}},
          },
          markdown = {
            {'`', '`', {triplet = true}},
          },
          tex = {
            {'$', '$', {cross_line = true}},
            -- Chinese pairs
            {'（', '）'},
            {'【', '】'},
            {'‘', '’'},
            {'“', '”'},
          }
        }
      
      
        default_opts = {
          ['*'] = {
            ignore_pre = '\\\\', -- double backslash or [[\\]]
            ignore_after = '\\w', -- double backslash or [[\w]]
          },
          lua = {
            ignore_pre = '[%\\\\]' -- double backslash
          }
        },
      
      
      opts = {
        key = string, key to be searched
        out = boolean, jump to the outside or inside of the key
      }
      
      
        indent = {
          ['*'] = 1,
          python = 2,
        }
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-pairs.md",
  },
  {
    "m4xshen/autoclose.nvim",
  },
  {
    "altermo/ultimate-autopair.nvim",
    config = function()
      
      {
          'altermo/ultimate-autopair.nvim',
          event={'InsertEnter','CmdlineEnter'},
          branch='v0.6', --recommended as each new version will have breaking changes
          opts={
              --Config goes here
          },
      }
      
      
      use{
          'altermo/ultimate-autopair.nvim',
          event={'InsertEnter','CmdlineEnter'},
          branch='v0.6', --recommended as each new version will have breaking changes
          config=function ()
              require('ultimate-autopair').setup({
                      --Config goes here
                      })
          end,
      }
      
    end,
  },
  {
    "utilyre/sentiment.nvim",
    config = function()
      
          {
            "utilyre/sentiment.nvim",
            version = "*",
            event = "VeryLazy", -- keep for lazy loading
            opts = {
              -- config
            },
            init = function()
              -- `matchparen.vim` needs to be disabled manually in case of lazy loading
              vim.g.loaded_matchparen = 1
            end,
          }
          
      
          use({
            "utilyre/sentiment.nvim",
            tag = "*",
            config = function()
              require("sentiment").setup({
                -- config
              })
            end,
          })
          
      
      {
        ---Dictionary to check whether a buftype should be included.
        ---
        ---@type table<string, boolean>
        included_buftypes = {
          [""] = true,
        },
      
        ---Dictionary to check whether a filetype should be excluded.
        ---
        ---@type table<string, boolean>
        excluded_filetypes = {},
      
        ---Dictionary to check whether a mode should be included.
        ---
        ---@type table<string, boolean>
        included_modes = {
          n = true,
          i = true,
        },
      
        ---How much (in milliseconds) should the cursor stay still to calculate and
        ---render a pair.
        ---
        ---NOTE: It's recommended to set this somewhere above and close to your key
        ---repeat speed in order to keep the calculations at minimum.
        ---
        ---@type integer
        delay = 50,
      
        ---How many lines to look backwards/forwards to find a pair.
        ---
        ---@type integer
        limit = 100,
      
        ---List of `(left, right)` pairs.
        ---
        ---NOTE: Both sides of a pair can't have the same character.
        ---
        ---@type tuple<string, string>[]
        pairs = {
          { "(", ")" },
          { "{", "}" },
          { "[", "]" },
        },
      }
      
    end,
  },
  {
    "monaqa/dial.nvim",
    config = function()
      
      vim.keymap.set("n", "<C-a>", function()
          require("dial.map").manipulate("increment", "normal")
      end)
      vim.keymap.set("n", "<C-x>", function()
          require("dial.map").manipulate("decrement", "normal")
      end)
      vim.keymap.set("n", "g<C-a>", function()
          require("dial.map").manipulate("increment", "gnormal")
      end)
      vim.keymap.set("n", "g<C-x>", function()
          require("dial.map").manipulate("decrement", "gnormal")
      end)
      vim.keymap.set("x", "<C-a>", function()
          require("dial.map").manipulate("increment", "visual")
      end)
      vim.keymap.set("x", "<C-x>", function()
          require("dial.map").manipulate("decrement", "visual")
      end)
      vim.keymap.set("x", "g<C-a>", function()
          require("dial.map").manipulate("increment", "gvisual")
      end)
      vim.keymap.set("x", "g<C-x>", function()
          require("dial.map").manipulate("decrement", "gvisual")
      end)
      
      
      local augend = require("dial.augend")
      require("dial.config").augends:register_group{
        -- default augends used when no group name is specified
        default = {
          augend.integer.alias.decimal,   -- nonnegative decimal number (0, 1, 2, 3, ...)
          augend.integer.alias.hex,       -- nonnegative hex number  (0x01, 0x1a1f, etc.)
          augend.date.alias["%Y/%m/%d"],  -- date (2022/02/19, etc.)
        },
      
        -- augends used when group with name `mygroup` is specified
        mygroup = {
          augend.integer.alias.decimal,
          augend.constant.alias.bool,    -- boolean value (true <-> false)
          augend.date.alias["%m/%d/%Y"], -- date (02/19/2022, etc.)
        }
      }
      
      
      vim.keymap.set("n", "<Leader>a", require("dial.map").inc_normal("mygroup"))
      
      
      local augend = require("dial.augend")
      require("dial.config").augends:register_group{
        default = {
          augend.integer.alias.decimal,
          augend.integer.alias.hex,
          augend.date.alias["%Y/%m/%d"],
        },
        only_in_visual = {
          augend.integer.alias.decimal,
          augend.integer.alias.hex,
          augend.date.alias["%Y/%m/%d"],
          augend.constant.alias.alpha,
          augend.constant.alias.Alpha,
        },
      }
      
      -- Use `only_in_visual` group only in VISUAL <C-a> / <C-x>
      vim.keymap.set("x", "<C-a>", function()
          require("dial.map").manipulate("increment", "visual", "only_in_visual")
      end)
      vim.keymap.set("x", "<C-x>", function()
          require("dial.map").manipulate("decrement", "visual", "only_in_visual")
      end)
      
      require("dial.config").augends:on_filetype {
        typescript = {
          augend.integer.alias.decimal,
          augend.integer.alias.hex,
          augend.constant.new{ elements = {"let", "const"} },
        },
      }
      
      
      local augend = require("dial.augend")
      
      
      require("dial.config").augends:register_group{
        default = {
          -- uppercase hex number (0x1A1A, 0xEEFE, etc.)
          augend.integer.new{
            radix = 16,
            prefix = "0x",
            natural = true,
            case = "upper",
          },
        },
      }
      
      
      require("dial.config").augends:register_group{
        default = {
          -- date with format `yyyy/mm/dd`
          augend.date.new{
              pattern = "%Y/%m/%d",
              default_kind = "day",
              -- if true, it does not match dates which does not exist, such as 2022/05/32
              only_valid = true,
              -- if true, it only matches dates with word boundary
              word = false,
          },
        },
      }
      
      
      require("dial.config").augends:register_group{
        default = {
          -- uppercase hex number (0x1A1A, 0xEEFE, etc.)
          augend.constant.new{
            elements = {"and", "or"},
            word = true, -- if false, "sand" is incremented into "sor", "doctor" into "doctand", etc.
            cyclic = true,  -- "or" is incremented into "and".
          },
          augend.constant.new{
            elements = {"&&", "||"},
            word = false,
            cyclic = true,
          },
        },
      }
      
      
      require("dial.config").augends:register_group{
        default = {
          -- hex colors (e.g. #1A1A1A, #EEFEFE, etc.)
          augend.hexcolor.new{
            case = "upper", -- or "lower", "prefer_upper", "prefer_lower", see below
          },
        },
      }
      
      
      require("dial.config").augends:register_group{
        default = {
          -- uppercase hex number (0x1A1A, 0xEEFE, etc.)
          augend.user.new{
            find = require("dial.augend.common").find_pattern("%d+"),
            add = function(text, addend, cursor)
                local n = tonumber(text)
                n = math.floor(n * (2 ^ addend))
                text = tostring(n)
                cursor = #text
                return {text = text, cursor = cursor}
            end
          },
        },
      }
      
      
      require("dial.config").augends:register_group{
        default = {
          augend.integer.alias.decimal,
          augend.integer.alias.hex,
          augend.date.alias["%Y/%m/%d"],
        },
      }
      
    end,
  },
  {
    "HiPhish/rainbow-delimiters.nvim",
  },
  {
    "AckslD/nvim-trevJ.lua",
    config = function()
      
      use {
        'AckslD/nvim-trevJ.lua',
        config = 'require("trevj").setup()',  -- optional call for configurating non-default filetypes etc
      
        -- uncomment if you want to lazy load
        -- module = 'trevj',
      
        -- an example for configuring a keybind, can also be done by filetype
        -- setup = function()
        --   vim.keymap.set('n', '<leader>j', function()
        --     require('trevj').format_at_cursor()
        --   end)
        -- end,
      }
      
      
      require('trevj').setup({
        containers = {
          lua = {
            table_constructor = {final_separator = ',', final_end_line = true},
            arguments = {final_separator = false, final_end_line = true},
            parameters = {final_separator = false, final_end_line = true},,
          },
          ... -- other filetypes
        },
      })
      
      
        html = {
          start_tag = {
            final_separator = false,
            final_end_line = true,
            skip = {tag_name = true},
          },
        }
        
    end,
  },
  {
    "pocco81/true-zen.nvim",
    config = function()
      
      use({
      	"Pocco81/true-zen.nvim",
      	config = function()
      		 require("true-zen").setup {
      			-- your config goes here
      			-- or just leave it empty :)
      		 }
      	end,
      })
      
      
      {
      	modes = { -- configurations per mode
      		ataraxis = {
      			shade = "dark", -- if `dark` then dim the padding windows, otherwise if it's `light` it'll brighten said windows
      			backdrop = 0, -- percentage by which padding windows should be dimmed/brightened. Must be a number between 0 and 1. Set to 0 to keep the same background color
      			minimum_writing_area = { -- minimum size of main window
      				width = 70,
      				height = 44,
      			},
      			quit_untoggles = true, -- type :q or :qa to quit Ataraxis mode
      			padding = { -- padding windows
      				left = 52,
      				right = 52,
      				top = 0,
      				bottom = 0,
      			},
      			callbacks = { -- run functions when opening/closing Ataraxis mode
      				open_pre = nil,
      				open_pos = nil,
      				close_pre = nil,
      				close_pos = nil
      			},
      		},
      		minimalist = {
      			ignored_buf_types = { "nofile" }, -- save current options from any window except ones displaying these kinds of buffers
      			options = { -- options to be disabled when entering Minimalist mode
      				number = false,
      				relativenumber = false,
      				showtabline = 0,
      				signcolumn = "no",
      				statusline = "",
      				cmdheight = 1,
      				laststatus = 0,
      				showcmd = false,
      				showmode = false,
      				ruler = false,
      				numberwidth = 1
      			},
      			callbacks = { -- run functions when opening/closing Minimalist mode
      				open_pre = nil,
      				open_pos = nil,
      				close_pre = nil,
      				close_pos = nil
      			},
      		},
      		narrow = {
      			--- change the style of the fold lines. Set it to:
      			--- `informative`: to get nice pre-baked folds
      			--- `invisible`: hide them
      			--- function() end: pass a custom func with your fold lines. See :h foldtext
      			folds_style = "informative",
      			run_ataraxis = true, -- display narrowed text in a Ataraxis session
      			callbacks = { -- run functions when opening/closing Narrow mode
      				open_pre = nil,
      				open_pos = nil,
      				close_pre = nil,
      				close_pos = nil
      			},
      		},
      		focus = {
      			callbacks = { -- run functions when opening/closing Focus mode
      				open_pre = nil,
      				open_pos = nil,
      				close_pre = nil,
      				close_pos = nil
      			},
      		}
      	},
      	integrations = {
      		tmux = false, -- hide tmux status bar in (minimalist, ataraxis)
      		kitty = { -- increment font size in Kitty. Note: you must set `allow_remote_control socket-only` and `listen_on unix:/tmp/kitty` in your personal config (ataraxis)
      			enabled = false,
      			font = "+3"
      		},
      		twilight = false, -- enable twilight (ataraxis)
      		lualine = false -- hide nvim-lualine (ataraxis)
      	},
      }
      
      
      local api = vim.api
      
      api.nvim_set_keymap("n", "<leader>zn", ":TZNarrow<CR>", {})
      api.nvim_set_keymap("v", "<leader>zn", ":'<,'>TZNarrow<CR>", {})
      api.nvim_set_keymap("n", "<leader>zf", ":TZFocus<CR>", {})
      api.nvim_set_keymap("n", "<leader>zm", ":TZMinimalist<CR>", {})
      api.nvim_set_keymap("n", "<leader>za", ":TZAtaraxis<CR>", {})
      
      -- or
      local truezen = require('true-zen')
      local keymap = vim.keymap
      
      keymap.set('n', '<leader>zn', function()
        local first = 0
        local last = vim.api.nvim_buf_line_count(0)
        truezen.narrow(first, last)
      end, { noremap = true })
      keymap.set('v', '<leader>zn', function()
        local first = vim.fn.line('v')
        local last = vim.fn.line('.')
        truezen.narrow(first, last)
      end, { noremap = true })
      keymap.set('n', '<leader>zf', truezen.focus, { noremap = true })
      keymap.set('n', '<leader>zm', truezen.minimalist, { noremap = true })
      keymap.set('n', '<leader>za', truezen.ataraxis, { noremap = true })
      
      
      require("true-zen.ataraxis") --[[
      	.toggle() - toggle on/off the mode
      	.running - `true` if the mode is on / `false` if the mode is off
      --]]
      
      require("true-zen.minimalist") --[[
      	.toggle() - toggle on/off the mode
      	.running - `true` if the mode is on / `false` if the mode is off
      --]]
      
      require("true-zen.narrow") --[[
      	.toggle(line1, line2) - toggle on/off the mode
      	vim.b.tz_narrowed_buffer - `true` if the mode is on / `false` if the mode is off
      --]]
      
      require("true-zen.focus") --[[
      	.toggle() - toggle on/off the mode
      	.running - `true` if the mode is on / `false` if the mode is off
      --]]
      
      --[[
      	Each one offers the following functions too:
      		.on() - turn on the mode
      		.off() - turn off the mode
      --]]
      
      
      
      callbacks = {
      	open_pre = nil,
      	open_pos = nil,
      	close_pre = nil,
      	close_pos = nil
      },
      
      
      vim.g.tz_disable_mode_status_when
      
    end,
  },
  {
    "pocco81/high-str.nvim",
    config = function()
      
      Plug 'Pocco81/HighStr.nvim'
      
      
      use "Pocco81/HighStr.nvim"
      
      
      Plugin 'Pocco81/HighStr.nvim'
      
      
      NeoBundleFetch 'Pocco81/HighStr.nvim'
      
      
      verbosity = 0,
      saving_path = "/tmp/highstr/",
      highlight_colors = {
      	color_0 = {"#0c0d0e", "smart"},	-- Cosmic charcoal
      	color_1 = {"#e5c07b", "smart"},	-- Pastel yellow
      	color_2 = {"#7FFFD4", "smart"},	-- Aqua menthe
      	color_3 = {"#8A2BE2", "smart"},	-- Proton purple
      	color_4 = {"#FF4500", "smart"},	-- Orange red
      	color_5 = {"#008000", "smart"},	-- Office green
      	color_6 = {"#0000FF", "smart"},	-- Just blue
      	color_7 = {"#FFC0CB", "smart"},	-- Blush pink
      	color_8 = {"#FFF9E3", "smart"},	-- Cosmic latte
      	color_9 = {"#7d5c34", "smart"},	-- Fallow brown
      }
      
      
      local high_str = require("high-str")
      
      high_str.setup({
      	verbosity = 0,
      	saving_path = "/tmp/highstr/",
      	highlight_colors = {
      		-- color_id = {"bg_hex_code",<"fg_hex_code"/"smart">}
      		color_0 = {"#0c0d0e", "smart"},	-- Cosmic charcoal
      		color_1 = {"#e5c07b", "smart"},	-- Pastel yellow
      		color_2 = {"#7FFFD4", "smart"},	-- Aqua menthe
      		color_3 = {"#8A2BE2", "smart"},	-- Proton purple
      		color_4 = {"#FF4500", "smart"},	-- Orange red
      		color_5 = {"#008000", "smart"},	-- Office green
      		color_6 = {"#0000FF", "smart"},	-- Just blue
      		color_7 = {"#FFC0CB", "smart"},	-- Blush pink
      		color_8 = {"#FFF9E3", "smart"},	-- Cosmic latte
      		color_9 = {"#7d5c34", "smart"},	-- Fallow brown
      	}
      })
      
      
      lua << EOF
      local high_str = require("high-str")
      
      
      high_str.setup({
      	verbosity = 0,
      	saving_path = "/tmp/highstr/",
      	highlight_colors = {
      		-- color_id = {"bg_hex_code",<"fg_hex_code"/"smart">}
      		color_0 = {"#0c0d0e", "smart"},	-- Cosmic charcoal
      		color_1 = {"#e5c07b", "smart"},	-- Pastel yellow
      		color_2 = {"#7FFFD4", "smart"},	-- Aqua menthe
      		color_3 = {"#8A2BE2", "smart"},	-- Proton purple
      		color_4 = {"#FF4500", "smart"},	-- Orange red
      		color_5 = {"#008000", "smart"},	-- Office green
      		color_6 = {"#0000FF", "smart"},	-- Just blue
      		color_7 = {"#FFC0CB", "smart"},	-- Blush pink
      		color_8 = {"#FFF9E3", "smart"},	-- Cosmic latte
      		color_9 = {"#7d5c34", "smart"},	-- Fallow brown
      	}
      })
      EOF
      
      
      :PackerUpdate
      
      
      vim.api.nvim_set_keymap(
          "v",
          "<F3>",
          ":<c-u>HSHighlight 1<CR>",
          {
              noremap = true,
              silent = true
          }
      )
      
      vim.api.nvim_set_keymap(
          "v",
          "<F4>",
          ":<c-u>HSRmHighlight<CR>",
          {
              noremap = true,
              silent = true
          }
      )
      
    end,
  },
  {
    "pocco81/auto-save.nvim",
    config = function()
      
      use({
      	"Pocco81/auto-save.nvim",
      	config = function()
      		 require("auto-save").setup {
      			-- your config goes here
      			-- or just leave it empty :)
      		 }
      	end,
      })
      
      
      {
          enabled = true, -- start auto-save when the plugin is loaded (i.e. when your package manager loads it)
          execution_message = {
      		message = function() -- message to print on save
      			return ("AutoSave: saved at " .. vim.fn.strftime("%H:%M:%S"))
      		end,
      		dim = 0.18, -- dim the color of `message`
      		cleaning_interval = 1250, -- (milliseconds) automatically clean MsgArea after displaying `message`. See :h MsgArea
      	},
          trigger_events = {"InsertLeave", "TextChanged"}, -- vim events that trigger auto-save. See :h events
      	-- function that determines whether to save the current buffer or not
      	-- return true: if buffer is ok to be saved
      	-- return false: if it's not ok to be saved
      	condition = function(buf)
      		local fn = vim.fn
      		local utils = require("auto-save.utils.data")
      
      		if
      			fn.getbufvar(buf, "&modifiable") == 1 and
      			utils.not_in(fn.getbufvar(buf, "&filetype"), {}) then
      			return true -- met condition(s), can save
      		end
      		return false -- can't save
      	end,
          write_all_buffers = false, -- write all buffers when the current one meets `condition`
          debounce_delay = 135, -- saves the file at most every `debounce_delay` milliseconds
      	callbacks = { -- functions to be executed at different intervals
      		enabling = nil, -- ran when enabling auto-save
      		disabling = nil, -- ran when disabling auto-save
      		before_asserting_save = nil, -- ran before checking `condition`
      		before_saving = nil, -- ran before doing the actual save
      		after_saving = nil -- ran after doing the actual save
      	}
      }
      
      
      vim.api.nvim_set_keymap("n", "<leader>n", ":ASToggle<CR>", {})
      
    end,
  },
  {
    "okuuva/auto-save.nvim",
    config = function()
      
      {
        "okuuva/auto-save.nvim",
        version = '^1.0.0', -- see https://devhints.io/semver, alternatively use '*' to use the latest tagged release
        cmd = "ASToggle", -- optional for lazy loading on command
        event = { "InsertLeave", "TextChanged" }, -- optional for lazy loading on trigger events
        opts = {
          -- your config goes here
          -- or just leave it empty :)
        },
      },
      
      
      use({
        "okuuva/auto-save.nvim",
        tag = 'v1*',
        config = function()
         require("auto-save").setup({
           -- your config goes here
           -- or just leave it empty :)
         })
        end,
      })
      
      
      {
        enabled = true, -- start auto-save when the plugin is loaded (i.e. when your package manager loads it)
        trigger_events = { -- See :h events
          immediate_save = { "BufLeave", "FocusLost", "QuitPre", "VimSuspend" }, -- vim events that trigger an immediate save
          defer_save = { "InsertLeave", "TextChanged" }, -- vim events that trigger a deferred save (saves after `debounce_delay`)
          cancel_deferred_save = { "InsertEnter" }, -- vim events that cancel a pending deferred save
        },
        -- function that takes the buffer handle and determines whether to save the current buffer or not
        -- return true: if buffer is ok to be saved
        -- return false: if it's not ok to be saved
        -- if set to `nil` then no specific condition is applied
        condition = nil,
        write_all_buffers = false, -- write all buffers when the current one meets `condition`
        noautocmd = false, -- do not execute autocmds when saving
        lockmarks = false, -- lock marks when saving, see `:h lockmarks` for more details
        debounce_delay = 1000, -- delay after which a pending save is executed
       -- log debug messages to 'auto-save.log' file in neovim cache directory, set to `true` to enable
        debug = false,
      }
      
      
      -- some recommended exclusions. you can use `:lua print(vim.bo.filetype)` to
      -- get the filetype string of the current buffer
      local excluded_filetypes = {
        -- this one is especially useful if you use neovim as a commit message editor
        "gitcommit",
        -- most of these are usually set to non-modifiable, which prevents autosaving
        -- by default, but it doesn't hurt to be extra safe.
        "NvimTree",
        "Outline",
        "TelescopePrompt",
        "alpha",
        "dashboard",
        "lazygit",
        "neo-tree",
        "oil",
        "prompt",
        "toggleterm",
      }
      
      local excluded_filenames = {
        "do-not-autosave-me.lua"
      }
      
      local function save_condition(buf)
        if
          vim.tbl_contains(excluded_filetypes, vim.fn.getbufvar(buf, "&filetype"))
          or vim.tbl_contains(excluded_filenames, vim.fn.expand("%:t"))
        then
          return false
        end
        return true
      end
      
      
      -- in your config table
      {
        condition = save_condition
      }
      
      
      {
        condition = function(buf)
          -- don't save for special-buffers
          if vim.fn.getbufvar(buf, "&buftype") ~= '' then
            return false
          end
          return true
        end
      }
      
      
      vim.api.nvim_set_keymap("n", "<leader>n", "<cmd>ASToggle<CR>", {})
      
      
      {
        "okuuva/auto-save.nvim",
        keys = {
          { "<leader>n", "<cmd>ASToggle<CR>", desc = "Toggle auto-save" },
        },
        ...
      },
      
      
      
      local group = vim.api.nvim_create_augroup('autosave', {})
      
      vim.api.nvim_create_autocmd('User', {
          pattern = 'AutoSaveWritePost',
          group = group,
          callback = function(opts)
              if opts.data.saved_buffer ~= nil then
                  local filename = vim.api.nvim_buf_get_name(opts.data.saved_buffer)
                  vim.notify('AutoSave: saved ' .. filename .. ' at ' .. vim.fn.strftime('%H:%M:%S'), vim.log.levels.INFO)
              end
          end,
      })
      
      
      local group = vim.api.nvim_create_augroup('autosave', {})
      
      vim.api.nvim_create_autocmd('User', {
          pattern = 'AutoSaveEnable',
          group = group,
          callback = function(opts)
              vim.notify('AutoSave enabled', vim.log.levels.INFO)
          end,
      })
      
      vim.api.nvim_create_autocmd('User', {
          pattern = 'AutoSaveDisable',
          group = group,
          callback = function(opts)
              vim.notify('AutoSave disabled', vim.log.levels.INFO)
          end,
      })
      
    end,
  },
  {
    "tmillr/sos.nvim",
    config = function()
      
      require('sos').setup {
        ---Whether to enable the plugin.
        enabled = true,
      
        ---Timeout in milliseconds for the global timer. Buffer changes debounce the
        ---timer.
        timeout = 10000,
      
        ---Automatically create missing parent directories when writing/autosaving a
        ---buffer.
        create_parent_dirs = true,
      
        ---Whether to set and manage Vim's 'autowrite' option.
        ---
        ---### Choices:
        ---
        ---  - "all": set and manage 'autowriteall'
        ---  - true : set and manage 'autowrite'
        ---  - false: don't set or manage any of Vim's 'autowwrite' options
        autowrite = true,
      
        ---Save all buffers before executing a `:` command on the cmdline (does not
        ---include `<Cmd>` mappings).
        ---
        ---### Choices:
        ---
        ---  - "all"                 : save on any cmd that gets executed
        ---  - "some"                : only for some commands (source, luafile, etc.).
        ---                            not perfect, but may lead to fewer unnecessary
        ---                            file writes compared to `"all"`.
        ---  - table<string, boolean>: map specifying which commands trigger a save
        ---                            where keys are the full command names
        ---  - false                 : never/disable
        save_on_cmd = 'some',
      
        ---Save current buffer on `BufLeave`. See `:help BufLeave`.
        save_on_bufleave = true,
      
        ---Save all buffers when Neovim loses focus or is suspended.
        save_on_focuslost = true,
      
        should_save = {
          ---Whether to autosave buffers which aren't modifiable.
          ---See `:help 'modifiable'`.
          unmodifiable = true,
      
          ---How to handle `acwrite` type buffers (i.e. where `vim.bo.buftype ==
          ---"acwrite"` or the buffer's name is a URI). These buffers use an autocmd to
          ---perform special actions and side-effects when saved/written.
          acwrite = {
            ---Whether to autosave buffers which perform network actions (such as sending a
            ---request) on save/write. E.g. `scp`, `http`
            net = true,
      
            ---Whether to autosave buffers which perform git actions (such as staging
            ---buffer content) on save/write. E.g. `fugitive`, `diffview`, `gitsigns`
            git = true,
      
            ---Whether to autosave buffers which process the file on save/write.
            ---E.g. `tar`, `zip`, `gzip`
            compress = true,
      
            ---Whether to autosave `acwrite` buffers which don't match any of the other
            ---acwrite criteria/filters.
            other = true,
      
            ---URI schemes to allow/disallow autosaving for. If a scheme is set to `false`,
            ---any buffer whose name begins with that scheme will not be autosaved.
            ---Provided schemes should be lowercase and will be matched case-insensitively.
            ---Schemes take precedence over other `acwrite` filters.
            ---
            ---Example:
            ---
            ---
    end,
  },
  {
    "folke/zen-mode.nvim",
    config = function()
      
      -- Lua
      {
        "folke/zen-mode.nvim",
        opts = {
          -- your configuration comes here
          -- or leave it empty to use the default settings
          -- refer to the configuration section below
        }
      }
      
      
      {
        window = {
          backdrop = 0.95, -- shade the backdrop of the Zen window. Set to 1 to keep the same as Normal
          -- height and width can be:
          -- * an absolute number of cells when > 1
          -- * a percentage of the width / height of the editor when <= 1
          -- * a function that returns the width or the height
          width = 120, -- width of the Zen window
          height = 1, -- height of the Zen window
          -- by default, no options are changed for the Zen window
          -- uncomment any of the options below, or add other vim.wo options you want to apply
          options = {
            -- signcolumn = "no", -- disable signcolumn
            -- number = false, -- disable number column
            -- relativenumber = false, -- disable relative numbers
            -- cursorline = false, -- disable cursorline
            -- cursorcolumn = false, -- disable cursor column
            -- foldcolumn = "0", -- disable fold column
            -- list = false, -- disable whitespace characters
          },
        },
        plugins = {
          -- disable some global vim options (vim.o...)
          -- comment the lines to not apply the options
          options = {
            enabled = true,
            ruler = false, -- disables the ruler text in the cmd line area
            showcmd = false, -- disables the command in the last line of the screen
            -- you may turn on/off statusline in zen mode by setting 'laststatus' 
            -- statusline will be shown only if 'laststatus' == 3
            laststatus = 0, -- turn off the statusline in zen mode
          },
          twilight = { enabled = true }, -- enable to start Twilight when zen mode opens
          gitsigns = { enabled = false }, -- disables git signs
          tmux = { enabled = false }, -- disables the tmux statusline
          todo = { enabled = false }, -- if set to "true", todo-comments.nvim highlights will be disabled
          -- this will change the font size on kitty when in zen mode
          -- to make this work, you need to set the following kitty options:
          -- - allow_remote_control socket-only
          -- - listen_on unix:/tmp/kitty
          kitty = {
            enabled = false,
            font = "+4", -- font size increment
          },
          -- this will change the font size on alacritty when in zen mode
          -- requires  Alacritty Version 0.10.0 or higher
          -- uses `alacritty msg` subcommand to change font size
          alacritty = {
            enabled = false,
            font = "14", -- font size
          },
          -- this will change the font size on wezterm when in zen mode
          -- See alse also the Plugins/Wezterm section in this projects README
          wezterm = {
            enabled = false,
            -- can be either an absolute font size or the number of incremental steps
            font = "+4", -- (10% increase per step)
          },
          -- this will change the scale factor in Neovide when in zen mode
          -- See alse also the Plugins/Wezterm section in this projects README
          neovide = {
              enabled = false,
              -- Will multiply the current scale factor by this number
              scale = 1.2
              -- disable the Neovide animations while in Zen mode
              disable_animations = {
                      neovide_animation_length = 0,
                      neovide_cursor_animate_command_line = false,
                      neovide_scroll_animation_length = 0,
                      neovide_position_animation_length = 0,
                      neovide_cursor_animation_length = 0,
                      neovide_cursor_vfx_mode = "",
                  }
          },
        },
        -- callback where you can add custom code when the Zen window opens
        on_open = function(win)
        end,
        -- callback where you can add custom code when the Zen window closes
        on_close = function()
        end,
      }
      
      
      require("zen-mode").toggle({
        window = {
          width = .85 -- width will be 85% of the editor width
        }
      })
      
      
      wezterm.on('user-var-changed', function(window, pane, name, value)
          local overrides = window:get_config_overrides() or {}
          if name == "ZEN_MODE" then
              local incremental = value:find("+")
              local number_value = tonumber(value)
              if incremental ~= nil then
                  while (number_value > 0) do
                      window:perform_action(wezterm.action.IncreaseFontSize, pane)
                      number_value = number_value - 1
                  end
                  overrides.enable_tab_bar = false
              elseif number_value < 0 then
                  window:perform_action(wezterm.action.ResetFontSize, pane)
                  overrides.font_size = nil
                  overrides.enable_tab_bar = true
              else
                  overrides.font_size = number_value
                  overrides.enable_tab_bar = false
              end
          end
          window:set_config_overrides(overrides)
      end)
      
    end,
  },
  {
    "andersevenrud/nvim_context_vt",
    config = function()
      
      require('nvim_context_vt').setup({
        -- Enable by default. You can disable and use :NvimContextVtToggle to maually enable.
        -- Default: true
        enabled = true,
      
        -- Override default virtual text prefix
        -- Default: '-->'
        prefix = '',
      
        -- Override default virtual text priority
        -- Default: 1000
        priority = 1000,
      
        -- Override the internal highlight group name
        -- Default: 'ContextVt'
        highlight = 'CustomContextVt',
      
        -- Disable virtual text for given filetypes
        -- Default: { 'markdown' }
        disable_ft = { 'markdown' },
      
        -- Disable display of virtual text below blocks for indentation based languages like Python
        -- Default: false
        disable_virtual_lines = false,
      
        -- Same as above but only for spesific filetypes
        -- Default: {}
        disable_virtual_lines_ft = { 'yaml' },
      
        -- How many lines required after starting position to show virtual text
        -- Default: 1 (equals two lines total)
        min_rows = 1,
      
        -- Same as above but only for spesific filetypes
        -- Default: {}
        min_rows_ft = {},
      
        -- Custom virtual text node parser callback
        -- Default: nil
        custom_parser = function(node, ft, opts)
          local utils = require('nvim_context_vt.utils')
      
          -- If you return `nil`, no virtual text will be displayed.
          if node:type() == 'function' then
            return nil
          end
      
          -- This is the standard text
          return opts.prefix .. ' ' .. utils.get_node_text(node)[1]
        end,
      
        -- Custom node validator callback
        -- Default: nil
        custom_validator = function(node, ft, opts)
          -- Internally a node is matched against min_rows and configured targets
          local default_validator = require('nvim_context_vt.utils').default_validator
          if default_validator(node, ft) then
            -- Custom behaviour after using the internal validator
            if node:type() == 'function' then
              return false
            end
          end
      
          return true
        end,
      
        -- Custom node virtual text resolver callback
        -- Default: nil
        custom_resolver = function(nodes, ft, opts)
          -- By default the last node is used
          return nodes[#nodes]
        end,
      })
      
    end,
  },
  {
    "nvim-treesitter/nvim-treesitter-context",
    config = function()
      
      require'treesitter-context'.setup{
        enable = true, -- Enable this plugin (Can be enabled/disabled later via commands)
        multiwindow = false, -- Enable multiwindow support.
        max_lines = 0, -- How many lines the window should span. Values <= 0 mean no limit.
        min_window_height = 0, -- Minimum editor window height to enable context. Values <= 0 mean no limit.
        line_numbers = true,
        multiline_threshold = 20, -- Maximum number of lines to show for a single context
        trim_scope = 'outer', -- Which context lines to discard if `max_lines` is exceeded. Choices: 'inner', 'outer'
        mode = 'cursor',  -- Line used to calculate context. Choices: 'cursor', 'topline'
        -- Separator between context and content. Should be a single character string, like '-'.
        -- When separator is set, the context will only show up when there are at least 2 lines above cursorline.
        separator = nil,
        zindex = 20, -- The Z-index of the context window
        on_attach = nil, -- (fun(buf: integer): boolean) return false to disable attaching
      }
      
      
      vim.keymap.set("n", "[c", function()
        require("treesitter-context").go_to_context(vim.v.count1)
      end, { silent = true })
      
    end,
  },
  {
    "mizlan/iswap.nvim",
    config = function()
      
      {
        "mizlan/iswap.nvim",
        event = "VeryLazy"
      }
      
      
      require('iswap').setup{
        -- The keys that will be used as a selection, in order
        -- ('asdfghjklqwertyuiopzxcvbnm' by default)
        keys = 'qwertyuiop',
      
        -- Grey out the rest of the text when making a selection
        -- (enabled by default)
        grey = 'disable',
      
        -- Highlight group for the sniping value (asdf etc.)
        -- default 'Search'
        hl_snipe = 'ErrorMsg',
      
        -- Highlight group for the visual selection of terms
        -- default 'Visual'
        hl_selection = 'WarningMsg',
      
        -- Highlight group for the greyed background
        -- default 'Comment'
        hl_grey = 'LineNr',
      
        -- Post-operation flashing highlight style,
        -- either 'simultaneous' or 'sequential', or false to disable
        -- default 'sequential'
        flash_style = false,
      
        -- Highlight group for flashing highlight afterward
        -- default 'IncSearch'
        hl_flash = 'ModeMsg',
      
        -- Move cursor to the other element in ISwap*With commands
        -- default false
        move_cursor = true,
      
        -- Automatically swap with only two arguments
        -- default nil
        autoswap = true,
      
        -- Other default options you probably should not change:
        debug = nil,
        hl_grey_priority = '1000',
      }
      
    end,
  },
  {
    "Wansmer/sibling-swap.nvim",
    config = function()
      
      use({
        'Wansmer/sibling-swap.nvim',
        requires = { 'nvim-treesitter' },
        config = function()
          require('sibling-swap').setup({--[[ your config ]]})
        end,
      })
      
      
      local DEFAULT_SETTINGS = {
        allowed_separators = {
          ',',
          ';',
          'and',
          'or',
          '&&',
          '&',
          '||',
          '|',
          '==',
          '===',
          '!=',
          '!==',
          '-',
          '+',
          ['<'] = '>',
          ['<='] = '>=',
          ['>'] = '<',
          ['>='] = '<=',
        },
        use_default_keymaps = true,
        -- Highlight recently swapped node. Can be boolean or table
        -- If table: { ms = 500, hl_opts = { link = 'IncSearch' } }
        -- `hl_opts` is a `val` from `nvim_set_hl()`
        highlight_node_at_cursor = false,
        -- keybinding for movements to right or left (and up or down, if `allow_interline_swaps` is true)
        -- (`<C-,>` and `<C-.>` may not map to control chars at system level, so are sent by certain terminals as just `,` and `.`. In this case, just add the mappings you want.)
        keymaps = {
          ['<C-.>'] = 'swap_with_right',
          ['<C-,>'] = 'swap_with_left',
          ['<space>.'] = 'swap_with_right_with_opp',
          ['<space>,'] = 'swap_with_left_with_opp',
        },
        ignore_injected_langs = false,
        -- allow swaps across lines
        allow_interline_swaps = true,
        -- swaps interline siblings without separators (no recommended, helpful for swaps html-like attributes)
        interline_swaps_without_separator = false,
        -- Fallbacs for tiny settings for langs and nodes. See #fallback
        fallback = {},
      }
      
      
      require('sibling-swap').setup({
        allowed_separators = {
          -- standart
          '=',
          -- with opposite value
          ['>>'] = '<<',
          ['<<'] = '>>',
          -- disable
          ['&'] = false,
        }
      })
      
      
      ---@class FallbackItem
      ---@field enable boolean|function(node: TSNode): boolean
      ---@field action function(node: TSNode, side: string): void
      
      require('sibling-swap').setup({
        ---@field fallback table<string, table<string, FallbackItem>>
        fallback = {
          ['javascript'] = {
            string = {
              enable = function(node)
                -- some condition
                return true
              end,
              action = function(node, side)
                -- Do something instead of swapping
              end,
            },
          },
        },
      })
      
    end,
  },
  {
    "Wansmer/binary-swap.nvim",
    config = function()
      
      use({
        'Wansmer/binary-swap.nvim',
        setup = function ()
          vim.keymap.set('n', 'YOUR PREFER KEYS', function ()
            require('binary-swap').swap_operands()
          end)
          vim.keymap.set('n', 'YOUR PREFER KEYS', function ()
            require('binary-swap').swap_operands_with_operator()
          end)
        end
      })
      
    end,
  },
  {
    "nacro90/numb.nvim",
    config = function()
      
      use 'nacro90/numb.nvim'
      
      
      paq 'nacro90/numb.nvim'
      
      
      {
        'nacro90/numb.nvim',
        config = function()
          require('numb').setup()
        end,
      }
      
      
      require('numb').setup()
      
      
      require('numb').disable()
      
      
      require('numb').setup{
        show_numbers = true, -- Enable 'number' for the window while peeking
        show_cursorline = true, -- Enable 'cursorline' for the window while peeking
        hide_relativenumbers = true, -- Enable turning off 'relativenumber' for the window while peeking
        number_only = false, -- Peek only when the command is only a number instead of when it starts with a number
        centered_peeking = true, -- Peeked line will be centered relative to window
      }
      
    end,
  },
  {
    "AllenDang/nvim-expand-expr",
    config = function()
      
      require("expand_expr").expand()
      
    end,
  },
  {
    "h-hg/fcitx.nvim",
    config = function()
      
      require('packer').startup(function()
        use 'h-hg/fcitx.nvim'
      end)
      
    end,
  },
  {
    "keaising/im-select.nvim",
    config = function()
      
      {
          "keaising/im-select.nvim",
          config = function()
              require("im_select").setup({})
          end,
      }
      
      
      {
          "keaising/im-select.nvim",
          config = function()
              require('im_select').setup({
                  -- IM will be set to `default_im_select` in `normal` mode
                  -- For Windows/WSL, default: "1033", aka: English US Keyboard
                  -- For macOS, default: "com.apple.keylayout.ABC", aka: US
                  -- For Linux, default:
                  --               "keyboard-us" for Fcitx5
                  --               "1" for Fcitx
                  --               "xkb:us::eng" for ibus
                  -- You can use `im-select` or `fcitx5-remote -n` to get the IM's name
                  default_im_select  = "com.apple.keylayout.ABC",
      
                  -- Can be binary's name, binary's full path, or a table, e.g. 'im-select',
                  -- '/usr/local/bin/im-select' for binary without extra arguments,
                  -- or { "AIMSwitcher.exe", "--imm" } for binary need extra arguments to work.
                  -- For Windows/WSL, default: "im-select.exe"
                  -- For macOS, default: "macism"
                  -- For Linux, default: "fcitx5-remote" or "fcitx-remote" or "ibus"
                  default_command = "im-select.exe",
      
                  -- Restore the default input method state when the following events are triggered
                  -- "VimEnter" and "FocusGained" were removed for causing problems, add it by your needs
                  set_default_events = { "InsertLeave", "CmdlineLeave" },
      
                  -- Restore the previous used input method state when the following events
                  -- are triggered, if you don't want to restore previous used im in Insert mode,
                  -- e.g. deprecated `disable_auto_restore = 1`, just let it empty
                  -- as `set_previous_events = {}`
                  set_previous_events = { "InsertEnter" },
      
                  -- Show notification about how to install executable binary when binary missed
                  keep_quiet_on_no_binary = false,
      
                  -- Async run `default_command` to switch IM or not
                  async_switch_im = true
              })
          end,
      }
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-trailspace.md",
  },
  {
    "smjonas/live-command.nvim",
    config = function()
      
      use {
        "smjonas/live-command.nvim",
        -- live-command supports semantic versioning via Git tags
        -- tag = "2.*",
        config = function()
          require("live-command").setup()
        end,
      }
      
      
      require("live-command").setup()
      
      
      require("live-command").setup {
        commands = {
          Norm = { cmd = "norm" },
        },
      }
      
      
      vim.cmd("cnoreabbrev norm Norm")
      
      
      require("live-command").setup {
        enable_highlighting = true,
        inline_highlighting = true,
        hl_groups = {
          insertion = "DiffAdd",
          deletion = "DiffDelete",
          change = "DiffChange",
        },
      }
      
    end,
  },
  {
    "filipdutescu/renamer.nvim",
    config = function()
      
      use {
        'filipdutescu/renamer.nvim',
        branch = 'master',
        requires = { {'nvim-lua/plenary.nvim'} }
      }
      
      
      vim.api.nvim_set_keymap('i', '<F2>', '<cmd>lua require("renamer").rename()<cr>', { noremap = true, silent = true })
      vim.api.nvim_set_keymap('n', '<leader>rn', '<cmd>lua require("renamer").rename()<cr>', { noremap = true, silent = true })
      vim.api.nvim_set_keymap('v', '<leader>rn', '<cmd>lua require("renamer").rename()<cr>', { noremap = true, silent = true })
      
      
      local mappings_utils = require('renamer.mappings.utils')
      require('renamer').setup {
          -- The popup title, shown if `border` is true
          title = 'Rename',
          -- The padding around the popup content
          padding = {
              top = 0,
              left = 0,
              bottom = 0,
              right = 0,
          },
          -- The minimum width of the popup
          min_width = 15,
          -- The maximum width of the popup
          max_width = 45,
          -- Whether or not to shown a border around the popup
          border = true,
          -- The characters which make up the border
          border_chars = { '─', '│', '─', '│', '╭', '╮', '╯', '╰' },
          -- Whether or not to highlight the current word references through LSP
          show_refs = true,
          -- Whether or not to add resulting changes to the quickfix list
          with_qf_list = true,
          -- Whether or not to enter the new name through the UI or Neovim's `input`
          -- prompt
          with_popup = true,
          -- The keymaps available while in the `renamer` buffer. The example below
          -- overrides the default values, but you can add others as well.
          mappings = {
              ['<c-i>'] = mappings_utils.set_cursor_to_start,
              ['<c-a>'] = mappings_utils.set_cursor_to_end,
              ['<c-e>'] = mappings_utils.set_cursor_to_word_end,
              ['<c-b>'] = mappings_utils.set_cursor_to_word_start,
              ['<c-c>'] = mappings_utils.clear_line,
              ['<c-u>'] = mappings_utils.undo,
              ['<c-r>'] = mappings_utils.redo,
          },
          -- Custom handler to be run after successfully renaming the word. Receives
          -- the LSP 'textDocument/rename' raw response as its parameter.
          handler = nil,
      }
      
      
      require('renamer').rename {
          -- Defines whether or not the popup should contain the initial word or be
          -- empty
          empty = false,
      }
      
      
      -- other setup code...
      
      ['<c-c>'] = function()
          vim.api.nvim_input('<esc>')
      end
      
      -- other setup code...
      
    end,
  },
  {
    "gbprod/cutlass.nvim",
    config = function()
      
      -- Lua
      {
        "gbprod/cutlass.nvim",
        opts = {
            -- your configuration comes here
            -- or don't set opts to use the default settings
            -- refer to the configuration section below
          }
      }
      
      
      -- Lua
      use({
        "gbprod/cutlass.nvim",
        config = function()
          require("cutlass").setup({
            -- your configuration comes here
            -- or leave it empty to use the default settings
            -- refer to the configuration section below
          })
        end
      })
      
      
      {
        cut_key = nil,
        override_del = nil,
        exclude = {},
        registers = {
          select = "_",
          delete = "_",
          change = "_",
        },
      }
      
      
      {
        registers = {
          select = "s",
          delete = "d",
          change = "c",
        },
      }
      
      
      use({
        "gbprod/cutlass.nvim",
        config = function()
          require("cutlass").setup({
              exclude = { "ns", "nS" },
          })
        end
      })
      
    end,
  },
  {
    "gbprod/substitute.nvim",
    config = function()
      
      {
          "gbprod/substitute.nvim",
          opts = {
              -- your configuration comes here
              -- or leave it empty to use the default settings
              -- refer to the configuration section below
          }
      }
      
      
      require('substitute').setup()
      
      
      require('substitute').setup({
        on_substitute = nil,
        yank_substituted_text = false,
        preserve_cursor_position = false,
        modifiers = nil,
        highlight_substituted_text = {
          enabled = true,
          timer = 500,
        },
        range = {
          prefix = "s",
          prompt_current_text = false,
          confirm = false,
          complete_word = false,
          subject = nil,
          range = nil,
          suffix = "",
          auto_apply = false,
          cursor_position = "end",
        },
        exchange = {
          motion = false,
          use_esc_to_cancel = true,
          preserve_cursor_position = false,
        },
      })
      
      
      -- Lua
      vim.keymap.set("n", "s", require('substitute').operator, { noremap = true })
      vim.keymap.set("n", "ss", require('substitute').line, { noremap = true })
      vim.keymap.set("n", "S", require('substitute').eol, { noremap = true })
      vim.keymap.set("x", "s", require('substitute').visual, { noremap = true })
      
      
      lua require('substitute').operator({
        count = 1,       -- number of substitutions
        register = "a",  -- register used for substitution
        motion = "iw",   -- only available for `operator`, this will automatically use
                         -- this motion for substitution instead of waiting for.
        modifiers = nil, -- this allows to modify substitued text, will override the default
                         -- configuration (see below)
      })
      
      
      require('substitute').operator({
        modifiers = { 'linewise', 'reindent' },
      })
      
      
      require('substitute').operator({
        modifiers = { 'join', 'trim' },
      })
      
      
      require('substitute').operator({
        modifiers = function(state)
          if state.vmode == 'char' then
            return { 'trim' }
          end
        end,
      })
      
      
      require('substitute').operator({
        modifiers = function(state)
          if state.vmode == 'line' then
            return { 'reindent' }
          end
        end,
      })
      
      
      require("substitute").setup({
        on_substitute = require("yanky.integration").substitute(),
      })
      
      
      require("substitute").setup({
        on_substitute = function(_)
          vim.cmd("call yoink#startUndoRepeatSwap()")
        end,
      })
      
      
      vim.keymap.set("x", "p", require('substitute').visual, { noremap = true })
      vim.keymap.set("x", "P", require('substitute').visual, { noremap = true })
      
      
      vim.keymap.set("n", "<leader>s", require('substitute.range').operator, { noremap = true })
      vim.keymap.set("x", "<leader>s", require('substitute.range').visual, { noremap = true })
      vim.keymap.set("n", "<leader>ss", require('substitute.range').word, { noremap = true })
      
      
      vim.keymap.set("n", "<leader>S", function ()
          require('substitute.range').operator({ prefix = 'S' })
      end, { noremap = true })
      
      
      require("substitute").setup({
        range = {
          prefix = "S",
        }
      })
      
      
      vim.keymap.set("n", "sx", require('substitute.exchange').operator, { noremap = true })
      vim.keymap.set("n", "sxx", require('substitute.exchange').line, { noremap = true })
      vim.keymap.set("x", "X", require('substitute.exchange').visual, { noremap = true })
      vim.keymap.set("n", "sxc", require('substitute.exchange').cancel, { noremap = true })
      
      
      vim.keymap.set("n", "sxc", require('substitute.exchange').cancel, { noremap = true })
      
    end,
  },
  {
    "gregorias/coerce.nvim",
    config = function()
      
      {
        "gregorias/coerce.nvim",
        tag = 'v4.1.0',
        config = true,
      }
      
      
      {
        "tpope/vim-abolish",
        init = function()
          -- Disable coercion mappings. I use coerce.nvim for that.
          vim.g.abolish_no_mappings = true
        end,
      }
      
      
      require"which-key".register({
        g = {
          p = {
            -- "p" makes sense, gv selects the last Visual selection, so this one
            -- selects the last pasted text.
            function()
                vim.api.nvim_feedkeys("`[" .. vim.fn.strpart(vim.fn.getregtype(), 0, 1) .. "`]", "n", false)
            end,
            "Switch to VISUAL using last paste/change",
          },
        },
      })
      
      
      require"coerce".setup{
        keymap_registry = require("coerce.keymap").keymap_registry(),
        -- The notification function used during error conditions.
        notify = function(...) return vim.notify(...) end,
        default_mode_keymap_prefixes = {
          normal_mode = "cr",
          motion_mode = "gcr",
          visual_mode = "gcr",
        },
        -- Set any field to false to disable that mode.
        default_mode_mask = {
          normal_mode = true,
          motion_mode = true,
          visual_mode = true,
        },
        -- If you don’t like the default cases and modes, you can override them.
        cases = require"coerce".default_cases,
        modes = require"coerce".get_default_modes(default_mode_mask, default_mode_keymap_prefixes),
      }
      
      
      require"coerce".register_case{
        keymap = "l",
        case = function(str)
          return vim.fn.tolower(str)
        end,
        description = "lowercase",
      }
      
      
      require"coerce".register_mode{
        vim_mode = "v",
        keymap_prefix = "gc",
        selector = function(cb)
          local s, e = -- Your function that finds start and end points.
                       -- For example, returning {0, 0}, {0, 5} selects the first 6
                       -- characters of the current buffer.
          local region_m = require"coerce.region"
          cb(region_m(region_m.modes.INLINE, s, e))
        end,
        transformer = require"coerce.transformer".transform_local,
      }
      
      
      require"coerce".setup{
        -- …
        default_mode_mask = {
          -- Disable the default `cr` binding.
          normal_mode = false,
        },
        -- …
      }
      
      -- Register a custom `cr` binding that uses the local-only transformation.
      require"coerce".register_mode{
        vim_mode = "n",
        keymap_prefix = "cr",
        selector = require"coerce.selector".select_current_word,
        transformer = require"coerce.transformer".transform_local,
      }
      
    end,
  },
  {
    "johmsalas/text-case.nvim",
    config = function()
      
      use { "johmsalas/text-case.nvim",
        config = function()
          require('textcase').setup {}
        end
      }
      
      
      {
        "johmsalas/text-case.nvim",
        dependencies = { "nvim-telescope/telescope.nvim" },
        config = function()
          require("textcase").setup({})
          require("telescope").load_extension("textcase")
        end,
        keys = {
          "ga", -- Default invocation prefix
          { "ga.", "<cmd>TextCaseOpenTelescope<CR>", mode = { "n", "x" }, desc = "Telescope" },
        },
        cmd = {
          -- NOTE: The Subs command name can be customized via the option "substitude_command_name"
          "Subs",
          "TextCaseOpenTelescope",
          "TextCaseOpenTelescopeQuickChange",
          "TextCaseOpenTelescopeLSPChange",
          "TextCaseStartReplacingCommand",
        },
        -- If you want to use the interactive feature of the `Subs` command right away, text-case.nvim
        -- has to be loaded on startup. Otherwise, the interactive feature of the `Subs` will only be
        -- available after the first executing of it or after a keymap of text-case.nvim has been used.
        lazy = false,
      }
      
      
      {
        -- Set `default_keymappings_enabled` to false if you don't want automatic keymappings to be registered.
        default_keymappings_enabled = true,
        -- `prefix` is only considered if `default_keymappings_enabled` is true. It configures the prefix
        -- of the keymappings, e.g. `gau ` executes the `current_word` method with `to_upper_case`
        -- and `gaou` executes the `operator` method with `to_upper_case`.
        prefix = "ga",
        -- If `substitude_command_name` is not nil, an additional command with the passed in name
        -- will be created that does the same thing as "Subs" does.
        substitude_command_name = nil,
        -- By default, all methods are enabled. If you set this option with some methods omitted,
        -- these methods will not be registered in the default keymappings. The methods will still
        -- be accessible when calling the exact lua function e.g.:
        -- "<CMD>lua require('textcase').current_word('to_snake_case')<CR>"
        enabled_methods = {
          "to_upper_case",
          "to_lower_case",
          "to_snake_case",
          "to_dash_case",
          "to_title_dash_case",
          "to_constant_case",
          "to_dot_case",
          "to_comma_case",
          "to_phrase_case",
          "to_camel_case",
          "to_pascal_case",
          "to_title_case",
          "to_path_case",
          "to_upper_phrase_case",
          "to_lower_phrase_case",
        },
      }
      
      
      config = function()
        require('textcase').setup {}
        require('telescope').load_extension('textcase')
        vim.api.nvim_set_keymap('n', 'ga.', '<cmd>TextCaseOpenTelescope<CR>', { desc = "Telescope" })
        vim.api.nvim_set_keymap('v', 'ga.', "<cmd>TextCaseOpenTelescope<CR>", { desc = "Telescope" })
      end
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-operators.md",
  },
  {
    "gbprod/yanky.nvim",
    config = function()
      
      {
        "gbprod/yanky.nvim",
        opts = {
          -- your configuration comes here
          -- or leave it empty to use the default settings
          -- refer to the configuration section below
        },
      }
      
      
      {
        "gbprod/yanky.nvim",
        dependencies = {
          { "kkharji/sqlite.lua" }
        },
        opts = {
          ring = { storage = "sqlite" },
        },
        keys = {
          { "<leader>p", "<cmd>YankyRingHistory<cr>", mode = { "n", "x" }, desc = "Open Yank History" },
          { "y", "<Plug>(YankyYank)", mode = { "n", "x" }, desc = "Yank text" },
          { "p", "<Plug>(YankyPutAfter)", mode = { "n", "x" }, desc = "Put yanked text after cursor" },
          { "P", "<Plug>(YankyPutBefore)", mode = { "n", "x" }, desc = "Put yanked text before cursor" },
          { "gp", "<Plug>(YankyGPutAfter)", mode = { "n", "x" }, desc = "Put yanked text after selection" },
          { "gP", "<Plug>(YankyGPutBefore)", mode = { "n", "x" }, desc = "Put yanked text before selection" },
          { "<c-p>", "<Plug>(YankyPreviousEntry)", desc = "Select previous entry through yank history" },
          { "<c-n>", "<Plug>(YankyNextEntry)", desc = "Select next entry through yank history" },
          { "]p", "<Plug>(YankyPutIndentAfterLinewise)", desc = "Put indented after cursor (linewise)" },
          { "[p", "<Plug>(YankyPutIndentBeforeLinewise)", desc = "Put indented before cursor (linewise)" },
          { "]P", "<Plug>(YankyPutIndentAfterLinewise)", desc = "Put indented after cursor (linewise)" },
          { "[P", "<Plug>(YankyPutIndentBeforeLinewise)", desc = "Put indented before cursor (linewise)" },
          { ">p", "<Plug>(YankyPutIndentAfterShiftRight)", desc = "Put and indent right" },
          { "<p", "<Plug>(YankyPutIndentAfterShiftLeft)", desc = "Put and indent left" },
          { ">P", "<Plug>(YankyPutIndentBeforeShiftRight)", desc = "Put before and indent right" },
          { "<P", "<Plug>(YankyPutIndentBeforeShiftLeft)", desc = "Put before and indent left" },
          { "=p", "<Plug>(YankyPutAfterFilter)", desc = "Put after applying a filter" },
          { "=P", "<Plug>(YankyPutBeforeFilter)", desc = "Put before applying a filter" },
        },
      }
      
      
      -- Lua
      use("gbprod/yanky.nvim")
      require("yanky").setup({
          -- your configuration comes here
          -- or leave it empty to use the default settings
          -- refer to the configuration section below
      })
      
      
      {
        ring = {
          history_length = 100,
          storage = "shada",
          storage_path = vim.fn.stdpath("data") .. "/databases/yanky.db", -- Only for sqlite storage
          sync_with_numbered_registers = true,
          cancel_event = "update",
          ignore_registers = { "_" },
          update_register_on_cycle = false,
          permanent_wrapper = nil,
        },
        picker = {
          select = {
            action = nil, -- nil to use default put action
          },
          telescope = {
            use_default_mappings = true, -- if default mappings should be used
            mappings = nil, -- nil to use default mappings or no mappings (see `use_default_mappings`)
          },
        },
        system_clipboard = {
          sync_with_ring = true,
          clipboard_register = nil,
        },
        highlight = {
          on_put = true,
          on_yank = true,
          timer = 500,
        },
        preserve_cursor_position = {
          enabled = true,
        },
        textobj = {
         enabled = false,
        },
      }
      
      
      vim.keymap.set({"n","x"}, "p", "<Plug>(YankyPutAfter)")
      vim.keymap.set({"n","x"}, "P", "<Plug>(YankyPutBefore)")
      vim.keymap.set({"n","x"}, "gp", "<Plug>(YankyGPutAfter)")
      vim.keymap.set({"n","x"}, "gP", "<Plug>(YankyGPutBefore)")
      
      vim.keymap.set("n", "<c-p>", "<Plug>(YankyPreviousEntry)")
      vim.keymap.set("n", "<c-n>", "<Plug>(YankyNextEntry)")
      
      
      vim.keymap.set("n", "]p", "<Plug>(YankyPutIndentAfterLinewise)")
      vim.keymap.set("n", "[p", "<Plug>(YankyPutIndentBeforeLinewise)")
      vim.keymap.set("n", "]P", "<Plug>(YankyPutIndentAfterLinewise)")
      vim.keymap.set("n", "[P", "<Plug>(YankyPutIndentBeforeLinewise)")
      
      vim.keymap.set("n", ">p", "<Plug>(YankyPutIndentAfterShiftRight)")
      vim.keymap.set("n", "<p", "<Plug>(YankyPutIndentAfterShiftLeft)")
      vim.keymap.set("n", ">P", "<Plug>(YankyPutIndentBeforeShiftRight)")
      vim.keymap.set("n", "<P", "<Plug>(YankyPutIndentBeforeShiftLeft)")
      
      vim.keymap.set("n", "=p", "<Plug>(YankyPutAfterFilter)")
      vim.keymap.set("n", "=P", "<Plug>(YankyPutBeforeFilter)")
      
      
      vim.keymap.set("n", "<c-p>", "<Plug>(YankyPreviousEntry)")
      vim.keymap.set("n", "<c-n>", "<Plug>(YankyNextEntry)")
      
      
      require("yanky").setup({
        ring = {
          history_length = 100,
          storage = "shada",
          sync_with_numbered_registers = true,
          cancel_event = "update",
          ignore_registers = { "_" },
          update_register_on_cycle = false,
          permanent_wrapper = nil,
        },
        system_clipboard = {
          sync_with_ring = true,
        },
      })
      
      
      use({
        "gbprod/yanky.nvim",
        requires = { "kkharji/sqlite.lua" }
      })
      
      
      {
        "gbprod/yanky.nvim",
        opts = { },
        dependencies = { "folke/snacks.nvim" },
        keys = {
          {
            "<leader>p",
            function()
                Snacks.picker.yanky()
            end,
            mode = { "n", "x" },
            desc = "Open Yank History",
          },
        }
      }
      
      
      :lua require("telescope").load_extension("yank_history")
      
      
      :lua require("telescope").extensions.yank_history.yank_history()
      
      
      require("yanky").setup({
        picker = {
          select = {
            action = nil, -- nil to use default put action
          },
          telescope = {
            mappings = nil, -- nil to use default mappings
          },
        },
      })
      
      
      require("yanky.picker").actions.put("p") -- put after cursor
      require("yanky.picker").actions.put("P") -- put before cursor
      require("yanky.picker").actions.put("gp") -- put after cursor and leave the cursor after
      require("yanky.picker").actions.put("gP") -- put before cursor and leave the cursor after
      require("yanky.picker").actions.delete() -- delete entry from yank history
      require("yanky.picker").actions.set_register(regname) -- fill register with selected value
      require("yanky.picker").actions.put_and_set_register("p", regname) -- put and fill register with selected value
      
      
      local utils = require("yanky.utils")
      local mapping = require("yanky.telescope.mapping")
      
      require("yanky").setup({
        picker = {
          telescope = {
            mappings = {
              default = mapping.put("p"),
              i = {
                ["<c-g>"] = mapping.put("p"),
                ["<c-k>"] = mapping.put("P"),
                ["<c-x>"] = mapping.delete(),
                ["<c-r>"] = mapping.set_register(utils.get_default_register()),
              },
              n = {
                p = mapping.put("p"),
                P = mapping.put("P"),
                d = mapping.delete(),
                r = mapping.set_register(utils.get_default_register())
              },
            }
          }
        }
      })
      
      
      require("yanky.telescope.mapping").put("p") -- put after cursor
      require("yanky.telescope.mapping").put("P") -- put before cursor
      require("yanky.telescope.mapping").put("gp") -- put after cursor and leave the cursor after
      require("yanky.telescope.mapping").put("gP") -- put before cursor and leave the cursor after
      require("yanky.telescope.mapping").delete() -- delete entry from yank history
      require("yanky.telescope.mapping").set_register(regname) -- fill register {regname} with selected value
      
      
      require("yanky.telescope.mapping").special_put("{{ name of the special put }}")
      
      -- eg.
      require("yanky.telescope.mapping").special_put("YankyPutAfterCharwiseJoined")
      
      
      require("yanky").setup({
        highlight = {
          on_put = true,
          on_yank = true,
          timer = 500,
        },
      })
      
      
      vim.keymap.set({"n","x"}, "y", "<Plug>(YankyYank)")
      
      
      require("yanky").setup({
        preserve_cursor_position = {
          enabled = true,
        },
      })
      
      
      vim.keymap.set("n", "]p", "<Plug>(YankyPutIndentAfterLinewise)")
      vim.keymap.set("n", "[p", "<Plug>(YankyPutIndentBeforeLinewise)")
      vim.keymap.set("n", "]P", "<Plug>(YankyPutIndentAfterLinewise)")
      vim.keymap.set("n", "[P", "<Plug>(YankyPutIndentBeforeLinewise)")
      
      vim.keymap.set("n", ">p", "<Plug>(YankyPutIndentAfterShiftRight)")
      vim.keymap.set("n", "<p", "<Plug>(YankyPutIndentAfterShiftLeft)")
      vim.keymap.set("n", ">P", "<Plug>(YankyPutIndentBeforeShiftRight)")
      vim.keymap.set("n", "<P", "<Plug>(YankyPutIndentBeforeShiftLeft)")
      
      vim.keymap.set("n", "=p", "<Plug>(YankyPutAfterFilter)")
      vim.keymap.set("n", "=P", "<Plug>(YankyPutBeforeFilter)")
      
      
      require("yanky").setup({
        textobj = {
          enabled = false,
        },
      })
      
      
      vim.keymap.set({ "o", "x" }, "iy", function()
        require("yanky.textobj").last_put()
      end, {})
      
      
      require("substitute").setup({
        on_substitute = require("yanky.integration").substitute(),
      })
      
      
      opts = {
        on_substitute = function() require("yanky.integration").substitute() end,
      }
      
      
      local Hydra = require("hydra")
      
      local function t(str)
        return api.nvim_replace_termcodes(str, true, true, true)
      end
      
      local yanky_hydra = Hydra({
        name = "Yank ring",
        mode = "n",
        heads = {
          { "p", "<Plug>(YankyPutAfter)", { desc = "After" } },
          { "P", "<Plug>(YankyPutBefore)", { desc = "Before" } },
          { "<c-p>", "<Plug>(YankyPreviousEntry)", { private = true, desc = "↑" } },
          { "<c-n>", "<Plug>(YankyNextEntry)", { private = true, desc = "↓" } },
        },
      })
      
      -- choose/change the mappings if you want
      for key, putAction in pairs({
        ["p"] = "<Plug>(YankyPutAfter)",
        ["P"] = "<Plug>(YankyPutBefore)",
        ["gp"] = "<Plug>(YankyGPutAfter)",
        ["gP"] = "<Plug>(YankyGPutBefore)",
      }) do
        vim.keymap.set({ "n", "x" }, key, function()
          vim.fn.feedkeys(t(putAction))
          yanky_hydra:activate()
        end)
      end
      
      -- choose/change the mappings if you want
      for key, putAction in pairs({
        ["]p"] = "<Plug>(YankyPutIndentAfterLinewise)",
        ["[p"] = "<Plug>(YankyPutIndentBeforeLinewise)",
        ["]P"] = "<Plug>(YankyPutIndentAfterLinewise)",
        ["[P"] = "<Plug>(YankyPutIndentBeforeLinewise)",
      
        [">p"] = "<Plug>(YankyPutIndentAfterShiftRight)",
        ["<p"] = "<Plug>(YankyPutIndentAfterShiftLeft)",
        [">P"] = "<Plug>(YankyPutIndentBeforeShiftRight)",
        ["<P"] = "<Plug>(YankyPutIndentBeforeShiftLeft)",
      
        ["=p"] = "<Plug>(YankyPutAfterFilter)",
        ["=P"] = "<Plug>(YankyPutBeforeFilter)",
      }) do
        vim.keymap.set("n", key, function()
          vim.fn.feedkeys(t(putAction))
          yanky_hydra:activate()
        end)
      end
      
      
      require("yanky").setup({
        ring = {
          permanent_wrapper = require("yanky.wrappers").remove_carriage_return,
        },
      })
      
    end,
  },
  {
    "sQVe/sort.nvim",
    config = function()
      
      {
        'sQVe/sort.nvim',
        config = function()
          require('sort').setup({
            -- Optional configuration overrides.
          })
        end,
      }
      
      
      {
        -- Delimiter priority order.
        delimiters = {
          ',',
          '|',
          ';',
          ':',
          's', -- Space.
          't'  -- Tab.
        },
      
        -- Natural sorting (default: true).
        natural_sort = true,
      
        -- Case-insensitive sorting (default: false).
        ignore_case = false,
      
        -- Whitespace alignment threshold.
        whitespace = {
          alignment_threshold = 3,
        },
      
        -- Default keymappings (set to false to disable).
        mappings = {
          operator = 'go',
          textobject = {
            inner = 'io',
            around = 'ao',
          },
          motion = {
            next_delimiter = ']o',
            prev_delimiter = '[o',
          },
        },
      }
      
      
      require('sort').setup({
        natural_sort = false,
      })
      
      
      require('sort').setup({
        ignore_case = true,
      })
      
      
      require('sort').setup({
        mappings = {
          operator = 'gs',
          textobject = {
            inner = 'ii',
            around = 'ai',
          },
          motion = {
            next_delimiter = ']d',
            prev_delimiter = '[d',
          },
        },
      })
      
      
      require('sort').setup({
        mappings = {
          operator = false,
          textobject = false,
          motion = false,
        },
      })
      
    end,
  },
  {
    "booperlv/nvim-gomove",
    config = function()
      
      require("gomove").setup {
        -- whether or not to map default key bindings, (true/false)
        map_defaults = true,
        -- whether or not to reindent lines moved vertically (true/false)
        reindent = true,
        -- whether or not to undojoin same direction moves (true/false)
        undojoin = true,
        -- whether to not to move past end column when moving blocks horizontally, (true/false)
        move_past_end_col = false,
      }
      
      
      local map = vim.api.nvim_set_keymap
      
      map( "n", "<S-h>", "<Plug>GoNSMLeft", {} )
      map( "n", "<S-j>", "<Plug>GoNSMDown", {} )
      map( "n", "<S-k>", "<Plug>GoNSMUp", {} )
      map( "n", "<S-l>", "<Plug>GoNSMRight", {} )
      
      map( "x", "<S-h>", "<Plug>GoVSMLeft", {} )
      map( "x", "<S-j>", "<Plug>GoVSMDown", {} )
      map( "x", "<S-k>", "<Plug>GoVSMUp", {} )
      map( "x", "<S-l>", "<Plug>GoVSMRight", {} )
      
      map( "n", "<C-h>", "<Plug>GoNSDLeft", {} )
      map( "n", "<C-j>", "<Plug>GoNSDDown", {} )
      map( "n", "<C-k>", "<Plug>GoNSDUp", {} )
      map( "n", "<C-l>", "<Plug>GoNSDRight", {} )
      
      map( "x", "<C-h>", "<Plug>GoVSDLeft", {} )
      map( "x", "<C-j>", "<Plug>GoVSDDown", {} )
      map( "x", "<C-k>", "<Plug>GoVSDUp", {} )
      map( "x", "<C-l>", "<Plug>GoVSDRight", {} )
      
    end,
  },
  {
    "hinell/duplicate.nvim",
    config = function()
      
      packer.setup(function(use)
          use({
              "hinell/duplicate.nvim",
              setup = function()
                  vim.g["duplicate-nvim-config"] = {
                      visual = {
                          selectAfter = true, -- true to select duplicated text
                          block       = true  -- true to enable block-wise duplication
                      }
                  }
              end
          })
      end)
      
      
      require("lazy").setup(
          { "hinell/duplicate.nvim" },
      	dependencies={ }
      )
      
    end,
  },
  {
    "hinell/move.nvim",
    config = function()
      
      "hinell/move.nvim"
      
    end,
  },
  {
    "willothy/moveline.nvim",
    config = function()
      
      {
          'willothy/moveline.nvim',
          build = 'make',
      }
      
      
      use('willothy/moveline', { run = 'make' })
      
      
      local moveline = require('moveline')
      vim.keymap.set('n', '<M-k>', moveline.up)
      vim.keymap.set('n', '<M-j>', moveline.down)
      vim.keymap.set('v', '<M-k>', moveline.block_up)
      vim.keymap.set('v', '<M-j>', moveline.block_down)
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-move.md",
  },
  {
    "anuvyklack/pretty-fold.nvim",
    config = function()
      
      use{ 'anuvyklack/pretty-fold.nvim',
         config = function()
            require('pretty-fold').setup()
         end
      }
      
      
      config = {
         sections = {
            left = {
               'content',
            },
            right = {
               ' ', 'number_of_folded_lines', ': ', 'percentage', ' ',
               function(config) return config.fill_char:rep(3) end
            }
         },
         fill_char = '•',
      
         remove_fold_markers = true,
      
         -- Keep the indentation of the content of the fold string.
         keep_indentation = true,
      
         -- Possible values:
         -- "delete" : Delete all comment signs from the fold string.
         -- "spaces" : Replace all comment signs with equal number of spaces.
         -- false    : Do nothing with comment signs.
         process_comment_signs = 'spaces',
      
         -- Comment signs additional to the value of `&commentstring` option.
         comment_signs = {},
      
         -- List of patterns that will be removed from content foldtext section.
         stop_words = {
            '@brief%s*', -- (for C++) Remove '@brief' and all spaces after.
         },
      
         add_close_pattern = true, -- true, 'last_line' or false
      
         matchup_patterns = {
            {  '{', '}' },
            { '%(', ')' }, -- % to escape lua pattern char
            { '%[', ']' }, -- % to escape lua pattern char
         },
      
         ft_ignore = { 'neorg' },
      }
      
      
      require('pretty-fold').setup {
         custom_function_arg = 'Hello from inside custom function!',
         sections = {
            left = {
               function(config)
                  return config.custom_function_arg
               end
            },
         }
      }
      
      
      comment_signs = {
          { '--[[', '--]]' }, -- multiline comment
      }
      
      
      comment_signs = { '//' }
      
      
      matchup_patterns = {
         -- ╟─ Start of line ──╭───────╮── "do" ── End of line ─╢
         --                    ╰─ WSP ─╯
         { '^%s*do$', 'end' }, -- `do ... end` blocks
      
         -- ╟─ Start of line ──╭───────╮── "if" ─╢
         --                    ╰─ WSP ─╯
         { '^%s*if', 'end' },
      
         -- ╟─ Start of line ──╭───────╮── "for" ─╢
         --                    ╰─ WSP ─╯
         { '^%s*for', 'end' },
      
         -- ╟─ "function" ──╭───────╮── "(" ─╢
         --                 ╰─ WSP ─╯
         { 'function%s*%(', 'end' }, -- 'function(' or 'function ('
      
         {  '{', '}' },
         { '%(', ')' }, -- % to escape lua pattern char
         { '%[', ']' }, -- % to escape lua pattern char
      },
      
      
         require('pretty-fold').setup(config: table)
         
      
         require('pretty-fold').ft_setup(filtype: string, config: table)
         
      
      require('pretty-fold').ft_setup('lua', {
         matchup_patterns = {
            { '^%s*do$', 'end' }, -- do ... end blocks
            { '^%s*if', 'end' },  -- if ... end
            { '^%s*for', 'end' }, -- for
            { 'function%s*%(', 'end' }, -- 'function( or 'function (''
            {  '{', '}' },
            { '%(', ')' }, -- % to escape lua pattern char
            { '%[', ']' }, -- % to escape lua pattern char
         },
      }
      
      
      require('pretty-fold').setup({
          global = {...}, -- global config table for all foldmethods
          marker = { process_comment_signs = 'spaces' },
          expr   = { process_comment_signs = false },
      })
      
      
      require('pretty-fold').setup{
         keep_indentation = false,
         fill_char = '•',
         sections = {
            left = {
               '+', function() return string.rep('-', vim.v.foldlevel) end,
               ' ', 'number_of_folded_lines', ':', 'content',
            }
         }
      }
      
      
      require('pretty-fold').setup{
         keep_indentation = false,
         fill_char = '━',
         sections = {
            left = {
               '━ ', function() return string.rep('*', vim.v.foldlevel) end, ' ━┫', 'content', '┣'
            },
            right = {
               '┫ ', 'number_of_folded_lines', ': ', 'percentage', ' ┣━━',
            }
         }
      }
      
      
      require('pretty-fold').ft_setup('cpp', {
         process_comment_signs = false,
         comment_signs = {
            '/**', -- C++ Doxygen comments
         },
         stop_words = {
            -- ╟─ "*" ──╭───────╮── "@brief" ──╭───────╮──╢
            --          ╰─ WSP ─╯              ╰─ WSP ─╯
            '%*%s*@brief%s*',
         },
      })
      
      
      vim.opt.fillchars:append('fold:•')
      
    end,
  },
  {
    "bennypowers/nvim-regexplainer",
    config = function()
      
      use { 'bennypowers/nvim-regexplainer',
            config = function() require'regexplainer'.setup() end,
            requires = {
              'nvim-treesitter/nvim-treesitter',
              'MunifTanjim/nui.nvim',
            } }
      
      
      -- defaults
      require'regexplainer'.setup {
        -- 'narrative', 'graphical'
        mode = 'narrative',
      
        -- automatically show the explainer when the cursor enters a regexp
        auto = false,
      
        -- filetypes (i.e. extensions) in which to run the autocommand
        filetypes = {
          'html',
          'js',
          'cjs',
          'mjs',
          'ts',
          'jsx',
          'tsx',
          'cjsx',
          'mjsx',
        },
      
        -- Whether to log debug messages
        debug = false,
      
        -- 'split', 'popup'
        display = 'popup',
      
        mappings = {
          toggle = 'gR',
          -- examples, not defaults:
          -- show = 'gS',
          -- hide = 'gH',
          -- show_split = 'gP',
          -- show_popup = 'gU',
        },
      
        narrative = {
          indendation_string = '> ', -- default '  '
        },
      
        graphical = {
          width = 800,        -- image width in pixels
          height = 600,       -- image height in pixels  
          python_cmd = nil,   -- python command (auto-detected)
        },
      
        deps = {
          auto_install = true,    -- automatically install Python dependencies
          python_cmd = nil,       -- python command (auto-detected)
          venv_path = nil,        -- virtual environment path (auto-generated)
          check_interval = 3600,  -- dependency check interval in seconds
        },
      }
      
      
      require'regexplainer'.show { display = 'split' }
      
      
      require'regexplainer'.show {
        display = 'popup',
        popup = {
          border = {
            padding = { 1, 2 },
            style = 'solid',
          },
        },
      }
      
      
      narrative = {
        indentation_string = function(component)
          return component.capture_depth .. '>  '
        end
      },
      
      
      require'regexplainer'.yank'+'
      
      
      require'regexplainer'.yank { register = '+' }
      
      
      require'regexplainer'.setup {
        mode = 'graphical',
        -- Both popup and split modes work with graphical display
        display = 'popup', -- or 'split'
        
        graphical = {
          -- Optional: customize image generation
          generation_width = 1200,   -- Initial generation width (default: 1200)
          generation_height = 800,   -- Initial generation height (default: 800)
        },
        
        deps = {
          auto_install = true, -- automatically install Python dependencies
        },
      }
      
      
      require'regexplainer'.setup {
        mode = 'graphical',
        deps = {
          auto_install = false,
          python_cmd = 'python3', -- specify Python executable
          venv_path = '/custom/path', -- custom virtual environment path
        },
      }
      
    end,
  },
  {
    "gbprod/stay-in-place.nvim",
    config = function()
      
      -- Lua
      use({
        "gbprod/stay-in-place.nvim",
        config = function()
          require("stay-in-place").setup({
            -- your configuration comes here
            -- or leave it empty to use the default settings
            -- refer to the configuration section below
          })
        end
      })
      
      
      {
        set_keymaps = true,
        preserve_visual_selection = true,
      }
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-ai.md",
  },
  {
    "Wansmer/treesj",
    config = function()
      
      return {
        'Wansmer/treesj',
        keys = { '<space>m', '<space>j', '<space>s' },
        dependencies = { 'nvim-treesitter/nvim-treesitter' }, -- if you install parsers with `nvim-treesitter`
        config = function()
          require('treesj').setup({--[[ your config ]]})
        end,
      }
      
      
      use({
        'Wansmer/treesj',
        requires = { 'nvim-treesitter/nvim-treesitter' }, -- if you install parsers with `nvim-treesitter`
        config = function()
          require('treesj').setup({--[[ your config ]]})
        end,
      })
      
      
      local tsj = require('treesj')
      
      local langs = {--[[ configuration for languages ]]}
      
      tsj.setup({
        ---@type boolean Use default keymaps (<space>m - toggle, <space>j - join, <space>s - split)
        use_default_keymaps = true,
        ---@type boolean Node with syntax error will not be formatted
        check_syntax_error = true,
        ---If line after join will be longer than max value,
        ---@type number If line after join will be longer than max value, node will not be formatted
        max_join_length = 120,
        ---Cursor behavior:
        ---hold - cursor follows the node/place on which it was called
        ---start - cursor jumps to the first symbol of the node being formatted
        ---end - cursor jumps to the last symbol of the node being formatted
        ---@type 'hold'|'start'|'end'
        cursor_behavior = 'hold',
        ---@type boolean Notify about possible problems or not
        notify = true,
        ---@type boolean Use `dot` for repeat action
        dot_repeat = true,
        ---@type nil|function Callback for treesj error handler. func (err_text, level, ...other_text)
        on_error = nil,
        ---@type table Presets for languages
        -- langs = {}, -- See the default presets in lua/treesj/langs
      })
      
      
      -- For default preset
      vim.keymap.set('n', '<leader>m', require('treesj').toggle)
      -- For extending default preset with `recursive = true`
      vim.keymap.set('n', '<leader>M', function()
          require('treesj').toggle({ split = { recursive = true } })
      end)
      
      
      local langs = {
        javascript = {
          array = {--[[ preset ]]},
          object = {--[[ preset ]]}
          ['function'] = { target_nodes = {--[[ targets ]]}}
        },
      }
      
      
      local node_type = {
        -- `both` will be merged with both presets from `split` and `join` modes tables.
        -- If you need different values for different modes, they can be overridden
        -- in mode tables unless otherwise noted.
        both = {
          ---If a node contains descendants with a type from the list, it will not be formatted
          ---@type string[]
          no_format_with = { 'comment' },
          ---Separator for arrays, objects, hash e.c.t. (usually ',')
          ---@type string
          separator = '',
          ---Set last separator or not
          ---@type boolean
          last_separator = false,
          ---If true, empty brackets, empty tags, or node which only contains nodes from 'omit' no will handling
          ---@type boolean
          format_empty_node = true,
          ---All nested configured nodes will process according to their presets
          ---@type boolean
          recursive = true,
          ---Type of configured node that must be ignored
          ---@type string[]
          recursive_ignore = {},
      
          --[[ Working with the options below is explained in detail in `advanced node configuration` section. ]]
          ---Set `false` if node should't be splitted or joined.
          ---@type boolean|function For function: function(tsnode: TSNode): boolean
          enable = true,
          ---@type function|nil function(tsj: TreeSJ): void
          format_tree = nil,
          ---@type function|nil function(lines: string[], tsn?: TSNode): string[]
          format_resulted_lines = nil,
          ---Passes control to an external script and terminates treesj execution.
          ---@type function|nil function(node: TSNode): void
          fallback = nil,
      
          --[[ The options below should be the same for both modes. ]]
          ---The text of the node will be merged with the previous one, without wrapping to a new line
          ---@type table List-like table with types 'string' (type of node) or 'function' (function(child: TreeSJ): boolean).
          omit = {},
          ---Non-bracket nodes (e.g., with 'then|()' ... 'end' instead of { ... }|< ... >|[ ... ])
          ---If value is table, should be contains follow keys: { left = 'text', right = 'text' }. Empty string uses by default
          ---@type boolean|table
          non_bracket_node = false,
          ---If you need to process only nodes in the range from / to.
          ---If `shrink_node` is present, `non_bracket_node` will be ignored
          ---Learn more in advanced node configuration
          ---@type table|nil
          shrink_node = nil,
          -- shrink_node = { from = string, to = string },
        },
        -- Use only for join. If contains field from 'both',
        -- field here have higher priority
        join = {
          ---Adding space in framing brackets or last/end element
          ---@type boolean
          space_in_brackets = false,
          ---Insert space between nodes or not
          ---@type boolean
          space_separator = true,
          ---Adds instruction separator like ';' in statement block.
          ---It's not the same as `separator`: `separator` is a separate node, `force_insert` is a last symbol of code instruction.
          ---@type string
          force_insert = '',
          ---The `force_insert` symbol will be omitted if the type of node contains in this list
          -- (e.g. function_declaration inside statement_block in JS no require instruction separator (';'))
          ---@type table List-like table with types 'string' (type of node) or 'function' (function(child: TreeSJ): boolean).
          no_insert_if = {},
        },
        -- Use only for split. If contains field from 'both',
        -- field here have higher priority
        split = {
          ---All nested configured nodes will process according to their presets
          ---@type boolean
          recursive = false,
          ---Which indent must be on the last line of the formatted node.
          --- 'normal' – indent equals of the indent from first line;
          --- 'inner' – indent, like all inner nodes (indent of start line of node + vim.fn.shiftwidth()).
          ---@type 'normal'|'inner'
          last_indent = 'normal',
          ---Which indent must be on the last line of the formatted node.
          --- 'normal' – indent equals of the indent from first line;
          --- 'inner' – indent, like all inner nodes (indent of start line of node + vim.fn.shiftwidth()).
          ---@type 'normal'|'inner'
          inner_indent = 'inner',
        },
        ---If 'true', node will be completely removed from langs preset
        ---@type boolean
        disable = false,
        ---TreeSJ will search child from list into this node and redirect to found child
        ---If list not empty, another fields (split, join) will be ignored
        ---@type string[]|table See `advanced node configuration`
        target_nodes = {},
      }
      
      
      local lang_utils = require('treesj.langs.utils')
      
      local langs = {
        javascript = {
          object = lang_utils.set_preset_for_dict(),
          array = lang_utils.set_preset_for_list(),
          formal_parameters = lang_utils.set_preset_for_args(),
          arguments = lang_utils.set_preset_for_args(),
          statement_block = lang_utils.set_preset_for_statement({
            join = {
              no_insert_if = {
                'function_declaration',
                'try_statement',
                'if_statement',
              },
            },
          }),
        },
        lua = {
          table_constructor = lang_utils.set_preset_for_dict(),
          arguments = lang_utils.set_preset_for_args(),
          parameters = lang_utils.set_preset_for_args(),
        },
      }
      
      
      local tsj_utils = require('treesj.langs.utils')
      local css = require('treesj.langs.css')
      
      local langs = {
        scss = tsj_utils.merge_preset(css, {--[[
          Here you can override existing nodes
          or add language-specific nodes
      ]]})
      }
      
      
      local go = {
        import_spec = lang_utils.set_preset_for_args({
          both = {
            -- If the parent is a 'import_spec_list', then skip this node and
            -- look for a suitable one for formatting further
            enable = function(tsn)
              return tsn:parent():type() ~= 'import_spec_list'
            end,
          },
          split = {
            -- If the parent was something else, then wrap the import in parentheses,
            -- which actually converts the 'import_spec' into the 'import_spec_list'
            format_tree = function(tsj)
              tsj:wrap({ left = '(', right = ')' })
            end,
          },
        }),
        import_spec_list = lang_utils.set_preset_for_args({
          join = {
            enable = function(tsn)
              -- If the node contains more than one named child node, then disable
              return tsn:named_child_count() < 2
            end,
            format_tree = function(tsj)
              -- If there was only one named element, then remove the brackets
              tsj:remove_child({ '(', ')' })
            end,
          },
        }),
      }
      
      
      ruby = {
        module = {
          both = {
            no_format_with = {}, -- Need to avoid 'no format with comment'
            fallback = function(_)
              vim.cmd('SplitjoinJoin')
            end,
          },
        },
        class = {
          both = {
            no_format_with = {},
            fallback = function(_)
              vim.cmd('SplitjoinSplit')
            end,
          },
        },
      },
      
      
      local lang_utils = require('treesj.langs.utils')
      
      local kotlin = {
        statements = lang_utils.set_preset_for_non_bracket({
          join = {
            force_insert = ';',
            no_insert_if = {
              lang_utils.no_insert.if_penultimate,
            },
          },
        }),
      }
      
      
      -- `block` in Lua does not have parentheses, but when it joins,
      -- it must jump up a line and pull an `end` node that is not part of it.
      -- To do this, you need to create imitators of framing nodes one line above
      -- and one line below
                     | -- imitator left-side bracket
      function test()|
        | -- real start of `block`
        |print(123)
        return 123| -- real end of `block`
      | -- imitator right-side bracket
      |end
      
      -- from
      function test()
        print(123)
        return 123
      end
      
      -- to and back
      function test() print(123) return 123 end
      
      
      local lang_utils = require('treesj.langs.utils')
      
      local lua = {
        block = {
          both = {
            non_bracket_node = true,
            -- non_bracket_node = { left = '', right = '' }, - it is similar
          },
          join = {
            space_in_brackets = true,
          },
        },
      }
      
      
      {
        function_declaration = lang_utils.set_preset_for_args({
          both = {
            non_bracket_node = true,
            shrink_node = { from = '(', to = ')' },
          },
        }),
      }
      
      
      -- these values are equivalent
      target_nodes = { 'block', 'statement' }
      target_nodes = { ['block'] = 'block', ['statement'] = 'statement' }
      
      
      {
        block = lang_utils.set_preset_for_statement(),
        my_custom_preset_for_block_inside_fun_dec = {--[[ another preset ]]}
        function_declaration = {
            target_nodes = { ['block'] = 'my_custom_preset_for_block_inside_fun_dec' }
        }
      }
      
      
      local rust = {
        match_arm = {
          target_nodes = { 'value' },
        },
        value = lang_utils.set_preset_for_statement({
          split = {
            format_tree = function(tsj)
              if tsj:type() ~= 'block' then
                tsj:wrap({ left = '{', right = '}' })
              end
            end,
          },
          join = {
            no_insert_if = { lang_utils.helpers.if_penultimate },
            format_tree = function(tsj)
              local node = tsj:tsnode()
              local parents = { 'match_arm', 'closure_expression' }
              local has_parent = vim.tbl_contains(parents, node:parent():type())
              if has_parent and node:named_child_count() == 1 then
                tsj:remove_child({ '{', '}' })
              end
            end,
          },
        }),
      }
      
      
      local python = {
        import_from_statement = lang_utils.set_preset_for_args({
          both = {
            -- There is no need to wrap the second element, the 'import' node,
            -- and the first parenthesis, which does not already exist.
            omit = { lang_utils.omit.if_second, 'import', ' (' },
          },
          split = {
            last_separator = true,
            format_tree = function(tsj)
              -- If there are no brackets, then create them
              if not tsj:has_children({ '(', ')' }) then
                tsj:create_child({ text = ' (' }, 4)
                tsj:create_child({ text = ')' }, #tsj:children() + 1)
                -- Since the elements have moved, you need to add the penultimate
                -- separator manually
                local penult = tsj:child(-2)
                penult:update_text(penult:text() .. ',')
              end
            end,
          },
          join = {
            format_tree = function(tsj)
              -- Remove brackets
              tsj:remove_child({ '(', ')' })
            end,
          },
        }),
      }
      
      
      -- base node
      local dict = { one = 'one', two = 'two' }
      
      -- array of string for replacement is { "{", "    one = 'one',", "    two = 'two',", "}" }
      
      -- base node after format
      local dict = {
          one = 'one',
          two = 'two',
      }
      
      
      
      local ruby = {
        conditional = lang_utils.set_default_preset({
          join = { enable = false },
          split = {
            omit = { lang_utils.omit.if_second },
            format_tree = function(tsj)
              local children = tsj:children()
              table.insert(children, tsj:create_child({ text = 'end', type = 'end' }))
              tsj:child('?'):update_text('if ')
              tsj:child(':'):update_text('else')
              local first, second = tsj:child(1), tsj:child(2)
              children[1] = second
              children[2] = first
              tsj:update_children(children)
            end,
            format_resulted_lines = function(lines)
              return vim.tbl_map(function(line)
                -- Need to remove one indent on `else` element
                if line:match('%s.else$') then
                  local rgx = '^' .. (' '):rep(vim.fn.shiftwidth())
                  return line:gsub(rgx, '')
                else
                  return line
                end
              end, lines)
            end,
          },
        }),
      }
      
      
      ---@param types? string[]
      ---@return boolean
      function TreeSJ:has_children(types)
      
      
      ---@return function, table
      function TreeSJ:iter_children()
      
      
      ---@param types? string[] List-like table with child's types for filtering
      ---@return TreeSJ[]
      function TreeSJ:children(types)
      
      
      ---@return TreeSJ TreeSJ instance
      function TreeSJ:root()
      
      
      ---@return TreeSJ|nil
      function TreeSJ:parent()
      
      
      ---@param type_or_index number|string Type of TreeSJ child or it index in children list
      ---@return TreeSJ|nil
      function TreeSJ:child(type_or_index)
      
      
      ---@param data table { text = string, type? = string }. If `type` not present, uses value of `text`
      ---@param index? integer Index where the child should be inserted.
      ---@return TreeSJ|nil
      function TreeSJ:create_child(data, index)
      
      
      ---@param children TreeSJ[]
      function TreeSJ:update_children(children)
      
      
      -- When a function should be called
      local children = tsj:children()
      local child = tsj:create_child({ text = 'end' })
      table.insert(children, child)
      tsj:update_children(children) -- important
      
      -- Here it is not necessary
      tsj:create_child({ text = 'end' }, #tsj:children() + 1)
      
      
      ---@param types_or_index string|string[]|integer Type, types, or index of child to remove
      function TreeSJ:remove_child(types_or_index)
      
      
      ---@param data table { left = string, right = string }
      ---@param mode? 'wrap'|'inline' 'wrap' by default
      function TreeSJ:wrap(data, mode)
      
      
      ---@param index1 integer
      ---@param index2 integer
      function TreeSJ:swap_children(index1, index2)
      
      
      ---@return TSNode|table TSNode or TSNode imitator
      function TreeSJ:tsnode()
      
      
      ---@return TreeSJ|nil
      function TreeSJ:prev()
      
      
      ---@return TreeSJ|nil
      function TreeSJ:next()
      
      
      ---@return string
      function TreeSJ:type()
      
      
      ---@return string|table
      function TreeSJ:text()
      
      
      ---@param new_text string|string[]
      function TreeSJ:update_text(new_text)
      
      
      {
        format_tree = function(tsj)
          if tsj:type() ~= 'statement_block' then
            -- ...
            local body = tsj:child(2)
            if body:will_be_formatted() then
              local set_return
              if body:has_preset('split') then
                set_return = body:child(1)
              else
                set_return = body:child(1):child(1)
              end
              set_return:update_text('return ' .. set_return:text())
            else
              body:update_text('return ' .. body:text())
            end
            -- ...
          end
        end,
      }
      
      
      ---@return boolean
      function TreeSJ:will_be_formatted()
      
      
      ---@return boolean
      function TreeSJ:is_ignore()
      
      
      ---@return boolean
      function TreeSJ:has_to_format()
      
      
      ---@return boolean
      function TreeSJ:is_first()
      
      
      ---@return boolean
      function TreeSJ:is_last()
      
      
      ---@return boolean
      function TreeSJ:is_framing()
      
      
      ---@return boolean
      function TreeSJ:is_omit()
      
      
      ---@return boolean
      function TreeSJ:is_imitator()
      
      
      ---@param mode? 'split'|'join' Current mode (split|join)
      ---@return table|nil
      function TreeSJ:preset(mode)
      
      
      ---@param mode? 'split'|'join' Current mode (split|join)
      ---@return table|nil
      function TreeSJ:parent_preset(mode)
      
      
      ---@param new_preset table
      ---@param mode? 'split'|'join'
      function TreeSJ:update_preset(new_preset, mode)
      
    end,
  },
  {
    "bennypowers/splitjoin.nvim",
    config = function()
      
      return { 'bennypowers/splitjoin.nvim',
        lazy = true,
        keys = {
          { 'gj', function() require'splitjoin'.join() end, desc = 'Join the object under cursor' },
          { 'g,', function() require'splitjoin'.split() end, desc = 'Split the object under cursor' },
        },
      }
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-splitjoin.md",
  },
  {
    "shortcuts/no-neck-pain.nvim",
    config = function()
      
      -- stable version
      use {"shortcuts/no-neck-pain.nvim", tag = "*" }
      -- dev version
      use {"shortcuts/no-neck-pain.nvim"}
      
      
      -- stable version
      Plug 'shortcuts/no-neck-pain.nvim', { 'tag': '*' }
      -- dev version
      Plug 'shortcuts/no-neck-pain.nvim'
      
      
      -- stable version
      require("lazy").setup({{"shortcuts/no-neck-pain.nvim", version = "*"}})
      -- dev version
      require("lazy").setup({"shortcuts/no-neck-pain.nvim"})
      
      
      require("no-neck-pain").setup({
          -- Prints useful logs about triggered events, and reasons actions are executed.
          ---@type boolean
          debug = false,
          -- The width of the focused window that will be centered. When the terminal width is less than the `width` option, the side buffers won't be created.
          ---@type integer|"textwidth"|"colorcolumn"
          width = 100,
          -- Represents the lowest width value a side buffer should be.
          -- This option can be useful when switching window size frequently, example:
          -- in full screen screen, width is 210, you define an NNP `width` of 100, which creates each side buffer with a width of 50. If you resize your terminal to the half of the screen, each side buffer would be of width 5 and thereforce might not be useful and/or add "noise" to your workflow.
          ---@type integer
          minSideBufferWidth = 10,
          -- Disables the plugin if the last valid buffer in the list have been closed.
          ---@type boolean
          disableOnLastBuffer = false,
          -- When `true`, disabling the plugin closes every other windows except the initially focused one.
          ---@usage: this parameter will be renamed `killAllWindowsOnDisable` in the next major release (^2.x.y).
          ---@type boolean
          killAllBuffersOnDisable = false,
          -- When `true`, deleting the main no-neck-pain buffer with `:bd`, `:bdelete` does not disable the plugin, it fallbacks on the newly focused window and refreshes the state by re-creating side-windows if necessary.
          ---@type boolean
          fallbackOnBufferDelete = true,
          -- Adds autocmd (@see `:h autocmd`) which aims at automatically enabling the plugin.
          ---@type table
          autocmds = {
              -- When `true`, enables the plugin when you start Neovim.
              -- If the main window is  a side tree (e.g. NvimTree) or a dashboard, the command is delayed until it finds a valid window.
              -- The command is cleaned once it has successfuly ran once.
              -- When `safe`, debounces the plugin before enabling it.
              -- This is recommended if you:
              --  - use a dashboard plugin, or something that also triggers when Neovim is entered.
              --  - usually leverage commands such as `nvim +line file` which are executed after Neovim has been entered.
              ---@type boolean | "safe"
              enableOnVimEnter = false,
              -- When `true`, enables the plugin when you enter a new Tab.
              -- note: it does not trigger if you come back to an existing tab, to prevent unwanted interfer with user's decisions.
              ---@type boolean
              enableOnTabEnter = false,
              -- When `true`, reloads the plugin configuration after a colorscheme change.
              ---@type boolean
              reloadOnColorSchemeChange = false,
              -- When `true`, entering one of no-neck-pain side buffer will automatically skip it and go to the next available buffer.
              ---@type boolean
              skipEnteringNoNeckPainBuffer = false,
          },
          -- Creates mappings for you to easily interact with the exposed commands.
          ---@type table
          mappings = {
              -- When `true`, creates all the mappings that are not set to `false`.
              ---@type boolean
              enabled = false,
              -- Sets a global mapping to Neovim, which allows you to toggle the plugin.
              -- When `false`, the mapping is not created.
              ---@type string
              toggle = "<Leader>np",
              -- Sets a global mapping to Neovim, which allows you to toggle the left side buffer.
              -- When `false`, the mapping is not created.
              ---@type string
              toggleLeftSide = "<Leader>nql",
              -- Sets a global mapping to Neovim, which allows you to toggle the right side buffer.
              -- When `false`, the mapping is not created.
              ---@type string
              toggleRightSide = "<Leader>nqr",
              -- Sets a global mapping to Neovim, which allows you to increase the width (+5) of the main window.
              -- When `false`, the mapping is not created.
              ---@type string | { mapping: string, value: number }
              widthUp = "<Leader>n=",
              -- Sets a global mapping to Neovim, which allows you to decrease the width (-5) of the main window.
              -- When `false`, the mapping is not created.
              ---@type string | { mapping: string, value: number }
              widthDown = "<Leader>n-",
              -- Sets a global mapping to Neovim, which allows you to toggle the scratchPad feature.
              -- When `false`, the mapping is not created.
              ---@type string
              scratchPad = "<Leader>ns",
          },
          --- Allows you to provide custom code to run before (pre) and after (post) no-neck-pain steps (e.g. enabling).
          --- See |NoNeckPain.callbacks|
          ---@type table
          callbacks = {
              -- Runs right before centering the buffer
              ---@type fun(state: { enabled: boolean, active_tab: number, tabs: number[], disabled_tabs: number[], previously_focused_win: number })|nil
              preEnable = nil,
              -- Runs right after the buffer is centered
              ---@type fun(state: { enabled: boolean, active_tab: number, tabs: number[], disabled_tabs: number[], previously_focused_win: number })|nil
              postEnable = nil,
              -- Runs right before toggling NoNeckPain off
              ---@type fun(state: { enabled: boolean, active_tab: number, tabs: number[], disabled_tabs: number[], previously_focused_win: number })|nil
              preDisable = nil,
              -- Runs right after NoNeckPain has been turned off
              ---@type fun(state: { enabled: boolean, active_tab: number, tabs: number[], disabled_tabs: number[], previously_focused_win: number })|nil
              postDisable = nil,
          },
          --- Common options that are set to both side buffers.
          --- See |NoNeckPain.bufferOptions| for option scoped to the `left` and/or `right` buffer.
          ---@type table
          buffers = {
              -- When `true`, the side buffers will be named `no-neck-pain-left` and `no-neck-pain-right` respectively.
              ---@type boolean
              setNames = false,
              -- Leverages the side buffers as notepads, which work like any Neovim buffer and automatically saves its content at the given `location`.
              -- note: quitting an unsaved scratchPad buffer is non-blocking, and the content is still saved.
              --- see |NoNeckPain.bufferOptionsScratchPad|
              scratchPad = NoNeckPain.bufferOptionsScratchPad,
              -- colors to apply to both side buffers, for buffer scopped options @see |NoNeckPain.bufferOptions|
              --- see |NoNeckPain.bufferOptionsColors|
              colors = NoNeckPain.bufferOptionsColors,
              -- Vim buffer-scoped options: any `vim.bo` options is accepted here.
              ---@see NoNeckPain.bufferOptionsBo `:h NoNeckPain.bufferOptionsBo`
              bo = NoNeckPain.bufferOptionsBo,
              -- Vim window-scoped options: any `vim.wo` options is accepted here.
              ---@see NoNeckPain.bufferOptionsWo `:h NoNeckPain.bufferOptionsWo`
              wo = NoNeckPain.bufferOptionsWo,
              --- Options applied to the `left` buffer, options defined here overrides the `buffers` ones.
              ---@see NoNeckPain.bufferOptions `:h NoNeckPain.bufferOptions`
              left = NoNeckPain.bufferOptions,
              --- Options applied to the `right` buffer, options defined here overrides the `buffers` ones.
              ---@see NoNeckPain.bufferOptions `:h NoNeckPain.bufferOptions`
              right = NoNeckPain.bufferOptions,
          },
          -- Supported integrations that might clash with `no-neck-pain.nvim`'s behavior.
          --
          -- The `position` is used when the plugin scans the layout in order to compute the width that should be added
          -- on each side. For example, if you were supposed to have a padding of 100 columns on each side, but an
          -- integration takes 42, only 58 will be added so your layout is still centered.
          --
          -- If `reopen` is set to `false`, we won't account the width but close the integration when encountered.
          ---@type table
          integrations = {
              -- @link https://github.com/nvim-tree/nvim-tree.lua
              ---@type table
              NvimTree = {
                  -- The position of the tree.
                  ---@type "left"|"right"
                  position = "left",
                  -- When `true`, if the tree was opened before enabling the plugin, we will reopen it.
                  ---@type boolean
                  reopen = true,
              },
              -- @link https://github.com/nvim-neo-tree/neo-tree.nvim
              NeoTree = {
                  -- The position of the tree.
                  ---@type "left"|"right"
                  position = "left",
                  -- When `true`, if the tree was opened before enabling the plugin, we will reopen it.
                  reopen = true,
              },
              -- @link https://github.com/mbbill/undotree
              undotree = {
                  -- The position of the tree.
                  ---@type "left"|"right"
                  position = "left",
              },
              -- @link https://github.com/nvim-neotest/neotest
              neotest = {
                  -- The position of the tree.
                  ---@type "right"
                  position = "right",
                  -- When `true`, if the tree was opened before enabling the plugin, we will reopen it.
                  reopen = true,
              },
              -- @link https://github.com/nvim-treesitter/playground
              TSPlayground = {
                  -- The position of the tree.
                  ---@type "right"|"left"
                  position = "right",
                  -- When `true`, if the tree was opened before enabling the plugin, we will reopen it.
                  reopen = true,
              },
              -- @link https://github.com/rcarriga/nvim-dap-ui
              NvimDAPUI = {
                  -- The position of the tree.
                  ---@type "none"
                  position = "none",
                  -- When `true`, if the tree was opened before enabling the plugin, we will reopen it.
                  reopen = true,
              },
              -- @link https://github.com/hedyhli/outline.nvim
              outline = {
                  -- The position of the tree.
                  ---@type "left"|"right"
                  position = "right",
                  -- When `true`, if the tree was opened before enabling the plugin, we will reopen it.
                  reopen = true,
              },
              -- @link https://github.com/stevearc/aerial.nvim
              aerial = {
                  -- The position of the tree.
                  ---@type "left"|"right"
                  position = "right",
                  -- When `true`, if the tree was opened before enabling the plugin, we will reopen it.
                  reopen = true,
              },
              -- this is a generic field to hint no-neck-pain that you use a dashboard plugin.
              -- you can find the filetype list of natively supported dashboards here: https://github.com/shortcuts/no-neck-pain.nvim/blob/main/lua/no-neck-pain/util/constants.lua#L82-L85
              -- if a dashboard that you use isn't supported, either set `dashboard.filetype` to the expected file type, or open a pull-request with the edited list.
              dashboard = {
                  -- When `true`, debounce will be applied to the init method, leaving time for the dashboard to open.
                  enabled = false,
                  -- if a dashboard that you use isn't supported, you can use this field to set a matching filetype, also don't hesitate to open a pull-request with the edited list (DASHBOARDS) found in lua/no-neck-pain/util/constants.lua.
                  ---@type string[]|nil
                  filetypes = nil,
              },
          },
      })
      
      --- NoNeckPain's buffer `vim.wo` options.
      ---@see window options `:h vim.wo`
      ---
      ---@type table
      --- Default values:
      ---@eval return MiniDoc.afterlines_to_code(MiniDoc.current.eval_section)
      NoNeckPain.bufferOptionsWo = {
          ---@type boolean
          cursorline = false,
          ---@type boolean
          cursorcolumn = false,
          ---@type string
          colorcolumn = "0",
          ---@type boolean
          number = false,
          ---@type boolean
          relativenumber = false,
          ---@type boolean
          foldenable = false,
          ---@type boolean
          list = false,
          ---@type boolean
          wrap = true,
          ---@type boolean
          linebreak = true,
      }
      
      --- NoNeckPain's buffer `vim.bo` options.
      ---@see buffer options `:h vim.bo`
      ---
      ---@type table
      --- Default values:
      ---@eval return MiniDoc.afterlines_to_code(MiniDoc.current.eval_section)
      NoNeckPain.bufferOptionsBo = {
          ---@type string
          filetype = "no-neck-pain",
          ---@type string
          buftype = "nofile",
          ---@type string
          bufhidden = "hide",
          ---@type boolean
          buflisted = false,
          ---@type boolean
          swapfile = false,
      }
      
      --- NoNeckPain's scratchPad buffer options.
      ---
      --- Leverages the side buffers as notepads, which work like any Neovim buffer and automatically saves its content at the given `location`.
      --- note: quitting an unsaved scratchPad buffer is non-blocking, and the content is still saved.
      ---
      ---@type table
      --- Default values:
      ---@eval return MiniDoc.afterlines_to_code(MiniDoc.current.eval_section)
      NoNeckPain.bufferOptionsScratchPad = {
          -- When `true`, automatically sets the following options to the side buffers:
          -- - `autowriteall`
          -- - `autoread`.
          ---@type boolean
          enabled = false,
          -- The name of the generated file. See `location` for more information.
          -- /!\ deprecated /!\ use `pathToFile` instead.
          ---@type string
          ---@example: `no-neck-pain-left.norg`
          ---@deprecated: use `pathToFile` instead.
          fileName = "no-neck-pain",
          -- By default, files are saved at the same location as the current Neovim session.
          -- note: filetype is defaulted to `norg` (https://github.com/nvim-neorg/neorg), but can be changed in `buffers.bo.filetype` or |NoNeckPain.bufferOptions| for option scoped to the `left` and/or `right` buffer.
          -- /!\ deprecated /!\ use `pathToFile` instead.
          ---@type string?
          ---@example: `no-neck-pain-left.norg`
          ---@deprecated: use `pathToFile` instead.
          location = nil,
          -- The path to the file to save the scratchPad content to and load it in the buffer.
          ---@type string?
          ---@example: `~/notes.norg`
          pathToFile = "",
      }
      
      --- NoNeckPain's buffer color options.
      ---
      ---@type table
      --- Default values:
      ---@eval return MiniDoc.afterlines_to_code(MiniDoc.current.eval_section)
      NoNeckPain.bufferOptionsColors = {
          -- Hexadecimal color code to override the current background color of the buffer. (e.g. #24273A)
          -- Transparent backgrounds are supported by default.
          -- popular theme are supported by their name:
          -- - catppuccin-frappe
          -- - catppuccin-frappe-dark
          -- - catppuccin-latte
          -- - catppuccin-latte-dark
          -- - catppuccin-macchiato
          -- - catppuccin-macchiato-dark
          -- - catppuccin-mocha
          -- - catppuccin-mocha-dark
          -- - github-nvim-theme-dark
          -- - github-nvim-theme-dimmed
          -- - github-nvim-theme-light
          -- - rose-pine
          -- - rose-pine-dawn
          -- - rose-pine-moon
          -- - tokyonight-day
          -- - tokyonight-moon
          -- - tokyonight-night
          -- - tokyonight-storm
          ---@type string?
          background = nil,
          -- Brighten (positive) or darken (negative) the side buffers background color. Accepted values are [-1..1].
          ---@type integer
          blend = 0,
          -- Hexadecimal color code to override the current text color of the buffer. (e.g. #7480c2)
          ---@type string?
          text = nil,
      }
      
      --- NoNeckPain's buffer side buffer option.
      ---
      ---@type table
      --- Default values:
      ---@eval return MiniDoc.afterlines_to_code(MiniDoc.current.eval_section)
      NoNeckPain.bufferOptions = {
          -- When `false`, the buffer won't be created.
          ---@type boolean
          enabled = true,
          ---@see NoNeckPain.bufferOptionsColors `:h NoNeckPain.bufferOptionsColors`
          colors = NoNeckPain.bufferOptionsColors,
          ---@see NoNeckPain.bufferOptionsBo `:h NoNeckPain.bufferOptionsBo`
          bo = NoNeckPain.bufferOptionsBo,
          ---@see NoNeckPain.bufferOptionsWo `:h NoNeckPain.bufferOptionsWo`
          wo = NoNeckPain.bufferOptionsWo,
          ---@see NoNeckPain.bufferOptionsScratchPad `:h NoNeckPain.bufferOptionsScratchPad`
          scratchPad = NoNeckPain.bufferOptionsScratchPad,
      }
      
    end,
  },
  {
    "debugloop/telescope-undo.nvim",
    config = function()
      
      {
        "nvim-telescope/telescope.nvim",
        dependencies = {
          "nvim-lua/plenary.nvim",
          "debugloop/telescope-undo.nvim",
        },
        config = function()
          require("telescope").setup({
            -- the rest of your telescope config goes here
            extensions = {
              undo = {
                -- telescope-undo.nvim config, see below
              },
              -- other extensions:
              -- file_browser = { ... }
            },
          })
          require("telescope").load_extension("undo")
          -- optional: vim.keymap.set("n", "<leader>u", "<cmd>Telescope undo<cr>")
        end,
      },
      
      
      {
        "debugloop/telescope-undo.nvim",
        dependencies = { -- note how they're inverted to above example
          {
            "nvim-telescope/telescope.nvim",
            dependencies = { "nvim-lua/plenary.nvim" },
          },
        },
        keys = {
          { -- lazy style key map
            "<leader>u",
            "<cmd>Telescope undo<cr>",
            desc = "undo history",
          },
        },
        opts = {
          -- don't use `defaults = { }` here, do this in the main telescope spec
          extensions = {
            undo = {
              -- telescope-undo.nvim config, see below
            },
            -- no other extensions here, they can have their own spec too
          },
        },
        config = function(_, opts)
          -- Calling telescope's setup from multiple specs does not hurt, it will happily merge the
          -- configs for us. We won't use data, as everything is in it's own namespace (telescope
          -- defaults, as well as each extension).
          require("telescope").setup(opts)
          require("telescope").load_extension("undo")
        end,
      },
      
      
      opts = {
        extensions = {
          undo = {
            use_delta = true,
            use_custom_command = nil, -- setting this implies `use_delta = false`. Accepted format is: { "bash", "-c", "echo '$DIFF' | delta" }
            side_by_side = false,
            vim_diff_opts = {
              ctxlen = vim.o.scrolloff,
            },
            entry_format = "state #$ID, $STAT, $TIME",
            time_format = "",
            saved_only = false,
          },
        },
      },
      
      
      opts = {
        extensions = {
          undo = {
            side_by_side = true,
            layout_strategy = "vertical",
            layout_config = {
              preview_height = 0.8,
            },
          },
        },
      }
      
      
      require("telescope").setup({
        extensions = {
          undo = {
            mappings = {
              i = {
                ["<cr>"] = require("telescope-undo.actions").yank_additions,
                ["<S-cr>"] = require("telescope-undo.actions").yank_deletions,
                ["<C-cr>"] = require("telescope-undo.actions").restore,
                -- alternative defaults, for users whose terminals do questionable things with modified <cr>
                ["<C-y>"] = require("telescope-undo.actions").yank_deletions,
                ["<C-r>"] = require("telescope-undo.actions").restore,
              },
              n = {
                ["y"] = require("telescope-undo.actions").yank_additions,
                ["Y"] = require("telescope-undo.actions").yank_deletions,
                ["u"] = require("telescope-undo.actions").restore,
              },
            },
          },
        },
      })
      
      
      opts = {
        extensions = {
          undo = {
            mappings = {
              -- Wrapping the actions inside a function prevents the error due to telescope-undo being not
              -- yet loaded.
              i = {
                ["<cr>"] = function(bufnr)
                  return require("telescope-undo.actions").yank_larger(bufnr)
                end,
              },
              n = {
                ["y"] = function(bufnr)
                  return require("telescope-undo.actions").yank_larger(bufnr)
                end,
              },
            },
          },
        },
      }
      
      
      opts = {
        extensions = {
          undo = {
            mappings = {
              i = {
                ["<C-y>"] = false,
              },
            },
          },
        },
      }
      
    end,
  },
  {
    "chrisgrieser/nvim-various-textobjs",
    config = function()
      
      -- lazy.nvim
      {
      	"chrisgrieser/nvim-various-textobjs",
      	event = "VeryLazy",
      	opts = { 
      		keymaps = {
      			useDefaults = true 
      		}
      	},
      },
      
      -- packer
      use {
      	"chrisgrieser/nvim-various-textobjs",
      	config = function () 
      		require("various-textobjs").setup({ 
      			keymaps = {
      				useDefaults = true 
      			}
      		})
      	end,
      }
      
      
      -- lazy.nvim
      {
      	"chrisgrieser/nvim-various-textobjs",
      	keys = {
      		-- ...
      	},
      },
      
      -- packer
      use { "chrisgrieser/nvim-various-textobjs" }
      
      
      -- default config
      require("various-textobjs").setup {
      	keymaps = {
      		-- See overview table in README for the defaults. (Note that lazy-loading
      		-- this plugin, the default keymaps cannot be set up. if you set this to
      		-- `true`, you thus need to add `lazy = false` to your lazy.nvim config.)
      		useDefaults = false,
      
      		-- disable only some default keymaps, for example { "ai", "!" }
      		-- (only relevant when you set `useDefaults = true`)
      		---@type string[]
      		disabledDefaults = {},
      	},
      
      	forwardLooking = {
      		-- Number of lines to seek forwards for a text object. See the overview
      		-- table in the README for which text object uses which value.
      		small = 5,
      		big = 15,
      	},
      	behavior = {
      		-- save position in jumplist when using text objects
      		jumplist = true,
      	},
      
      	-- extra configuration for specific text objects
      	textobjs = {
      		indentation = {
      			-- `false`: only indentation decreases delimit the text object
      			-- `true`: indentation decreases as well as blank lines serve as delimiter
      			blanksAreDelimiter = false,
      		},
      		subword = {
      			-- When deleting the start of a camelCased word, the result should
      			-- still be camelCased and not PascalCased (see #113).
      			noCamelToPascalCase = true,
      		},
      		diagnostic = {
      			wrap = true,
      		},
      		url = {
      			patterns = {
      				[[%l%l%l+://[^%s)%]}"'`>]+]],
      			},
      		},
      	},
      
      	notify = {
      		icon = "󰠱", -- only used with notification plugins like `nvim-notify`
      		whenObjectNotFound = true,
      	},
      
      	-- show debugging messages on use of certain text objects
      	debug = false,
      }
      
      
      -- example: `U` for url textobj
      vim.keymap.set({ "o", "x" }, "U", '<cmd>lua require("various-textobjs").url()<CR>')
      
      -- example: `as` for outer subword, `is` for inner subword
      vim.keymap.set({ "o", "x" }, "as", '<cmd>lua require("various-textobjs").subword("outer")<CR>')
      vim.keymap.set({ "o", "x" }, "is", '<cmd>lua require("various-textobjs").subword("inner")<CR>')
      
      
      -- THE INDENTATION TEXTOBJ requires two parameters, the first for exclusion of
      -- the starting border, the second for the exclusion of ending border
      vim.keymap.set(
      	{ "o", "x" },
      	"ii",
      	'<cmd>lua require("various-textobjs").indentation("inner", "inner")<CR>'
      )
      vim.keymap.set(
      	{ "o", "x" },
      	"ai",
      	'<cmd>lua require("various-textobjs").indentation("outer", "inner")<CR>'
      )
      
      
      -- THE COLUMN TEXTOBJ takes an optional parameter for direction:
      -- "down" (default), "up", "both"
      vim.keymap.set({ "o", "x" }, "|", '<cmd>lua require("various-textobjs").column("down")<CR>')
      vim.keymap.set({ "o", "x" }, "a|", '<cmd>lua require("various-textobjs").column("both")<CR>')
      
      
      -- Example: one keymap for `http` urls only, one for `ftp` urls only
      vim.keymap.set({ "o", "x" }, "H", function()
      	require("various-textobjs").setup {
      		textobjs = {
      			url = {
      				patterns = { [[https?://[^%s)%]}"'`>]+]] },
      			},
      		},
      	}
      	return "<cmd>lua require('various-textobjs').url()<CR>"
      end, { expr = true, desc = "http-url textobj" })
      
      vim.keymap.set({ "o", "x" }, "F", function()
      	require("various-textobjs").setup {
      		textobjs = {
      			url = {
      				patterns = { [[ftp://[^%s)%]}"'`>]+]] },
      			},
      		},
      	}
      	return "<cmd>lua require('various-textobjs').url()<CR>"
      end, { expr = true, desc = "ftp-url textobj" })
      
      
      -- when on unindented line, `ii` should select entire buffer
      vim.keymap.set("o", "ii", function()
      	if vim.fn.indent(".") == 0 then
      		require("various-textobjs").entireBuffer()
      	else
      		require("various-textobjs").indentation("inner", "inner")
      	end
      end)
      
      
      vim.keymap.set("n", "gx", function()
      	require("various-textobjs").url() -- select URL
      
      	local foundURL = vim.fn.mode() == "v" -- only switches to visual mode when textobj found
      	if not foundURL then return end
      
      	local url = vim.fn.getregion(vim.fn.getpos("."), vim.fn.getpos("v"), { type = "v" })[1]
      	vim.ui.open(url) -- requires nvim 0.10
      	vim.cmd.normal { "v", bang = true } -- leave visual mode
      end, { desc = "URL Opener" })
      
      
      vim.keymap.set("n", "gf", function()
      	require("various-textobjs").filepath("outer") -- select filepath
      
      	local foundPath = vim.fn.mode() == "v" -- only switches to visual mode when textobj found
      	if not foundPath then return end
      
      	local path = vim.fn.getregion(vim.fn.getpos("."), vim.fn.getpos("v"), { type = "v" })[1]
      
      	local exists = vim.uv.fs_stat(vim.fs.normalize(path)) ~= nil
      	if exists then
      		vim.ui.open(path)
      	else
      		vim.notify("Path does not exist.", vim.log.levels.WARN)
      	end
      end, { desc = "URL Opener" })
      
      
      -- before
      if foo then
      	print("bar") -- <- cursor is on this line
      	print("baz")
      end
      
      -- after
      print("bar")
      print("baz")
      
      
      vim.keymap.set("n", "dsi", function()
      	-- select outer indentation
      	require("various-textobjs").indentation("outer", "outer")
      
      	-- plugin only switches to visual mode when a textobj has been found
      	local indentationFound = vim.fn.mode():find("V")
      	if not indentationFound then return end
      
      	-- dedent indentation
      	vim.cmd.normal { "<", bang = true }
      
      	-- delete surrounding lines
      	local endBorderLn = vim.api.nvim_buf_get_mark(0, ">")[1]
      	local startBorderLn = vim.api.nvim_buf_get_mark(0, "<")[1]
      	vim.cmd(tostring(endBorderLn) .. " delete") -- delete end first so line index is not shifted
      	vim.cmd(tostring(startBorderLn) .. " delete")
      end, { desc = "Delete Surrounding Indentation" })
      
      
      -- NOTE this function uses `vim.hl.range` requires nvim 0.11
      vim.keymap.set("n", "ysii", function()
      	local startPos = vim.api.nvim_win_get_cursor(0)
      
      	-- identify start- and end-border
      	require("various-textobjs").indentation("outer", "outer")
      	local indentationFound = vim.fn.mode():find("V")
      	if not indentationFound then return end
      	vim.cmd.normal { "V", bang = true } -- leave visual mode so the '< '> marks are set
      
      	-- copy them into the + register
      	local startLn = vim.api.nvim_buf_get_mark(0, "<")[1] - 1
      	local endLn = vim.api.nvim_buf_get_mark(0, ">")[1] - 1
      	local startLine = vim.api.nvim_buf_get_lines(0, startLn, startLn + 1, false)[1]
      	local endLine = vim.api.nvim_buf_get_lines(0, endLn, endLn + 1, false)[1]
      	vim.fn.setreg("+", startLine .. "\n" .. endLine .. "\n")
      
      	-- highlight yanked text
      	local dur = 1500
      	local ns = vim.api.nvim_create_namespace("ysii")
      	local bufnr = vim.api.nvim_get_current_buf()
      	vim.hl.range(bufnr, ns, "IncSearch", { startLn, 0 }, { startLn, -1 }, { timeout = dur })
      	vim.hl.range(bufnr, ns, "IncSearch", { endLn, 0 }, { endLn, -1 }, { timeout = dur })
      
      	-- restore cursor position
      	vim.api.nvim_win_set_cursor(0, startPos)
      end, { desc = "Yank surrounding indentation" })
      
      
      vim.keymap.set("n", "P", function()
      	require("various-textobjs").lastChange()
      	local changeFound = vim.fn.mode():find("v")
      	if changeFound then vim.cmd.normal { ">", bang = true } end
      end
      
      
      local function gotoNextInnerNumber()
      	require("various-textobjs").number("inner")
      	local mode = vim.fn.mode()
      	if mode:find("[Vv]") then -- only switches to visual when textobj found
      		vim.cmd.normal { mode, bang = true } -- leaves visual mode
      	end
      end
      
    end,
  },
  {
    "XXiaoA/ns-textobject.nvim",
    config = function()
      
      require("ns-textobject").setup({})
      
      -- from https://github.com/kylechui/nvim-surround/discussions/53#discussioncomment-3134891
      -- move the following callback into `~/.config/nvim/after/ftplugin/markdown.lua`
      require("nvim-surround").buffer_setup({
          surrounds = {
              ["l"] = {
                  add = function()
                      local clipboard = vim.fn.getreg("+"):gsub("\n", "")
                      return {
                          { "[" },
                          { "](" .. clipboard .. ")" },
                      }
                  end,
                  find = "%b[]%b()",
                  delete = "^(%[)().-(%]%b())()$",
                  change = {
                      target = "^()()%b[]%((.-)()%)$",
                      replacement = function()
                          local clipboard = vim.fn.getreg("+"):gsub("\n", "")
                          return {
                              { "" },
                              { clipboard },
                          }
                      end,
                  },
              },
          }
      })
      
      
      local nstextobject = require("ns-textobject")
      
      vim.keymap.set({ "x", "o" }, "aq", function()
          -- First parameter means a alias or surround of nvim-surround
          -- The second one has two choice: `a` means around or `i` means inside
          nstextobject.create_textobj("q", "a")
      end, { desc = "Around the quote" })
      vim.keymap.set({ "x", "o" }, "iq", function()
          nstextobject.create_textobj("q", "i")
      end, { desc = "Inside the quote" })
      
      -- Or a simple way:
      -- First parameter means a alias or surround of nvim-surround
      -- The second one used to add the description for keymap
      nstextobject.map_textobj("q", "quotes")
      
      
      a = func(args)
      -- if press dsf
      a = args
      -- if press daf
      a =
      -- if press dif
      a = func()
      
      
      s = "this's a `string`"
      -- press ciqworld (cursor inside "")
      s = "word"
      -- press ciqworld (cursor inside ``)
      s = "this's a `world`"
      
      
      use({
          "XXiaoA/ns-textobject.nvim",
          after = "nvim-surround",
          config = function()
              require("ns-textobject").setup({
                  -- your configuration here
                  -- or just left empty to use defaluts
              })
          end
      })
      
      
      {
          auto_mapping = {
              -- automatically mapping for nvim-surround's aliases
              aliases = true,
              -- for nvim-surround's surrounds
              surrounds = true,
          },
          disable_builtin_mapping = {
              enabled = true,
              -- list of char which shouldn't mapping by auto_mapping
              chars = { "b", "B", "t", "`", "'", '"', "{", "}", "(", ")", "[", "]", "<", ">" },
          },
      }
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-basics.md",
  },
  {
    "niuiic/part-edit.nvim",
    config = function()
      
      -- default config
      {
          -- float | tab
          open_in = "tab",
          float = {
              win = {
                  -- the ratio of the floating window width to the editor width
                  width_ratio = 1,
                  -- the ratio of the floating window height to the editor height
                  height_ratio = 1,
              },
          },
          -- whether to delete the buffer when leave
          -- notice: you have to delete previous buffer before you run 'PartEdit' again
          delete_buf_on_leave = false,
          -- path to the swap file of the new buffer
          swap_path = function()
              return ".swap"
          end,
          -- default file suffix of selected code (for example, markdown code -> md)
          -- this plugin will ask you to input file suffix if no default file suffix specified
          default_file_suffix = nil,
          -- whether to save original file when update
          save_original_file = true,
      }
      
      
      -- keymap example
      vim.keymap.set("v", "<space>p", "<cmd>PartEdit<CR>", { silent = true, mode = "v"})
      
    end,
  },
  {
    "niuiic/divider.nvim",
    config = function()
      
      local screen_w = vim.opt.columns:get()
      local screen_h = vim.opt.lines:get() - vim.opt.cmdheight:get()
      local preview_win_width = math.floor(screen_w * 0.6)
      local preview_win_height = math.floor(screen_h * 0.6)
      
      local default_config = {
      	is_enabled = function(bufnr)
      		local ok, value = pcall(vim.api.nvim_buf_get_var, bufnr, "divider")
      		return not ok or value ~= "disabled"
      	end,
      	dividers = {
      		{
      			pattern = [[ %% (.+) %%]],
      			level = 1,
      			hl_group = "LineNr",
      			mark_char = "-",
      			mark_pos = "bottom",
      			is_visible_in_outline = true,
      			is_enabled = function()
      				return true
      			end,
      		},
      		{
      			pattern = [[ %%%% (.+) %%%%]],
      			level = 2,
      			hl_group = "CursorLineNr",
      			mark_char = "-",
      			mark_pos = "bottom",
      			is_visible_in_outline = true,
      			is_enabled = function()
      				return true
      			end,
      		},
      		{
      			pattern = [[ %%%%%% (.+) %%%%%%]],
      			level = 3,
      			hl_group = "ModeMsg",
      			mark_char = "-",
      			mark_pos = "bottom",
      			is_visible_in_outline = true,
      			is_enabled = function()
      				return true
      			end,
      		},
      	},
      	outline = {
      		win_pos = "left",
      		win_size = 30,
      		enter_window = false,
      		hl_group = "CursorLine",
      		close_after_navigate = false,
      		preview_win_width = preview_win_width,
      		preview_win_height = preview_win_height,
      		preview_on_hover = true,
      		keymap_navigate = "<cr>",
      		keymap_preview = "p",
      		keymap_close = "q",
      	},
      }
      
      
      -- config
      require("divider").setup(new_config)
      
      -- open/close outline
      require("divider").toggle_outline()
      
    end,
  },
  {
    "CKolkey/ts-node-action",
    config = function()
      
      {
          'ckolkey/ts-node-action',
           opts = {},
      },
      
      
      use({
          'ckolkey/ts-node-action',
           config = function()
               require("ts-node-action").setup({})
           end
      })
      
      
      vim.keymap.set(
          { "n" },
          "K",
          require("ts-node-action").node_action,
          { desc = "Trigger Node Action" },
      )
      
      
      {
          ['*'] = { -- Global table is checked for all langs
              ["node_type"] = fn,
              ...
          },
          lang = {
              ["node_type"] = fn,
              ...
          },
          ...
      }
      
      
      ["node_type"] = {
        { function_one, name = "Action One" },
        { function_two, name = "Action Two" },
      }
      
      
      ["node_type"] = {
        { function_one, name = "Action One" },
        { function_two, name = "Action Two" },
        ask = false,
      }
      
      
      {
        cursor   = { row = 0, col = 0 },
        callback = function() ... end,
        format   = true,
        target   = <tsnode>
      }
      
      
      local action = node_actions[lang][node:type()]
      local replacement, opts = action(node)
      replace_node(node, replacement, opts or {})
      
      
      local null_ls = require("null-ls")
      null_ls.setup({
        sources = {
          null_ls.builtins.code_actions.ts_node_action,
          ...
        }
      })
      
      
      require("ts-node-action.helpers").node_text(node)
      
      
      @node: tsnode
      @return: string
      
      
      require("ts-node-action.helpers").node_is_multiline(node)
      
      
      @node: tsnode
      @return: boolean
      
      
      require("ts-node-action.helpers").padded_node_text(node, padding)
      
      
      @node: tsnode
      @padding: table
      @return: string
      
      
      { [","] = "%s " }
      
      
      require("ts-node-action.actions").cycle_case(formats)
      
      
      @param formats table|nil
      
      
      { "snake_case", "pascal_case", "screaming_snake_case", "camel_case" }
      
      
          standardize("ts_node_action") -> { "ts", "node", "action" }
          standardize("tsNodeAction")   -> { "ts", "node", "action" }
          standardize("TsNodeAction")   -> { "ts", "node", "action" }
          standardize("TS_NODE_ACTION") -> { "ts", "node", "action" }
      
    end,
  },
  {
    "tomiis4/hypersonic.nvim",
    config = function()
      
      use 'tomiis4/Hypersonic.nvim'
      
      
      {
          'tomiis4/Hypersonic.nvim',
          event = "CmdlineEnter",
          cmd = "Hypersonic",
          config = function()
              require('hypersonic').setup({
                  -- config
              })
          end
      },
      
      
      require('hypersonic').setup()
      
      
      require('hypersonic').setup({
          ---@type 'none'|'single'|'double'|'rounded'|'solid'|'shadow'|table
          border = 'rounded',
          ---@type number 0-100
          winblend = 0,
          ---@type boolean
          add_padding = true,
          ---@type string
          hl_group = 'Keyword',
          ---@type string
          wrapping = '"',
          ---@type boolean
          enable_cmdline = true
      })
      
      
      {
          {
              type = "character",
              value = "g"
          },
          {
              type = "character",
              value = "r"
          },
          {
              type = "class",
              value = "ae"
          },
          {
              type = "character",
              value = "y"
          }
      }
      
      
      local meta_table = {
          ['n'] = 'Newline',
          ['r'] = 'Carriage return',
          ['t'] = 'Tab',
          ['s'] = 'Any whitespace character',
          ['S'] = 'Any non-whitespace character',
          ['d'] = 'Any digit',
          -- more in tables.lua
      }
      
      
      {
          type = 'character'|'escaped'|'class'|'group'|'quantifier',
          value = '',
          children = Node|{},
          quantifiers = ''
      }
      
      
      {
          {
              explanation = "Match g",
              value = "g"
          },
          {
              explanation = "Match r",
              value = "r"
          },
          {
              children = { "a", "e" },
              explanation = "Match either",
              value = "[ae]"
          },
          {
              explanation = "Match y",
              value = "y"
          }
      }
      
      
      { 
          {
              explanation = "Match gr",
              value = "gr"
          }, 
          {
              explanation = "Match either",
              children = { "a or e" },
              value = "[ae]"
          }, 
          {
              explanation = "Match y",
              value = "y"
          }
      }
      
    end,
  },
  {
    "chrisgrieser/nvim-puppeteer",
    config = function()
      
      -- lazy.nvim
      { 
      	"chrisgrieser/nvim-puppeteer",
      	lazy = false, -- plugin lazy-loads itself. Can also load on filetypes.
      },
      
      -- packer
      use { "chrisgrieser/nvim-puppeteer" }
      
      
      -- list of filestypes (please see the README before enabling this plugin for lua)
      vim.g.puppeteer_disable_filetypes = { "lua" }
      
      -- quotation mark to use when converting back to normal string (" or ')
      vim.g.puppeteer_js_quotation_mark = '"'
      
      
      -- desired: conversion to format string when typing the placeholder "%s"
      local str = "foobar %s baz" -- before
      local str = ("foobar %s baz"):format() -- after
      
      -- problem case that can be dealt with: "%s" used as class in lua pattern
      local found = str:find("foobar %s")
      
      -- problem case that cannot be dealt with: "%s" in string, which
      -- is only later used as pattern
      local pattern = "foobar %s baz"
      -- some code…
      str:find(pattern)
      
      
      -- Enable auto-conversion of lua strings by removing lua from the disabled filetypes
      vim.g.puppeteer_disable_filetypes = {}
      
    end,
  },
  {
    "nat-418/boole.nvim",
    config = function()
      
      require('boole').setup({
        mappings = {
          increment = '<C-a>',
          decrement = '<C-x>'
        },
        -- User defined loops
        additions = {
          {'Foo', 'Bar'},
          {'tic', 'tac', 'toe'}
        },
        allow_caps_additions = {
          {'enable', 'disable'}
          -- enable → disable
          -- Enable → Disable
          -- ENABLE → DISABLE
        }
      })
      
    end,
  },
  {
    "cshuaimin/ssr.nvim",
    config = function()
      
      use {
        "cshuaimin/ssr.nvim",
        module = "ssr",
        -- Calling setup is optional.
        config = function()
          require("ssr").setup {
            border = "rounded",
            min_width = 50,
            min_height = 5,
            max_width = 120,
            max_height = 25,
            adjust_window = true,
            keymaps = {
              close = "q",
              next_match = "n",
              prev_match = "N",
              replace_confirm = "<cr>",
              replace_all = "<leader><cr>",
            },
          }
        end
      }
      
      
      vim.keymap.set({ "n", "x" }, "<leader>sr", function() require("ssr").open() end)
      
    end,
  },
  {
    "Jxstxs/conceal.nvim",
    config = function()
      
      use { "Jxstxs/conceal.nvim", requires = "nvim-treesitter/nvim-treesitter" }
      
      
      local conceal = require("conceal")
      
      -- should be run before .generate_conceals to use user Configuration
      conceal.setup({
          --[[ ["language"] = {
              enabled = bool,
              keywords = {
                ["keyword"] = {
                    enabled     = bool,
                    conceal     = string,
                    highlight   = string
                }
              }
          } ]]
          ["lua"] = {
            enabled = true,
            keywords = {
              ["local"] = {
                enabled = false -- to disable concealing for "local"
              },
              ["return"] = {
                conceal = "R" -- to set the concealing to "R"
              },
              ["for"] = {
                highlight = "keyword" -- to set the Highlight group to "@keyword"
              }
            }
          },
          ["language"] = {
            enabled = false -- to disable the whole language
          }
      })
      
      -- generate the scm queries
      -- only need to be run when the Configuration changes
      conceal.generate_conceals()
      
      -- bind a <leader>tc to toggle the concealing level
      vim.keymap.set("n", "<leader>tc", function()
        require("conceal").toggle_conceal()
      end, { silent = true})
      
    end,
  },
  {
    "hiberabyss/bzlops.vim",
  },
  {
    "altermo/iedit.nvim",
    config = function()
      
      {
       select={
        map={
         q={'done'},
         ['<Esc>']={'select','done'},
         ['<CR>']={'toggle'},
         n={'toggle','next'},
         p={'toggle','prev'},
         N={'next'},
         P={'prev'},
         a={'all'},
         --Mapping to use while in selection-mode
         --Possible values are:
         -- • `done` Done with selection
         -- • `next` Go to next occurrence
         -- • `prev` Go to previous occurrence
         -- • `select` Select current
         -- • `unselect` Unselect current
         -- • `toggle` Toggle current
         -- • `all` Select all
        },
        highlight={
         current='CurSearch',
         selected='Search'
        }
       },
       highlight='IncSearch',
      }
      
    end,
  },
  {
    "ptdewey/yankbank-nvim",
    config = function()
      
      {
          "ptdewey/yankbank-nvim",
          dependencies = "kkharji/sqlite.lua",
          cmd = { "YankBank" },
          config = function()
              require('yankbank').setup({
                  persist_type = "sqlite",
              })
          end,
      }
      
      
      {
          "ptdewey/yankbank-nvim",
          cmd = { "YankBank" },
          config = function()
              require('yankbank').setup()
          end,
      }
      
      
      -- plugins/yankbank.lua
      return {
          {
              "ptdewey/yankbank-nvim",
              lazy = false,
              config = function()
                  -- ...
              end,
          },
          {
              "kkharji/sqlite.lua",
              lazy = true,
          },
      }
      
      
      {
          "ptdewey/yankbank-nvim",
          dependencies = "kkharji/sqlite.lua",
          keys = {
              { "y" },
              { "Y", "y$" }, -- redefine Y behavior to y$ to avoid breaking lazy
              { "D" },
              { "d" },
              { "x" },
              { "<leader>p", desc = "Open YankBank" },
          },
          cmd = { "YankBank" },
          event = { "FocusGained" },
          config = function()
              require("yankbank").setup({
                  -- ...
              })
          end
      }
      
      
      {
          "ptdewey/yankbank-nvim",
          config = function()
              require('yankbank').setup({
                  max_entries = 9,
                  sep = "-----",
                  num_behavior = "jump",
                  focus_gain_poll = true,
                  persist_type = "sqlite",
                  keymaps = {
                      paste = "<CR>",
                      paste_back = "P",
                  },
                  registers = {
                      yank_register = "+",
                  },
                  bind_indices = "<leader>p"
              })
          end,
      }
      
      
      -- lazy
      return {
          "ptdewey/yankbank-nvim",
          dependencies = "kkharji/sqlite.lua",
          config = function()
              require('yankbank').setup({
                  -- other options...
                  persist_type = "sqlite"
              })
          end,
      }
      
      
      -- map to '<leader>y'
      vim.keymap.set("n", "<leader>y", "<cmd>YankBank<CR>", { noremap = true })
      
      
      -- get the ith entry in the bank
      ---@param i integer index to get
      -- output format: { yank_text = "entry", reg_type = "v" }
      local e = require("yankbank.api").get_entry(i)
      
      -- add an entry to the bank
      ---@param yank_text string yank text to add to YANKS table
      ---@param reg_type string register type "v", "V", or "^V" (visual, v-line, v-block respectively)
      require("yankbank.api").add_entry("yank_text", "reg_type")
      
      -- remove an entry from the bank by index
      ---@param i integer index to remove
      require("yankbank.api").remove_entry(i)
      
      --- pin entry to yankbank so that it won't be removed when its position exceeds the max number of entries
      ---@param i integer index to pin
      require("yankbank.api").pin_entry(i)
      
      
      --- unpin bank entry
      ---@param i integer index to unpin
      require("yankbank.api").unpin_entry(i)
      
    end,
  },
  {
    "SunnyTamang/select-undo.nvim",
    config = function()
      
      {
        "SunnyTamang/select-undo.nvim",
        opts = {},
      }
      
      
      use {
        "SunnyTamang/select-undo.nvim",
        config = function()
          require("select-undo").setup()
        end
      }
      
      
      require("select-undo").setup({
        line_mapping = "gU",    -- Change line undo mapping
        partial_mapping = "gCp" -- Change partial undo mapping
      })
      
      
      require("select-undo").setup({
        persistent_undo = true,  -- Enables persistent undo history
        mapping = true,          -- Enables default keybindings
        line_mapping = "gu",     -- Undo for entire lines
        partial_mapping = "gcu"  -- Undo for selected characters -- Note: dont use this line as gu can also handle partial undo
      })
      
    end,
  },
  {
    "OXY2DEV/foldtext.nvim",
    config = function()
      
      {
          "OXY2DEV/foldtext.nvim",
          lazy = false
      }
      
      
      return {
          "OXY2DEV/foldtext.nvim",
          lazy = false
      }
      
      
      local MiniDeps = require("mini.deps");
      
      MiniDeps.add({
          source = "OXY2DEV/foldtext.nvim"
      });
      
      
      require("foldtext").setup({
          -- Ignore buffers with these buftypes.
          ignore_buftypes = {},
          -- Ignore buffers with these filetypes.
          ignore_filetypes = {},
          -- Ignore buffers/windows if the result
          -- is false.
          condition = function ()
              return true;
          end,
      
          styles = {
              default = {
                  { kind = "bufline" }
              },
      
              -- Custom foldtext.
              custom_a = {
                  -- Only on these filetypes.
                  filetypes = {},
                  -- Only on these buftypes.
                  buftypes = {},
      
                  -- Only if this condition is
                  -- true.
                  condition = function (win)
                      return vim.wo[win].foldmethod == "manual";
                  end,
      
                  -- Parts to create the foldtext.
                  parts = {
                      { kind = "fold_size" }
                  }
              }
          }
      });
      
      
      {
          kind = "bufline",
          -- Optional condition for this
          -- part.
          condition = function ()
              return true;
          end
      
          -- Delimiter between the start/end line.
          delimiter = "...",
          -- Highlight group for `delimiter`.
          hl = "@comment"
      }
      
      
      {
          kind = "description",
          -- Optional condition for this
          -- part.
          condition = function ()
              return true;
          end
      
          -- Pattern to detect the foldtext from the start line.
          -- Here I am using, "feat: Keymaps" & "fix, Something's not right here"
          pattern = '[\'"](.+)[\'"]',
          styles = {
              default = {
                  hl = "@comment",
                  icon = "💭 ",
                  icon_hl = nil
              },
      
              -- Style for `doc`(case-insensitive).
              -- Options are merged with `default`
              -- before being used.
              doc = {
                  -- hl, icon_hl are inherited from
                  -- `default`.
                  icon = "📚 ",
              }
          }
      }
      
      
      {
          kind = "section",
          -- Optional condition for this
          -- part.
          condition = function ()
              return true;
          end
      
          -- Text to show for this section. Has
          -- the same structure as virtual text.
          -- [ text, highlight_group ][]
          output = {
              { "Hello, Neovim!", "Comment" }
          },
          -- Can also be a function!
          output = function (buffer, window)
              return {
                  { "Buf: " .. buffer },
                  { "Win: " .. window },
              };
          end
      }
      
      
      {
          kind = "fold_size",
          -- Optional condition for this
          -- part.
          condition = function ()
              return true;
          end
      
          -- Highlight group for the entire
          -- part.
          hl = "@comment",
      
          icon = "←→ ",
          icon_hl = nil,
      
          padding_left = " ",
          padding_left_hl = nil,
      
          padding_right = " ",
          padding_right_hl = nil,
      }
      
      
      {
          kind = "indent",
          -- Optional condition for this
          -- part.
          condition = function ()
              return true;
          end
      
          hl = nil
      }
      
    end,
  },
  {
    "tummetott/unimpaired.nvim",
  },
  {
    "daltongd/yanklock.nvim",
    config = function()
      
      require('yanklock').setup()
      
      
      require('yanklock').setup({
        -- your options go here. see: ### Customization section in this readme
      })
      
      
      vim.keymap.set("n", "<leader>yl", ":lua require('yanklock').toggle()<cr>", { desc = "yanklock toggle" })
      
      
      return {
        "daltongd/yanklock.nvim",
        opts = {
          notify = true, -- optional
        },
        keys = {
          {
            "<leader>yl",
            function()
              require("yanklock").toggle()
            end,
            desc = "yanklock toggle",
          },
        },
      }
      
      
      {
        "daltongd/yanklock.nvim",
        opts = {
          notify = true, -- optional
        },
        keys = {
          {
            "<leader>yl",
            function()
              require("yanklock").toggle()
            end,
            desc = "yanklock toggle",
          },
        },
      },
      
      
      :lua require('yanklock').toggle()
      
      
      :lua require('yanklock').lock()
      
      
      :lua require('yanklock').unlock()
      
      
      {
        modes = { "n", "x" },
        notify = false,
      }
      
      
      {
        "daltongd/yanklock.nvim",
        opts = {
          modes = { "n", "x" },
          notify = true,
        },
        keys = {
          {
            "<leader>yl",
            function()
              require("yanklock").toggle()
            end,
            desc = "yanklock toggle",
          },
        },
      },
      
      
      require('yanklock').setup({
        modes = { "n", "x" },
        notify = true,
      })
      
    end,
  },
  {
    "zongben/capsoff.nvim",
    config = function()
      
      --Lazy
      {
        "zongben/capsoff.nvim",
        build = ":CapsLockOffBuild",
        config = function()
          require("capsoff").setup()
        end,
      }
      
      
      {
          -- Automatically turn off Caps Lock when leaving insert mode
          -- If you want to turn off Caps Lock manually, you can set it to false
          auto = true,
      }
      
    end,
  },
  {
    "kobbikobb/move-lines.nvim",
    config = function()
      
      {
          'kobbikobb/move-lines.nvim',
          config = function()
              require('move-lines').setup()
          end,
      }
      
      
      {
          'kobbikobb/move-lines.nvim',
          config = function()
              require('move-lines').setup()
          end,
      }
      
      
      require('move-lines').setup({
          move_down = '<C-J>', -- Custom key for moving lines down
          move_up = '<C-K>',   -- Custom key for moving lines up
          move_left = '<C-H>', -- Custom key for moving lines left
          move_right = '<C-L>' -- Custom key for moving lines right
      })
      
    end,
  },
  {
    "kiyoon/telescope-insert-path.nvim",
    config = function()
      
      use {'kiyoon/telescope-insert-path.nvim'}
      
      
      local path_actions = require('telescope_insert_path')
      
      require('telescope').setup {
        defaults = {
          mappings = {
            n = {
              -- E.g. Type `[i`, `[I`, `[a`, `[A`, `[o`, `[O` to insert relative path and select the path in visual mode.
              -- Other mappings work the same way with a different prefix.
              ["["] = path_actions.insert_reltobufpath_visual,
              ["]"] = path_actions.insert_abspath_visual,
              ["{"] = path_actions.insert_reltobufpath_insert,
              ["}"] = path_actions.insert_abspath_insert,
              ["-"] = path_actions.insert_reltobufpath_normal,
              ["="] = path_actions.insert_abspath_normal,
      	-- If you want to get relative path that is relative to the cwd, use
      	-- `relpath` instead of `reltobufpath`
              -- You can skip the location postfix if you specify that in the function name.
              -- ["<C-o>"] = path_actions.insert_relpath_o_visual,
            }
          }
        }
      }
      
    end,
  },
  {
    "zhisme/copy_with_context.nvim",
    config = function()
      
      use {
          'zhisme/copy_with_context.nvim',
          config = function()
            require('copy_with_context').setup({
              -- Customize mappings
              mappings = {
                relative = '<leader>cy',
                absolute = '<leader>cY'
              },
              -- whether to trim lines or not
              trim_lines = false,
              context_format = '# %s:%s', -- Default format for context: "# Source file: filepath:line"
            })
          end
        }
      
      
      {
          'zhisme/copy_with_context.nvim',
          config = function()
            require('copy_with_context').setup({
              -- Customize mappings
              mappings = {
                relative = '<leader>cy',
                absolute = '<leader>cY'
              },
              -- whether to trim lines or not
              trim_lines = false,
              context_format = '# %s:%s', -- Default format for context: "# Source file: filepath:line"
            })
          end
        },
      
      
      -- default options
      require('copy_with_context').setup({
          -- Customize mappings
          mappings = {
            relative = '<leader>cy',
            absolute = '<leader>cY'
          },
          -- whether to trim lines or not
          trim_lines = false,
          context_format = '# %s:%s',  -- Default format for context: "# Source file: filepath:line"
        -- context_format = '# Source file: %s:%s',
        -- Other format for context: "# Source file: /path/to/file:123"
      })
      
      
      use {
        "~/path/to/copy_with_context.nvim",
        config = function()
            require('copy_with_context').setup({
                    -- Customize mappings
                    mappings = {
                    relative = '<leader>cy',
                    absolute = '<leader>cY'
                    },
                    -- whether to trim lines or not
                    trim_lines = false,
                    context_format = '# %s:%s',  -- Default format for context: "# filepath:line"
                    -- context_format = '# Source file: %s:%s',
                    -- Other format for context: "# Source file: /path/to/file:123"
                    })
        end
      }
      
      
      {
        dir = "~/path/to/copy_with_context.nvim",
        dev = true,
        opts = {
            mappings = {
                relative = '<leader>cy',
                absolute = '<leader>cY'
            },
            -- whether to trim lines or not
            trim_lines = false,
            context_format = '# %s:%s',  -- Default format for context: "# filepath:line"
            -- context_format = '# Source file: %s:%s',
            -- Other format for context: "# Source file: /path/to/file:123"
        }
      }
      
    end,
  },
  {
    "jake-stewart/multicursor.nvim",
  },
  {
    "brenton-leighton/multiple-cursors.nvim",
    config = function()
      
      {
        "brenton-leighton/multiple-cursors.nvim",
        version = "*",  -- Use the latest tagged version
        opts = {},  -- This causes the plugin setup function to be called
        keys = {
          {"<C-j>", "<Cmd>MultipleCursorsAddDown<CR>", mode = {"n", "x"}, desc = "Add cursor and move down"},
          {"<C-k>", "<Cmd>MultipleCursorsAddUp<CR>", mode = {"n", "x"}, desc = "Add cursor and move up"},
      
          {"<C-Up>", "<Cmd>MultipleCursorsAddUp<CR>", mode = {"n", "i", "x"}, desc = "Add cursor and move up"},
          {"<C-Down>", "<Cmd>MultipleCursorsAddDown<CR>", mode = {"n", "i", "x"}, desc = "Add cursor and move down"},
      
          {"<C-LeftMouse>", "<Cmd>MultipleCursorsMouseAddDelete<CR>", mode = {"n", "i"}, desc = "Add or remove cursor"},
      
          {"<Leader>m", "<Cmd>MultipleCursorsAddVisualArea<CR>", mode = {"x"}, desc = "Add cursors to the lines of the visual area"},
      
          {"<Leader>a", "<Cmd>MultipleCursorsAddMatches<CR>", mode = {"n", "x"}, desc = "Add cursors to cword"},
          {"<Leader>A", "<Cmd>MultipleCursorsAddMatchesV<CR>", mode = {"n", "x"}, desc = "Add cursors to cword in previous area"},
      
          {"<Leader>d", "<Cmd>MultipleCursorsAddJumpNextMatch<CR>", mode = {"n", "x"}, desc = "Add cursor and jump to next cword"},
          {"<Leader>D", "<Cmd>MultipleCursorsJumpNextMatch<CR>", mode = {"n", "x"}, desc = "Jump to next cword"},
      
          {"<Leader>l", "<Cmd>MultipleCursorsLock<CR>", mode = {"n", "x"}, desc = "Lock virtual cursors"},
        },
      },
      
      
      keys = {
        {"<Leader>l", "<Cmd>MultipleCursorsLockToggle<CR>", mode = {"n", "x"}, desc = "Toggle locking virtual cursors"},
      },
      
      
      opts = {
        custom_key_maps = {
          {"n", "<Leader>|", function() require("multiple-cursors").align() end},
        },
      },
      
      
      opts = {
        custom_key_maps = {
          {{"n", "i"}, "<C-/>", function() vim.cmd("normal gcc") end},
          {"v", "<C-/>", function() vim.cmd("normal gc") end},
        },
      },
      
      
      {
        "brenton-leighton/multiple-cursors.nvim",
        version = "*",
        opts = {
          pre_hook = function()
            vim.cmd("set nocul")
            vim.cmd("NoMatchParen")
          end,
          post_hook = function()
            vim.cmd("set cul")
            vim.cmd("DoMatchParen")
          end,
        },
        keys = {
          {"<C-j>", "<Cmd>MultipleCursorsAddDown<CR>", mode = {"n", "x"}, desc = "Add a cursor then move down"},
          {"<C-Down>", "<Cmd>MultipleCursorsAddDown<CR>", mode = {"n", "i", "x"}, desc = "Add a cursor then move down"},
          {"<C-k>", "<Cmd>MultipleCursorsAddUp<CR>", mode = {"n", "x"}, desc = "Add a cursor then move up"},
          {"<C-Up>", "<Cmd>MultipleCursorsAddUp<CR>", mode = {"n", "i", "x"}, desc = "Add a cursor then move up"},
          {"<C-LeftMouse>", "<Cmd>MultipleCursorsMouseAddDelete<CR>", mode = {"n", "i"}, desc = "Add or remove a cursor"},
          {"<Leader>a", "<Cmd>MultipleCursorsAddMatches<CR>", mode = {"n", "x"}, desc = "Add cursors to the word under the cursor"},
        },
      },
      
      
      opts = {
        pre_hook = function()
          vim.opt.cursorline = false
          vim.cmd("NoMatchParen")
        end,
        post_hook = function()
          vim.opt.cursorline = true
          vim.cmd("DoMatchParen")
        end,
      },
      
      
      opts = {
        custom_key_maps = {
          -- No option
          {"n", "<Leader>a", function(register, count)
            vim.print(register .. count)
          end}
      
          -- Motion command
          {"n", "<Leader>b", function(register, count, motion_cmd)
            vim.print(register .. count .. motion_cmd)
          end, "m"}
      
          -- Character
          {"n", "<Leader>c", function(register, count, char)
            vim.print(register .. count .. char)
          end, "c"}
      
          -- Motion command then character
          {"n", "<Leader>d", function(register, count, motion_cmd, char)
            vim.print(register .. count .. motion_cmd .. char)
          end, "mc"}
        },
      },
      
      
      opts = {
        custom_key_maps = {
          -- Remap j, k, and l to n, e, and i
          {{"n", "x"}, "n", function() require("multiple-cursors.normal_mode.motion").j() end, "nowrap"},
          {{"n", "x"}, "e", function() require("multiple-cursors.normal_mode.motion").k() end, "nowrap"},
          {{"n", "x"}, "i", function() require("multiple-cursors.normal_mode.motion").l() end, "nowrap"},
      
          -- Remap i and I to l and L
          {{"n", "x"}, "l", function() require("multiple-cursors.normal_mode_mode_change.i() end, "nowrap"},
          {{"n", "x"}, "L", function() require("multiple-cursors.normal_mode_mode_change.I() end, "nowrap"},
      
          -- Disable j and k
          {{"n", "x"}, "j", nil },
          {{"n", "x"}, "k", nil },
        }
      }
      
      
      opts = {
        custom_key_maps = {
          -- Swap j and k
          {{"n", "x"}, "j", function() require("multiple-cursors.normal_mode.motion").k() end, "nowrap"},
          {{"n", "x"}, "k", function() require("multiple-cursors.normal_mode.motion").j() end, "nowrap"},
        }
      }
      
      
      pre_hook = function()
        vim.cmd("Lazy load PLUGIN_NAME")
      end,
      
      
      custom_key_maps = {
        {"n", {"<A-k>", "<A-Up>"}, function() MiniMove.move_line("up") end},
        {"n", {"<A-j>", "<A-Down>"}, function() MiniMove.move_line("down") end},
        {"n", {"<A-h>", "<A-Left>"}, function() MiniMove.move_line("left") end},
        {"n", {"<A-l>", "<A-Right>"}, function() MiniMove.move_line("right") end},
      
        {"x", {"<A-k>", "<A-Up>"}, function() MiniMove.move_selection("up") end},
        {"x", {"<A-j>", "<A-Down>"}, function() MiniMove.move_selection("down") end},
        {"x", {"<A-h>", "<A-Left>"}, function() MiniMove.move_selection("left") end},
        {"x", {"<A-l>", "<A-Right>"}, function() MiniMove.move_selection("right") end},
      },
      
      
      pre_hook = function()
        vim.cmd("Lazy load mini.move")
      end,
      
      
      pre_hook = function()
        vim.g.minipairs_disable = true
      end,
      post_hook = function()
        vim.g.minipairs_disable = false
      end,
      
      
      custom_key_maps = {
        {"n", "<Leader>sa", function(_, count, motion_cmd, char)
          vim.cmd("normal " .. count .. "sa" .. motion_cmd .. char)
        end, "mc"},
      },
      
      
      pre_hook = function()
        require('nvim-autopairs').disable()
      end,
      post_hook = function()
        require('nvim-autopairs').enable()
      end,
      
      
      pre_hook = function()
        require("cmp").setup({enabled=false})
      end,
      post_hook = function()
        require("cmp").setup({enabled=true})
      end,
      
      
      custom_key_maps = {
        -- w
        {{"n", "x"}, "w", function(_, count)
          if  count ~=0 and vim.api.nvim_get_mode().mode == "n" then
            vim.cmd("normal! " .. count)
          end
          require('spider').motion('w')
        end},
      
        -- e
        {{"n", "x"}, "e", function(_, count)
          if  count ~=0 and vim.api.nvim_get_mode().mode == "n" then
            vim.cmd("normal! " .. count)
          end
          require('spider').motion('e')
        end},
      
        -- b
        {{"n", "x"}, "b", function(_, count)
          if  count ~=0 and vim.api.nvim_get_mode().mode == "n" then
            vim.cmd("normal! " .. count)
          end
          require('spider').motion('b')
        end},
      },
      
      
      custom_key_maps = {
        {"n", {">>", "<Tab>"}, function() require("stay-in-place").shift_right_line() end},
        {"n", "<<", function() require("stay-in-place").shift_left_line() end},
        {{"n", "i"}, "<S-Tab>", function() require("stay-in-place").shift_left_line() end},
      },
      
      
      {
        "folke/which-key.nvim",
        opts = {},
        config = function(_, opts)
          require("which-key.plugins.presets").operators["v"] = nil
          require("which-key").setup(opts)
        end,
      },
      
      
      config = function(_, opts)
        vim.api.nvim_set_hl(0, "MultipleCursorsCursor", {bg="#999999", fg="#000000"})
        vim.api.nvim_set_hl(0, "MultipleCursorsVisual", {bg="#777777", fg="#BBBBBB"})
        vim.api.nvim_set_hl(0, "MultipleCursorsLockedCursor", {bg="#666666", fg="#222222"})
        vim.api.nvim_set_hl(0, "MultipleCursorsLockedVisual", {bg="#555555", fg="#999999"})
      
        require("multiple-cursors").setup(opts)
      end,
      
      
      pre_hook = function()
        -- Set MultipleCursorsCursor to be slightly darker than Cursor
        local cursor = vim.api.nvim_get_hl(0, {name="Cursor"})
        cursor.bg = cursor.bg - 3355443  -- -#333333
        vim.api.nvim_set_hl(0, "MultipleCursorsCursor", cursor)
      
        -- Set MultipleCursorsVisual to be slightly darker than Visual
        local visual = vim.api.nvim_get_hl(0, {name="Visual"})
        visual.bg = visual.bg - 1118481  -- -#111111
        vim.api.nvim_set_hl(0, "MultipleCursorsVisual", visual)
      end,
      
      
      require("multiple-cursors").add_cursor(lnum, col, curswant)
      
    end,
  },
  {
    "smoka7/multicursors.nvim",
    config = function()
      
      -- lazy.nvim:
      {
          "smoka7/multicursors.nvim",
          event = "VeryLazy",
          dependencies = {
              'nvimtools/hydra.nvim',
          },
          opts = {},
          cmd = { 'MCstart', 'MCvisual', 'MCclear', 'MCpattern', 'MCvisualPattern', 'MCunderCursor' },
          keys = {
                  {
                      mode = { 'v', 'n' },
                      '<Leader>m',
                      '<cmd>MCstart<cr>',
                      desc = 'Create a selection for selected text or word under the cursor',
                  },
              },
      }
      
      
      {
          DEBUG_MODE = false,
          create_commands = true, -- create Multicursor user commands
          updatetime = 50, -- selections get updated if this many milliseconds nothing is typed in the insert mode see :help updatetime
          nowait = true, -- see :help :map-nowait
          mode_keys = {
              append = 'a',
              change = 'c',
              extend = 'e',
              insert = 'i',
          }, -- set bindings to start these modes
          normal_keys = normal_keys,
          insert_keys = insert_keys,
          extend_keys = extend_keys,
          -- see :help hydra-config.hint
          hint_config = {
              float_opts = {
                  border = 'none',
              },
              position = 'bottom',
          },
          -- accepted values:
          -- -1 true: generate hints
          -- -2 false: don't generate hints
          -- -3 [[multi line string]] provide your own hints
          -- -4 fun(heads: Head[]): string - provide your own hints
          generate_hints = {
              normal = true,
              insert = true,
              extend = true,
              config = {
                   -- determines how many columns are used to display the hints. If you leave this option nil, the number of columns will depend on the size of your window.
                  column_count = nil,
                  -- maximum width of a column.
                  max_hint_length = 25,
              }
          },
      }
      
      
       require('multicursors').setup {
          local N = require("multicursors.normal_mode")
          normal_keys = {
              -- to change default lhs of key mapping change the key
              [','] = {
                  -- assigning nil to method exits from multi cursor mode
                  -- assigning false to method removes the binding
                  method = N.clear_others,
                  -- you can pass :map-arguments here
                  opts = { desc = 'Clear others' },
              },
              ['<C-/>'] = {
                  method = function()
                      require('multicursors.utils').call_on_selections(function(selection)
                          vim.api.nvim_win_set_cursor(0, { selection.row + 1, selection.col + 1 })
                          local line_count = selection.end_row - selection.row + 1
                          vim.cmd('normal ' .. line_count .. 'gcc')
                      end)
                  end,
                  opts = { desc = 'comment selections' },
              },
          },
      }
      
      
       require('multicursors').setup {
          hint_config = false,
      }
      
      local function is_active()
          local ok, hydra = pcall(require, 'hydra.statusline')
          return ok and hydra.is_active()
      end
      
      local function get_name()
          local ok, hydra = pcall(require, 'hydra.statusline')
          if ok then
              return hydra.get_name()
          end
          return ''
      end
      
      --- for lualine add this component
      lualine_b = {
          { get_name, cond = is_active },
       }
      
      
       require('multicursors').setup {
          hint_config = {
              float_opts = {
                  border = 'rounded',
              },
              position = 'bottom-right',
          },
          generate_hints = {
              normal = true,
              insert = true,
              extend = true,
              config = {
                  column_count = 1,
              },
          },
      }
      
    end,
  },
  {
    "tigion/swap.nvim",
    config = function()
      
      return {
        'tigion/swap.nvim',
        keys = {
          { '<Leader>i', function() require('swap').switch() end, desc = 'Swap word' },
          -- { '<Leader>I', function() require('swap').opposites.switch() end, desc = 'Swap to opposite word' },
          -- { '<Leader>I', function() require('swap').chains.switch() end, desc = 'Swap to next word' },
          -- { '<Leader>I', function() require('swap').cases.switch() end, desc = 'Swap naming convention' },
          -- { '<Leader>I', function() require('swap').cases.switch('pascal') end, desc = 'Swap to PascalCase' },
          -- { '<Leader>I', function() require('swap').todos.switch() end, desc = 'Swap todo state' },
        },
        ---@module 'swap'
        ---@type swap.Config
        opts = {},
      }
      
      
      vim.pack.add({
        'https://github.com/tigion/swap.nvim',
        -- { src = 'https://github.com/tigion/swap.nvim', version = 'main' },
      })
      
      -- Use `setup()` for your own user configuration in the `{}` table.
      require('swap').setup({})
      
      -- Add a key mapping to switch something.
      vim.keymap.set('n', '<Leader>i', require('swap').switch, { desc = 'Swap word' })
      
      
      vim.keymap.set('n', '<Leader>i', require('swap').switch, { desc = 'Swap word' })
      
      
      opts = {
        all = {
          -- modules = { 'opposites', 'todos' }, -- defaults
          modules = { 'opposites', 'chains', 'cases', 'todos' },
        },
      }
      
      
      opts = {
        opposites = {
          words = { -- Default opposite words.
            ['angel'] = 'devil', -- Adds a new one.
            ['yes'] = 'ja',      -- Replaces the default `['yes'] = 'no'`.
            ['min'] = nil,       -- Removes a default.
          },
          words_by_ft = { -- File type specific opposite words.
            ['lua'] = {
              ['=='] = '~=',     -- Replaces the default `['=='] = '!='` for lua files.
            },
            ['sql'] = {
              ['asc'] = 'desc',  -- Adds a new for SQL files.
            },
          },
        },
      }
      
      
      opts = {
        chains = {
          words = { -- Default word chains.
            { 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday' },
            { 'foo', 'bar', 'baz', 'qux' },
          },
          words_by_ft = { -- File type specific word chains.
            asciidoc = {
              { '[NOTE]', '[TIP]', '[IMPORTANT]', '[WARNING]', '[CAUTION]' }, -- AsciiDoc admonitions (block)
              { 'NOTE:', 'TIP:', 'IMPORTANT:', 'WARNING:', 'CAUTION:' }, -- AsciiDoc admonitions (line)
            },
            markdown = {
              { '[!NOTE]', '[!TIP]', '[!IMPORTANT]', '[!WARNING]', '[!CAUTION]' }, -- Markdown (GitHub) alerts
            },
          },
        },
      }
      
      
      opts = {
        cases = {
          types = {
            'snake', -- snake_case
            'screaming_snake', -- SCREAMING_SNAKE_CASE
            'kebab', -- kebab-case
            'screaming_kebab', -- SCREAMING-KEBAB-CASE
            'camel', -- camelCase
            'pascal', -- PascalCase
          },
        },
      }
      
      
      ---@alias swap.ConfigModule
      --- | 'opposites'
      --- | 'cases'
      --- | 'chains'
      --- | 'todos'
      ---@alias swap.ConfigOppositesWords table<string, string>
      ---@alias swap.ConfigOppositesWordsByFt table<string, swap.ConfigOppositesWords>
      ---@alias swap.ConfigChainsWords string[][]
      ---@alias swap.ConfigChainsWordsByFt table<string, swap.ConfigChainsWords>
      ---@alias swap.ConfigCasesId
      --- | 'snake' snake_case
      --- | 'screaming_snake' SCREAMING_SNAKE_CASE
      --- | 'kebab' kebab-case
      --- | 'screaming_kebab' SCREAMING-KEBAB-CASE
      --- | 'camel' camelCase
      --- | 'pascal' PascalCase
      ---@alias swap.ConfigCasesTypes swap.ConfigCasesId[]
      
      ---@class swap.ConfigAll
      ---@field modules? swap.ConfigModule[] The default modules to use.
      
      ---@class swap.ConfigOpposites
      ---@field use_case_sensitive_mask? boolean Whether to use a case sensitive mask.
      ---@field use_default_words? boolean Whether to use the default opposites.
      ---@field use_default_words_by_ft? boolean Whether to use the default opposites by file type.
      ---@field words? swap.ConfigOppositesWords The words with their opposite words.
      ---@field words_by_ft? swap.ConfigOppositesWordsByFt The file type specific words with their opposite words.
      
      ---@class swap.ConfigChains
      ---@field use_case_sensitive_mask? boolean Whether to use a case sensitive mask.
      ---@field words? swap.ConfigChainsWords The word chains to search for.
      ---@field words_by_ft? swap.ConfigChainsWordsByFt The file type specific word chains to search for.
      
      ---@class swap.ConfigCases
      ---@field types? swap.ConfigCasesTypes The allowed case types to parse.
      
      ---@class swap.ConfigNotify
      ---@field found? boolean Whether to notify when a word is found.
      ---@field not_found? boolean Whether to notify when no word is found.
      
      ---@class swap.Config
      ---@field max_line_length? integer The maximum line length to search.
      ---@field ignore_overlapping_matches? boolean Whether to ignore overlapping matches.
      ---@field all? swap.ConfigAll The options for all modules.
      ---@field opposites? swap.ConfigOpposites The options for the opposites.
      ---@field cases? swap.ConfigCases The options for the cases.
      ---@field chains? swap.ConfigChains The options for the chains.
      ---@field notify? swap.ConfigNotify The notifications to show.
      
      
      ---@type swap.Config
      local defaults = {
        max_line_length = 1000,
        ignore_overlapping_matches = true,
        all = {
          modules = { 'opposites', 'todos' },
        },
        opposites = {
          use_case_sensitive_mask = true,
          use_default_words = true,
          use_default_words_by_ft = true,
          words = {
            ['enable'] = 'disable',
            ['true'] = 'false',
            ['yes'] = 'no',
            ['on'] = 'off',
            ['and'] = 'or',
            ['left'] = 'right',
            ['up'] = 'down',
            ['min'] = 'max',
            ['=='] = '!=',
            ['<='] = '>=',
            ['<'] = '>',
          },
          words_by_ft = {
            ['lua'] = {
              ['=='] = '~=',
            },
            ['sql'] = {
              ['asc'] = 'desc',
            },
          },
        },
        chains = {
          use_case_sensitive_mask = true,
          words = {},
          words_by_ft = {},
        },
        cases = {
          types = {
            'snake',
            'screaming_snake',
            'kebab',
            'screaming_kebab',
            'camel',
            'pascal',
          },
        },
        notify = {
          found = false,
          not_found = true,
        },
      }
      
    end,
  },
  {
    "numToStr/Comment.nvim",
    config = function()
      
      -- add this to your lua/plugins.lua, lua/plugins/init.lua,  or the file you keep your other plugins:
      {
          'numToStr/Comment.nvim',
          opts = {
              -- add any options here
          }
      }
      
      
      
      use {
          'numToStr/Comment.nvim',
          config = function()
              require('Comment').setup()
          end
      }
      
      
      require('Comment').setup()
      
      
      {
          ---Add a space b/w comment and the line
          padding = true,
          ---Whether the cursor should stay at its position
          sticky = true,
          ---Lines to be ignored while (un)comment
          ignore = nil,
          ---LHS of toggle mappings in NORMAL mode
          toggler = {
              ---Line-comment toggle keymap
              line = 'gcc',
              ---Block-comment toggle keymap
              block = 'gbc',
          },
          ---LHS of operator-pending mappings in NORMAL and VISUAL mode
          opleader = {
              ---Line-comment keymap
              line = 'gc',
              ---Block-comment keymap
              block = 'gb',
          },
          ---LHS of extra mappings
          extra = {
              ---Add comment on the line above
              above = 'gcO',
              ---Add comment on the line below
              below = 'gco',
              ---Add comment at the end of line
              eol = 'gcA',
          },
          ---Enable keybindings
          ---NOTE: If given `false` then the plugin won't create any mappings
          mappings = {
              ---Operator-pending mapping; `gcc` `gbc` `gc[count]{motion}` `gb[count]{motion}`
              basic = true,
              ---Extra mapping; `gco`, `gcO`, `gcA`
              extra = true,
          },
          ---Function to call before (un)comment
          pre_hook = nil,
          ---Function to call after (un)comment
          post_hook = nil,
      }
      
      
      {
          pre_hook = function(ctx)
              if ctx.range.srow == ctx.range.erow then
                  -- do something with the current line
              else
                  -- do something with lines range
              end
          end,
      }
      
      
      {
          pre_hook = require('ts_context_commentstring.integrations.comment_nvim').create_pre_hook(),
      }
      
      
      {
          post_hook = function(ctx)
              if ctx.range.srow == ctx.range.erow then
                  -- do something with the current line
              else
                  -- do something with lines range
              end
          end,
      }
      
      
      -- ignores empty lines
      ignore = '^$'
      
      -- ignores line that starts with `local` (excluding any leading whitespace)
      ignore = '^(%s*)local'
      
      -- ignores any lines similar to arrow function
      ignore = '^const(.*)=(%s?)%((.*)%)(%s?)=>'
      
      
      {
          ignore = function()
              -- Only ignore empty lines for lua files
              if vim.bo.filetype == 'lua' then
                  return '^$'
              end
          end,
      }
      
      
      vim.bo.commentstring = '//%s'
      
      -- or
      vim.api.nvim_command('set commentstring=//%s')
      
      
      local ft = require('Comment.ft')
      
      -- 1. Using set function
      
      ft
       -- Set only line comment
       .set('yaml', '#%s')
       -- Or set both line and block commentstring
       .set('javascript', {'//%s', '/*%s*/'})
      
      -- 2. Metatable magic
      
      ft.javascript = {'//%s', '/*%s*/'}
      ft.yaml = '#%s'
      
      -- Multiple filetypes
      ft({'go', 'rust'}, ft.get('c'))
      ft({'toml', 'graphql'}, '#%s')
      
      
      ----------------------
      -- This is a header --
      ----------------------
      
    end,
  },
  {
    "b3nj5m1n/kommentary",
    config = function()
      
      use 'b3nj5m1n/kommentary'
      
      
      require('kommentary.config').use_extended_mappings()
      
      
      vim.api.nvim_set_keymap("n", "<leader>cic", "<Plug>kommentary_line_increase", {})
      vim.api.nvim_set_keymap("n", "<leader>ci", "<Plug>kommentary_motion_increase", {})
      vim.api.nvim_set_keymap("x", "<leader>ci", "<Plug>kommentary_visual_increase", {})
      vim.api.nvim_set_keymap("n", "<leader>cdc", "<Plug>kommentary_line_decrease", {})
      vim.api.nvim_set_keymap("n", "<leader>cd", "<Plug>kommentary_motion_decrease", {})
      vim.api.nvim_set_keymap("x", "<leader>cd", "<Plug>kommentary_visual_decrease", {})
      
      
      vim.g.kommentary_create_default_mappings = false
      
      
      vim.api.nvim_set_keymap("n", "<leader>cc", "<Plug>kommentary_line_default", {})
      vim.api.nvim_set_keymap("n", "<leader>c", "<Plug>kommentary_motion_default", {})
      vim.api.nvim_set_keymap("x", "<leader>c", "<Plug>kommentary_visual_default", {})
      
      
      vim.api.nvim_set_keymap("n", "gcc", "<Plug>kommentary_line_default", {})
      vim.api.nvim_set_keymap("n", "gc", "<Plug>kommentary_motion_default", {})
      vim.api.nvim_set_keymap("v", "gc", "<Plug>kommentary_visual_default<C-c>", {})
      
      
      lua << EOF
      require('kommentary.config').configure_language("rust", {
          single_line_comment_string = "//",
          multi_line_comment_strings = {"/*", "*/"},
      })
      EOF
      
      
      lua << EOF
      require('kommentary.config').configure_language("rust", {
          prefer_single_line_comments = true,
      })
      EOF
      
      
      lua << EOF
      require('kommentary.config').configure_language("rust", {
          prefer_multi_line_comments = true,
      })
      EOF
      
      
      lua << EOF
      require('kommentary.config').configure_language("default", {
          prefer_single_line_comments = true,
      })
      EOF
      
      
      -- local function example()
      --    print("Example")
      -- end
      
      
      -- local function example()
          -- print("Example")
      -- end
      
      
      -- function test_function_1()
      --     print("test")
      -- end
      
      -- function test_function_2()
      --     print("test")
      -- end
      
      
      -- function test_function_1()
      --     print("test")
      -- end
      --
      -- function test_function_2()
      --     print("test")
      -- end
      
      
      lua << EOF
      require('kommentary.config').configure_language({"c", "rust"}, {
          prefer_single_line_comments = true,
      })
      EOF
      
      
      local config = require('kommentary.config')
      local M = {}
      
      --[[ This function will be called automatically by the mapping, the first
      argument will be the line that is being operated on. ]]
      function M.insert_comment_below(...)
          local args = {...}
          -- This includes the commentstring
          local configuration = config.get_config(0)
          local line_number = args[1]
          -- Get the current content of the line
          local content = vim.api.nvim_buf_get_lines(0, line_number-1, line_number, false)[1]
          --[[ Get the level of indentation of that line (Find the index of the
          first non-whitespace character) ]]
          local indentation = string.find(content, "%S")
          --[[ Create a string with that indentation, with a dot at the end so that
          kommentary respects that indentation ]]
          local new_line = string.rep(" ", indentation-1) .. "."
          -- Insert the new line underneath the current one
          vim.api.nvim_buf_set_lines(0, line_number, line_number, false, {new_line})
          -- Comment in the new line
          require('kommentary.kommentary').comment_in_line(line_number+1, configuration)
          -- Set the cursor to the correct position
          vim.api.nvim_win_set_cursor(0, {vim.api.nvim_win_get_cursor(0)[1]+1, #new_line+2})
          -- Change the char under cursor (.)
          vim.api.nvim_feedkeys("cl", "n", false)
      end
      
      --[[ This is a method provided by kommentary's config, it will take care of
      setting up a <Plug> mapping. The last argument is the optional callback
      function, meaning when we execute this mapping, this function will be
      called instead of the default. --]]
      config.add_keymap("n", "kommentary_insert_below", config.context.line, { expr = true }, M.insert_comment_below)
      -- Set up a regular keymapping to the new <Plug> mapping
      vim.api.nvim_set_keymap('n', '<leader>co', '<Plug>kommentary_insert_below', { silent = true })
      
      return M
      
    end,
  },
  {
    "gennaro-tedesco/nvim-commaround",
  },
  {
    "folke/todo-comments.nvim",
    config = function()
      
      {
        "folke/todo-comments.nvim",
        dependencies = { "nvim-lua/plenary.nvim" },
        opts = {
          -- your configuration comes here
          -- or leave it empty to use the default settings
          -- refer to the configuration section below
        }
      }
      
      
      {
        signs = true, -- show icons in the signs column
        sign_priority = 8, -- sign priority
        -- keywords recognized as todo comments
        keywords = {
          FIX = {
            icon = " ", -- icon used for the sign, and in search results
            color = "error", -- can be a hex color, or a named color (see below)
            alt = { "FIXME", "BUG", "FIXIT", "ISSUE" }, -- a set of other keywords that all map to this FIX keywords
            -- signs = false, -- configure signs for some keywords individually
          },
          TODO = { icon = " ", color = "info" },
          HACK = { icon = " ", color = "warning" },
          WARN = { icon = " ", color = "warning", alt = { "WARNING", "XXX" } },
          PERF = { icon = " ", alt = { "OPTIM", "PERFORMANCE", "OPTIMIZE" } },
          NOTE = { icon = " ", color = "hint", alt = { "INFO" } },
          TEST = { icon = "⏲ ", color = "test", alt = { "TESTING", "PASSED", "FAILED" } },
        },
        gui_style = {
          fg = "NONE", -- The gui style to use for the fg highlight group.
          bg = "BOLD", -- The gui style to use for the bg highlight group.
        },
        merge_keywords = true, -- when true, custom keywords will be merged with the defaults
        -- highlighting of the line containing the todo comment
        -- * before: highlights before the keyword (typically comment characters)
        -- * keyword: highlights of the keyword
        -- * after: highlights after the keyword (todo text)
        highlight = {
          multiline = true, -- enable multine todo comments
          multiline_pattern = "^.", -- lua pattern to match the next multiline from the start of the matched keyword
          multiline_context = 10, -- extra lines that will be re-evaluated when changing a line
          before = "", -- "fg" or "bg" or empty
          keyword = "wide", -- "fg", "bg", "wide", "wide_bg", "wide_fg" or empty. (wide and wide_bg is the same as bg, but will also highlight surrounding characters, wide_fg acts accordingly but with fg)
          after = "fg", -- "fg" or "bg" or empty
          pattern = [[.*<(KEYWORDS)\s*:]], -- pattern or table of patterns, used for highlighting (vim regex)
          comments_only = true, -- uses treesitter to match keywords in comments only
          max_line_len = 400, -- ignore lines longer than this
          exclude = {}, -- list of file types to exclude highlighting
        },
        -- list of named colors where we try to extract the guifg from the
        -- list of highlight groups or use the hex color if hl not found as a fallback
        colors = {
          error = { "DiagnosticError", "ErrorMsg", "#DC2626" },
          warning = { "DiagnosticWarn", "WarningMsg", "#FBBF24" },
          info = { "DiagnosticInfo", "#2563EB" },
          hint = { "DiagnosticHint", "#10B981" },
          default = { "Identifier", "#7C3AED" },
          test = { "Identifier", "#FF00FF" }
        },
        search = {
          command = "rg",
          args = {
            "--color=never",
            "--no-heading",
            "--with-filename",
            "--line-number",
            "--column",
          },
          -- regex that will be used to match keywords.
          -- don't replace the (KEYWORDS) placeholder
          pattern = [[\b(KEYWORDS):]], -- ripgrep regex
          -- pattern = [[\b(KEYWORDS)\b]], -- match without the extra colon. You'll likely get false positives
        },
      }
      
      
      
      vim.keymap.set("n", "]t", function()
        require("todo-comments").jump_next()
      end, { desc = "Next todo comment" })
      
      vim.keymap.set("n", "[t", function()
        require("todo-comments").jump_prev()
      end, { desc = "Previous todo comment" })
      
      -- You can also specify a list of valid jump keywords
      
      vim.keymap.set("n", "]t", function()
        require("todo-comments").jump_next({keywords = { "ERROR", "WARNING" }})
      end, { desc = "Next error/warning todo comment" })
      
      
    end,
  },
  {
    "terrortylor/nvim-comment",
    config = function()
      
      require('nvim_comment').setup()
      
      
      {
        -- Linters prefer comment and line to have a space in between markers
        marker_padding = true,
        -- should comment out empty or whitespace only lines
        comment_empty = true,
        -- trim empty comment whitespace
        comment_empty_trim_whitespace = true,
        -- Should key mappings be created
        create_mappings = true,
        -- Normal mode mapping left hand side
        line_mapping = "gcc",
        -- Visual/Operator mapping left hand side
        operator_mapping = "gc",
        -- text object mapping, comment chunk,,
        comment_chunk_text_object = "ic",
        -- Hook function to call before commenting takes place
        hook = nil
      }
      
      
      require('nvim_comment').setup({comment_empty = false})
      
      
      require('nvim_comment').setup({comment_empty_trim_whitespace = false})
      
      
      require('nvim_comment').setup({create_mappings = false})
      
      
      require('nvim_comment').setup({line_mapping = "<leader>cl", operator_mapping = "<leader>c", comment_chunk_text_object = "ic"})
      
      
      require('nvim_comment').setup({marker_padding = false})
      
      
      require('nvim_comment').setup({
        hook = function()
          if vim.api.nvim_buf_get_option(0, "filetype") == "vue" then
            require("ts_context_commentstring.internal").update_commentstring()
          end
        end
      })
      
      
      -- Assumes this is being run in the context of the filetype...
      vim.api.nvim_buf_set_option(0, "commentstring", "# %s")
      
      
      vim.api.nvim_buf_set_option(0, "commentstring", "# %s")
      
      
      use "terrortylor/nvim-comment"
      require('nvim_comment').setup()
      
    end,
  },
  {
    "winston0410/commented.nvim",
    config = function()
      
      vim.api.nvim_set_keymap(
      	"n",
      	"<leader>ff",
      	"v:lua.require'commented'.codetags.fixme_line()",
      	{ expr = true, silent = true, noremap = true }
      )
      
      
      -- packer.nvim example
      use({
          "winston0410/commented.nvim",
          config = function()
              require("commented").setup({
                  codetags_keybindings = {
                      fixme = "<leader>f",
                      fixme_line = "<leader>ff",
                      todo = "<leader>t",
                      todo_line = "<leader>tt",
                      bug = "<leader>b",
                      bug_line = "<leader>bb",
                      note = "<leader>n",
                      note_line = "<leader>nn",
                      wont_fix = "<leader>w",
                      wont_fix_line = "<leader>ww",
                  },
              })
          end,
      })
      
      
      local foo = function()
          return commented("bar")
      end
      
      
      vim.api.nvim_set_keymap(
      	"n",
      	"<leader>d",
      	"v:lua.require'filename'.foo()",
      	{ expr = true, silent = true, noremap = true }
      )
      
      
      paq{'winston0410/commented.nvim'}
      
      
      Plug 'winston0410/commented.nvim'
      
      
      use{'winston0410/commented.nvim'}
      
      
      local opts = {
      	comment_padding = " ", -- padding between starting and ending comment symbols
      	keybindings = {n = "<leader>c", v = "<leader>c", nl = "<leader>cc"}, -- what key to toggle comment, nl is for mapping <leader>c$, just like dd for d
      	prefer_block_comment = false, -- Set it to true to automatically use block comment when multiple lines are selected
      	set_keybindings = true, -- whether or not keybinding is set on setup
      	ex_mode_cmd = "Comment" -- command for commenting in ex-mode, set it null to not set the command initially.
      }
      
      
      require('commented').setup()
      
      
      require'nvim-treesitter.configs'.setup {
        context_commentstring = {
          enable = true,
          -- This plugin provided an autocommand option
          enable_autocmd = true,
        }
      }
      
      
      require("commented").setup({
          hooks = {
              before_comment = require("ts_context_commentstring.internal").update_commentstring,
          },
      })
      
    end,
  },
  {
    "s1n7ax/nvim-comment-frame",
    config = function()
      
      --********************************************************--
      --    Lua is a lightweight, high-level, multi-paradigm    --
      --      programming language designed primarily for       --
      --              embedded use in applications              --
      --********************************************************--
      function String.trim(str)
          return str:gsub('^%s+', ''):gsub('%s+$', '')
      end
      
      
      use { 
          's1n7ax/nvim-comment-frame',
          requires = {
              { 'nvim-treesitter' }
          },
          config = function()
              require('nvim-comment-frame').setup()
          end
      }
      
      
      require('nvim-comment-frame').setup({
          keymap = '<leader>cc',
          --       ^^^^^^^^^^^ change this to what ever you want
      
          multiline_keymap = '<leader>C',
          --                 ^^^^^^^^^^^ change this to what ever you want
      })
      
      
      vim.api.nvim_set_keymap('n', '<leader>cc', ":lua require('nvim-comment-frame').add_comment()<CR>", {})
      --                           ^^^^^^^^^^^ change this to what ever you want
      
      vim.api.nvim_set_keymap('n', '<leader>C', ":lua require('nvim-comment-frame').add_multiline_comment()<CR>", {})
      --                           ^^^^^^^^^^^ change this to what ever you want
      
      
      require('nvim-comment-frame').setup({
      
          -- if true, <leader>cf keymap will be disabled
          disable_default_keymap = false,
      
          -- adds custom keymap
          keymap = '<leader>cc',
          multiline_keymap = '<leader>C',
      
          -- start the comment with this string
          start_str = '//',
      
          -- end the comment line with this string
          end_str = '//',
      
          -- fill the comment frame border with this character
          fill_char = '-',
      
          -- width of the comment frame
          frame_width = 70,
      
          -- wrap the line after 'n' characters
          line_wrap_len = 50,
      
          -- automatically indent the comment frame based on the line
          auto_indent = true,
      
          -- add comment above the current line
          add_comment_above = true,
      
          -- configurations for individual language goes here
          languages = {
          }
      })
      
      
      require('nvim-comment-frame').setup({
          languages = {
              -- configuration for Lua programming language
              -- @NOTE global configuration will be overridden by language level
              -- configuration if provided
              lua = {
                  -- start the comment with this string
                  start_str = '--[[',
      
                  -- end the comment line with this string
                  end_str = ']]--',
      
                  -- fill the comment frame border with this character
                  fill_char = '*',
      
                  -- width of the comment frame
                  frame_width = 100,
      
                  -- wrap the line after 'n' characters
                  line_wrap_len = 70,
      
                  -- automatically indent the comment frame based on the line
                  auto_indent = false,
      
                  -- add comment above the current line
                  add_comment_above = false,
              },
          }
      })
      
    end,
  },
  {
    "danymat/neogen",
    config = function()
      
      { 
          "danymat/neogen", 
          config = true,
          -- Uncomment next line if you want to follow only stable versions
          -- version = "*" 
      }
      
      
      use {
          "danymat/neogen",
          config = function()
              require('neogen').setup {}
          end,
          -- Uncomment next line if you want to follow only stable versions
          -- tag = "*"
      }
      
      
      require('neogen').generate()
      
      
      local opts = { noremap = true, silent = true }
      vim.api.nvim_set_keymap("n", "<Leader>nf", ":lua require('neogen').generate()<CR>", opts)
      
      
      require('neogen').generate({
          type = "func" -- the annotation type to generate. Currently supported: func, class, type, file
      })
      
      
      local opts = { noremap = true, silent = true }
      vim.api.nvim_set_keymap("n", "<Leader>nc", ":lua require('neogen').generate({ type = 'class' })<CR>", opts)
      
      
      require('neogen').setup({ snippet_engine = "luasnip" })
      
      
      local snippet, row, col = require('neogen').generate({ snippet_engine = "luasnip" })
      
      
      local opts = { noremap = true, silent = true }
      vim.api.nvim_set_keymap("i", "<C-l>", ":lua require('neogen').jump_next<CR>", opts)
      vim.api.nvim_set_keymap("i", "<C-h>", ":lua require('neogen').jump_prev<CR>", opts)
      
      
      local cmp = require('cmp')
      local neogen = require('neogen')
      
      cmp.setup {
          ...
      
          -- You must set mapping if you want.
          mapping = {
              ["<tab>"] = cmp.mapping(function(fallback)
                  if neogen.jumpable() then
                      neogen.jump_next()
                  else
                      fallback()
                  end
              end, {
                  "i",
                  "s",
              }),
              ["<S-tab>"] = cmp.mapping(function(fallback)
                  if neogen.jumpable(true) then
                      neogen.jump_prev()
                  else
                      fallback()
                  end
              end, {
                  "i",
                  "s",
              }),
          },
          ...
      }
      
      
      require('neogen').setup {
          enabled = true,             --if you want to disable Neogen
          input_after_comment = true, -- (default: true) automatic jump (with insert mode) on inserted annotation
          -- jump_map = "<C-e>"       -- (DROPPED SUPPORT, see [here](#cycle-between-annotations) !) The keymap in order to jump in the annotation fields (in insert mode)
      }
      
      
      require('neogen').setup {
          enabled = true,
          languages = {
              lua = {
                  template = {
                      annotation_convention = "emmylua" -- for a full list of annotation_conventions, see supported-languages below,
                      ... -- for more template configurations, see the language's configuration file in configurations/{lang}.lua
                      }
              },
              ...
          }
      }
      
      
      require('neogen').setup({
          languages = {
              ['cpp.doxygen'] = require('neogen.configurations.cpp')
          }
      })
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-comment.md",
  },
  {
    "LudoPinelli/comment-box.nvim",
    config = function()
      
      { "LudoPinelli/comment-box.nvim", }
      
      
      use("LudoPinelli/comment-box.nvim")
      
      
      local keymap = vim.keymap.set
      local opts = { noremap = true, silent = true }
      
      -- Titles
      keymap({ "n", "v" }, "<Leader>cb", "<Cmd>CBccbox<CR>", opts)
      -- Named parts
      keymap({ "n", "v" }, "<Leader>ct", "<Cmd>CBllline<CR>", opts)
      -- Simple line
      keymap("n", "<Leader>cl", "<Cmd>CBline<CR>", opts)
      -- keymap("i", "<M-l>", "<Cmd>CBline<CR>", opts) -- To use in Insert Mode
      -- Marked comments
      keymap({ "n", "v" }, "<Leader>cm", "<Cmd>CBllbox14<CR>", opts)
      -- Removing a box is simple enough with the command (CBd), but if you
      -- use it a lot:
      -- keymap({ "n", "v" }, "<Leader>cd", "<Cmd>CBd<CR>", opts)
      
      
      local wk = require("which-key")
      
      wk.register({
        ["<Leader>"] = {
          c = {
            name = " □  Boxes",
            b = { "<Cmd>CBccbox<CR>", "Box Title" },
            t = { "<Cmd>CBllline<CR>", "Titled Line" },
            l = { "<Cmd>CBline<CR>", "Simple Line" },
            m = { "<Cmd>CBllbox14<CR>", "Marked" },
            -- d = { "<Cmd>CBd<CR>", "Remove a box" },
          },
        },
      })
      
      
      -- A left aligned fixed size box with the text left justified:
      :CBllbox
      -- or
      :lua require("comment-box").llbox()
      
      -- A centered fixed size box with the text centered:
      :CBccbox
      -- or
      :lua require("comment-box").ccbox()
      
      -- A centered adapted box:
      :CBacbox
      -- or
      :lua require("comment-box").acbox()
      
      -- A left aligned fixed size box with the text left justified,
      -- using the syle 17 from the catalog:
      :CBllbox17
      -- or
      :lua require("comment-box").llbox(17)
      
      
      -- A left aligned titled line with the text left justified:
      :CBllline
      -- or
      :lua require("comment-box").llline()
      
      -- A centered titled line with the text right justified:
      :CBcrline
      -- or
      :lua require("comment-box").crline()
      
      -- A right aligned titled line with the text centered,
      -- using the style 13 from the catalog:
      :CBrcline13
      -- or
      :lua require("comment-box").rcline(13)
      
      
      -- A left aligned line:
      :CBline
      -- or
      :lua require("comment-box").line()
      
      -- A centered line:
      :CBcline
      -- or
      :lua require("comment-box").cline()
      
      -- A right aligned line using the style 6 from the catalog:
      :CBrline6
      -- or
      :lua require("comment-box").rline(6)
      
      
      local keymap = vim.keymap.set
      local opts = { noremap = true, silent = true }
      local cb = require("comment-box")
      
      -- left aligned fixed size box with left aligned text
      keymap({ "n", "v"}, "<Leader>cb", "<Cmd>CBllbox<CR>", opts)
      -- centered adapted box
      keymap({ "n", "v"}, "<Leader>cc", "<Cmd>CBacbox<CR>", opts)
      
      -- left aligned titled line with left aligned text
      keymap({ "n", "v" }, "<Leader>ct", "<Cmd>llline<CR>", opts)
      
      -- centered line
      keymap("n", "<Leader>cl", "<Cmd>CBcline<CR>", opts)
      keymap("i", "<M-l>", "<Cmd>CBcline<CR>", opts)
      
      -- remove a box or a titled line
      keymap({ "n", "v" }, "<Leader>cd", "<Cmd>CBd<CR>", opts)
      
      
      :CBcatalog
      -- or
      :lua require("comment-box").catalog()
      
      
      -- A box with the text centered and the predefined type of box n°10:
      :CBcbox10
      -- or
      :lua require("comment-box").cbox(10)
      
      -- A line with the predefined type of line n°4:
      :CBline4
      -- or
      :lua require("comment-box").line(4)
      
      
      require('comment-box').setup({
        -- type of comments:
        --   - "line":  comment-box will always use line style comments
        --   - "block": comment-box will always use block style comments
        --   - "auto":  comment-box will use block line style comments if
        --              multiple lines are selected, line style comments
        --              otherwise
        comment_style = "line",
        doc_width = 80, -- width of the document
        box_width = 60, -- width of the boxes
        borders = { -- symbols used to draw a box
          top = "─",
          bottom = "─",
          left = "│",
          right = "│",
          top_left = "╭",
          top_right = "╮",
          bottom_left = "╰",
          bottom_right = "╯",
        },
        line_width = 70, -- width of the lines
        lines = { -- symbols used to draw a line
          line = "─",
          line_start = "─",
          line_end = "─",
          title_left = "─",
          title_right = "─",
        },
        outer_blank_lines_above = false, -- insert a blank line above the box
        outer_blank_lines_below = false, -- insert a blank line below the box
        inner_blank_lines = false, -- insert a blank line above and below the text
        line_blank_line_above = false, -- insert a blank line above the line
        line_blank_line_below = false, -- insert a blank line below the line
      })
      
      
      -- map ]b [b to go to next block comment
      vim.keymap.set('n', ']b', '/\\S\\zs\\s*╭<CR>zt')
      vim.keymap.set('n', '[b', '?\\S\\zs\\s*╭<CR>zt')
      
    end,
  },
  {
    "JoosepAlviste/nvim-ts-context-commentstring",
    config = function()
      
      require('lazy').setup {
        'JoosepAlviste/nvim-ts-context-commentstring',
      }
      
      
      require('ts_context_commentstring').setup {
        enable_autocmd = false,
      }
      
      
      vim.opt.updatetime = 100
      
    end,
  },
  {
    "LucasTavaresA/SingleComment.nvim",
    config = function()
      
      use {
        "lucastavaresa/SingleComment.nvim",
      }
      
      
      {
        "lucastavaresa/SingleComment.nvim",
      }
      
      
      -- comments the current line, or a number of lines 5gcc
      vim.keymap.set("n", "gcc", require("SingleComment").SingleComment, { expr = true })
      -- comments the selected lines
      vim.keymap.set("v", "gcc", require("SingleComment").Comment, {})
      -- toggle a comment top/ahead of the current line
      vim.keymap.set("n", "gca", require("SingleComment").ToggleCommentAhead, {})
      -- comments ahead of the current line
      vim.keymap.set("n", "gcA", require("SingleComment").CommentAhead, {})
      -- comment a block, and removes the innermost block comment in normal mode
      vim.keymap.set({ "n", "v" }, "gcb", require("SingleComment").BlockComment)
      -- pastes as a comment, accounting for indentation
      vim.keymap.set({ "n", "v" }, "gcp", require("SingleComment").CommentPaste)
      
      
      -- you can pass "block", and it will **try** to get block comments
      local comment = require("SingleComment").GetComment()
      
      
        use {
          "lucastavaresa/SingleComment.nvim",
          opt = true,
          keybindings = {
            { { "n", "v" }, "gcc" }, { "n", "gca" }, { "n", "gcA" },
            { { "n", "v" }, "gcb" }, { { "n", "v" }, "gcp" }
          },
          requires = {
            "nvim-treesitter/nvim-treesitter",
            "JoosepAlviste/nvim-ts-context-commentstring"
          },
          setup = function()
            vim.keymap.set(
              "n",
              "gcc",
              require("SingleComment").SingleComment,
              { expr = true }
            )
            vim.keymap.set("v", "gcc", require("SingleComment").Comment, {})
            vim.keymap.set("n", "gca", require("SingleComment").ToggleCommentAhead, {})
            vim.keymap.set("n", "gcA", require("SingleComment").CommentAhead, {})
            vim.keymap.set({ "n", "v" }, "gcb", require("SingleComment").BlockComment)
            vim.keymap.set({ "n", "v" }, "gcp", require("SingleComment").CommentPaste)
          end
        }
      
      
        {
          "lucastavaresa/SingleComment.nvim",
          lazy = true,
          dependencies = {
            "nvim-treesitter/nvim-treesitter",
            "JoosepAlviste/nvim-ts-context-commentstring"
          },
          init = function()
            vim.keymap.set("n", "gcc", require("SingleComment").SingleComment, { expr = true })
            vim.keymap.set("v", "gcc", require("SingleComment").Comment, {})
            vim.keymap.set("n", "gca", require("SingleComment").ToggleCommentAhead, {})
            vim.keymap.set("n", "gcA", require("SingleComment").CommentAhead, {})
            vim.keymap.set({ "n", "v" }, "gcb", require("SingleComment").BlockComment)
            vim.keymap.set({ "n", "v" }, "gcp", require("SingleComment").CommentPaste)
          end,
        },
      
    end,
  },
  {
    "Zeioth/dooku.nvim",
    config = function()
      
      {
        "Zeioth/dooku.nvim",
        event = "VeryLazy",
        opts = {
          -- your config options here
        },
      },
      
      
      project_root = { '.git', '.hg', '.svn', '.bzr', '_darcs', '_FOSSIL_', '.fslckout' } -- when one of these files is found, consider that directory the project root. Search starts upwards from the current buffer.
      browser_cmd = "xdg-open"     -- write your internet browser here. If unset, it will attempt to detect it automatically.
      
      -- automations
      on_bufwrite_generate = false -- auto run :DookuGenerate when a buffer is written.
      on_generate_open = true      -- auto open when running :DookuGenerate. This options is not triggered by on_bufwrite_generate.
      auto_setup = true            -- auto download a config for the generator if it doesn't exist in the project.
      
      -- notifications
      on_generate_notification = true
      on_open_notification = true
      
    end,
  },
  {
    "soemre/commentless.nvim",
    config = function()
      
      {
          "soemre/commentless.nvim",
          cmd = "Commentless",
          keys = {
              {
                  "<leader>/",
                  function()
                      require("commentless").toggle()
                  end,
                  desc = "Toggle Comments",
              },
          },
          dependencies = {
              "nvim-treesitter/nvim-treesitter",
          },
          opts = {
              -- Customize Configuration
          },
      }
      
      
      vim.keymap.set("n", "<leader>/", function()
          require("commentless").toggle()
      end)
      
      
      {
          hide_following_blank_lines = true,
          foldtext = function(folded_count)
              return "(" .. folded_count .. " comments)"
          end,
      }
      
      
      vim.opt.foldminlines = 0 -- Allow folding/hiding single lines
      vim.opt.fillchars = "fold: " -- Remove the trailing dots
      
    end,
  },
  {
    "TheLazyCat00/simple-format",
    config = function()
      
      {
          "TheLazyCat00/simple-format",
          opts = {
              -- the anchors for search and replace
              -- use uncommon characters or sequences
              opening_anchor = "\226\160\128",
              closing_anchor = "\226\160\129",
      
              -- the opening and closing tags for the search syntax
              group_start = "<",
              group_end = ">",
          },
          config = function (_, opts)
              local replace = require("simple-format").replace
              replace.setup(opts)
      
              -- add your own formatting logic
              -- remember to use vim.schedule to prevent blocking the user
          end
      }
      
      
      {
          -- HACK: use uncommon characters as anchors
          opening_anchor = "\226\160\128",
          closing_anchor = "\226\160\129",
          group_start = "<",
          group_end = ">",
      }
      
      
      {
          "TheLazyCat00/simple-format",
          event = "BufReadPost",
          -- enabled = false,
          opts = {},
          config = function (_, opts)
              local simple_format = require("simple-format")
              simple_format.setup(opts)
              local replace = simple_format.replace
              vim.api.nvim_create_autocmd("InsertLeave", {
                  callback = function()
                      vim.schedule(function ()
                          replace("(%S)(<operator=.->)", "%1 %2")
                          replace("(<operator=.->)(%S)", "%1 %2")
                          replace("(<punctuation.delimiter=,>) -(%S)", "%1 %2")
                          replace("(<punctuation.bracket={>) -(%S.-%S) -(<punctuation.bracket=}>)", "%1 %2 %3")
                          replace("(<punctuation.bracket={>) -(<punctuation.bracket=}>)", "%1%2")
                          replace("(<punctuation.bracket=%(>) -(%S.-%S) -(<punctuation.bracket=%)>)", "%1%2%3")
                          replace("(<punctuation.bracket=%(>) -(<punctuation.bracket=%)>)", "%1%2")
                      end)
                  end,
              })
          end
      }
      
      
        replace("(<punctuation.delimiter=,>)(%S)", "%1 %2")
        -- Explanation: We wanna search for a punctuation delimiter with
        -- the value ",".
        -- We need to capture this, so that we can use the value in the replace process:
        -- We do this putting it in parentheses.
        -- Then we search for a character that is not a white space:
        -- %S means anything thats NOT a white space character.
        -- We also capture this value for later use.
      
        -- Then we replace the string with "%1 %2".
        -- This means that we take capture group 1, put a space and add group 2.
        -- NOTE: Groups get labeled automatically in regex according to the order.
          
      
        -- We need to escape parentheses
        replace("<punctuation.bracket=%(> ", "(")
        replace(" <punctuation.bracket=%)>", ")")
          
    end,
  },
  {
    "gpanders/editorconfig.nvim",
    config = function()
      
      require('editorconfig').properties.foo = function(bufnr, val)
        vim.b[bufnr].foo = val
      end
      
    end,
  },
  {
    "mhartington/formatter.nvim",
    config = function()
      
      require('packer').use { 'mhartington/formatter.nvim' }
      
      
      require("paq") { 'mhartington/formatter.nvim' }
      
      
      -- Utilities for creating configurations
      local util = require "formatter.util"
      
      -- Provides the Format, FormatWrite, FormatLock, and FormatWriteLock commands
      require("formatter").setup {
        -- Enable or disable logging
        logging = true,
        -- Set the log level
        log_level = vim.log.levels.WARN,
        -- All formatter configurations are opt-in
        filetype = {
          -- Formatter configurations for filetype "lua" go here
          -- and will be executed in order
          lua = {
            -- "formatter.filetypes.lua" defines default configurations for the
            -- "lua" filetype
            require("formatter.filetypes.lua").stylua,
      
            -- You can also define your own configuration
            function()
              -- Supports conditional formatting
              if util.get_current_buffer_file_name() == "special.lua" then
                return nil
              end
      
              -- Full specification of configurations is down below and in Vim help
              -- files
              return {
                exe = "stylua",
                args = {
                  "--search-parent-directories",
                  "--stdin-filepath",
                  util.escape_path(util.get_current_buffer_file_path()),
                  "--",
                  "-",
                },
                stdin = true,
              }
            end
          },
      
          -- Use the special "*" filetype for defining formatter configurations on
          -- any filetype
          ["*"] = {
            -- "formatter.filetypes.any" defines default configurations for any
            -- filetype
            require("formatter.filetypes.any").remove_trailing_whitespace,
            -- Remove trailing whitespace without 'sed'
            -- require("formatter.filetypes.any").substitute_trailing_whitespace,
          }
        }
      }
      
      
      local augroup = vim.api.nvim_create_augroup
      local autocmd = vim.api.nvim_create_autocmd
      augroup("__formatter__", { clear = true })
      autocmd("BufWritePost", {
      	group = "__formatter__",
      	command = ":FormatWrite",
      })
      
      
    end,
  },
  {
    "lukas-reineke/lsp-format.nvim",
    config = function()
      
      -- init.lua
      require("packer").startup(function()
          use "lukas-reineke/lsp-format.nvim"
      end)
      
      
      require("lsp-format").setup {}
      
      vim.api.nvim_create_autocmd('LspAttach', {
        callback = function(args)
          local client = assert(vim.lsp.get_client_by_id(args.data.client_id))
          require("lsp-format").on_attach(client, args.buf)
        end,
      })
      
      
      vim.cmd [[cabbrev wq execute "Format sync" <bar> wq]]
      
      
      require("lsp-format").setup {
          typescript = {
              tab_width = function()
                  return vim.opt.shiftwidth:get()
              end,
          },
          yaml = { tab_width = 2 },
      }
      local prettier = {
          formatCommand = [[prettier --stdin-filepath ${INPUT} ${--tab-width:tab_width}]],
          formatStdin = true,
      }
      require("lspconfig").efm.setup {
          on_attach = require("lsp-format").on_attach,
          init_options = { documentFormatting = true },
          settings = {
              languages = {
                  typescript = { prettier },
                  yaml = { prettier },
              },
          },
      }
      
    end,
  },
  {
    "sbdchd/neoformat",
  },
  {
    "cappyzawa/trim.nvim",
    config = function()
      
      require("lazy").setup({
        "cappyzawa/trim.nvim",
        opts = {}
      }, opt)
      
      
      use({
        "cappyzawa/trim.nvim",
        config = function()
          require("trim").setup({})
        end
      })
      
      
      -- default config
      local default_config = {
        ft_blocklist = {},
        patterns = {},
        trim_on_write = true,
        trim_trailing = true,
        trim_last_line = true,
        trim_first_line = true,
        highlight = false,
        highlight_bg = '#ff0000', -- or 'red'
        highlight_ctermbg = 'red',
        notifications = true,
      }
      
      
      require('trim').setup({
        -- if you want to ignore markdown file.
        -- you can specify filetypes.
        ft_blocklist = {"markdown"},
      
        -- if you want to remove multiple blank lines
        patterns = {
          [[%s/\(\n\n\)\n\+/\1/]],   -- replace multiple blank lines with a single line
        },
      
        -- if you want to disable trim on write by default
        trim_on_write = false,
      
        -- highlight trailing spaces
        highlight = true
      })
      
    end,
  },
  {
    "mcauley-penney/tidy.nvim",
    config = function()
      
      {
          "mcauley-penney/tidy.nvim",
          config = true,
      }
      
      
      {
        enabled_on_save = true
        filetype_exclude = {}  -- Tidy will not be enabled for any filetype, e.g. "diff", in this table
        only_modified_lines = false,
        provide_undefined_editorconfig_behavior = false,
      }
      
      
      {
          "mcauley-penney/tidy.nvim",
          opts = {
              enabled_on_save = false
              filetype_exclude = { "markdown", "diff" }
          },
          init = function()
              vim.keymap.set('n', "<leader>tt", require("tidy").toggle, {})
              vim.keymap.set('n', "<leader>tr", require("tidy").run, {})
          end
      }
      
    end,
  },
  {
    "MunifTanjim/prettier.nvim",
    config = function()
      
      use('neovim/nvim-lspconfig')
      use('jose-elias-alvarez/null-ls.nvim')
      use('MunifTanjim/prettier.nvim')
      
      
      local null_ls = require("null-ls")
      
      local group = vim.api.nvim_create_augroup("lsp_format_on_save", { clear = false })
      local event = "BufWritePre" -- or "BufWritePost"
      local async = event == "BufWritePost"
      
      null_ls.setup({
        on_attach = function(client, bufnr)
          if client.supports_method("textDocument/formatting") then
            vim.keymap.set("n", "<Leader>f", function()
              vim.lsp.buf.format({ bufnr = vim.api.nvim_get_current_buf() })
            end, { buffer = bufnr, desc = "[lsp] format" })
      
            -- format on save
            vim.api.nvim_clear_autocmds({ buffer = bufnr, group = group })
            vim.api.nvim_create_autocmd(event, {
              buffer = bufnr,
              group = group,
              callback = function()
                vim.lsp.buf.format({ bufnr = bufnr, async = async })
              end,
              desc = "[lsp] format on save",
            })
          end
      
          if client.supports_method("textDocument/rangeFormatting") then
            vim.keymap.set("x", "<Leader>f", function()
              vim.lsp.buf.format({ bufnr = vim.api.nvim_get_current_buf() })
            end, { buffer = bufnr, desc = "[lsp] format" })
          end
        end,
      })
      
      
      local null_ls = require("null-ls")
      
      null_ls.setup({
        on_attach = function(client, bufnr)
          if client.resolved_capabilities.document_formatting then
            vim.cmd("nnoremap <silent><buffer> <Leader>f :lua vim.lsp.buf.formatting()<CR>")
      
            -- format on save
            vim.cmd("autocmd BufWritePost <buffer> lua vim.lsp.buf.formatting()")
          end
      
          if client.resolved_capabilities.document_range_formatting then
            vim.cmd("xnoremap <silent><buffer> <Leader>f :lua vim.lsp.buf.range_formatting({})<CR>")
          end
        end,
      })
      
      
      local prettier = require("prettier")
      
      prettier.setup({
        bin = 'prettier', -- or `'prettierd'` (v0.23.3+)
        filetypes = {
          "css",
          "graphql",
          "html",
          "javascript",
          "javascriptreact",
          "json",
          "less",
          "markdown",
          "scss",
          "typescript",
          "typescriptreact",
          "yaml",
        },
      })
      
      
      prettier.setup({
        ["null-ls"] = {
          condition = function()
            return prettier.config_exists({
              -- if `false`, skips checking `package.json` for `"prettier"` key
              check_package_json = true,
            })
          end,
          runtime_condition = function(params)
            -- return false to skip running prettier
            return true
          end,
          timeout = 5000,
        }
      })
      
      
      prettier.setup({
        cli_options = {
          arrow_parens = "always",
          bracket_spacing = true,
          bracket_same_line = false,
          embedded_language_formatting = "auto",
          end_of_line = "lf",
          html_whitespace_sensitivity = "css",
          -- jsx_bracket_same_line = false,
          jsx_single_quote = false,
          print_width = 80,
          prose_wrap = "preserve",
          quote_props = "as-needed",
          semi = true,
          single_attribute_per_line = false,
          single_quote = false,
          tab_width = 2,
          trailing_comma = "es5",
          use_tabs = false,
          vue_indent_script_and_style = false,
        },
      })
      
      
      prettier.setup({
        cli_options = {
          -- https://prettier.io/docs/en/cli.html#--config-precedence
          config_precedence = "prefer-file", -- or "cli-override" or "file-override"
        },
      })
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-align.md",
  },
  {
    "emileferreira/nvim-strict",
    config = function()
      
      use({
          'emileferreira/nvim-strict',
          config = function()
              require('strict').setup()
          end
      })
      
      
      local default_config = {
          included_filetypes = nil,
          excluded_filetypes = nil,
          excluded_buftypes = { 'help', 'nofile', 'terminal', 'prompt' },
          match_priority = -1,
          deep_nesting = {
              highlight = true,
              highlight_group = 'DiffDelete',
              depth_limit = 3,
              ignored_trailing_characters = nil,
              ignored_leading_characters = nil
          },
          overlong_lines = {
              highlight = true,
              highlight_group = 'DiffDelete',
              length_limit = 80,
              split_on_save = true
          },
          trailing_whitespace = {
              highlight = true,
              highlight_group = 'SpellBad',
              remove_on_save = true
          },
          trailing_empty_lines = {
              highlight = true,
              highlight_group = 'SpellBad',
              remove_on_save = true
          },
          space_indentation = {
              highlight = false,
              highlight_group = 'SpellBad',
              convert_on_save = false
          },
          tab_indentation = {
              highlight = true,
              highlight_group = 'SpellBad',
              convert_on_save = true
          },
          todos = {
              highlight = true,
              highlight_group = 'DiffAdd'
          }
      }
      
      
      require('strict').setup({
          excluded_filetypes = { 'text', 'markdown', 'html' },
          deep_nesting = {
              depth_limit = 5,
              ignored_trailing_characters = ',',
              ignored_leading_characters = '.'
          },
          overlong_lines = {
              length_limit = 120
          }
      })
      
      
      local strict = require('strict')
      local options = { noremap = true, silent = true }
      vim.keymap.set('n', '<Leader>tw', strict.remove_trailing_whitespace, options)
      vim.keymap.set('n', '<Leader>tl', strict.remove_trailing_empty_lines, options)
      vim.keymap.set('n', '<Leader>st', strict.convert_spaces_to_tabs, options)
      vim.keymap.set('n', '<Leader>ts', strict.convert_tabs_to_spaces, options)
      vim.keymap.set('n', '<Leader>ol', strict.split_overlong_lines, options)
      
    end,
  },
  {
    "tenxsoydev/tabs-vs-spaces.nvim",
    config = function()
      
      use "tenxsoydev/tabs-vs-spaces.nvim"
      
      -- ..
      -- Then load it in a preferred location.
      require("tabs-vs-spaces").setup()
      
      
      { "tenxsoydev/tabs-vs-spaces.nvim", config = true },
      
      
      require("tabs-vs-spaces").setup {
        -- Preferred indentation. Possible values: "auto"|"tabs"|"spaces".
        -- "auto" detects the dominant indentation style in a buffer and highlights deviations.
        indentation = "auto",
        -- Use a string like "DiagnosticUnderlineError" to link the `TabsVsSpace` highlight to another highlight.
        -- Or a table valid for `nvim_set_hl` - e.g. { fg = "MediumSlateBlue", undercurl = true }.
        highlight = "DiagnosticUnderlineHint",
        -- Priority of highight matches.
        priority = 20,
        ignore = {
          filetypes = {},
          -- Works for normal buffers by default.
          buftypes = {
            "acwrite",
            "help",
            "nofile",
            "nowrite",
            "quickfix",
            "terminal",
            "prompt",
          },
        },
        standartize_on_save = false,
        -- Enable or disable user commands see Readme.md/#Commands for more info.
        user_commands = true,
      }
      
    end,
  },
  {
    "bennypowers/svgo.nvim",
    config = function()
      
      return { 'bennypowers/svgo.nvim',
        opts = {
          -- uses the bundled config by default, override by passing a config path
          config = vim.fn.expand('~/.config/svgo/svgo.config.js')
        }
      }
      
    end,
  },
  {
    "niuiic/format.nvim",
    config = function()
      
      require("format").setup({
      	allow_update_if_buf_changed = false,
      	-- function to calculate path of the temp file
      	temp_file = function(file_path)
      		local core = require("core")
      		local new_file_path = core.file.dir(file_path)
      			.. "/_"
      			.. core.file.name(file_path)
      			.. "."
      			.. (core.file.extension(file_path) or "")
      		return new_file_path
      	end,
      	hooks = {
      		---@type fun(code: integer, signal: integer) | nil
      		on_success = function()
      			vim.notify("Formatting Succeed", vim.log.levels.INFO, { title = "Format" })
      		end,
      		---@type fun(err: string | nil, data: string | nil) | nil
      		on_err = function()
      			vim.notify("Formatting Failed", vim.log.levels.ERROR, { title = "Format" })
      		end,
      		on_timeout = function()
      			vim.notify("Formatting Timeout", vim.log.levels.ERROR, { title = "Format" })
      		end,
      	},
      	filetypes = {
      		-- see format configuration below
      		lua = require("format.builtins.stylua"),
      		rust = require("format.builtins.rustfmt"),
      		javascript = require("format.builtins.prettier"),
      		typescript = require("format.builtins.prettier"),
      		-- ...
      	},
      })
      
      
      javascript = function(file_path)
      	return {
      		-- the first task
      		---@class format.config
      		---@field cmd string
      		---@field args string[]
      		---@field options {env?: table<string, any>, cwd?: string, uid?: number, gid?: number, verbatim?: boolean, detached?: boolean, hide?: boolean, timeout?: number} | nil
      		---@field on_success fun(code: integer, signal: integer) | nil
      		---@field on_err fun(err: string | nil, data: string | nil) | nil
      		---@field ignore_err (fun(err: string | nil, data: string | nil): boolean) | nil
      		{
      			cmd = "prettier",
      			args = {
      				-- this plugin copies content of current buffer to a temporary file, and format this file, then write back to the buffer, thus, you need to make sure the formatter can write to the file
      				"-w",
      				file_path,
      			},
      			-- some formatters may output to stderr when formatted successfully, use this function to ignore these errors
      			ignore_err = function(err, data)
      				return err == nil and data == nil
      			end,
      		},
      		-- the second task
      		{
      			cmd = "eslint",
      			args = {
      				"--fix",
      				file_path,
      			},
      			-- just try to fix error with eslint, ignore the errors whether it succeed or not
      			ignore_err = function()
      				return true
      			end,
      			-- only the last task's `on_success` works
      			-- all tasks's `on_err` works
      			on_success = function()
      				print("format success")
      			end,
      		},
      	}
      end
      
      
      local filetypes_use_lsp_format = {
      	"c",
      	"cpp",
      }
      local format = function()
      	local core = require("core")
      	if
      		core.lua.list.includes(filetypes_use_lsp_format, function(filetype)
      			return filetype == vim.bo.filetype
      		end)
      	then
      		vim.lsp.buf.format()
      	else
      		require("format").format()
      	end
      end
      
    end,
  },
  {
    "elentok/format-on-save.nvim",
    config = function()
      
      require('format-on-save').setup({
        experiments = {
          partial_update = 'diff', -- or 'line-by-line'
        }
      })
      
      
      { "elentok/format-on-save.nvim" },
      
      
      local format_on_save = require("format-on-save")
      local formatters = require("format-on-save.formatters")
      
      format_on_save.setup({
        exclude_path_patterns = {
          "/node_modules/",
          ".local/share/nvim/lazy",
        },
        formatter_by_ft = {
          css = formatters.lsp,
          html = formatters.lsp,
          java = formatters.lsp,
          javascript = formatters.lsp,
          json = formatters.lsp,
          lua = formatters.lsp,
          markdown = formatters.prettierd,
          openscad = formatters.lsp,
          python = formatters.black,
          rust = formatters.lsp,
          scad = formatters.lsp,
          scss = formatters.lsp,
          sh = formatters.shfmt,
          terraform = formatters.lsp,
          typescript = formatters.prettierd,
          typescriptreact = formatters.prettierd,
          yaml = formatters.lsp,
      
          -- Add your own shell formatters:
          myfiletype = formatters.shell({ cmd = { "myformatter", "%" } }),
      
          -- Add lazy formatter that will only run when formatting:
          my_custom_formatter = function()
            if vim.api.nvim_buf_get_name(0):match("/README.md$") then
              return formatters.prettierd
            else
              return formatters.lsp()
            end
          end,
      
          -- Add custom formatter
          filetype1 = formatters.remove_trailing_whitespace,
          filetype2 = formatters.custom({ format = function(lines)
            return vim.tbl_map(function(line)
              return line:gsub("true", "false")
            end, lines)
          end}),
      
          -- Concatenate formatters
          python = {
            formatters.remove_trailing_whitespace,
            formatters.shell({ cmd = "tidy-imports" }),
            formatters.black,
            formatters.ruff,
          },
      
          -- Use a tempfile instead of stdin
          go = {
            formatters.shell({
              cmd = { "goimports-reviser", "-rm-unused", "-set-alias", "-format", "%" },
              tempfile = function()
                return vim.fn.expand("%") .. '.formatter-temp'
              end
            }),
            formatters.shell({ cmd = { "gofmt" } }),
          },
      
          -- Add conditional formatter that only runs if a certain file exists
          -- in one of the parent directories.
          javascript = {
            formatters.if_file_exists({
              pattern = ".eslintrc.*",
              formatter = formatters.eslint_d_fix
            }),
            formatters.if_file_exists({
              pattern = { ".prettierrc", ".prettierrc.*", "prettier.config.*" },
              formatter = formatters.prettierd,
            }),
            -- By default it stops at the git repo root (or "/" if git repo not found)
            -- but it can be customized with the `stop_path` option:
            formatters.if_file_exists({
              pattern = ".prettierrc",
              formatter = formatters.prettierd,
              stop_path = function()
                return "/my/custom/stop/path"
              end
            }),
          },
        },
      
        -- Optional: fallback formatter to use when no formatters match the current filetype
        fallback_formatter = {
          formatters.remove_trailing_whitespace,
          formatters.remove_trailing_newlines,
          formatters.prettierd,
        },
      
        -- By default, all shell commands are prefixed with "sh -c" (see PR #3)
        -- To prevent that set `run_with_sh` to `false`.
        run_with_sh = false,
      })
      
      
      local format_on_save = require("format-on-save")
      local vim_notify = require("format-on-save.error-notifiers.vim-notify")
      
      format_on_save.setup({
        error_notifier = vim_notify,
      })
      
      
      local format_on_save = require("format-on-save")
      
      ---@type ErrorNotifier
      local error_notifier = {
        show = function(opts)
          -- use opts.title and opts.body
        end,
        hide = function()
          -- hide the error when it's been resolved
        end,
      }
      
      format_on_save.setup({
        error_notifier = error_notifier,
      })
      
      
      require('format-on-save').setup({
        stderr_loglevel = vim.log.levels.OFF,
      })
      
      
      require('format-on-save').setup({
        auto_commands = false,
        user_commands = false,
      })
      
      
      require('format-on-save').format()
      
      
      require('format-on-save').restore_cursors()
      
    end,
  },
  {
    "stevearc/conform.nvim",
    config = function()
      
      {
        'stevearc/conform.nvim',
        opts = {},
      }
      
      
      require("packer").startup(function()
        use({
          "stevearc/conform.nvim",
          config = function()
            require("conform").setup()
          end,
        })
      end)
      
      
      require("paq")({
        { "stevearc/conform.nvim" },
      })
      
      
      require("conform").setup({
        formatters_by_ft = {
          lua = { "stylua" },
          -- Conform will run multiple formatters sequentially
          python = { "isort", "black" },
          -- You can customize some of the format options for the filetype (:help conform.format)
          rust = { "rustfmt", lsp_format = "fallback" },
          -- Conform will run the first available formatter
          javascript = { "prettierd", "prettier", stop_after_first = true },
        },
      })
      
      
      vim.api.nvim_create_autocmd("BufWritePre", {
        pattern = "*",
        callback = function(args)
          require("conform").format({ bufnr = args.buf })
        end,
      })
      
      
      require("conform").setup({
        format_on_save = {
          -- These options will be passed to conform.format()
          timeout_ms = 500,
          lsp_format = "fallback",
        },
      })
      
      
      vim.o.formatexpr = "v:lua.require'conform'.formatexpr()"
      
      
      require("conform").setup({
        formatters = {
          yamlfix = {
            -- Change where to find the command
            command = "local/path/yamlfix",
            -- Adds environment args to the yamlfix formatter
            env = {
              YAMLFIX_SEQUENCE_STYLE = "block_style",
            },
          },
        },
      })
      
      -- These can also be set directly
      require("conform").formatters.yamlfix = {
        env = {
          YAMLFIX_SEQUENCE_STYLE = "block_style",
        },
      }
      
      -- This can also be a function that returns the config,
      -- which can be useful if you're doing lazy loading
      require("conform").formatters.yamlfix = function(bufnr)
        return {
          command = require("conform.util").find_executable({
            "local/path/yamlfix",
          }, "yamlfix"),
        }
      end
      
      
      require("conform").formatters.shfmt = {
        append_args = { "-i", "2" },
        -- The base args are { "-filename", "$FILENAME" } so the final args will be
        -- { "-filename", "$FILENAME", "-i", "2" }
      }
      -- append_args can be a function, just like args
      require("conform").formatters.shfmt = {
        append_args = function(self, ctx)
          return { "-i", "2" }
        end,
      }
      
      
      require("conform").formatters.shfmt = {
        inherit = false,
        command = "shfmt",
        args = { "-filename", "$FILENAME", "-i", "2" },
      }
      
      
      require("conform").setup({
        -- Map of filetype to formatters
        formatters_by_ft = {
          lua = { "stylua" },
          -- Conform will run multiple formatters sequentially
          go = { "goimports", "gofmt" },
          -- You can also customize some of the format options for the filetype
          rust = { "rustfmt", lsp_format = "fallback" },
          -- You can use a function here to determine the formatters dynamically
          python = function(bufnr)
            if require("conform").get_formatter_info("ruff_format", bufnr).available then
              return { "ruff_format" }
            else
              return { "isort", "black" }
            end
          end,
          -- Use the "*" filetype to run formatters on all filetypes.
          ["*"] = { "codespell" },
          -- Use the "_" filetype to run formatters on filetypes that don't
          -- have other formatters configured.
          ["_"] = { "trim_whitespace" },
        },
        -- Set this to change the default values when calling conform.format()
        -- This will also affect the default values for format_on_save/format_after_save
        default_format_opts = {
          lsp_format = "fallback",
        },
        -- If this is set, Conform will run the formatter on save.
        -- It will pass the table to conform.format().
        -- This can also be a function that returns the table.
        format_on_save = {
          -- I recommend these options. See :help conform.format for details.
          lsp_format = "fallback",
          timeout_ms = 500,
        },
        -- If this is set, Conform will run the formatter asynchronously after save.
        -- It will pass the table to conform.format().
        -- This can also be a function that returns the table.
        format_after_save = {
          lsp_format = "fallback",
        },
        -- Set the log level. Use `:ConformInfo` to see the location of the log file.
        log_level = vim.log.levels.ERROR,
        -- Conform will notify you when a formatter errors
        notify_on_error = true,
        -- Conform will notify you when no formatters are available for the buffer
        notify_no_formatters = true,
        -- Custom formatters and overrides for built-in formatters
        formatters = {
          my_formatter = {
            -- This can be a string or a function that returns a string.
            -- When defining a new formatter, this is the only field that is required
            command = "my_cmd",
            -- A list of strings, or a function that returns a list of strings
            -- Return a single string instead of a list to run the command in a shell
            args = { "--stdin-from-filename", "$FILENAME" },
            -- If the formatter supports range formatting, create the range arguments here
            range_args = function(self, ctx)
              return { "--line-start", ctx.range.start[1], "--line-end", ctx.range["end"][1] }
            end,
            -- Send file contents to stdin, read new contents from stdout (default true)
            -- When false, will create a temp file (will appear in "$FILENAME" args). The temp
            -- file is assumed to be modified in-place by the format command.
            stdin = true,
            -- A function that calculates the directory to run the command in
            cwd = require("conform.util").root_file({ ".editorconfig", "package.json" }),
            -- When cwd is not found, don't run the formatter (default false)
            require_cwd = true,
            -- When stdin=false, use this template to generate the temporary file that gets formatted
            tmpfile_format = ".conform.$RANDOM.$FILENAME",
            -- When returns false, the formatter will not be used
            condition = function(self, ctx)
              return vim.fs.basename(ctx.filename) ~= "README.md"
            end,
            -- Exit codes that indicate success (default { 0 })
            exit_codes = { 0, 1 },
            -- Environment variables. This can also be a function that returns a table.
            env = {
              VAR = "value",
            },
            -- Set to false to disable merging the config with the base definition
            inherit = true,
            -- When inherit = true, add these additional arguments to the beginning of the command.
            -- This can also be a function, like args
            prepend_args = { "--use-tabs" },
            -- When inherit = true, add these additional arguments to the end of the command.
            -- This can also be a function, like args
            append_args = { "--trailing-comma" },
          },
          -- These can also be a function that returns the formatter
          other_formatter = function(bufnr)
            return {
              command = "my_cmd",
            }
          end,
        },
      })
      
      -- You can set formatters_by_ft and formatters directly
      require("conform").formatters_by_ft.lua = { "stylua" }
      require("conform").formatters.my_formatter = {
        command = "my_cmd",
      }
      
      
      -- Synchronously format the current buffer
      conform.format({ lsp_format = "fallback" })
      -- Asynchronously format the current buffer; will not block the UI
      conform.format({ async = true }, function(err, did_edit)
        -- called after formatting
      end
      -- Format the current buffer with a specific formatter
      conform.format({ formatters = { "ruff_fix" } })
      
    end,
  },
  {
    "nvimdev/guard.nvim",
    config = function()
      
      local ft = require('guard.filetype')
      ft('c'):fmt('clang-format')
      
      
      local ft = require('guard.filetype')
      ft('lua'):lint('selene')
      
      
      local ft = require('guard.filetype')
      ft('haskell'):fmt('ormolu')
                   :lint('hlint')
      
      
      local ft = require('guard.filetype')
      ft('python'):fmt('isort')
                  :append('black')
                  :lint('mypy')
                  :append('mypyc')
                  :append('dmypy')
      
      
      local ft = require('guard.filetype')
      ft('typescript,javascript,typescriptreact'):fmt('prettier')
      
      
      -- this does not work with formatters
      ft('*'):lint('codespell')
      
      
      -- always use 4 spaces for c files
      ft('c'):fmt({
          cmd = "clang-format",
          args = { "--style={IndentWidth: 4}" },
          stdin = true,
      })
      
      
      -- defaults
      vim.g.guard_config = {
          -- format on write to buffer
          fmt_on_save = true,
          -- use lsp if no formatter was defined for this filetype
          lsp_as_default_formatter = false,
          -- whether or not to save the buffer after formatting
          save_on_fmt = true,
          -- automatic linting
          auto_lint = true,
          -- how frequently can linters be called
          lint_interval = 500
          -- show diagnostic after format done
          refresh_diagnostic = true,
      }
      
    end,
  },
  {
    "paul-louyot/toggle-quotes.nvim",
    config = function()
      
      use 'paul-louyot/toggle-quotes.nvim'
      
    end,
  },
  {
    "nvimdev/indentmini.nvim",
    config = function()
      
      config = function()
          require("indentmini").setup() -- use default config
      end,
      
      
      -- Colors are applied automatically based on user-defined highlight groups.
      -- There is no default value.
      vim.cmd.highlight('IndentLine guifg=#123456')
      -- Current indent line highlight
      vim.cmd.highlight('IndentLineCurrent guifg=#123456')
      
    end,
  },
  {
    "lukas-reineke/indent-blankline.nvim",
    config = function()
      
      {
          "lukas-reineke/indent-blankline.nvim",
          main = "ibl",
          ---@module "ibl"
          ---@type ibl.config
          opts = {},
      }
      
      
      use "lukas-reineke/indent-blankline.nvim"
      
      
      require("ibl").setup()
      
      
      require("ibl").setup()
      
      
      require("ibl").setup()
      
      
      require("ibl").setup()
      
      
      local highlight = {
          "RainbowRed",
          "RainbowYellow",
          "RainbowBlue",
          "RainbowOrange",
          "RainbowGreen",
          "RainbowViolet",
          "RainbowCyan",
      }
      
      local hooks = require "ibl.hooks"
      -- create the highlight groups in the highlight setup hook, so they are reset
      -- every time the colorscheme changes
      hooks.register(hooks.type.HIGHLIGHT_SETUP, function()
          vim.api.nvim_set_hl(0, "RainbowRed", { fg = "#E06C75" })
          vim.api.nvim_set_hl(0, "RainbowYellow", { fg = "#E5C07B" })
          vim.api.nvim_set_hl(0, "RainbowBlue", { fg = "#61AFEF" })
          vim.api.nvim_set_hl(0, "RainbowOrange", { fg = "#D19A66" })
          vim.api.nvim_set_hl(0, "RainbowGreen", { fg = "#98C379" })
          vim.api.nvim_set_hl(0, "RainbowViolet", { fg = "#C678DD" })
          vim.api.nvim_set_hl(0, "RainbowCyan", { fg = "#56B6C2" })
      end)
      
      require("ibl").setup { indent = { highlight = highlight } }
      
      
      local highlight = {
          "CursorColumn",
          "Whitespace",
      }
      require("ibl").setup {
          indent = { highlight = highlight, char = "" },
          whitespace = {
              highlight = highlight,
              remove_blankline_trail = false,
          },
          scope = { enabled = false },
      }
      
      
      local highlight = {
          "RainbowRed",
          "RainbowYellow",
          "RainbowBlue",
          "RainbowOrange",
          "RainbowGreen",
          "RainbowViolet",
          "RainbowCyan",
      }
      local hooks = require "ibl.hooks"
      -- create the highlight groups in the highlight setup hook, so they are reset
      -- every time the colorscheme changes
      hooks.register(hooks.type.HIGHLIGHT_SETUP, function()
          vim.api.nvim_set_hl(0, "RainbowRed", { fg = "#E06C75" })
          vim.api.nvim_set_hl(0, "RainbowYellow", { fg = "#E5C07B" })
          vim.api.nvim_set_hl(0, "RainbowBlue", { fg = "#61AFEF" })
          vim.api.nvim_set_hl(0, "RainbowOrange", { fg = "#D19A66" })
          vim.api.nvim_set_hl(0, "RainbowGreen", { fg = "#98C379" })
          vim.api.nvim_set_hl(0, "RainbowViolet", { fg = "#C678DD" })
          vim.api.nvim_set_hl(0, "RainbowCyan", { fg = "#56B6C2" })
      end)
      
      vim.g.rainbow_delimiters = { highlight = highlight }
      require("ibl").setup { scope = { highlight = highlight } }
      
      hooks.register(hooks.type.SCOPE_HIGHLIGHT, hooks.builtin.scope_highlight_from_extmark)
      
    end,
  },
  {
    "LucasTavaresA/simpleIndentGuides.nvim",
    config = function()
      
      use {
        'lucastavaresa/simpleIndentGuides.nvim',
        config = function()
          vim.opt.list = true -- enable in all buffers
          require("simpleIndentGuides").setup()
        end
      }
      
      
      vim.api.nvim_create_autocmd("FileType", {
        pattern = { "markdown", "org", "txt", "norg" },
        command = "setlocal nolist",
      })
      
      
      require("simpleIndentGuides").setup("┊")
      
      
      require("simpleIndentGuides").setup("┊", "·")
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-indentscope.md",
  },
  {
    "NMAC427/guess-indent.nvim",
    config = function()
      
      require('guess-indent').setup {}
      
      
      -- using packer.nvim
      use {
        'nmac427/guess-indent.nvim',
        config = function() require('guess-indent').setup {} end,
      }
      
      
      -- This is the default configuration
      require('guess-indent').setup {
        auto_cmd = true,  -- Set to false to disable automatic execution
        override_editorconfig = false, -- Set to true to override settings set by .editorconfig
        filetype_exclude = {  -- A list of filetypes for which the auto command gets disabled
          "netrw",
          "tutor",
        },
        buftype_exclude = {  -- A list of buffer types for which the auto command gets disabled
          "help",
          "nofile",
          "terminal",
          "prompt",
        },
        on_tab_options = { -- A table of vim options when tabs are detected 
          ["expandtab"] = false,
        },
        on_space_options = { -- A table of vim options when spaces are detected 
          ["expandtab"] = true,
          ["tabstop"] = "detected", -- If the option value is 'detected', The value is set to the automatically detected indent size.
          ["softtabstop"] = "detected",
          ["shiftwidth"] = "detected",
        },
      }
      
    end,
  },
  {
    "Darazaki/indent-o-matic",
    config = function()
      
      require('indent-o-matic').setup {
          -- The values indicated here are the defaults
      
          -- Number of lines without indentation before giving up (use -1 for infinite)
          max_lines = 2048,
      
          -- Space indentations that should be detected
          standard_widths = { 2, 4, 8 },
      
          -- Skip multi-line comments and strings (more accurate detection but less performant)
          skip_multiline = true,
      }
      
      
      require('indent-o-matic').setup {
          -- Global settings (optional, used as fallback)
          max_lines = 2048,
          standard_widths = { 2, 4, 8 },
      
          -- Disable indent-o-matic for LISP files
          filetype_lisp = {
              max_lines = 0,
          },
      
          -- Only detect 4 spaces and tabs for Rust files
          filetype_rust = {
              standard_widths = { 4 },
          },
      
          -- Don't detect 8 spaces indentations inside files without a filetype
          filetype_ = {
              standard_widths = { 2, 4 },
          },
      }
      
    end,
  },
  {
    "yaocccc/nvim-hlchunk",
  },
  {
    "shellRaining/hlchunk.nvim",
    config = function()
      
      {
        "shellRaining/hlchunk.nvim",
        event = { "BufReadPre", "BufNewFile" },
        config = function()
          require("hlchunk").setup({})
        end
      },
      
      
      local default_conf = {
          enable = false,
          style = {},
          notify = false,
          priority = 0,
          exclude_filetypes = {
              aerial = true,
              dashboard = true,
              -- some other filetypes
          }
      }
      
      
      require('hlchunk').setup({
          chunk = {
              enable = true
              -- ...
          },
          indent = {
              enable = true
              -- ...
          }
      })
      
      
      local indent = require('hlchunk.mods.indent')
      indent({
          style = {
              -- ...
          }
      }):enable() -- don't forget call enable method
      
      
      vim.bo.shiftwidth = xxx
      
    end,
  },
  {
    "VidocqH/auto-indent.nvim",
    config = function()
      
      requir("lazy").setup({
        {
          'vidocqh/auto-indent.nvim',
          opts = {},
        },
      })
      
      
      require("auto-indent").setup({
        lightmode = true,        -- Lightmode assumes tabstop and indentexpr not change within buffer's lifetime
        indentexpr = nil,        -- Use vim.bo.indentexpr by default, see 'Custom Indent Evaluate Method'
        ignore_filetype = {},    -- Disable plugin for specific filetypes, e.g. ignore_filetype = { 'javascript' }
      })
      
      
      {
        ---@param lnum: number
        ---@return number
        indentexpr = function(lnum)
          return require("nvim-treesitter.indent").get_indent(lnum)
        end
      }
      
    end,
  },
  {
    "Mr-LLLLL/cool-chunk.nvim",
    config = function()
      
      {
          "Mr-LLLLL/cool-chunk.nvim",
          event = { "CursorHold", "CursorHoldI" },
          dependencies = {
              "nvim-treesitter/nvim-treesitter",
          },
          config = function()
              require("cool-chunk").setup({})
          end
      },
      
      
      {
          chunk = {
              notify = true,
              support_filetypes = ft.support_filetypes, -- ft = require("cool-chunk.utils.filetype").support_filetypes
              exclude_filetypes = ft.exclude_filetypes,
              hl_group = {
                  chunk = "CursorLineNr",
                  error = "Error",
              },
              chars = {
                  horizontal_line = "─",
                  vertical_line = "│",
                  left_top = "╭",
                  left_bottom = "╰",
                  left_arrow = "<",
                  bottom_arrow = "v",
                  right_arrow = ">",
              },
              textobject = "ah",
              animate_duration = 200, -- if don't want to animation, set to 0.
              fire_event = { "CursorHold", "CursorHoldI" },
          },
          context = {
              notify = true,
              chars = {
                  "│",
              },
              hl_group = {
                  context = "LineNr",
              },
              exclude_filetypes = ft.exclude_filetypes,
              support_filetypes = ft.support_filetypes,
              textobject = "ih",
              jump_support_filetypes = { "lua", "python" },
              jump_start = "[{",
              jump_end = "]}",
              fire_event = { "CursorHold", "CursorHoldI" },
          },
          line_num = {
              notify = true,
              hl_group = {
                  chunk = "CursorLineNr",
                  context = "LineNr",
                  error = "Error",
              },
              support_filetypes = ft.support_filetypes,
              exclude_filetypes = ft.exclude_filetypes,
              fire_event = { "CursorHold", "CursorHoldI" },
          }
      }
      
    end,
  },
  {
    "gh-liu/fold_line.nvim",
    config = function()
      
      -- init.lua:
      {
          "gh-liu/fold_line.nvim",
          event = "VeryLazy",
          init = function()
              -- change the char of the line, see the `Appearance` section
              vim.g.fold_line_char_open_start = "╭"
              vim.g.fold_line_char_open_end = "╰"
          end,
      }
      
      
      vim.g.fold_line_char_top_close = "+"        -- default: fillchars.foldclose or "+"
      vim.g.fold_line_char_close = "├"            -- default: fillchars.vertright or "├"
      vim.g.fold_line_char_open_sep = "│"         -- default: fillchars.foldsep or "│"
      vim.g.fold_line_char_open_start = "╭"       -- default: "┌"
      vim.g.fold_line_char_open_end = "╰"         -- default: "└"
      vim.g.fold_line_char_open_start_close = "╒" -- default: "╒"
      vim.g.fold_line_char_open_end_close = "╘"   -- default: "╘"
      
    end,
  },
  {
    "notomo/cmdbuf.nvim",
    config = function()
      
      vim.keymap.set("n", "q:", function()
        require("cmdbuf").split_open(vim.o.cmdwinheight)
      end)
      vim.keymap.set("c", "<C-f>", function()
        require("cmdbuf").split_open(vim.o.cmdwinheight, { line = vim.fn.getcmdline(), column = vim.fn.getcmdpos() })
        vim.api.nvim_feedkeys(vim.keycode("<C-c>"), "n", true)
      end)
      
      -- Custom buffer mappings
      vim.api.nvim_create_autocmd({ "User" }, {
        group = vim.api.nvim_create_augroup("config.cmdbuf", {}),
        pattern = { "CmdbufNew" },
        callback = function(args)
          vim.bo.bufhidden = "wipe" -- if you don't need previous opened buffer state
          vim.keymap.set("n", "q", [[<Cmd>quit<CR>]], { nowait = true, buffer = true })
          vim.keymap.set("n", "dd", [[<Cmd>lua require('cmdbuf').delete()<CR>]], { buffer = true })
          vim.keymap.set({ "n", "i" }, "<C-c>", function()
            return require("cmdbuf").cmdline_expr()
          end, { buffer = true, expr = true })
      
          local typ = require("cmdbuf").get_context().type
          if typ == "vim/cmd" then
            -- you can filter buffer lines
            local lines = vim
              .iter(vim.api.nvim_buf_get_lines(args.buf, 0, -1, false))
              :filter(function(line)
                return line ~= "q"
              end)
              :totable()
            vim.api.nvim_buf_set_lines(args.buf, 0, -1, false, lines)
          end
        end,
      })
      
      -- open lua command-line window
      vim.keymap.set("n", "ql", function()
        require("cmdbuf").split_open(vim.o.cmdwinheight, { type = "lua/cmd" })
      end)
      
      -- q/, q? alternative
      vim.keymap.set("n", "q/", function()
        require("cmdbuf").split_open(vim.o.cmdwinheight, { type = "vim/search/forward" })
      end)
      vim.keymap.set("n", "q?", function()
        require("cmdbuf").split_open(vim.o.cmdwinheight, { type = "vim/search/backward" })
      end)
      
    end,
  },
  {
    "gelguy/wilder.nvim",
    config = function()
      
      use {
        'gelguy/wilder.nvim',
        config = function()
          -- config goes here
        end,
      }
      
      
      local wilder = require('wilder')
      wilder.setup({modes = {':', '/', '?'}})
      
      
      wilder.set_option('pipeline', {
        wilder.branch(
          wilder.cmdline_pipeline({
            -- sets the language to use, 'vim' and 'python' are supported
            language = 'python',
            -- 0 turns off fuzzy matching
            -- 1 turns on fuzzy matching
            -- 2 partial fuzzy matching (match does not have to begin with the same first letter)
            fuzzy = 1,
          }),
          wilder.python_search_pipeline({
            -- can be set to wilder#python_fuzzy_delimiter_pattern() for stricter fuzzy matching
            pattern = wilder.python_fuzzy_pattern(),
            -- omit to get results in the order they appear in the buffer
            sorter = wilder.python_difflib_sorter(),
            -- can be set to 're2' for performance, requires pyre2 to be installed
            -- see :h wilder#python_search() for more details
            engine = 're',
          })
        ),
      })
      
      
      wilder.set_option('pipeline', {
        wilder.branch(
          wilder.python_file_finder_pipeline({
            -- to use ripgrep : {'rg', '--files'}
            -- to use fd      : {'fd', '-tf'}
            file_command = {'find', '.', '-type', 'f', '-printf', '%P\n'}, 
            -- to use fd      : {'fd', '-td'}
            dir_command = {'find', '.', '-type', 'd', '-printf', '%P\n'},
            -- use {'cpsm_filter'} for performance, requires cpsm vim plugin
            -- found at https://github.com/nixprime/cpsm
            filters = {'fuzzy_filter', 'difflib_sorter'},
          }),
          wilder.cmdline_pipeline(),
          wilder.python_search_pipeline()
        ),
      })
      
      
      wilder.set_option('renderer', wilder.wildmenu_renderer({
        -- highlighter applies highlighting to the candidates
        highlighter = wilder.basic_highlighter(),
      }))
      
      
      wilder.set_option('renderer', wilder.wildmenu_renderer({
        highlighter = wilder.basic_highlighter(),
        separator = ' · ',
        left = {' ', wilder.wildmenu_spinner(), ' '},
        right = {' ', wilder.wildmenu_index()},
      }))
      
      
      wilder.set_option('renderer', wilder.wildmenu_renderer(
        -- use wilder.wildmenu_lightline_theme() if using Lightline
        wilder.wildmenu_airline_theme({
          -- highlights can be overriden, see :h wilder#wildmenu_renderer()
          highlights = {default = 'StatusLine'},
          highlighter = wilder.basic_highlighter(),
          separator = ' · ',
        })
      ))
      
      
      wilder.set_option('renderer', wilder.popupmenu_renderer({
        -- highlighter applies highlighting to the candidates
        highlighter = wilder.basic_highlighter(),
      }))
      
      
      wilder.set_option('renderer', wilder.renderer_mux({
        [':'] = wilder.popupmenu_renderer({
          highlighter = wilder.basic_highlighter(),
        }),
        ['/'] = wilder.wildmenu_renderer({
          highlighter = wilder.basic_highlighter(),
        }),
      }))
      
      
      wilder.set_option('renderer', wilder.popupmenu_renderer({
        pumblend = 20,
      }))
      
      
      wilder.set_option('renderer', wilder.popupmenu_renderer(
        wilder.popupmenu_border_theme({
          highlights = {
            border = 'Normal', -- highlight to use for the border
          },
          -- 'single', 'double', 'rounded' or 'solid'
          -- can also be a list of 8 characters, see :h wilder#popupmenu_border_theme() for more details
          border = 'rounded',
        })
      ))
      
      
      wilder.set_option('renderer', wilder.popupmenu_renderer(
        wilder.popupmenu_border_theme({
          highlighter = wilder.basic_highlighter(),
          min_width = '100%', -- minimum height of the popupmenu, can also be a number
          min_height = '50%', -- to set a fixed height, set max_height to the same value
          reverse = 0,        -- if 1, shows the candidates from bottom to top
        })
      ))
      
      
      wilder.set_option('renderer', wilder.popupmenu_renderer({
        highlighter = wilder.basic_highlighter(),
        left = {' ', wilder.popupmenu_devicons()},
        right = {' ', wilder.popupmenu_scrollbar()},
      }))
      
      
      wilder.set_option('renderer', wilder.popupmenu_renderer(
        wilder.popupmenu_palette_theme({
          -- 'single', 'double', 'rounded' or 'solid'
          -- can also be a list of 8 characters, see :h wilder#popupmenu_palette_theme() for more details
          border = 'rounded',
          max_height = '75%',      -- max height of the palette
          min_height = 0,          -- set to the same as 'max_height' for a fixed height window
          prompt_position = 'top', -- 'top' or 'bottom' to set the location of the prompt
          reverse = 0,             -- set to 1 to reverse the order of the list, use in combination with 'prompt_position'
        })
      ))
      
      
      wilder.set_option('renderer', wilder.popupmenu_renderer({
        highlighter = {
          wilder.lua_pcre2_highlighter(), -- requires `luarocks install pcre2`
          wilder.lua_fzy_highlighter(),   -- requires fzy-lua-native vim plugin found
                                          -- at https://github.com/romgrk/fzy-lua-native
        },
        highlights = {
          accent = wilder.make_hl('WilderAccent', 'Pmenu', {{a = 1}, {a = 1}, {foreground = '#f4468f'}}),
        },
      }))
      
      
      local gradient = {
        '#f4468f', '#fd4a85', '#ff507a', '#ff566f', '#ff5e63',
        '#ff6658', '#ff704e', '#ff7a45', '#ff843d', '#ff9036',
        '#f89b31', '#efa72f', '#e6b32e', '#dcbe30', '#d2c934',
        '#c8d43a', '#bfde43', '#b6e84e', '#aff05b'
      }
      
      for i, fg in ipairs(gradient) do
        gradient[i] = wilder.make_hl('WilderGradient' .. i, 'Pmenu', {{a = 1}, {a = 1}, {foreground = fg}})
      end
      
      wilder.set_option('renderer', wilder.popupmenu_renderer({
        highlights = {
          gradient = gradient, -- must be set
          -- selected_gradient key can be set to apply gradient highlighting for the selected candidate.
        },
        highlighter = wilder.highlighter_with_gradient({
          wilder.basic_highlighter(), -- or wilder.lua_fzy_highlighter(),
        }),
      }))
      
      
      local wilder = require('wilder')
      wilder.setup({modes = {':', '/', '?'}})
      
      wilder.set_option('pipeline', {
        wilder.branch(
          wilder.cmdline_pipeline(),
          wilder.search_pipeline()
        ),
      })
      
      wilder.set_option('renderer', wilder.wildmenu_renderer({
        highlighter = wilder.basic_highlighter(),
      }))
      
      
      local wilder = require('wilder')
      wilder.setup({modes = {':', '/', '?'}})
      
      wilder.set_option('pipeline', {
        wilder.branch(
          wilder.cmdline_pipeline({
            fuzzy = 1,
            set_pcre2_pattern = 1,
          }),
          wilder.python_search_pipeline({
            pattern = 'fuzzy',
          })
        ),
      })
      
      local highlighters = {
        wilder.pcre2_highlighter(),
        wilder.basic_highlighter(),
      }
      
      wilder.set_option('renderer', wilder.renderer_mux({
        [':'] = wilder.popupmenu_renderer({
          highlighter = highlighters,
        }),
        ['/'] = wilder.wildmenu_renderer({
          highlighter = highlighters,
        }),
      }))
      
      
      local wilder = require('wilder')
      wilder.setup({modes = {':', '/', '?'}})
      -- Disable Python remote plugin
      wilder.set_option('use_python_remote_plugin', 0)
      
      wilder.set_option('pipeline', {
        wilder.branch(
          wilder.cmdline_pipeline({
            fuzzy = 1,
            fuzzy_filter = wilder.lua_fzy_filter(),
          }),
          wilder.vim_search_pipeline()
        )
      })
      
      wilder.set_option('renderer', wilder.renderer_mux({
        [':'] = wilder.popupmenu_renderer({
          highlighter = wilder.lua_fzy_highlighter(),
          left = {
            ' ',
            wilder.popupmenu_devicons()
          },
          right = {
            ' ',
            wilder.popupmenu_scrollbar()
          },
        }),
        ['/'] = wilder.wildmenu_renderer({
          highlighter = wilder.lua_fzy_highlighter(),
        }),
      }))
      
      
      local wilder = require('wilder')
      wilder.setup({modes = {':', '/', '?'}})
      
      wilder.set_option('pipeline', {
        wilder.branch(
          wilder.python_file_finder_pipeline({
            file_command = function(ctx, arg)
              if string.find(arg, '.') ~= nil then
                return {'fdfind', '-tf', '-H'}
              else
                return {'fdfind', '-tf'}
              end
            end,
            dir_command = {'fd', '-td'},
            filters = {'cpsm_filter'},
          }),
          wilder.substitute_pipeline({
            pipeline = wilder.python_search_pipeline({
              skip_cmdtype_check = 1,
              pattern = wilder.python_fuzzy_pattern({
                start_at_boundary = 0,
              }),
            }),
          }),
          wilder.cmdline_pipeline({
            fuzzy = 2,
            fuzzy_filter = wilder.lua_fzy_filter(),
          }),
          {
            wilder.check(function(ctx, x) return x == '' end),
            wilder.history(),
          },
          wilder.python_search_pipeline({
            pattern = wilder.python_fuzzy_pattern({
              start_at_boundary = 0,
            }),
          })
        ),
      })
      
      local highlighters = {
        wilder.pcre2_highlighter(),
        wilder.lua_fzy_highlighter(),
      }
      
      local popupmenu_renderer = wilder.popupmenu_renderer(
        wilder.popupmenu_border_theme({
          border = 'rounded',
          empty_message = wilder.popupmenu_empty_message_with_spinner(),
          highlighter = highlighters,
          left = {
            ' ',
            wilder.popupmenu_devicons(),
            wilder.popupmenu_buffer_flags({
              flags = ' a + ',
              icons = {['+'] = '', a = '', h = ''},
            }),
          },
          right = {
            ' ',
            wilder.popupmenu_scrollbar(),
          },
        })
      )
      
      local wildmenu_renderer = wilder.wildmenu_renderer({
        highlighter = highlighters,
        separator = ' · ',
        left = {' ', wilder.wildmenu_spinner(), ' '},
        right = {' ', wilder.wildmenu_index()},
      })
      
      wilder.set_option('renderer', wilder.renderer_mux({
        [':'] = popupmenu_renderer,
        ['/'] = wildmenu_renderer,
        substitute = wildmenu_renderer,
      }))
      
    end,
  },
  {
    "vzze/cmdline.nvim",
    config = function()
      
      require('cmdline').setup({
          cmdtype = ":", -- you can also add / and ? by using ":/?"
                         -- as a string
      
          window = {
              matchFuzzy = true,
              offset     = 1,    -- depending on 'cmdheight' you might need to offset
              debounceMs = 10    -- the lower the number the more responsive however
                                 -- more resource intensive
          },
      
          hl = {
              default   = "Pmenu",
              selection = "PmenuSel",
              directory = "Directory",
              substr    = "LineNr"
          },
      
          column = {
              maxNumber = 6,
              minWidth  = 20
          },
      
          binds = {
              next = "<Tab>",
              back = "<S-Tab>"
          }
      })
      
    end,
  },
  {
    "rmagatti/auto-session",
    config = function()
      
      return {
        "rmagatti/auto-session",
        lazy = false,
      
        ---enables autocomplete for opts
        ---@module "auto-session"
        ---@type AutoSession.Config
        opts = {
          suppressed_dirs = { "~/", "~/Projects", "~/Downloads", "/" },
          -- log_level = 'debug',
        },
      }
      
      
      require("auto-session").setup({})
      
      
      local defaults = {
        -- Saving / restoring
        enabled = true, -- Enables/disables auto creating, saving and restoring
        auto_save = true, -- Enables/disables auto saving session on exit
        auto_restore = true, -- Enables/disables auto restoring session on start
        auto_create = true, -- Enables/disables auto creating new session files. Can be a function that returns true if a new session file should be allowed
        auto_restore_last_session = false, -- On startup, loads the last saved session if session for cwd does not exist
        cwd_change_handling = false, -- Automatically save/restore sessions when changing directories
        single_session_mode = false, -- Enable single session mode to keep all work in one session regardless of cwd changes. When enabled, prevents creation of separate sessions for different directories and maintains one unified session. Does not work with cwd_change_handling
      
        -- Filtering
        suppressed_dirs = nil, -- Suppress session restore/create in certain directories
        allowed_dirs = nil, -- Allow session restore/create in certain directories
        bypass_save_filetypes = nil, -- List of filetypes to bypass auto save when the only buffer open is one of the file types listed, useful to ignore dashboards
        close_filetypes_on_save = { "checkhealth" }, -- Buffers with matching filetypes will be closed before saving
        close_unsupported_windows = true, -- Close windows that aren't backed by normal file before autosaving a session
        preserve_buffer_on_restore = nil, -- Function that returns true if a buffer should be preserved when restoring a session
      
        -- Git / Session naming
        git_use_branch_name = false, -- Include git branch name in session name, can also be a function that takes an optional path and returns the name of the branch
        git_auto_restore_on_branch_change = false, -- Should we auto-restore the session when the git branch changes. Requires git_use_branch_name
        custom_session_tag = nil, -- Function that can return a string to be used as part of the session name
      
        -- Deleting
        auto_delete_empty_sessions = true, -- Enables/disables deleting the session if there are only unnamed/empty buffers when auto-saving
        purge_after_minutes = nil, -- Sessions older than purge_after_minutes will be deleted asynchronously on startup, e.g. set to 14400 to delete sessions that haven't been accessed for more than 10 days, defaults to off (no purging), requires >= nvim 0.10
      
        -- Saving extra data
        save_extra_data = nil, -- Function that returns extra data that should be saved with the session. Will be passed to restore_extra_data on restore
        restore_extra_data = nil, -- Function called when there's extra data saved for a session
      
        -- Argument handling
        args_allow_single_directory = true, -- Follow normal session save/load logic if launched with a single directory as the only argument
        args_allow_files_auto_save = false, -- Allow saving a session even when launched with a file argument (or multiple files/dirs). It does not load any existing session first. Can be true or a function that returns true when saving is allowed. See documentation for more detail
      
        -- Misc
        log_level = "error", -- Sets the log level of the plugin (debug, info, warn, error).
        root_dir = vim.fn.stdpath("data") .. "/sessions/", -- Root dir where sessions will be stored
        show_auto_restore_notif = false, -- Whether to show a notification when auto-restoring
        restore_error_handler = nil, -- Function called when there's an error restoring. By default, it ignores fold errors otherwise it displays the error and returns false to disable auto_save
        continue_restore_on_error = true, -- Keep loading the session even if there's an error
        lsp_stop_on_restore = false, -- Should language servers be stopped when restoring a session. Can also be a function that will be called if set. Not called on autorestore from startup
        lazy_support = true, -- Automatically detect if Lazy.nvim is being used and wait until Lazy is done to make sure session is restored correctly. Does nothing if Lazy isn't being used
        legacy_cmds = true, -- Define legacy commands: Session*, Autosession (lowercase s), currently true. Set to false to prevent defining them
      
        ---@type SessionLens
        session_lens = {
          picker = nil, -- "telescope"|"snacks"|"fzf"|"select"|nil Pickers are detected automatically but you can also set one manually. Falls back to vim.ui.select
          load_on_setup = true, -- Only used for telescope, registers the telescope extension at startup so you can use :Telescope session-lens
          picker_opts = nil, -- Table passed to Telescope / Snacks / Fzf-Lua to configure the picker. See below for more information
      
          ---@type SessionLensMappings
          mappings = {
            -- Mode can be a string or a table, e.g. {"i", "n"} for both insert and normal mode
            delete_session = { "i", "<C-d>" }, -- mode and key for deleting a session from the picker
            alternate_session = { "i", "<C-s>" }, -- mode and key for swapping to alternate session from the picker
            copy_session = { "i", "<C-y>" }, -- mode and key for copying a session from the picker
          },
      
          ---@type SessionControl
          session_control = {
            control_dir = vim.fn.stdpath("data") .. "/auto_session/", -- Auto session control dir, for control files, like alternating between two sessions with session-lens
            control_filename = "session_control.json", -- File name of the session control file
          },
        },
      }
      
      
      ---@class AutoSession.Config
      ---
      ---Saving / restoring
      ---@field enabled? boolean
      ---@field auto_save? boolean
      ---@field auto_restore? boolean
      ---@field auto_create? boolean|fun(): should_create_session:boolean
      ---@field auto_restore_last_session? boolean
      ---@field cwd_change_handling? boolean
      ---@field single_session_mode? boolean
      ---
      ---Filtering
      ---@field suppressed_dirs? table
      ---@field allowed_dirs? table
      ---@field bypass_save_filetypes? table
      ---@field close_filetypes_on_save? table
      ---@field close_unsupported_windows? boolean
      ---@field preserve_buffer_on_restore? fun(bufnr:number): preserve_buffer:boolean
      ---
      ---Git / Session naming
      ---@field git_use_branch_name? boolean|fun(path:string?): branch_name:string|nil
      ---@field git_auto_restore_on_branch_change? boolean
      ---@field custom_session_tag? fun(session_name:string): tag:string
      ---
      ---Deleting
      ---@field auto_delete_empty_sessions? boolean
      ---@field purge_after_minutes? number
      ---
      ---Saving extra data
      ---@field save_extra_data? fun(session_name:string): extra_data:string|nil
      ---@field restore_extra_data? fun(session_name:string, extra_data:string)
      ---
      ---Argument handling
      ---@field args_allow_single_directory? boolean
      ---@field args_allow_files_auto_save? boolean|fun(): disable_auto_save:boolean
      ---
      ---Misc
      ---@field log_level? string|integer
      ---@field root_dir? string
      ---@field show_auto_restore_notif? boolean
      ---@field restore_error_handler? fun(error_msg:string): disable_auto_save:boolean
      ---@field continue_restore_on_error? boolean
      ---@field lsp_stop_on_restore? boolean|fun()
      ---@field lazy_support? boolean
      ---@field legacy_cmds? boolean
      ---
      ---@field session_lens? SessionLens
      ---
      ---Session Lens Config
      ---@class SessionLens
      ---@field picker? "telescope"|"snacks"|"fzf"|"select"
      ---@field load_on_setup? boolean
      ---@field picker_opts? table
      ---@field mappings? SessionLensMappings
      ---@field session_control? SessionControl
      ---
      ---@class SessionLensMappings
      ---@field delete_session? table
      ---@field alternate_session? table
      ---@field copy_session? table
      ---
      ---@class SessionControl
      ---@field control_dir? string
      ---@field control_filename? string
      ---
      ---Hooks
      ---@field pre_save_cmds? table executes before a session is saved
      ---@field save_extra_cmds? table executes before a session is saved
      ---@field post_save_cmds? table executes after a session is saved
      ---@field pre_restore_cmds? table executes before a session is restored
      ---@field post_restore_cmds? table executes after a session is restored
      ---@field pre_delete_cmds? table executes before a session is deleted
      ---@field post_delete_cmds? table executes after a session is deleted
      ---@field no_restore_cmds? table executes when no session is restored when auto-restoring, happens on startup or possibly on cwd/git branch changes
      ---@field pre_cwd_changed_cmds? table executes before cwd is changed if cwd_change_handling is true
      ---@field post_cwd_changed_cmds? table executes after cwd is changed if cwd_change_handling is true
      
      
      vim.o.sessionoptions = "blank,buffers,curdir,folds,help,tabpages,winsize,winpos,terminal,localoptions"
      
      
      return {
        "rmagatti/auto-session",
        lazy = false,
        keys = {
          -- Will use Telescope if installed or a vim.ui.select picker otherwise
          { "<leader>wr", "<cmd>AutoSession search<CR>", desc = "Session search" },
          { "<leader>ws", "<cmd>AutoSession save<CR>", desc = "Save session" },
          { "<leader>wa", "<cmd>AutoSession toggle<CR>", desc = "Toggle autosave" },
        },
      
        ---enables autocomplete for opts
        ---@module "auto-session"
        ---@type AutoSession.Config
        opts = {
          -- The following are already the default values, no need to provide them if these are already the settings you want.
          session_lens = {
            picker = nil, -- "telescope"|"snacks"|"fzf"|"select"|nil Pickers are detected automatically but you can also manually choose one. Falls back to vim.ui.select
            mappings = {
              -- Mode can be a string or a table, e.g. {"i", "n"} for both insert and normal mode
              delete_session = { "i", "<C-d>" },
              alternate_session = { "i", "<C-s>" },
              copy_session = { "i", "<C-y>" },
            },
      
            picker_opts = {
              -- For Telescope, you can set theme options here, see:
              -- https://github.com/nvim-telescope/telescope.nvim/blob/master/doc/telescope.txt#L112
              -- https://github.com/nvim-telescope/telescope.nvim/blob/master/lua/telescope/themes.lua
              --
              -- border = true,
              -- layout_config = {
              --   width = 0.8, -- Can set width and height as percent of window
              --   height = 0.5,
              -- },
      
              -- For Snacks, you can set layout options here, see:
              -- https://github.com/folke/snacks.nvim/blob/main/docs/picker.md#%EF%B8%8F-layouts
              --
              -- preset = "dropdown",
              -- preview = false,
              -- layout = {
              --   width = 0.4,
              --   height = 0.4,
              -- },
      
              -- For Fzf-Lua, picker_opts just turns into winopts, see:
              -- https://github.com/ibhagwan/fzf-lua#customization
              --
              --  height = 0.8,
              --  width = 0.50,
            },
      
            -- Telescope only: If load_on_setup is false, make sure you use `:AutoSession search` to open the picker as it will initialize everything first
            load_on_setup = true,
          },
        },
      }
      
      
      opts = {
        allowed_dirs = { "/some/dir/", "/projects/*" },
        suppressed_dirs = { "/projects/secret" },
      }
      
      
      opts = {
        cwd_change_handling = true,
      
        pre_cwd_changed_cmds = {
          "tabdo NERDTreeClose", -- Close NERDTree before saving session
        },
      
        post_cwd_changed_cmds = {
          function()
            require("lualine").refresh() -- example refreshing the lualine status line _after_ the cwd changes
          end,
        },
      }
      
      
      opts = {
        git_use_branch_name = true,
        git_auto_restore_on_branch_change = true,
      }
      
      
      opts = {
        bypass_save_filetypes = { "alpha", "dashboard", "snacks_dashboard" }, -- or whatever dashboard you use
      }
      
      
      require("lualine").setup({
        options = {
          theme = "tokyonight",
        },
        sections = {
          lualine_x = {
            function()
              return require("auto-session.lib").current_session_name(true)
            end,
          },
        },
      })
      
      
      opts = {
        -- {hook_name}_cmds = {"{hook_command1}", "{hook_command2}"}
      
        pre_save_cmds = {
          "tabdo NERDTreeClose", -- Close NERDTree before saving session
        },
      
        post_restore_cmds = {
          "someOtherVimCommand",
          function()
            -- Restore nvim-tree after a session is restored
            local nvim_tree_api = require("nvim-tree.api")
            nvim_tree_api.tree.open()
            nvim_tree_api.tree.change_root(vim.fn.getcwd())
            nvim_tree_api.tree.reload()
          end,
        },
      
        -- Save quickfix list and open it when restoring the session
        save_extra_cmds = {
          function()
            local qflist = vim.fn.getqflist()
            -- return nil to clear any old qflist
            if #qflist == 0 then
              return nil
            end
            local qfinfo = vim.fn.getqflist({ title = 1 })
      
            for _, entry in ipairs(qflist) do
              -- use filename instead of bufnr so it can be reloaded
              entry.filename = vim.api.nvim_buf_get_name(entry.bufnr)
              entry.bufnr = nil
            end
      
            local setqflist = "call setqflist(" .. vim.fn.string(qflist) .. ")"
            local setqfinfo = 'call setqflist([], "a", ' .. vim.fn.string(qfinfo) .. ")"
            return { setqflist, setqfinfo, "copen" }
          end,
        },
      }
      
      
      ---@module "auto-session"
      ---@type AutoSession.Config
      local opts = {
      
        save_extra_data = function(_)
          local ok, breakpoints = pcall(require, "dap.breakpoints")
          if not ok or not breakpoints then
            return
          end
      
          local bps = {}
          local breakpoints_by_buf = breakpoints.get()
          for buf, buf_bps in pairs(breakpoints_by_buf) do
            bps[vim.api.nvim_buf_get_name(buf)] = buf_bps
          end
          if vim.tbl_isempty(bps) then
            return
          end
          local extra_data = {
            breakpoints = bps,
          }
          return vim.fn.json_encode(extra_data)
        end,
      
        restore_extra_data = function(_, extra_data)
          local json = vim.fn.json_decode(extra_data)
      
          if json.breakpoints then
            local ok, breakpoints = pcall(require, "dap.breakpoints")
      
            if not ok or not breakpoints then
              return
            end
            vim.notify("restoring breakpoints")
            for buf_name, buf_bps in pairs(json.breakpoints) do
              for _, bp in pairs(buf_bps) do
                local line = bp.line
                local opts = {
                  condition = bp.condition,
                  log_message = bp.logMessage,
                  hit_condition = bp.hitCondition,
                }
                breakpoints.set(opts, vim.fn.bufnr(buf_name), line)
              end
            end
          end
        end,
      }
      
      
      return {
        "rmagatti/auto-session",
        lazy = false,
        cond = not vim.g.started_by_firenvim and not vim.g.vscode,
      }
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-sessions.md",
  },
  {
    "gennaro-tedesco/nvim-possession",
    config = function()
      
      {
          "gennaro-tedesco/nvim-possession",
          dependencies = {
              "ibhagwan/fzf-lua",
          },
          config = true,
          keys = {
              { "<leader>sl", function() require("nvim-possession").list() end, desc = "📌list sessions", },
              { "<leader>sn", function() require("nvim-possession").new() end, desc = "📌create new session", },
              { "<leader>su", function() require("nvim-possession").update() end, desc = "📌update current session", },
              { "<leader>sd", function() require("nvim-possession").delete() end, desc = "📌delete selected session"},
          },
      }
      
      
      
      require("nvim-possession").setup({
          sessions = {
              sessions_path = ... -- folder to look for sessions, must be a valid existing path
              sessions_variable = ... -- defines vim.g[sessions_variable] when a session is loaded
              sessions_icon = ...-- string: shows icon both in the prompt and in the statusline
              sessions_prompt = ... -- fzf prompt string
          },
      
          autoload = false, -- whether to autoload sessions in the cwd at startup
          autosave = true, -- whether to autosave loaded sessions before quitting
          autoswitch = {
              enable = false -- whether to enable autoswitch
              exclude_ft = {}, -- list of filetypes to exclude from autoswitch
          }
      
          save_hook = nil -- callback, function to execute before saving a session
                          -- useful to update or cleanup global variables for example
          post_hook = nil -- callback, function to execute after loading a session
                          -- useful to restore file trees, file managers or terminals
                          -- function()
                          --     require('FTerm').open()
                          --     require("nvim-tree.api").tree.toggle()
                          -- end
      
          ---@type possession.Hls
          fzf_hls = { -- highlight groups for the sessions and preview windows
              normal = "Normal",
              preview_normal = "Normal",
              border = "Todo",
              preview_border = "Constant",
          },
          ---@type possession.Winopts
          fzf_winopts = {
              -- any valid fzf-lua winopts options, for instance
              width = 0.5,
              preview = {
                  vertical = "right:30%"
              }
          }
          ---@type possession.Mapopts
          mappings = { -- configure action keymaps on possession.list() picker
              action_delete = "ctrl-x",
              action_rename = "ctrl-r",
              action_new = "ctrl-n",
          }
          sort = require("nvim-possession.sorting").alpha_sort -- callback, sorting function to list sessions
                                                               -- require("nvim-possession.sorting").time_sort
                                                               -- to sort by last updated instead
      })
      
      
      require("nvim-possession").setup({
          autoload = true -- default false
      })
      
      
      require("nvim-possession").setup({
          autoprompt = true -- default false
      })
      
      
      require("nvim-possession").setup({
          autosave = false -- default true
      })
      
      
      require("nvim-possession").setup({
          autoswitch = {
              enable = true, -- default false
          }
      })
      
      
      require("nvim-possession").setup({
          autoswitch = {
              enable = true, -- default false
              exclude_ft = {"...", "..."}, -- list of filetypes to exclude from deletion
          }
      })
      
      
      require("nvim-possession").setup({
          save_hook = function()
              -- Get visible buffers
              local visible_buffers = {}
              for _, win in ipairs(vim.api.nvim_list_wins()) do
                  visible_buffers[vim.api.nvim_win_get_buf(win)] = true
              end
      
              local buflist = vim.api.nvim_list_bufs()
              for _, bufnr in ipairs(buflist) do
                  if visible_buffers[bufnr] == nil then -- Delete buffer if not visible
                      vim.cmd("bd " .. bufnr)
                  end
              end
          end
      })
      
      
      
      
      require("nvim-possession").setup({
          post_hook = function()
              require("FTerm").open()
              require("nvim-tree.api").tree.toggle()
              vim.lsp.buf.format()
          end
      })
      
      
      
      lualine.setup({
          sections = {
              lualine_a = ...
              lualine_b = ...
              lualine_c = {
                  { "filename", path = 1 },
                  {
                      require("nvim-possession").status,
                      cond = function()
                          return require("nvim-possession").status() ~= nil
                      end,
                  },
              },
          }
      })
      
    end,
  },
  {
    "olimorris/persisted.nvim",
    config = function()
      
      -- Lua
      {
        "olimorris/persisted.nvim",
        event = "BufReadPre", -- Ensure the plugin loads only when a buffer has been loaded
        opts = {
          -- Your config goes here ...
        },
      }
      
      
      -- Lua
      use({
        "olimorris/persisted.nvim",
        config = function()
          require("persisted").setup()
        end,
      })
      
      
      require("telescope").load_extension("persisted")
      
      
      require('telescope').setup({
        defaults = {
          …
        },
        extensions = {
          persisted = {
            layout_config = { width = 0.55, height = 0.55 }
          }
        }
      })
      
      
      {
        autostart = true, -- Automatically start the plugin on load?
      
        -- Function to determine if a session should be saved
        ---@type fun(): boolean
        should_save = function()
          return true
        end,
      
        save_dir = vim.fn.expand(vim.fn.stdpath("data") .. "/sessions/"), -- Directory where session files are saved
      
        follow_cwd = true, -- Change the session file to match any change in the cwd?
        use_git_branch = false, -- Include the git branch in the session file name?
        autoload = false, -- Automatically load the session for the cwd on Neovim startup?
      
        -- Function to run when `autoload = true` but there is no session to load
        ---@type fun(): any
        on_autoload_no_session = function() end,
      
        allowed_dirs = {}, -- Table of dirs that the plugin will start and autoload from
        ignored_dirs = {}, -- Table of dirs that are ignored for starting and autoloading
      
        telescope = {
          mappings = { -- Mappings for managing sessions in Telescope
            copy_session = "<C-c>",
            change_branch = "<C-b>",
            delete_session = "<C-d>",
          },
          icons = { -- icons displayed in the Telescope picker
            selected = " ",
            dir = "  ",
            branch = " ",
          },
        },
      }
      
      
      {
        save_dir = vim.fn.expand(vim.fn.stdpath("data") .. "/sessions/"), -- Resolves to ~/.local/share/nvim/sessions/
      }
      
      
      {
        use_git_branch = true,
      }
      
      
      {
        autostart = false,
      }
      
      
      {
        ---@return bool
        should_save = function()
          -- Do not save if the alpha dashboard is the current filetype
          if vim.bo.filetype == "alpha" then
            return false
          end
          return true
        end,
      }
      
      
      {
        autoload = true,
      }
      
      
      {
        autoload = true,
        on_autoload_no_session = function()
          vim.notify("No existing session to load.")
        end
      }
      
      
      {
        allowed_dirs = {
          "~/.dotfiles",
          "~/Code",
        },
      }
      
      
      {
        ignored_dirs = {
          "~/.config",
          "~/.local/nvim"
        },
      }
      
      
      {
        ignored_dirs = {
          "~/.config",
          "~/.local/nvim",
          { "/", exact = true },
          { "/tmp", exact = true }
        },
      }
      
      
      vim.api.nvim_create_autocmd("User", {
        pattern = "PersistedTelescopeLoadPre",
        callback = function(session)
          -- Save the currently loaded session passing in the path to the current session
          require("persisted").save({ session = vim.g.persisted_loaded_session })
      
          -- Delete all of the open buffers
          vim.api.nvim_input("<ESC>:%bd!<CR>")
        end,
      })
      
      
      vim.api.nvim_create_autocmd("User", {
        pattern = "PersistedSavePre",
        callback = function()
          for _, buf in ipairs(vim.api.nvim_list_bufs()) do
            if vim.bo[buf].filetype == "codecompanion" then
              vim.api.nvim_buf_delete(buf, { force = true })
            end
          end
        end,
      })
      
      
      {
        "olimorris/persisted.nvim",
        lazy = false,
        opts = {
          autoload = true,
        },
      }
      
      -- Somewhere in your config
      local persisted = require("persisted")
      vim.api.nvim_create_autocmd("VimEnter", {
        nested = true,
        callback = function()
          if vim.g.started_with_stdin then
            return
          end
      
          local forceload = false
          if vim.fn.argc() == 0 then
            forceload = true
          elseif vim.fn.argc() == 1 then
            local dir = vim.fn.expand(vim.fn.argv(0))
            if dir == '.' then
              dir = vim.fn.getcwd()
            end
      
            if vim.fn.isdirectory(dir) ~= 0 then
              forceload = true
            end
          end
      
          persisted.autoload({ force = forceload })
        end,
      })
      
      
      {
        "olimorris/persisted.nvim",
        lazy = false,
        opts = {
          autoload = true,
          autosave = true,
          use_git_branch = true,
        },
        config = function(_, opts)
          local persisted = require("persisted")
          persisted.branch = function()
            local branch = vim.fn.systemlist("git branch --show-current")[1]
            return vim.v.shell_error == 0 and branch or nil
          end
          persisted.setup(opts)
        end,
      }
      
      
      {
        "olimorris/persisted.nvim",
        lazy = false,
        opts = {
          autostart = true,
          use_git_branch = true,
        },
        config = function(_, opts)
          local persisted = require("persisted")
          local utils = require("persisted.utils")
          local ignored_branches = {
            "feature_branch"
            "bug_fix_branch"
          }
      
          persisted.setup(opts)
      
          -- Only start the plugin if the branch isn't in the ignored list
          if not utils.in_table(persisted.branch(), ignored_branches) then
            persisted.start()
          end
        end
      }
      
      
      {
        "olimorris/persisted.nvim",
        lazy = false,
        config = function()
          local persisted = require("persisted")
          persisted.setup({
            should_save = function()
              -- Ref: https://github.com/folke/persistence.nvim/blob/166a79a55bfa7a4db3e26fc031b4d92af71d0b51/lua/persistence/init.lua#L46
              local bufs = vim.tbl_filter(function(b)
                if vim.bo[b].buftype ~= "" or vim.tbl_contains({ "gitcommit", "gitrebase", "jj" }, vim.bo[b].filetype) then
                  return false
                end
                return vim.api.nvim_buf_get_name(b) ~= ""
              end, vim.api.nvim_list_bufs())
              if #bufs < 1 then
                return false
              end
              return true
            end,
          })
        end,
      }
      
      
      {
        "olimorris/persisted.nvim",
        lazy = false,
        config = function()
          local persisted = require("persisted")
          local utils = require("persisted.utils")
          local allowed_dirs = {
            "~/code",
            "~/notes/api"
          }
      
          persisted.setup({
            should_save = function()
              return utils.dirs_match(vim.fn.getcwd(), allowed_dirs)
            end,
          })
        end,
      }
      
    end,
  },
  {
    "folke/persistence.nvim",
    config = function()
      
      -- Lua
      {
        "folke/persistence.nvim",
        event = "BufReadPre", -- this will only start session saving when an actual file was opened
        opts = {
          -- add any custom options here
        }
      }
      
      
      {
        dir = vim.fn.stdpath("state") .. "/sessions/", -- directory where session files are saved
        -- minimum number of file buffers that need to be open to save
        -- Set to 0 to always save
        need = 1,
        branch = true, -- use git branch to save session
      }
      
      
      -- load the session for the current directory
      vim.keymap.set("n", "<leader>qs", function() require("persistence").load() end)
      
      -- select a session to load
      vim.keymap.set("n", "<leader>qS", function() require("persistence").select() end)
      
      -- load the last session
      vim.keymap.set("n", "<leader>ql", function() require("persistence").load({ last = true }) end)
      
      -- stop Persistence => session won't be saved on exit
      vim.keymap.set("n", "<leader>qd", function() require("persistence").stop() end)
      
    end,
  },
  {
    "Shatur/neovim-session-manager",
    config = function()
      
      local Path = require('plenary.path')
      local config = require('session_manager.config')
      require('session_manager').setup({
        sessions_dir = Path:new(vim.fn.stdpath('data'), 'sessions'), -- The directory where the session files will be saved.
        session_filename_to_dir = session_filename_to_dir, -- Function that replaces symbols into separators and colons to transform filename into a session directory.
        dir_to_session_filename = dir_to_session_filename, -- Function that replaces separators and colons into special symbols to transform session directory into a filename. Should use `vim.uv.cwd()` if the passed `dir` is `nil`.
        autoload_mode = config.AutoloadMode.LastSession, -- Define what to do when Neovim is started without arguments. See "Autoload mode" section below.
        autosave_last_session = true, -- Automatically save last session on exit and on session switch.
        autosave_ignore_not_normal = true, -- Plugin will not save a session when no buffers are opened, or all of them aren't writable or listed.
        autosave_ignore_dirs = {}, -- A list of directories where the session will not be autosaved.
        autosave_ignore_filetypes = { -- All buffers of these file types will be closed before the session is saved.
          'gitcommit',
          'gitrebase',
        },
        autosave_ignore_buftypes = {}, -- All buffers of these bufer types will be closed before the session is saved.
        autosave_only_in_session = false, -- Always autosaves session. If true, only autosaves after a session is active.
        max_path_length = 80,  -- Shorten the display path if length exceeds this threshold. Use 0 if don't want to shorten the path at all.
        load_include_current = false,  -- The currently loaded session appears in the load_session UI.
      })
      
      
      autoload_mode = { config.AutoloadMode.CurrentDir, config.AutoloadMode.LastSession }
      
      
      local config_group = vim.api.nvim_create_augroup('MyConfigGroup', {}) -- A global group for all your config autocommands
      
      vim.api.nvim_create_autocmd({ 'User' }, {
        pattern = "SessionLoadPost",
        group = config_group,
        callback = function()
          require('nvim-tree.api').tree.toggle(false, true)
        end,
      })
      
      
      -- Auto save session
      vim.api.nvim_create_autocmd({ 'BufWritePre' }, {
        callback = function ()
          for _, buf in ipairs(vim.api.nvim_list_bufs()) do
            -- Don't save while there's any 'nofile' buffer open.
            if vim.api.nvim_get_option_value("buftype", { buf = buf }) == 'nofile' then
              return
            end
          end
          session_manager.save_current_session()
        end
      })
      
    end,
  },
  {
    "jedrzejboczar/possession.nvim",
    config = function()
      
      use {
          'jedrzejboczar/possession.nvim',
          requires = { 'nvim-lua/plenary.nvim' },
      }
      
      
      require('possession').setup {
          session_dir = (Path:new(vim.fn.stdpath('data')) / 'possession'):absolute(),
          silent = false,
          load_silent = true,
          debug = false,
          logfile = false,
          prompt_no_cr = false,
          autosave = {
              current = false,  -- or fun(name): boolean
              cwd = false, -- or fun(): boolean
              tmp = false,  -- or fun(): boolean
              tmp_name = 'tmp', -- or fun(): string
              on_load = true,
              on_quit = true,
          },
          autoload = false, -- or 'last' or 'auto_cwd' or 'last_cwd' or fun(): string
          commands = {
              save = 'PossessionSave',
              load = 'PossessionLoad',
              save_cwd = 'PossessionSaveCwd',
              load_cwd = 'PossessionLoadCwd',
              rename = 'PossessionRename',
              close = 'PossessionClose',
              delete = 'PossessionDelete',
              show = 'PossessionShow',
              pick = 'PossessionPick',
              list = 'PossessionList',
              list_cwd = 'PossessionListCwd',
              migrate = 'PossessionMigrate',
          },
          hooks = {
              before_save = function(name) return {} end,
              after_save = function(name, user_data, aborted) end,
              before_load = function(name, user_data) return user_data end,
              after_load = function(name, user_data) end,
          },
          plugins = {
              close_windows = {
                  hooks = {'before_save', 'before_load'},
                  preserve_layout = true,  -- or fun(win): boolean
                  match = {
                      floating = true,
                      buftype = {},
                      filetype = {},
                      custom = false,  -- or fun(win): boolean
                  },
              },
              delete_hidden_buffers = {
                  hooks = {
                      'before_load',
                      vim.o.sessionoptions:match('buffer') and 'before_save',
                  },
                  force = false,  -- or fun(buf): boolean
              },
              nvim_tree = true,
              neo_tree = true,
              symbols_outline = true,
              outline = true,
              tabby = true,
              dap = true,
              dapui = true,
              neotest = true,
              kulala = true,
              delete_buffers = false,
              stop_lsp_clients = false,
          },
          telescope = {
              previewer = {
                  enabled = true,
                  previewer = 'pretty', -- or 'raw' or fun(opts): Previewer
                  wrap_lines = true,
                  include_empty_plugin_data = false,
                  cwd_colors = {
                      cwd = 'Comment',
                      tab_cwd = { '#cc241d', '#b16286', '#d79921', '#689d6a', '#d65d0e', '#458588' }
                  }
              },
              list = {
                  default_action = 'load',
                  mappings = {
                      save = { n = '<c-x>', i = '<c-x>' },
                      load = { n = '<c-v>', i = '<c-v>' },
                      delete = { n = '<c-t>', i = '<c-t>' },
                      rename = { n = '<c-r>', i = '<c-r>' },
                      grep   = { n = '<c-g>', i = '<c-g>' },
                      find   = { n = '<c-f>', i = '<c-f>' },
                  },
              },
          },
      }
      
      
      require('possession').setup {
          commands = {
              save = 'SSave',
              load = 'SLoad',
              delete = 'SDelete',
              list = 'SList',
          }
      }
      
      
      require('telescope').load_extension('possession')
      
      
      autosave = {
          cwd = function()
                return not require('possession.session').exists(require('possession.paths').cwd_session_name())
          end
      }
      
      
      local function session_name()
          return require('possession.session').get_session_name() or ''
      end
      
      
      local query = require('possession.query')
      local workspaces = {
          {
              'Workspace A',  -- title
              'a',            -- shortcuts prefix
              {
                  '/root/directory/a',
                  '/other/root/directory/',
              },
          }, {
              'Workspace B',
              'b',
              '/root/directory/b',
          }
      }
      -- e.g. https://github.com/goolord/alpha-nvim/blob/8a1477d8b99a931530f3cfb70f6805b759bebbf7/lua/alpha/themes/startify.lua#L28
      local create_button = function(shortcut, text, keymap)
          -- ...
      end
      
      local get_layout = function()
          return query.alpha_workspace_layout(workspaces, create_button, {
              others_name = 'Sessions Without Workspace',
          })
      end
      
      -- use with the rest of sections for alpha.nvim, with throttling to avoid reading files on each redraw
      local utils = require('possession.utils')
      local sections = {
          -- ...
          sessions = {
              type = 'group',
              val = utils.throttle(get_layout, 5000),
          },
          -- ...
      }
      
    end,
  },
  {
    "niuiic/multiple-session.nvim",
    config = function()
      
      -- default config
      require("multiple-session").setup({
      	-- used to search root path of the project
      	-- if .git does not exist, current directory path would be used
      	root_pattern = ".git",
      	-- where to store session
      	session_dir = function(project_root)
      		return project_root .. "/.nvim/session"
      	end,
      	-- name of default session
      	default_session = "default",
      	-- whether to use builtin session feature for storing/restoring
      	-- you have to implement this feature with hooks if the builtin feature is disabled
      	use_builtin_session = true,
      	-- whether to auto load session when neovim start
      	auto_load_session = function(_cur_session, cur_session_path)
      		if #vim.v.argv > 2 then
      			return false
      		end
      
      		-- detect whether in a nested instance
      		if vim.env.NVIM then
      			return false
      		end
      
      		local core = require("core")
      		if not core.file.file_or_dir_exists(cur_session_path) then
      			return false
      		end
      
      		return true
      	end,
      	-- whether to auto save session when neovim exits
      	auto_save_session = function(_cur_session, cur_session_path)
      		if #vim.v.argv > 2 then
      			return false
      		end
      
      		if vim.env.NVIM then
      			return false
      		end
      
      		local core = require("core")
      		if not core.file.file_or_dir_exists(cur_session_path) then
      			return false
      		end
      
      		return true
      	end,
      	---@type fun(session_dir: string, cur_session: string)
      	on_session_to_save = function() end,
      	---@type fun(session_dir: string, cur_session: string)
      	on_session_saved = function() end,
      	---@type fun(session_dir: string, cur_session: string)
      	on_session_to_restore = function() end,
      	---@type fun(session_dir: string, cur_session: string)
      	on_session_restored = function() end,
      })
      
      
      local core = require("core")
      local dap_utils = require("dap-utils")
      require("multiple-session").setup({
      	on_session_saved = function(session_dir)
      		-- niuiic/dap-utils.nvim
      		dap_utils.store_breakpoints(session_dir .. "/breakpoints")
      		dap_utils.store_watches(session_dir .. "/watches")
      		-- niuiic/quickfix.nvim
      		require("quickfix").store(session_dir .. "/quickfix")
      		vim.cmd("wundo " .. session_dir .. "/undo")
      	end,
      	on_session_to_restore = function()
      		-- close all buffers (optional)
      		local ok = pcall(vim.cmd, "%bd")
      		if not ok then
      			vim.notify("Some buffers are not saved", vim.log.levels.ERROR, {
      				title = "Session",
      			})
      		end
      	end,
      	on_session_restored = function(session_dir)
      		if core.file.file_or_dir_exists(session_dir .. "/" .. "breakpoints") then
      			dap_utils.restore_breakpoints(session_dir .. "/breakpoints")
      		end
      		if core.file.file_or_dir_exists(session_dir .. "/watches") then
      			dap_utils.restore_watches(session_dir .. "/watches")
      		end
      		if core.file.file_or_dir_exists(session_dir .. "/" .. "quickfix") then
      			require("quickfix").restore(session_dir .. "/quickfix")
      		end
      		if core.file.file_or_dir_exists(session_dir .. "/undo") then
      			vim.cmd("rundo " .. session_dir .. "/undo")
      		end
      	end,
      })
      
      
      {
      	{
      		"<leader>ss",
      		function()
      			require("multiple-session").save_session()
      		end,
      		desc = "save session",
      	},
      	{
      		"<leader>sr",
      		function()
      			require("multiple-session").restore_session()
      		end,
      		desc = "restore session",
      	},
      	{
      		"<leader>sd",
      		function()
      			require("multiple-session").delete_session()
      		end,
      		desc = "delete session",
      	},
      }
      
    end,
  },
  {
    "RutaTang/spectacle.nvim",
    config = function()
      
      require("lazy").setup({
        {
          "RutaTang/spectacle.nvim",
          dependencies = {
              'nvim-lua/plenary.nvim',
              'nvim-telescope/telescope.nvim'
          }
              opts = {session_dir = "/path/of/dir/where/you/want/to/save/all/sessions"}
        },
      })
      
      
      :lua require('spectacle').SpectacleTelescope()
      
      
      vim.api.nvim_set_keymap("n", "<leader>t", "<cmd>:lua require('spectacle').SpectacleTelescope()<cr>",{})
      
    end,
  },
  {
    "coffebar/neovim-project",
    config = function()
      
      {
        "coffebar/neovim-project",
        opts = {
          projects = { -- define project roots
            "~/projects/*",
            "~/.config/*",
          },
          picker = {
            type = "telescope", -- one of "telescope", "fzf-lua", or "snacks"
          }
        },
        init = function()
          -- enable saving the state of plugins in the session
          vim.opt.sessionoptions:append("globals") -- save global variables that start with an uppercase letter and contain at least one lowercase letter.
        end,
        dependencies = {
          { "nvim-lua/plenary.nvim" },
          -- optional picker
          { "nvim-telescope/telescope.nvim", tag = "0.1.4" },
          -- optional picker
          { "ibhagwan/fzf-lua" },
          -- optional picker
          { "folke/snacks.nvim" },
          { "Shatur/neovim-session-manager" },
        },
        lazy = false,
        priority = 100,
      },
      
      
      use({
        "coffebar/neovim-project",
        config = function()
          -- enable saving the state of plugins in the session
          vim.opt.sessionoptions:append("globals") -- save global variables that start with an uppercase letter and contain at least one lowercase letter.
          -- setup neovim-project plugin
          require("neovim-project").setup {
            projects = { -- define project roots
              "~/projects/*",
              "~/.config/*",
            },
            picker = {
            type = "telescope", -- one of "telescope", "fzf-lua", or "snacks"
            }
          }
        end,
        requires = {
          { "nvim-lua/plenary.nvim" },
          -- optional picker
          { "nvim-telescope/telescope.nvim", tag = "0.1.4" },
          -- optional picker
          { "ibhagwan/fzf-lua" },
          -- optional picker
          { "folke/snacks.nvim" },
          { "Shatur/neovim-session-manager" },
        }
      })
      
      
      {
        "coffebar/neovim-project",
        config = function()
          -- enable saving the state of plugins in the session
          vim.opt.sessionoptions:append("globals") -- save global variables that start with an uppercase letter and contain at least one lowercase letter.
          -- setup neovim-project plugin
          require("neovim-project").setup {
            projects = { -- define project roots
              "~/projects/*",
              "~/.config/*",
            },
            picker = {
              type = "telescope", -- one of "telescope", "fzf-lua", or "snacks"
            }
          }
        end,
        requires = {
          { "nvim-lua/plenary.nvim" },
          -- optional picker
          { "nvim-telescope/telescope.nvim", tag = "0.1.4" },
          -- optional picker
          { "ibhagwan/fzf-lua" },
          -- optional picker
          { "folke/snacks.nvim" },
          { "Shatur/neovim-session-manager" },
        }
      };
      
      
      {
        -- Project directories
        projects = {
          "~/projects/*",
          "~/p*cts/*", -- glob pattern is supported
          "~/projects/repos/*",
          "~/.config/*",
          "~/work/*",
        },
        -- Path to store history and sessions
        datapath = vim.fn.stdpath("data"), -- ~/.local/share/nvim/
        -- Load the most recent session on startup if not in the project directory
        last_session_on_startup = true,
        -- Dashboard mode prevent session autoload on startup
        dashboard_mode = false,
        -- Timeout in milliseconds before trigger FileType autocmd after session load
        -- to make sure lsp servers are attached to the current buffer.
        -- Set to 0 to disable triggering FileType autocmd
        filetype_autocmd_timeout = 200,
        -- Keymap to delete project from history in Telescope picker
        forget_project_keys = {
            -- insert mode: Ctrl+d
            i = "<C-d>",
            -- normal mode: d
            n = "d"
        },
        -- Follow symbolic links in glob patterns (affects startup speed)
        -- "full" or true - follow symlinks in all matched directories
        -- "partial" - follow symlinks before any matching operators (*, ?, [])
        -- "none" or false or nil - do not follow symlinks
        follow_symlinks = "full",
      
        -- Overwrite some of Session Manager options
        session_manager_opts = {
          autosave_ignore_dirs = {
            vim.fn.expand("~"), -- don't create a session for $HOME/
            "/tmp",
          },
          autosave_ignore_filetypes = {
            -- All buffers of these file types will be closed before the session is saved
            "ccc-ui",
            "dap-repl",
            "dap-view",
            "dap-view-term",
            "gitcommit",
            "gitrebase",
            "qf",
            "toggleterm",
          },
        },
        -- Picker to use for project selection
        -- Options: "telescope", "fzf-lua", "snacks"
        -- Fallback to builtin select ui if the specified picker is not available
        picker = {
          type = "telescope", -- one of "telescope", "fzf-lua", or "snacks"
      
          preview = {
            enabled = true, -- show directory structure in Telescope preview
            git_status = true, -- show branch name, an ahead/behind counter, and the git status of each file/folder
            git_fetch = false, -- fetch from remote, used to display the number of commits ahead/behind, requires git authorization
            show_hidden = true, -- show hidden files/folders
          },
          opts = {
            -- picker-specific options
          },
        },
        
      }
      
      
      local augroup = vim.api.nvim_create_augroup("user_cmds", { clear = true })
      
      local function update_git_env_for_dotfiles()
        -- Auto change ENV variables to enable
        -- bare git repository for dotfiles after
        -- loading saved session
        local home = vim.fn.expand("~")
        local git_dir = home .. "/dotfiles"
      
        if vim.env.GIT_DIR ~= nil and vim.env.GIT_DIR ~= git_dir then
          return
        end
      
        -- check dotfiles dir exists on current machine
        if vim.fn.isdirectory(git_dir) ~= 1 then
          vim.env.GIT_DIR = nil
          vim.env.GIT_WORK_TREE = nil
          return
        end
      
        -- check if the current working directory should belong to dotfiles
        local cwd = vim.loop.cwd()
        if vim.startswith(cwd, home .. "/.config/") or cwd == home or cwd == home .. "/.local/bin" then
          if vim.env.GIT_DIR == nil then
            -- export git location into ENV
            vim.env.GIT_DIR = git_dir
            vim.env.GIT_WORK_TREE = home
          end
        else
          if vim.env.GIT_DIR == git_dir then
            -- unset variables
            vim.env.GIT_DIR = nil
            vim.env.GIT_WORK_TREE = nil
          end
        end
      end
      
      vim.api.nvim_create_autocmd("DirChanged", {
        pattern = { "*" },
        group = augroup,
        desc = "Update git env for dotfiles after changing directory",
        callback = function()
          update_git_env_for_dotfiles()
        end,
      })
      
      vim.api.nvim_create_autocmd("User", {
        pattern = { "SessionLoadPost" },
        group = augroup,
        desc = "Update git env for dotfiles after loading session",
        callback = function()
          update_git_env_for_dotfiles()
        end,
      })
      
    end,
  },
  {
    "njayman/season.nvim",
    config = function()
      
      {
          'njayman/season.nvim',
          opts = {
              show_notifications = true, -- Enable or disable notifications (default: true)
          }
      }
      
      
      require('season').setup({
        show_notifications = true,  -- Enable or disable session messages (default: true)
      })
      
      
      :lua require('season').save_session()
      
      
      :lua require('season').load_session()
      
      
      vim.keymap.set('n','<leader>ss', function() require('season').save_session() end, { desc = "Save Session" })
      
      vim.keymap.set('n', '<leader>sl', function() require('season').load_session() end, { desc = "Load Session" })
      
    end,
  },
  {
    "inhesrom/remote-ssh.nvim",
    config = function()
      
      {
          "inhesrom/remote-ssh.nvim",
          branch = "master",
          dependencies = {
              "inhesrom/telescope-remote-buffer", --See https://github.com/inhesrom/telescope-remote-buffer for features
              "nvim-telescope/telescope.nvim",
              "nvim-lua/plenary.nvim",
              "neovim/nvim-lspconfig",
              -- nvim-notify is recommended, but not necessarily required into order to get notifcations during operations - https://github.com/rcarriga/nvim-notify
              "rcarriga/nvim-notify",
          },
          config = function ()
              require('telescope-remote-buffer').setup(
                  -- Default keymaps to open telescope and search open buffers including "remote" open buffers
                  --fzf = "<leader>fz",
                  --match = "<leader>gb",
                  --oldfiles = "<leader>rb"
              )
      
              -- setup lsp_config here or import from part of neovim config that sets up LSP
      
              require('remote-ssh').setup({
                  on_attach = lsp_config.on_attach,
                  capabilities = lsp_config.capabilities,
                  filetype_to_server = lsp_config.filetype_to_server
              })
          end
      }
      
      
      use {
          'inhesrom/remote-ssh.nvim',
          branch = "master",
          requires = {
              "inhesrom/telescope-remote-buffer",
              "nvim-telescope/telescope.nvim",
              "nvim-lua/plenary.nvim",
              'neovim/nvim-lspconfig',
          },
          config = function()
              require('telescope-remote-buffer').setup()
      
              -- setup lsp_config here or import from part of neovim config that sets up LSP
      
              require('remote-ssh').setup({
                  on_attach = lsp_config.on_attach,
                  capabilities = lsp_config.capabilities,
                  filetype_to_server = lsp_config.filetype_to_server
              })
          end
      }
      
      
      -- lsp_util.lua
      local M = {}
      
      -- LSP on_attach function with key mappings
      M.on_attach = function(client, bufnr)
          local nmap = function(keys, func, desc)
              vim.keymap.set('n', keys, func, { buffer = bufnr, desc = desc })
          end
      
          -- Key mappings
          nmap('gd', require('telescope.builtin').lsp_definitions, '[G]oto [D]efinition')
          nmap('gr', require('telescope.builtin').lsp_references, '[G]oto [R]eferences')
          nmap('gI', require('telescope.builtin').lsp_implementations, '[G]oto [I]mplementation')
          nmap('K', vim.lsp.buf.hover, 'Hover Documentation')
          nmap('<leader>rn', vim.lsp.buf.rename, '[R]e[n]ame')
          nmap('<leader>ca', vim.lsp.buf.code_action, '[C]ode [A]ction')
      end
      
      -- LSP capabilities
      local capabilities = vim.lsp.protocol.make_client_capabilities()
      M.capabilities = require('cmp_nvim_lsp').default_capabilities(capabilities)
      
      -- Server definitions
      M.servers = {
          clangd = {},            -- C/C++
          rust_analyzer = {},     -- Rust
          pylsp = {},             -- Python
          lua_ls = {},            -- Lua
          -- Add more servers as needed
      }
      
      -- Generate filetype to server mapping
      M.filetype_to_server = {}
      for server_name, _ in pairs(M.servers) do
          local filetypes = require('lspconfig')[server_name].document_config.default_config.filetypes or {}
          for _, ft in ipairs(filetypes) do
              M.filetype_to_server[ft] = server_name
          end
      end
      
      return M
      
      
      -- In your plugin configuration
      {
          'williamboman/mason.nvim',
          dependencies = { 'williamboman/mason-lspconfig.nvim' },
          config = function()
              require('mason').setup()
              require('mason-lspconfig').setup({
                  ensure_installed = vim.tbl_keys(require('lsp_util').servers),
              })
          end
      }
      
      
      require('remote-ssh').setup({
          -- Optional: Custom on_attach function for LSP clients
          on_attach = function(client, bufnr)
              -- Your LSP keybindings and setup
          end,
      
          -- Optional: Custom capabilities for LSP clients
          capabilities = vim.lsp.protocol.make_client_capabilities(),
      
          -- Custom mapping from filetype to LSP server name
          filetype_to_server = {
              -- Example: Use pylsp for Python (default and recommended)
              python = "pylsp",
              -- More customizations...
          },
      
          -- Custom server configurations
          server_configs = {
              -- Custom config for clangd
              clangd = {
                  filetypes = { "c", "cpp", "objc", "objcpp" },
                  root_patterns = { ".git", "compile_commands.json" },
                  init_options = {
                      usePlaceholders = true,
                      completeUnimported = true
                  }
              },
              -- More server configs...
          },
      
          -- Async write configuration
          async_write_opts = {
              timeout = 30,         -- Timeout in seconds for write operations
              debug = false,        -- Enable debug logging
              log_level = vim.log.levels.INFO,
              autosave = true,      -- Enable automatic saving on text changes (default: true)
                                    -- Set to false to disable auto-save while keeping manual saves (:w) working
              save_debounce_ms = 3000 -- Delay before initiating auto-save to handle rapid editing (default: 3000)
          }
      })
      
      
      require('remote-ssh').setup({
          async_write_opts = {
              autosave = true,        -- Auto-save on text changes
              save_debounce_ms = 3000 -- Wait 3 seconds after editing before saving
          }
      })
      
      
      require('remote-ssh').setup({
          async_write_opts = {
              autosave = false  -- Disable auto-save, but `:w` still works
          }
      })
      
    end,
  },
  {
    "chipsenkbeil/distant.nvim",
    config = function()
      
      {
          'chipsenkbeil/distant.nvim', 
          branch = 'v0.3',
          config = function()
              require('distant'):setup()
          end
      }
      
      
      use {
          'chipsenkbeil/distant.nvim',
          branch = 'v0.3',
          config = function()
              require('distant'):setup()
          end
      }
      
    end,
  },
  {
    "jamestthompson3/nvim-remote-containers",
  },
  {
    "esensar/nvim-dev-container",
    config = function()
      
      {
        'https://codeberg.org/esensar/nvim-dev-container',
        dependencies = 'nvim-treesitter/nvim-treesitter'
      }
      
      
      { 'https://codeberg.org/esensar/nvim-dev-container' }
      
      
      require("devcontainer").setup{}
      
      
      require("devcontainer").setup {
        config_search_start = function()
          -- By default this function uses vim.loop.cwd()
          -- This is used to find a starting point for .devcontainer.json file search
          -- Since by default, it is searched for recursively
          -- That behavior can also be disabled
        end,
        workspace_folder_provider = function()
          -- By default this function uses first workspace folder for integrated lsp if available and vim.loop.cwd() as a fallback
          -- This is used to replace `${localWorkspaceFolder}` in devcontainer.json
          -- Also used for creating default .devcontainer.json file
        end,
        terminal_handler = function(command)
          -- By default this function creates a terminal in a new tab using :terminal command
          -- It also removes statusline when that tab is active, to prevent double statusline
          -- It can be overridden to provide custom terminal handling
        end,
        nvim_installation_commands_provider = function(path_binaries, version_string)
          -- Returns table - list of commands to run when adding neovim to container
          -- Each command can either be a string or a table (list of command parts)
          -- Takes binaries available in path on current container and version_string passed to the command or current version of neovim
        end,
        devcontainer_json_template = function()
          -- Returns table - list of lines to set when creating new devcontainer.json files
          -- As a template
          -- Used only when using functions from commands module or created commands
        end,
        -- Can be set to false to prevent generating default commands
        -- Default commands are listed below
        generate_commands = true,
        -- By default no autocommands are generated
        -- This option can be used to configure automatic starting and cleaning of containers
        autocommands = {
          -- can be set to true to automatically start containers when devcontainer.json is available
          init = false,
          -- can be set to true to automatically remove any started containers and any built images when exiting vim
          clean = false,
          -- can be set to true to automatically restart containers when devcontainer.json file is updated
          update = false,
        },
        -- can be changed to increase or decrease logging from library
        log_level = "info",
        -- can be set to true to disable recursive search
        -- in that case only .devcontainer.json and .devcontainer/devcontainer.json files will be checked relative
        -- to the directory provided by config_search_start
        disable_recursive_config_search = false,
        -- can be set to false to disable image caching when adding neovim
        -- by default it is set to true to make attaching to containers faster after first time
        cache_images = true,
        -- By default all mounts are added (config, data and state)
        -- This can be changed to disable mounts or change their options
        -- This can be useful to mount local configuration
        -- And any other mounts when attaching to containers with this plugin
        attach_mounts = {
          neovim_config = {
            -- enables mounting local config to /root/.config/nvim in container
            enabled = false,
            -- makes mount readonly in container
            options = { "readonly" }
          },
          neovim_data = {
            -- enables mounting local data to /root/.local/share/nvim in container
            enabled = false,
            -- no options by default
            options = {}
          },
          -- Only useful if using neovim 0.8.0+
          neovim_state = {
            -- enables mounting local state to /root/.local/state/nvim in container
            enabled = false,
            -- no options by default
            options = {}
          },
        },
        -- This takes a list of mounts (strings) that should always be added to every run container
        -- This is passed directly as --mount option to docker command
        -- Or multiple --mount options if there are multiple values
        always_mount = {},
        -- This takes a string (usually either "podman" or "docker") representing container runtime - "devcontainer-cli" is also partially supported
        -- That is the command that will be invoked for container operations
        -- If it is nil, plugin will use whatever is available (trying "podman" first)
        container_runtime = nil,
        -- Similar to container runtime, but will be used if main runtime does not support an action - useful for "devcontainer-cli"
        backup_runtime = nil,
        -- This takes a string (usually either "podman-compose" or "docker-compose") representing compose command - "devcontainer-cli" is also partially supported
        -- That is the command that will be invoked for compose operations
        -- If it is nil, plugin will use whatever is available (trying "podman-compose" first)
        compose_command = nil,
        -- Similar to compose command, but will be used if main command does not support an action - useful for "devcontainer-cli"
        backup_compose_command = nil,
      }
      
    end,
  },
  {
    "miversen33/netman.nvim",
    config = function()
      
      require("netman")
      
      
      require("neo-tree").setup({
          sources = {
              "filesystem", -- Neotree filesystem source
              "netman.ui.neo-tree", -- The one you really care about 😉
          }
      })
      
      
      vim.g.netman_log_level = 1
      
    end,
  },
  {
    "niuiic/remote.nvim",
    config = function()
      
      {
      	config_file = ".nvim/remote.json",
      	log_file = ".nvim/remote.log",
      	unmount = function(path)
      		return "umount " .. path
      	end,
      	disconnect_on_leave = true,
      	---@type fun(config: remote.Config)
      	on_each_to_connect = function() end,
      	---@type fun(config: remote.Config)
      	on_each_connected = function() end,
      	---@type fun(config: remote.Config)
      	on_each_to_disconnect = function() end,
      	---@type fun(config: remote.Config)
      	on_each_disconnected = function() end,
      }
      
      ---@class remote.Config
      ---@field host string
      ---@field user string
      ---@field passwd string
      ---@field remote_dir string
      ---@field mount_point string
      ---@field options string[] | nil
      
    end,
  },
  {
    "uhs-robert/sshfs.nvim",
    config = function()
      
      {
        "uhs-robert/sshfs.nvim",
        opts = {
          -- Refer to the configuration section below
          -- or leave empty for defaults
        },
      }
      
      
      use {
        "uhs-robert/sshfs.nvim",
        config = function()
          require("sshfs").setup({
            -- Your configuration here
          })
        end
      }
      
      
      require("sshfs").setup({
        -- Your configuration here
      })
      
      
      require("sshfs").setup({
        -- Your configuration here
      })
      
      
      require("sshfs").setup({
        connections = {
          ssh_configs = require("sshfs.core.config").get_default_ssh_configs(),
          sshfs_args = { -- these are the sshfs options that will be used
            "-o reconnect",            -- Automatically reconnect if the connection drops
            "-o ConnectTimeout=5",     -- Time (in seconds) to wait before failing a connection attempt
            "-o compression=yes",      -- Enable compression to reduce bandwidth usage
            "-o ServerAliveInterval=15", -- Send a keepalive packet every 15 seconds to prevent timeouts
            "-o ServerAliveCountMax=3",  -- Number of missed keepalive packets before disconnecting
          },
        },
        mounts = {
          base_dir = vim.fn.expand("$HOME") .. "/mnt", -- where remote mounts are created
          unmount_on_exit = true, -- auto-disconnect all mounts on :q or exit
        },
        handlers = {
          on_disconnect = {
            clean_mount_folders = true, -- optionally clean up mount folders after disconnect
          },
        },
        ui = {
          file_picker = {
            auto_open_on_mount = true, -- auto-open picker after connecting
            preferred_picker = "auto", -- one of: "auto", "telescope", "oil", "neo-tree", "nvim-tree", "snacks", "fzf-lua", "mini", "yazi", "lf", "nnn", "ranger", "netrw"
            fallback_to_netrw = true,  -- fallback to netrw if no picker is available
          },
        },
        lead_prefix = "<leader>m", -- change keymap prefix (default: <leader>m)
        keymaps = {
          mount = "<leader>mm",
          unmount = "<leader>mu",
          edit = "<leader>me",
          reload = "<leader>mr",
          open = "<leader>mo",
          grep = "<leader>mg",
        },
        log = {
          enabled = false,
          truncate = false,
          types = {
            all = false,
            util = false,
            handler = false,
            sshfs = false,
          },
        },
      })
      
      
      require("sshfs").setup({
        lead_prefix = "<leader>m", -- change keymap prefix (default: <leader>m)
        keymaps = {
          mount = "<leader>mm",
          unmount = "<leader>mu",
          edit = "<leader>me",
          reload = "<leader>mr",
          open = "<leader>mo",
          grep = "<leader>mg",
        },
      })
      
    end,
  },
  {
    "nosduco/remote-sshfs.nvim",
    config = function()
      
      // Using lazy.nvim
      return {
        "nosduco/remote-sshfs.nvim",
        dependencies = { "nvim-telescope/telescope.nvim", "nvim-lua/plenary.nvim" },
        opts = {
          -- Refer to the configuration section below
          -- or leave empty for defaults
        },
      }
      
      
      require('telescope').load_extension 'remote-sshfs'
      
      
      require('remote-sshfs').setup{
        connections = {
          ssh_configs = { -- which ssh configs to parse for hosts list
            vim.fn.expand "$HOME" .. "/.ssh/config",
            "/etc/ssh/ssh_config",
            -- "/path/to/custom/ssh_config"
          },
          ssh_known_hosts = vim.fn.expand "$HOME" .. "/.ssh/known_hosts",
          -- NOTE: Can define ssh_configs similarly to include all configs in a folder
          -- ssh_configs = vim.split(vim.fn.globpath(vim.fn.expand "$HOME" .. "/.ssh/configs", "*"), "\n")
          sshfs_args = { -- arguments to pass to the sshfs command
            "-o reconnect",
            "-o ConnectTimeout=5",
          },
        },
        mounts = {
          base_dir = vim.fn.expand "$HOME" .. "/.sshfs/", -- base directory for mount points
          unmount_on_exit = true, -- run sshfs as foreground, will unmount on vim exit
        },
        handlers = {
          on_connect = {
            change_dir = true, -- when connected change vim working directory to mount point
          },
          on_disconnect = {
            clean_mount_folders = false, -- remove mount point folder on disconnect/unmount
          },
          on_edit = {}, -- not yet implemented
        },
        ui = {
          select_prompts = false, -- not yet implemented
          confirm = {
            connect = true, -- prompt y/n when host is selected to connect to
            change_dir = false, -- prompt y/n to change working directory on connection (only applicable if handlers.on_connect.change_dir is enabled)
          },
        },
        log = {
          enabled = false, -- enable logging
          truncate = false, -- truncate logs
          types = { -- enabled log types
            all = false,
            util = false,
            handler = false,
            sshfs = false,
          },
        },
      }
      
      
      local api = require('remote-sshfs.api')
      vim.keymap.set('n', '<leader>rc', api.connect, {})
      vim.keymap.set('n', '<leader>rd', api.disconnect, {})
      vim.keymap.set('n', '<leader>re', api.edit, {})
      
      -- (optional) Override telescope find_files and live_grep to make dynamic based on if connected to host
      local builtin = require("telescope.builtin")
      local connections = require("remote-sshfs.connections")
      vim.keymap.set("n", "<leader>ff", function()
       if connections.is_connected() then
        api.find_files()
       else
        builtin.find_files()
       end
      end, {})
      vim.keymap.set("n", "<leader>fg", function()
       if connections.is_connected() then
        api.live_grep()
       else
        builtin.live_grep()
       end
      end, {})
      
      
      require("remote-sshfs").callback.on_connect_success:add(function(host, mount_dir)
        vim.notify("Mounted " .. host .. " at " .. mount_dir)
      end)
      
      
      -- ~/.config/nvim/lua/chadrc.lua
      
      local M = {}
      
      -- 1️⃣  Create a callable module for NvChad’s statusline
      local remote_module = require("remote-sshfs.statusline").nvchad_module {
        highlight = "St_gitIcons", -- highlight group (optional)
      }
      
      --  Option A: use an *existing* highlight group by name (as above).
      --  Option B: provide a colour table and the plugin will create a group for you:
      -- local remote_module = require("remote-sshfs.statusline").nvchad_module {
      --   highlight = { fg = "#6A9955", bold = true },
      -- }
      
      -- 2️⃣  Add it to `modules` *and* reference it in `order`
      M.ui = {
        statusline = {
          -- theme / separator_style as you already have…
      
          -- insert the module name wherever you like
          order = { "mode", "file", "git", "%=", "lsp_msg", "%=", "diagnostics", "remote", "lsp", "cwd", "cursor" },
      
          modules = {
            remote = remote_module,
          },
        },
      }
      
      return M
      
      
      -- has to be set *before* `require("remote-sshfs")` is executed
      vim.g.remote_sshfs_status_icon = ""  -- VS Code-style lock icon
      
    end,
  },
  {
    "azratul/live-share.nvim",
    config = function()
      
      -- packer.nvim
      use { "azratul/live-share.nvim", tag = "v1.0.0" }
      
      -- lazy.nvim
      { "azratul/live-share.nvim", version = "v1.0.0" }
      
      
      use {
        'azratul/live-share.nvim',
        requires = {'jbyuki/instant.nvim'}
        config = function()
          vim.g.instant_username = "your-username"
          require("live-share").setup({
            -- Add your configuration here
          })
        end
      }
      
      
      {
        "azratul/live-share.nvim",
        dependencies = {
          "jbyuki/instant.nvim",
        },
        config = function()
          vim.g.instant_username = "your-username"
          require("live-share").setup({
           -- Add your configuration here
          })
        end
      }
      
      
      require("live-share").setup({
        port_internal = 9876, -- The local port to be used for the live share connection
        max_attempts = 20, -- Maximum number of attempts to read the URL from service(serveo.net or localhost.run), every 250 ms
        service_url = "/tmp/service.url", -- Path to the file where the URL from serveo.net will be stored
        service = "nokey@localhost.run", -- Service to use, options are serveo.net or localhost.run
      })
      
      
      {
        "azratul/live-share.nvim",
        dependencies = {
          "jbyuki/instant.nvim",
        },
        config = function()
          vim.g.instant_username = "your-username"
          require("live-share").setup({
            port_internal = 8765,
            max_attempts = 40, -- 10 seconds
            service = "serveo.net"
          })
        end
      }
      
      
      require("live-share.provider").register("bore", {
        command = "your-command",
        pattern = "your-regex-pattern",
      })
      
      
        {
          "azratul/live-share.nvim",
          lazy = false,
          dependencies = {
            "jbyuki/instant.nvim",
          },
          config = function()
            require("live-share.provider").register("bore", {
              command = function(_, port, service_url)
                return string.format(
                  "bore local %d --to bore.pub > %s 2>/dev/null",
                  port,
                  service_url
                )
              end,
              pattern = "bore%.pub:%d+",
            })
      
            vim.g.instant_username = "your-username"
            require("live-share").setup {
              service = "bore",
            }
          end,
        }
      
    end,
  },
  {
    "yorickpeterse/nvim-window",
    config = function()
      
      {
        "yorickpeterse/nvim-window",
        keys = {
          { "<leader>wj", "<cmd>lua require('nvim-window').pick()<cr>", desc = "nvim-window: Jump to window" },
        },
        config = true,
      }
      
      
      require('nvim-window').setup({
        -- The characters available for hinting windows.
        chars = {
          'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
          'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
        },
      
        -- A group to use for overwriting the Normal highlight group in the floating
        -- window. This can be used to change the background color.
        normal_hl = 'Normal',
      
        -- The border style to use for the floating window.
        border = 'single',
      
        -- How the hints should be rendered. The possible values are:
        --
        -- - "float" (default): renders the hints using floating windows
        -- - "status": renders the hints to a string and calls `redrawstatus`,
        --   allowing you to show the hints in a status or winbar line
        render = 'float',
      })
      
    end,
  },
  {
    "sindrets/winshift.nvim",
    config = function()
      
      -- Packer
      use 'sindrets/winshift.nvim'
      
      
      -- Lua
      require("winshift").setup({
        highlight_moving_win = true,  -- Highlight the window being moved
        focused_hl_group = "Visual",  -- The highlight group used for the moving window
        moving_win_options = {
          -- These are local options applied to the moving window while it's
          -- being moved. They are unset when you leave Win-Move mode.
          wrap = false,
          cursorline = false,
          cursorcolumn = false,
          colorcolumn = "",
        },
        keymaps = {
          disable_defaults = false, -- Disable the default keymaps
          win_move_mode = {
            ["h"] = "left",
            ["j"] = "down",
            ["k"] = "up",
            ["l"] = "right",
            ["H"] = "far_left",
            ["J"] = "far_down",
            ["K"] = "far_up",
            ["L"] = "far_right",
            ["<left>"] = "left",
            ["<down>"] = "down",
            ["<up>"] = "up",
            ["<right>"] = "right",
            ["<S-left>"] = "far_left",
            ["<S-down>"] = "far_down",
            ["<S-up>"] = "far_up",
            ["<S-right>"] = "far_right",
          },
        },
        ---A function that should prompt the user to select a window.
        ---
        ---The window picker is used to select a window while swapping windows with
        ---`:WinShift swap`.
        ---@return integer? winid # Either the selected window ID, or `nil` to
        ---   indicate that the user cancelled / gave an invalid selection.
        window_picker = function()
          return require("winshift.lib").pick_window({
            -- A string of chars used as identifiers by the window picker.
            picker_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890",
            filter_rules = {
              -- This table allows you to indicate to the window picker that a window
              -- should be ignored if its buffer matches any of the following criteria.
              cur_win = true, -- Filter out the current window
              floats = true,  -- Filter out floating windows
              filetype = {},  -- List of ignored file types
              buftype = {},   -- List of ignored buftypes
              bufname = {},   -- List of vim regex patterns matching ignored buffer names
            },
            ---A function used to filter the list of selectable windows.
            ---@param winids integer[] # The list of selectable window IDs.
            ---@return integer[] filtered # The filtered list of window IDs.
            filter_func = nil,
          })
        end,
      })
      
    end,
  },
  {
    "nvim-focus/focus.nvim",
    config = function()
      
      require("focus").setup()
      
      
      require("focus").setup({
          enable = true, -- Enable module
          commands = true, -- Create Focus commands
          autoresize = {
              enable = true, -- Enable or disable auto-resizing of splits
              width = 0, -- Force width for the focused window
              height = 0, -- Force height for the focused window
              minwidth = 0, -- Force minimum width for the unfocused window
              minheight = 0, -- Force minimum height for the unfocused window
              focusedwindow_minwidth = 0, --Force minimum width for the focused window
              focusedwindow_minheight = 0, --Force minimum height for the focused window
              height_quickfix = 10, -- Set the height of quickfix panel
          },
          split = {
              bufnew = false, -- Create blank buffer for new split windows
              tmux = false, -- Create tmux splits instead of neovim splits
          },
          ui = {
              number = false, -- Display line numbers in the focussed window only
              relativenumber = false, -- Display relative line numbers in the focussed window only
              hybridnumber = false, -- Display hybrid line numbers in the focussed window only
              absolutenumber_unfocussed = false, -- Preserve absolute numbers in the unfocussed windows
      
              cursorline = true, -- Display a cursorline in the focussed window only
              cursorcolumn = false, -- Display cursorcolumn in the focussed window only
              colorcolumn = {
                  enable = false, -- Display colorcolumn in the foccused window only
                  list = '+1', -- Set the comma-saperated list for the colorcolumn
              },
              signcolumn = true, -- Display signcolumn in the focussed window only
              winhighlight = false, -- Auto highlighting for focussed/unfocussed windows
          }
      })
      
      
      -- Completely disable this plugin
      -- Default: true
      require("focus").setup({enable = false})
      
      
      -- This not export :Focus* commands
      -- Default: true
      require("focus").setup({commands = false})
      
      
      --The focussed window will no longer automatically resize. Other focus features are still available
      -- Default: true
      require("focus").setup({ autoresize = { enable = false } })
      
      
      -- Force width for the focused window
      -- Default: Calculated based on golden ratio
      require("focus").setup({ autoresize = { width = 120 } })
      
      
      -- Force minimum width for the unfocused window
      -- Default: Calculated based on golden ratio
      require("focus").setup({ autoresize = { minwidth = 80} })
      
      
      -- Force minimum width for the focused window
      -- Default: Calculated based on golden ratio
      require("focus").setup({ autoresize = { focusedwindow_minwidth = 80} })
      
      
      -- Force height for the focused window
      -- Default: Calculated based on golden ratio
      require("focus").setup({ autoresize = { height = 40 } })
      
      
      -- Force minimum height for the unfocused window
      -- Default: 0
      require("focus").setup({ autoresize = { minheight = 10} })
      
      
      -- Force minimum height for the focused window
      -- Default: Calculated based on golden ratio
      require("focus").setup({ autoresize = { focusedwindow_minheight = 80} })
      
      
      -- Sets the height of quickfix panel, in case you pass the height to
      -- `:copen <height>`
      -- Default: 10
      require("focus").setup({ autoresize = { height_quickfix = 10 })
      
      
      -- True: When a :Focus.. command creates a new split window, initialise it as a new blank buffer
      -- False: When a :Focus.. command creates a new split, retain a copy of the current window in the new window
      -- Default: false
      require("focus").setup({ split = { bufnew = true } })
      
      
      -- Displays line numbers in the focussed window only
      -- Not displayed in unfocussed windows
      -- Default: true
      require("focus").setup({ui = { number = false } })
      
      
      -- Displays relative line numbers in the focussed window only
      -- Not displayed in unfocussed windows
      -- See :help relativenumber
      -- Default: false
      require("focus").setup({ ui = { relativenumber = true } })
      
      
      -- Displays hybrid line numbers in the focussed window only
      -- Not displayed in unfocussed windows
      -- Combination of :help relativenumber, but also displays the line number of the
      -- current line only
      -- Default: false
      require("focus").setup({ ui = { hybridnumber = true} })
      
      
      -- Preserve absolute numbers in the unfocussed windows
      -- Works in combination with relativenumber or hybridnumber
      -- Default: false
      require("focus").setup({ ui = { absolutenumber_unfocussed = true } })
      
      
      -- True: Create tmux splits instead of neovim splits
      -- False: Create neovim split windows
      -- Default: false
      require("focus").setup({ split = { tmux = true } })
      
      
      -- Displays a cursorline in the focussed window only
      -- Not displayed in unfocussed windows
      -- Default: true
      require("focus").setup({ ui = { cursorline = false } })
      
      
      -- Displays a cursor column in the focussed window only
      -- See :help cursorcolumn for more options
      -- Default: false
      require("focus").setup({ ui = { cursorcolumn = true } })
      
      
      -- Displays a color column in the focussed window only
      -- See :help colorcolumn for more options
      -- Default: enable = false, list = '+1'
      require("focus").setup({
          ui = {
              colorcolumn = {
                  enable = true,
                  list = '+1,+2'
              }
          }
      })
      
      
      -- Displays a sign column in the focussed window only
      -- Gets the vim variable setcolumn when focus.setup() is run
      -- See :help signcolumn for more options e.g :set signcolum=yes
      -- Default: true, signcolumn=auto
      require("focus").setup({ ui = { signcolumn = false } })
      
      
      -- Enable auto highlighting for focussed/unfocussed windows
      -- Default: false
      require("focus").setup({ ui = { winhighlight = true } })
      
      -- By default, the highlight groups are setup as such:
      --   hi default link FocusedWindow VertSplit
      --   hi default link UnfocusedWindow Normal
      -- To change them, you can link them to a different highlight group, see
      -- `:help hi-default` for more info.
      vim.highlight.link('FocusedWindow', 'CursorLine', true)
      vim.highlight.link('UnfocusedWindow', 'VisualNOS', true)
      
      
      local ignore_filetypes = { 'neo-tree' }
      local ignore_buftypes = { 'nofile', 'prompt', 'popup' }
      
      local augroup =
          vim.api.nvim_create_augroup('FocusDisable', { clear = true })
      
      vim.api.nvim_create_autocmd('WinEnter', {
          group = augroup,
          callback = function(_)
              if vim.tbl_contains(ignore_buftypes, vim.bo.buftype)
              then
                  vim.w.focus_disable = true
              else
                  vim.w.focus_disable = false
              end
          end,
          desc = 'Disable focus autoresize for BufType',
      })
      
      vim.api.nvim_create_autocmd('FileType', {
          group = augroup,
          callback = function(_)
              if vim.tbl_contains(ignore_filetypes, vim.bo.filetype) then
                  vim.b.focus_disable = true
              else
                  vim.b.focus_disable = false
              end
          end,
          desc = 'Disable focus autoresize for FileType',
      })
      
      
      keymap('n', '<c-l>', function()
          require('focus').split_nicely()
      end, { desc = 'split nicely' })
      
      
      local focusmap = function(direction)
          vim.keymap.set('n', '<Leader>'..direction, function()
              require('focus').split_command(direction)
          end, { desc = string.format('Create or move to split (%s)', direction) })
      end
      
      -- Use `<Leader>h` to split the screen to the left, same as command FocusSplitLeft etc
      focusmap('h')
      focusmap('j')
      focusmap('k')
      focusmap('l')
      
    end,
  },
  {
    "anuvyklack/windows.nvim",
    config = function()
      
        use { "anuvyklack/windows.nvim",
           requires = {
              "anuvyklack/middleclass",
              "anuvyklack/animation.nvim"
           },
           config = function()
              vim.o.winwidth = 10
              vim.o.winminwidth = 10
              vim.o.equalalways = false
              require('windows').setup()
           end
        }
        
      
        use { "anuvyklack/windows.nvim",
           requires = "anuvyklack/middleclass",
           config = function()
              require('windows').setup()
           end
        }
        
      
      local function cmd(command)
         return table.concat({ '<Cmd>', command, '<CR>' })
      end
      
      vim.keymap.set('n', '<C-w>z', cmd 'WindowsMaximize')
      vim.keymap.set('n', '<C-w>_', cmd 'WindowsMaximizeVertically')
      vim.keymap.set('n', '<C-w>|', cmd 'WindowsMaximizeHorizontally')
      vim.keymap.set('n', '<C-w>=', cmd 'WindowsEqualize')
      
    end,
  },
  {
    "nvim-zh/colorful-winsep.nvim",
    config = function()
      
      Plug 'nvim-zh/colorful-winsep.nvim'
      
      
      use {
          "nvim-zh/colorful-winsep.nvim",
          config = function ()
              require('colorful-winsep').setup()
          end
      }
      
      
      {
        "nvim-zh/colorful-winsep.nvim",
        config = true,
        event = { "WinLeave" },
      }
      
      
      require("colorful-winsep").setup({
          -- choose between "single", "rounded", "bold" and "double".
          -- Or pass a table like this: { "─", "│", "┌", "┐", "└", "┘" },
          border = "bold",
          excluded_ft = { "packer", "TelescopePrompt", "mason" },
          highlight = nil, -- nil|string|function. See the docs's Highlights section
          animate = {
              enabled = "shift", -- false to disable, or choose a option below (e.g. "shift") and set option for it if needed
              shift = {
                  delta_time = 0.1,
                  smooth_speed = 1,
                  delay = 3,
              },
              progressive = {
                  -- animation's speed for different direction
                  vertical_delay = 20,
                  horizontal_delay = 2,
              },
          },
          indicator_for_2wins = {
              -- only work when the total of windows is two
              position = "center", -- false to disable or choose between "center", "start", "end" and "both"
              symbols = {
                  -- the meaning of left, down ,up, right is the position of separator
                  start_left = "󱞬",
                  end_left = "󱞪",
                  start_down = "󱞾",
                  end_down = "󱟀",
                  start_up = "󱞢",
                  end_up = "󱞤",
                  start_right = "󱞨",
                  end_right = "󱞦",
              },
          },
      })
      
    end,
  },
  {
    "nyngwang/NeoNoName.lua",
    config = function()
      
      function()
        vim.cmd('BufferLineCycleNext')
      end
      
      
      should_skip = function ()
        return vim.bo.buftype == 'terminal'
      end,
      
      
      before_hooks = {
        -- this abort `NeoNoName` when calling on terminal buffer created by ibhagwan/fzf-lua.
        function (u)
          if vim.bo.filetype == 'fzf' then
            vim.api.nvim_input('a<Esc>')
            u.abort()
          end
        end,
      }
      
      
      -- remove `use` if you're using folke/lazy.nvim
      use {
        'nyngwang/NeoNoName.lua',
        config = function ()
          require('neo-no-name').setup {
            before_hooks = {
              function (u)
                if vim.bo.filetype == 'fzf' then
                  vim.api.nvim_input('a<Esc>')
                  u.abort()
                end
              end,
            },
            should_skip = function ()
              -- never go next to a terminal buffer.
              return vim.bo.buftype == 'terminal'
            end,
            go_next_on_delete = false, -- layout-preserving buffer deletion.
          }
          -- replace the current buffer with the `[No Name]`.
          vim.keymap.set('n', '<M-w>', function () vim.cmd('NeoNoName') end)
          -- the plain old buffer delete.
          vim.keymap.set('n', '<Leader>bd', function ()
            vim.cmd('NeoNoName')
            vim.cmd('NeoNoName')
          end)
        end
      }
      
    end,
  },
  {
    "famiu/bufdelete.nvim",
    config = function()
      
      -- Forcibly delete current buffer
      require('bufdelete').bufdelete(0, true)
      
      -- Wipeout buffer number 100 without force
      require('bufdelete').bufwipeout(100)
      
      -- Delete buffer 7 and 30 without force.
      require('bufdelete').bufdelete({7, 30})
      
      -- Delete buffer matching foo.txt with force
      require('bufdelete').bufdelete("foo.txt", true)
      
      -- Delete buffer matching foo.txt, buffer matching bar.txt and buffer 3 with force
      require('bufdelete').bufdelete({"foo.txt", "bar.txt", 3}, true)
      
      -- Delete current buffer and switch to one of buffer 3, 5 or 10
      require('bufdelete').bufdelete(0, false, { 3, 5, 10 })
      
    end,
  },
  {
    "nvim-mini/mini.nvim/blob/main/readmes/mini-bufremove.md",
  },
  {
    "jyscao/ventana.nvim",
    config = function()
      
      { 'jyscao/ventana.nvim' }
      
      
      vim.keymap.set("n", "<C-w><C-t>", "<Cmd>VentanaTranspose<CR>")
      vim.keymap.set("n", "<C-w><C-f>", "<Cmd>VentanaShift<CR>")
      vim.keymap.set("n", "<C-w>f",     "<Cmd>VentanaShiftMaintainLinear<CR>")
      
    end,
  },
  {
    "mrjones2014/smart-splits.nvim",
    config = function()
      
      use('mrjones2014/smart-splits.nvim')
      -- or use a specific version
      use({ 'mrjones2014/smart-splits.nvim', tag = 'v1.0.0' })
      -- to use Kitty multiplexer support, run the post install hook
      use({ 'mrjones2014/smart-splits.nvim', run = './kitty/install-kittens.bash' })
      
      
      { 'mrjones2014/smart-splits.nvim' }
      -- or use a specific version, or a range of versions using lazy.nvim's version API
      { 'mrjones2014/smart-splits.nvim', version = '>=1.0.0' }
      -- to use Kitty multiplexer support, run the post install hook
      { 'mrjones2014/smart-splits.nvim', build = './kitty/install-kittens.bash' }
      
      
      require('smart-splits').setup({
        -- Ignored buffer types (only while resizing)
        ignored_buftypes = {
          'nofile',
          'quickfix',
          'prompt',
        },
        -- Ignored filetypes (only while resizing)
        ignored_filetypes = { 'NvimTree' },
        -- the default number of lines/columns to resize by at a time
        default_amount = 3,
        -- Desired behavior when your cursor is at an edge and you
        -- are moving towards that same edge:
        -- 'wrap' => Wrap to opposite side
        -- 'split' => Create a new split in the desired direction
        -- 'stop' => Do nothing
        -- function => You handle the behavior yourself
        -- NOTE: If using a function, the function will be called with
        -- a context object with the following fields:
        -- {
        --    mux = {
        --      type:'tmux'|'wezterm'|'kitty'|'zellij'
        --      current_pane_id():number,
        --      is_in_session(): boolean
        --      current_pane_is_zoomed():boolean,
        --      -- following methods return a boolean to indicate success or failure
        --      current_pane_at_edge(direction:'left'|'right'|'up'|'down'):boolean
        --      next_pane(direction:'left'|'right'|'up'|'down'):boolean
        --      resize_pane(direction:'left'|'right'|'up'|'down'):boolean
        --      split_pane(direction:'left'|'right'|'up'|'down',size:number|nil):boolean
        --    },
        --    direction = 'left'|'right'|'up'|'down',
        --    split(), -- utility function to split current Neovim pane in the current direction
        --    wrap(), -- utility function to wrap to opposite Neovim pane
        -- }
        -- NOTE: `at_edge = 'wrap'` is not supported on Kitty terminal
        -- multiplexer, as there is no way to determine layout via the CLI
        at_edge = 'wrap',
        -- Desired behavior when the current window is floating:
        -- 'previous' => Focus previous Vim window and perform action
        -- 'mux' => Always forward action to multiplexer
        float_win_behavior = 'previous',
        -- when moving cursor between splits left or right,
        -- place the cursor on the same row of the *screen*
        -- regardless of line numbers. False by default.
        -- Can be overridden via function parameter, see Usage.
        move_cursor_same_row = false,
        -- whether the cursor should follow the buffer when swapping
        -- buffers by default; it can also be controlled by passing
        -- `{ move_cursor = true }` or `{ move_cursor = false }`
        -- when calling the Lua function.
        cursor_follows_swapped_bufs = false,
        -- ignore these autocmd events (via :h eventignore) while processing
        -- smart-splits.nvim computations, which involve visiting different
        -- buffers and windows. These events will be ignored during processing,
        -- and un-ignored on completed. This only applies to resize events,
        -- not cursor movement events.
        ignored_events = {
          'BufEnter',
          'WinEnter',
        },
        -- enable or disable a multiplexer integration;
        -- automatically determined, unless explicitly disabled or set,
        -- by checking the $TERM_PROGRAM environment variable,
        -- and the $KITTY_LISTEN_ON environment variable for Kitty.
        -- You can also set this value by setting `vim.g.smart_splits_multiplexer_integration`
        -- before the plugin is loaded (e.g. for lazy environments).
        multiplexer_integration = nil,
        -- disable multiplexer navigation if current multiplexer pane is zoomed
        -- NOTE: This does not work on Zellij as there is no way to determine the
        -- pane zoom state outside of the Zellij Plugin API, which does not apply here
        disable_multiplexer_nav_when_zoomed = true,
        -- Supply a Kitty remote control password if needed,
        -- or you can also set vim.g.smart_splits_kitty_password
        -- see https://sw.kovidgoyal.net/kitty/conf/#opt-kitty.remote_control_password
        kitty_password = nil,
        -- In Zellij, set this to true if you would like to move to the next *tab*
        -- when the current pane is at the edge of the zellij tab/window
        zellij_move_focus_or_tab = false,
        -- default logging level, one of: 'trace'|'debug'|'info'|'warn'|'error'|'fatal'
        log_level = 'info',
      })
      
      
      -- recommended mappings
      -- resizing splits
      -- these keymaps will also accept a range,
      -- for example `10<A-h>` will `resize_left` by `(10 * config.default_amount)`
      vim.keymap.set('n', '<A-h>', require('smart-splits').resize_left)
      vim.keymap.set('n', '<A-j>', require('smart-splits').resize_down)
      vim.keymap.set('n', '<A-k>', require('smart-splits').resize_up)
      vim.keymap.set('n', '<A-l>', require('smart-splits').resize_right)
      -- moving between splits
      vim.keymap.set('n', '<C-h>', require('smart-splits').move_cursor_left)
      vim.keymap.set('n', '<C-j>', require('smart-splits').move_cursor_down)
      vim.keymap.set('n', '<C-k>', require('smart-splits').move_cursor_up)
      vim.keymap.set('n', '<C-l>', require('smart-splits').move_cursor_right)
      vim.keymap.set('n', '<C-\\>', require('smart-splits').move_cursor_previous)
      -- swapping buffers between windows
      vim.keymap.set('n', '<leader><leader>h', require('smart-splits').swap_buf_left)
      vim.keymap.set('n', '<leader><leader>j', require('smart-splits').swap_buf_down)
      vim.keymap.set('n', '<leader><leader>k', require('smart-splits').swap_buf_up)
      vim.keymap.set('n', '<leader><leader>l', require('smart-splits').swap_buf_right)
      
      
      -- resizing splits
      -- amount defaults to 3 if not specified
      -- use absolute values, no + or -
      -- the functions also check for a range,
      -- so for example if you bind `<A-h>` to `resize_left`,
      -- then `10<A-h>` will `resize_left` by `(10 * config.default_amount)`
      require('smart-splits').resize_up(amount)
      require('smart-splits').resize_down(amount)
      require('smart-splits').resize_left(amount)
      require('smart-splits').resize_right(amount)
      -- moving between splits
      -- You can override config.at_edge and
      -- config.move_cursor_same_row via opts
      -- See Configuration.
      require('smart-splits').move_cursor_up({ same_row = boolean, at_edge = 'wrap' | 'split' | 'stop' })
      require('smart-splits').move_cursor_down()
      require('smart-splits').move_cursor_left()
      require('smart-splits').move_cursor_right()
      require('smart-splits').move_cursor_previous()
      -- Swapping buffers directionally with the window to the specified direction
      require('smart-splits').swap_buf_up()
      require('smart-splits').swap_buf_down()
      require('smart-splits').swap_buf_left()
      require('smart-splits').swap_buf_right()
      -- the buffer swap functions can also take an `opts` table to override the
      -- default behavior of whether or not the cursor follows the buffer
      require('smart-splits').swap_buf_right({ move_cursor = true })
      
      
      local wezterm = require('wezterm')
      local smart_splits = wezterm.plugin.require('https://github.com/mrjones2014/smart-splits.nvim')
      local config = wezterm.config_builder()
      -- you can put the rest of your Wezterm config here
      smart_splits.apply_to_config(config, {
        -- the default config is here, if you'd like to use the default keys,
        -- you can omit this configuration table parameter and just use
        -- smart_splits.apply_to_config(config)
      
        -- directional keys to use in order of: left, down, up, right
        direction_keys = { 'h', 'j', 'k', 'l' },
        -- if you want to use separate direction keys for move vs. resize, you
        -- can also do this:
        direction_keys = {
          move = { 'h', 'j', 'k', 'l' },
          resize = { 'LeftArrow', 'DownArrow', 'UpArrow', 'RightArrow' },
        },
        -- modifier keys to combine with direction_keys
        modifiers = {
          move = 'CTRL', -- modifier to use for pane movement, e.g. CTRL+h to move left
          resize = 'META', -- modifier to use for pane resize, e.g. META+h to resize to the left
        },
        -- log level to use: info, warn, error
        log_level = 'info',
      })
      
      
      local w = require('wezterm')
      
      -- if you are *NOT* lazy-loading smart-splits.nvim (recommended)
      local function is_vim(pane)
        -- this is set by the plugin, and unset on ExitPre in Neovim
        return pane:get_user_vars().IS_NVIM == 'true'
      end
      
      -- if you *ARE* lazy-loading smart-splits.nvim (not recommended)
      -- you have to use this instead, but note that this will not work
      -- in all cases (e.g. over an SSH connection). Also note that
      -- `pane:get_foreground_process_name()` can have high and highly variable
      -- latency, so the other implementation of `is_vim()` will be more
      -- performant as well.
      local function is_vim(pane)
        -- This gsub is equivalent to POSIX basename(3)
        -- Given "/foo/bar" returns "bar"
        -- Given "c:\\foo\\bar" returns "bar"
        local process_name = string.gsub(pane:get_foreground_process_name(), '(.*[/\\])(.*)', '%2')
        return process_name == 'nvim' or process_name == 'vim'
      end
      
      local direction_keys = {
        h = 'Left',
        j = 'Down',
        k = 'Up',
        l = 'Right',
      }
      
      local function split_nav(resize_or_move, key)
        return {
          key = key,
          mods = resize_or_move == 'resize' and 'META' or 'CTRL',
          action = w.action_callback(function(win, pane)
            if is_vim(pane) then
              -- pass the keys through to vim/nvim
              win:perform_action({
                SendKey = { key = key, mods = resize_or_move == 'resize' and 'META' or 'CTRL' },
              }, pane)
            else
              if resize_or_move == 'resize' then
                win:perform_action({ AdjustPaneSize = { direction_keys[key], 3 } }, pane)
              else
                win:perform_action({ ActivatePaneDirection = direction_keys[key] }, pane)
              end
            end
          end),
        }
      end
      
      return {
        keys = {
          -- move between split panes
          split_nav('move', 'h'),
          split_nav('move', 'j'),
          split_nav('move', 'k'),
          split_nav('move', 'l'),
          -- resize panes
          split_nav('resize', 'h'),
          split_nav('resize', 'j'),
          split_nav('resize', 'k'),
          split_nav('resize', 'l'),
        },
      }
      
      
      local mux = require('smart-splits.mux').get()
      
      
      local mux = require('smart-splits.mux').get()
      -- mux matches the following type annotations
      ---@class SmartSplitsMultiplexer
      ---@field current_pane_id fun():number|nil
      ---@field current_pane_at_edge fun(direction:'left'|'right'|'up'|'down'):boolean
      ---@field is_in_session fun():boolean
      ---@field current_pane_is_zoomed fun():boolean
      ---@field next_pane fun(direction:'left'|'right'|'up'|'down'):boolean
      ---@field resize_pane fun(direction:'left'|'right'|'up'|'down', amount:number):boolean
      ---@field split_pane fun(direction:'left'|'right'|'up'|'down',size:number|nil):boolean
      ---@field type 'tmux'|'wezterm'|'kitty'|'zellij'
      
      
      {
        'mrjones2014/smart-splits.nvim',
        event = 'VeryLazy',
        dependencies = {
          'pogyomo/submode.nvim',
        },
        config = function()
          -- Resize
          local submode = require 'submode'
          submode.create('WinResize', {
            mode = 'n',
            enter = '<C-w>r',
            leave = { '<Esc>', 'q', '<C-c>' },
            hook = {
              on_enter = function()
                vim.notify 'Use { h, j, k, l } or { <Left>, <Down>, <Up>, <Right> } to resize the window'
              end,
              on_leave = function()
                vim.notify ''
              end,
            },
            default = function(register)
              register('h', require('smart-splits').resize_left, { desc = 'Resize left' })
              register('j', require('smart-splits').resize_down, { desc = 'Resize down' })
              register('k', require('smart-splits').resize_up, { desc = 'Resize up' })
              register('l', require('smart-splits').resize_right, { desc = 'Resize right' })
              register('<Left>', require('smart-splits').resize_left, { desc = 'Resize left' })
              register('<Down>', require('smart-splits').resize_down, { desc = 'Resize down' })
              register('<Up>', require('smart-splits').resize_up, { desc = 'Resize up' })
              register('<Right>', require('smart-splits').resize_right, { desc = 'Resize right' })
            end,
          })
        end,
      }
      
    end,
  },
  {
    "altermo/nwm",
    config = function()
      
      {'altermo/nwm',branch='x11'},
      
      
      use {'altermo/nwm',branch='x11'},
      
      
      {
          --What happens when a new x-window is created
          on_win_open=function (buf,xwin)
              vim.cmd.vsplit()
              vim.api.nvim_set_current_buf(buf)
          end,
          --Configuration to pass to window
          --`conf` is global config
          on_win_get_conf=function (conf,xwin) return conf end,
          --How to handle when multiple windows in the same tabpage has the x-window-buffer open
          on_multiple_win_open=function (vwins,buf,xwin)
              for k,vwin in ipairs(vwins) do
                  if k~=1 then
                      local scratchbuf=vim.api.nvim_create_buf(false,true)
                      vim.bo[scratchbuf].bufhidden='wipe'
                      vim.api.nvim_win_set_buf(vwin,scratchbuf)
                  end
              end
          end,
          --Whether to be more verbose
          verbal=false,
          --Whether to show float windows above x-windows (depending on z-index)
          floatover=true,
          --Map to unfocus a window (multiple key mappings is not (yet) supported)
          unfocus_map='<A-F4>',
          --Create your own mappings
          --IMPORTANT: the x-window needs to be focused for such mappings to work
          maps={
              --{'<C-A-del>',function () vim.cmd'quitall!' end},
              --Or you could also have lhs as a table
              --{{mods={'control','mod1'},key='Delete'},function () vim.cmd'quitall!' end},
          },
          --Window-opt: auto focus x-window when entering x-window-buffer
          autofocus=false,
          --Window-opt: try-delete x-window if no vim-window shows buffer (similar to `bufhidden=wipe`)
          delhidden=true,
          --Window-opt: when click on x-window, goto that buffer (may not focus x-window)
          clickgoto=true,
          --Window-opt: offset the window this many x pixels (useful if terminal has padding)
          xoffset=0,
          --Window-opt: offset the window this many y pixels (useful if terminal has padding)
          yoffset=0,
      }
      
    end,
  },
  {
    "MisanthropicBit/winmove.nvim",
    config = function()
      
      use 'MisanthropicBit/winmove.nvim'
      
      
      require('winmove').configure({
          keymaps = {
              help = "?", -- Open floating window with help for the current mode
              help_close = "q", -- Close the floating help window
              quit = "q", -- Quit current mode
              toggle_mode = "<tab>", -- Toggle between modes when in a mode
          },
          modes = {
              move = {
                  highlight = "Visual", -- Highlight group for move mode
                  at_edge = {
                      horizontal = at_edge.AtEdge.None, -- Behaviour at horizontal edges
                      vertical = at_edge.AtEdge.None, -- Behaviour at vertical edges
                  },
                  keymaps = {
                      left = "h", -- Move window left
                      down = "j", -- Move window down
                      up = "k", -- Move window up
                      right = "l", -- Move window right
                      far_left = "H", -- Move window far left and maximize it
                      far_down = "J", -- Move window down and maximize it
                      far_up = "K", -- Move window up and maximize it
                      far_right = "L", -- Move window right and maximize it
                      split_left = "sh", -- Create a split with the window on the left
                      split_down = "sj", -- Create a split with the window below
                      split_up = "sk", -- Create a split with the window above
                      split_right = "sl", -- Create a split with the window on the right
                  },
              },
              swap = {
                  highlight = "Substitute", -- Highlight group for swap mode
                  at_edge = {
                      horizontal = at_edge.AtEdge.None, -- Behaviour at horizontal edges
                      vertical = at_edge.AtEdge.None, -- Behaviour at vertical edges
                  },
                  keymaps = {
                      left = "h", -- Swap left
                      down = "j", -- Swap down
                      up = "k", -- Swap up
                      right = "l", -- Swap right
                  },
              },
              resize = {
                  highlight = "Todo", -- Highlight group for resize mode
                  default_resize_count = 3, -- Default amount to resize windows
                  keymaps = {
                      -- When resizing, the anchor is in the top-left corner of the window by default
                      left = "h", -- Resize to the left
                      down = "j", -- Resize down
                      up = "k", -- Resize up
                      right = "l", -- Resize to the right
                      large_left = "H", -- Resize window a large amount left
                      large_down = "J", -- Resize window a large amount down
                      large_up = "K", -- Resize window a large amount up
                      large_right = "L", -- Resize window a large amount right
                      left_botright = "<c-h>", -- Resize left with bottom-right anchor
                      down_botright = "<c-j>", -- Resize down with bottom-right anchor
                      up_botright = "<c-k>", -- Resize up with bottom-right anchor
                      right_botright = "<c-l>", -- Resize right with bottom-right anchor
                      large_left_botright = "<c-s-h>", -- Resize a large amount left with bottom-right anchor
                      large_down_botright = "<c-s-j>", -- Resize a large amount down with bottom-right anchor
                      large_up_botright = "<c-s-k>", -- Resize a large amount up with bottom-right anchor
                      large_right_botright = "<c-s-l>", -- Resize a large amount right with bottom-right anchor
                  },
              },
          },
      })
      
      
      vim.api.nvim_create_autocmd("User", {
          pattern = { "WinmoveModeStart", "WinmoveModeEnd" },
          ---@param event { match: string, data: { mode: winmove.Mode } }
          callback = function(event)
              local event_type = event.match == "WinmoveModeStart" and "started" or "ended"
      
              vim.notify(("Mode %s %s"):format(event.data.mode, event_type), vim.log.levels.INFO)
          end,
      })
      
      
      ---@param mode winmove.Mode
      winmove.start_mode(mode)
      
      -- Example:
      winmove.start_mode(winmove.Mode.Move)
      winmove.start_mode("swap")
      winmove.start_mode("move")
      winmove.start_mode(winmove.Mode.Resize)
      
      
      ---@param win_id integer
      ---@param dir winmove.Direction
      winmove.move_window(win_id, dir)
      
      -- Example:
      winmove.move_window(1000, "k")
      
      
      ---@param win_id integer
      ---@param dir winmove.Direction
      winmove.split_into(win_id, dir)
      
      -- Example:
      winmove.split_into(1000, "l")
      
      
      ---@param win_id integer
      ---@param dir winmove.Direction
      winmove.move_window_far(win_id, dir)
      
      -- Example:
      winmove.move_window_far(1000, "h")
      
      
      ---@param win_id integer
      ---@param dir winmove.Direction
      winmove.swap_window_in_direction(win_id, dir)
      
      -- Example:
      winmove.swap_window_in_direction(1000, "j")
      winmove.swap_window_in_direction(1000, "l")
      
      
      ---@param win_id integer
      ---@param dir winmove.Direction
      winmove.swap_window(win_id, dir)
      
      -- Example:
      winmove.swap_window(1000)
      winmove.swap_window(1000)
      
      
      ---@param win_id integer
      ---@param dir winmove.Direction
      ---@param count integer
      ---@param anchor winmove.ResizeAnchor?
      winmove.resize_window(win_id, dir, count, anchor)
      
      -- Example:
      winmove.resize_window(1000, "j", 3, winmove.ResizeAnchor.TopLeft)
      winmove.resize_window(1000, "l", 1, winmove.ResizeAnchor.BottomRight)
      
      
      local default_options = {
          -- Options for each mode
          modes = {
              move = {
                  icon = "󰆾",
              },
              swap = {
                  icon = "󰓡",
              },
              resize = {
                  icon = "󰩨",
              },
          },
          -- Formatter function given the current context which is the currently
          -- active mode (or nil if no mode) and the settings for that mode
          ---@param context winmove.LuaLineComponentFormatterContext
          formatter = function(context)
              if not context.mode then
                  -- Do not show anything if no mode is currently active
                  return nil
              else
                  return ("%s%s mode"):format(context.icon and context.icon .. " " or "", context.mode)
              end
          end
      }
      
      
      lualine_a = {
          "winmove",
          modes = {
              move = { icon: "✔" },
          },
      },
      
      
    end,
  },
  {
    "ycdzj/win-mover.nvim",
    config = function()
      
      {
        'ycdzj/win-mover.nvim',
        lazy = false,
        opts = {}, -- configuration goes here
      }
      
      
      use {
        'ycdzj/win-mover.nvim',
        config = function()
          local win_mover = require('win-mover')
          win_mover.setup({}) -- configuration goes here
        end,
      }
      
      
      {
        ignore = {
          enable = false,
          filetypes = {},
        },
        highlight = {
          color = '#2e3440',
          transparency = 60,
        },
        move_mode = {
          keymap = {},
        },
      }
      
      
      local win_mover = require('win-mover')
      win_mover.setup({
        ignore = {
          enable = true,
          filetypes = { 'NvimTree', 'neo-tree', 'Outline', 'toggleterm' },
        },
        move_mode = {
          keymap = {
            h = win_mover.ops.move_left,
            j = win_mover.ops.move_down,
            k = win_mover.ops.move_up,
            l = win_mover.ops.move_right,
      
            H = win_mover.ops.move_far_left,
            J = win_mover.ops.move_far_down,
            K = win_mover.ops.move_far_up,
            L = win_mover.ops.move_far_right,
      
            q = win_mover.ops.quit,
            ['<Esc>'] = win_mover.ops.quit,
          },
        },
      })
      vim.keymap.set("n", "<leader>e", win_mover.enter_move_mode, { noremap = true, silent = true })
      
    end,
  },
  {
    "mkajsjo/windowcolumns.nvim",
    config = function()
      
      require('windowcolumns').create_column('right')
      
      
      require('windowcolumns').move_column('right')
      
      
      require('windowcolumns').move_window('right', 'new')
      
      
      {
          'mkajsjo/windowcolumns.nvim',
          version = 'v1.0.0',
          keys = {
              { '<leader>wv', function() require('windowcolumns').create_column() end },
              { '<leader>wh', function() require('windowcolumns').move_column('left') end },
              { '<leader>wl', function() require('windowcolumns').move_column('right') end },
              { '<leader>wj', function() require('windowcolumns').move_window('down') end },
              { '<leader>wk', function() require('windowcolumns').move_window('up') end },
              { '<leader>Wh', function() require('windowcolumns').move_window('left') end },
              { '<leader>Wl', function() require('windowcolumns').move_window('right') end },
          },
      }
      
      
      use {
          'mkajsjo/windowcolumns.nvim',
          tag = 'v1.0.0',
      }
      
      
      vim.keymap.set('n', '<leader>wv', function() require('windowcolumns').create_column() end)
      vim.keymap.set('n', '<leader>wh', function() require('windowcolumns').move_column('left') end)
      vim.keymap.set('n', '<leader>wl', function() require('windowcolumns').move_column('right') end)
      vim.keymap.set('n', '<leader>wj', function() require('windowcolumns').move_window('down') end)
      vim.keymap.set('n', '<leader>wk', function() require('windowcolumns').move_window('up') end)
      vim.keymap.set('n', '<leader>Wh', function() require('windowcolumns').move_window('left') end)
      vim.keymap.set('n', '<leader>Wl', function() require('windowcolumns').move_window('right') end)
      
    end,
  },
  {
    "aserowy/tmux.nvim",
    config = function()
      
      use({
          "aserowy/tmux.nvim",
          config = function() return require("tmux").setup() end
      })
      
      
      {
          copy_sync = {
              -- enables copy sync. by default, all registers are synchronized.
              -- to control which registers are synced, see the `sync_*` options.
              enable = true,
      
              -- ignore specific tmux buffers e.g. buffer0 = true to ignore the
              -- first buffer or named_buffer_name = true to ignore a named tmux
              -- buffer with name named_buffer_name :)
              ignore_buffers = { empty = false },
      
              -- TMUX >= 3.2: all yanks (and deletes) will get redirected to system
              -- clipboard by tmux
              redirect_to_clipboard = false,
      
              -- offset controls where register sync starts
              -- e.g. offset 2 lets registers 0 and 1 untouched
              register_offset = 0,
      
              -- overwrites vim.g.clipboard to redirect * and + to the system
              -- clipboard using tmux. If you sync your system clipboard without tmux,
              -- disable this option!
              sync_clipboard = true,
      
              -- synchronizes registers *, +, unnamed, and 0 till 9 with tmux buffers.
              sync_registers = true,
      
              -- synchronizes registers when pressing p and P.
              sync_registers_keymap_put = true,
      
              -- synchronizes registers when pressing (C-r) and ".
              sync_registers_keymap_reg = true,
      
              -- syncs deletes with tmux clipboard as well, it is adviced to
              -- do so. Nvim does not allow syncing registers 0 and 1 without
              -- overwriting the unnamed register. Thus, ddp would not be possible.
              sync_deletes = true,
      
              -- syncs the unnamed register with the first buffer entry from tmux.
              sync_unnamed = true,
          },
          navigation = {
              -- cycles to opposite pane while navigating into the border
              cycle_navigation = true,
      
              -- enables default keybindings (C-hjkl) for normal mode
              enable_default_keybindings = true,
      
              -- prevents unzoom tmux when navigating beyond vim border
              persist_zoom = false,
          },
          resize = {
              -- enables default keybindings (A-hjkl) for normal mode
              enable_default_keybindings = true,
      
              -- sets resize steps for x axis
              resize_step_x = 1,
      
              -- sets resize steps for y axis
              resize_step_y = 1,
          },
          swap = {
              -- cycles to opposite pane while navigating into the border
              cycle_navigation = false,
      
              -- enables default keybindings (C-A-hjkl) for normal mode
              enable_default_keybindings = true,
          }
      }
      
      
      {
          [[<cmd>lua require("tmux").move_left()<cr>]],
          [[<cmd>lua require("tmux").move_bottom()<cr>]],
          [[<cmd>lua require("tmux").move_top()<cr>]],
          [[<cmd>lua require("tmux").move_right()<cr>]],
          [[<cmd>lua require("tmux").next_window()<cr>]],
          [[<cmd>lua require("tmux").previous_window()<cr>]],
      }
      
      
      {
          [[<cmd>lua require("tmux").resize_left()<cr>]],
          [[<cmd>lua require("tmux").resize_bottom()<cr>]],
          [[<cmd>lua require("tmux").resize_top()<cr>]],
          [[<cmd>lua require("tmux").resize_right()<cr>]],
      }
      
      
      {
          [[<cmd>lua require("tmux").swap_left()<cr>]],
          [[<cmd>lua require("tmux").swap_bottom()<cr>]],
          [[<cmd>lua require("tmux").swap_top()<cr>]],
          [[<cmd>lua require("tmux").swap_right()<cr>]],
      }
      
    end,
  },
  {
    "danielpieper/telescope-tmuxinator.nvim",
    config = function()
      
      require('telescope').load_extension('tmuxinator')
      
      
      require('telescope').extensions.tmuxinator.projects{}
      
      
      require('telescope').extensions.tmuxinator.projects(require('telescope.themes').get_dropdown({}))
      
      
      telescope.setup {
        extensions = {
          tmuxinator = {
            select_action = 'switch', -- | 'stop' | 'kill'
            stop_action = 'stop', -- | 'kill'
            disable_icons = false,
          },
        },
      }
      
    end,
  },
  {
    "hkupty/nvimux",
    config = function()
      
      lua << EOF
      -- Nvimux configuration
      local nvimux = require('nvimux')
      nvimux.setup{
        config = {
          prefix = '<C-a>',
        },
        bindings = {
          {{'n', 'v', 'i', 't'}, 's', nvimux.commands.horizontal_split},
          {{'n', 'v', 'i', 't'}, 'v', nvimux.commands.vertical_split},
        }
      }
      EOF
      
      
      lua require('nvimux').setup{}
      
    end,
  },
  {
    "numToStr/Navigator.nvim",
    config = function()
      
      use {
          'numToStr/Navigator.nvim',
          config = function()
              require('Navigator').setup()
          end
      }
      
      
      require('Navigator').setup()
      
      
      vim.keymap.set({'n', 't'}, '<A-h>', '<CMD>NavigatorLeft<CR>')
      vim.keymap.set({'n', 't'}, '<A-l>', '<CMD>NavigatorRight<CR>')
      vim.keymap.set({'n', 't'}, '<A-k>', '<CMD>NavigatorUp<CR>')
      vim.keymap.set({'n', 't'}, '<A-j>', '<CMD>NavigatorDown<CR>')
      vim.keymap.set({'n', 't'}, '<A-p>', '<CMD>NavigatorPrevious<CR>')
      
      
      {
          -- Save modified buffer(s) when moving to mux
          -- nil - Don't save (default)
          -- 'current' - Only save the current modified buffer
          -- 'all' - Save all the buffers
          auto_save = nil,
      
          -- Disable navigation when the current mux pane is zoomed in
          disable_on_zoom = false,
      
          -- Multiplexer to use
          -- 'auto' - Chooses mux based on priority (default)
          -- table - Custom mux to use
          mux = 'auto'
      }
      
      
      require('Navigator').left()
      require('Navigator').right()
      require('Navigator').up()
      require('Navigator').down()
      require('Navigator').previous()
      
    end,
  },
  {
    "declancm/windex.nvim",
    config = function()
      
      use {
        'declancm/windex.nvim',
        config = function() require('windex').setup() end
      }
      
      
      -- KEYMAPS:
      default_keymaps = true, -- Enable default keymaps.
      extra_keymaps = false,  -- Enable extra keymaps.
      arrow_keys = false,     -- Default window movement keymaps use arrow keys instead of 'h,j,k,l'.
      
      -- OPTIONS:
      numbered_term = false,  -- Enable line numbers in the terminal.
      save_buffers = false,   -- Save all buffers before switching tmux panes.
      warnings = true,        -- Enable warnings before some actions such as closing tmux panes.
      
      
      require('windex').setup {
        extra_keymaps = true,
        save_buffers = true,
      }
      
      
      -- MAXIMIZE:
      
      -- Toggle maximizing the current window:
      vim.keymap.set('n', '<Leader>z', "<Cmd>lua require('windex').toggle_maximize()<CR>")
      
      -- TERMINAL:
      
      -- Toggle the terminal:
      vim.keymap.set({ 'n', 't' }, '<C-Bslash>', "<Cmd>lua require('windex').toggle_terminal()<CR>")
      
      -- Enter normal mode within terminal:
      vim.keymap.set('t', '<C-n>', '<C-Bslash><C-n>')
      
      -- MOVEMENT:
      
      -- Move between nvim windows and tmux panes:
      vim.keymap.set('n', '<Leader>k', "<Cmd>lua require('windex').switch_window('up')<CR>")
      vim.keymap.set('n', '<Leader>j', "<Cmd>lua require('windex').switch_window('down')<CR>")
      vim.keymap.set('n', '<Leader>h', "<Cmd>lua require('windex').switch_window('left')<CR>")
      vim.keymap.set('n', '<Leader>l', "<Cmd>lua require('windex').switch_window('right')<CR>")
      
      -- Save and close the nvim window or kill the tmux pane in the direction selected:
      vim.keymap.set('n', '<Leader>xk', "<Cmd>lua require('windex').close_window('up')<CR>")
      vim.keymap.set('n', '<Leader>xj', "<Cmd>lua require('windex').close_window('down')<CR>")
      vim.keymap.set('n', '<Leader>xh', "<Cmd>lua require('windex').close_window('left')<CR>")
      vim.keymap.set('n', '<Leader>xl', "<Cmd>lua require('windex').close_window('right')<CR>")
      
      -- Switch to previous nvim window or tmux pane:
      vim.keymap.set('n', '<Leader>;', "<Cmd>lua require('windex').previous_window()<CR>")
      
      
      -- MOVEMENT:
      
      -- Create nvim panes:
      vim.keymap.set('n', '<Leader>v', '<Cmd>wincmd v<CR>')
      vim.keymap.set('n', '<Leader>s', '<Cmd>wincmd s<CR>')
      
      -- Create tmux panes:
      vim.keymap.set('n', '<Leader>tv', "<Cmd>lua require('windex').create_pane('vertical')<CR>")
      vim.keymap.set('n', '<Leader>ts', "<Cmd>lua require('windex').create_pane('horizontal')<CR>")
      
      
      local function maximize_status()
        return vim.t.maximized and ' ' or ''
      end
      
      require('lualine').setup {
        sections = {
          lualine_c = { maximize_status }
        }
      }
      
      
      -- ~/.config/nvim/lua/winbar.lua
      local M = {}
      
      M.maximize_status = function()
        return vim.t.maximized and ' ' or ''
      end
      
      return M
      
      -- ~/.config/nvim/init.lua
      vim.o.winbar = "%{%v:lua.require('winbar').maximize_status()%}"
      
      
        require('windex').toggle_nvim_maximize()
        
      
        require('windex').toggle_maximize()
        
      
        require('windex').toggle_terminal([{maximize} [, {command}]])
        
      
          vim.api.nvim_set_keymap(
            'n',
            '<C-g>',
            "<Cmd>lua require('windex').toggle_terminal('all','lazygit')<CR>",
            { noremap = true, silent = true }
          )
          
      
        require('windex').switch_window({direction})
        
      
        require('windex').close_window({direction})
        
      
        require('windex').previous_window()
        
      
        require('windex').create_pane({split})
        
    end,
  },
  {
    "otavioschwanck/tmux-awesome-manager.nvim",
    config = function()
      
      {
        "otavioschwanck/tmux-awesome-manager.nvim",
        dependencies = {
          "nvim-telescope/telescope.nvim", -- Optional: for telescope picker
          -- OR
          -- "ibhagwan/fzf-lua", -- Optional: for fzf-lua picker
        },
        config = function()
          require('tmux-awesome-manager').setup({
            per_project_commands = { -- Configure your per project servers with
            -- project name = { { cmd, name } }
              api = { { cmd = 'rails server', name = 'Rails Server' } },
              front = { { cmd = 'yarn dev', name = 'react server' } },
            },
            session_name = 'Neovim Terminals',
            use_icon = false, -- use prefix icon
            picker = 'telescope', -- 🔍 Choose picker: 'telescope' or 'fzf-lua' (default: 'telescope')
            icon = ' ', -- Prefix icon to use
            -- project_open_as = 'window', -- Open per_project_commands as.  Default: separated_session
            -- default_size = '30%', -- on panes, the default size
            -- open_new_as = 'window', -- open new command as.  options: pane, window, separated_session.
            -- default_orientation = 'vertical' -- Can also be horizontal
          })
        end
      }
      
      
      use {
        'otavioschwanck/tmux-awesome-manager.nvim',
        requires = {
          'nvim-telescope/telescope.nvim', -- Optional: for telescope picker
          -- OR
          -- 'ibhagwan/fzf-lua', -- Optional: for fzf-lua picker
        },
        config = function()
          require('tmux-awesome-manager').setup({
            per_project_commands = { -- Configure your per project servers with
            -- project name = { { cmd, name } }
              api = { { cmd = 'rails server', name = 'Rails Server' } },
              front = { { cmd = 'yarn dev', name = 'react server' } },
            },
            session_name = 'Neovim Terminals',
            use_icon = false, -- use prefix icon
            picker = 'telescope', -- 🔍 Choose picker: 'telescope' or 'fzf-lua' (default: 'telescope')
            icon = ' ', -- Prefix icon to use
            -- project_open_as = 'window', -- Open per_project_commands as.  Default: separated_session
            -- default_size = '30%', -- on panes, the default size
            -- open_new_as = 'window', -- open new command as.  options: pane, window, separated_session.
            -- default_orientation = 'vertical' -- Can also be horizontal
          })
        end
      }
      
      
      Plug 'otavioschwanck/tmux-awesome-manager.nvim'
      Plug 'nvim-telescope/telescope.nvim' " Optional: for telescope picker
      " OR
      " Plug 'ibhagwan/fzf-lua' " Optional: for fzf-lua picker
      
      " Add to your init.lua or in a lua heredoc:
      lua << EOF
      require('tmux-awesome-manager').setup({
        picker = 'telescope', -- or 'fzf-lua'
        -- ... other options
      })
      EOF
      
      
      :Rocks install tmux-awesome-manager.nvim
      
      
      require('tmux-awesome-manager').setup({
        picker = 'telescope', -- or 'fzf-lua'
        -- ... other options
      })
      
      
      -- Lazy.nvim
      {
        "otavioschwanck/tmux-awesome-manager.nvim",
        config = true -- Uses default configuration
      }
      
      -- Or manual setup with defaults
      require('tmux-awesome-manager').setup({})
      
      
      require('tmux-awesome-manager').setup({
        per_project_commands = { -- Configure your per project servers with
        -- project name = { { cmd, name } }
          api = { { cmd = 'rails server', name = 'Rails Server' } },
          front = { { cmd = 'yarn dev', name = 'react server' } },
        },
        session_name = 'Neovim Terminals',
        use_icon = false, -- use prefix icon
        picker = 'telescope', -- 🔍 Choose picker: 'telescope' or 'fzf-lua' (default: 'telescope')
        icon = ' ', -- Prefix icon to use
        -- project_open_as = 'window', -- Open per_project_commands as.  Default: separated_session
        -- default_size = '30%', -- on panes, the default size
        -- open_new_as = 'window', -- open new command as.  options: pane, window, separated_session.
        -- default_orientation = 'vertical' -- Can also be horizontal
      })
      
      
      -- Use telescope (default)
      require('tmux-awesome-manager').setup({
        picker = 'telescope'
      })
      
      -- Use fzf-lua for faster performance
      require('tmux-awesome-manager').setup({
        picker = 'fzf-lua'
      })
      
      
      local tmux = require("tmux-awesome-manager")
      
      -- List all saved commands
      tmux.list_terms()
      
      -- List currently open terminals
      tmux.list_open_terms()
      
      
      -- List all saved commands
      vim.cmd(":Telescope tmux-awesome-manager list_terms")
      
      -- List currently open terminals
      vim.cmd(":Telescope tmux-awesome-manager list_open_terms")
      
      
      -- With options
      require("tmux-awesome-manager").list_terms({ layout_config = { width = 0.9 } })
      
      -- Simple call
      require("tmux-awesome-manager").list_open_terms()
      
      
      local tmux = require("tmux-awesome-manager")
      
      vim.keymap.set('v', 'l', tmux.send_text_to, {}) -- Send text to a open terminal?
      vim.keymap.set('n', 'lo', tmux.switch_orientation, {}) -- Open new panes as vertical / horizontal?
      vim.keymap.set('n', 'lp', tmux.switch_open_as, {}) -- Open new terminals as panes or windows?
      vim.keymap.set('n', 'lk', tmux.kill_all_terms, {}) -- Kill all open terms.
      vim.keymap.set('n', 'l!', tmux.run_project_terms, {}) -- Run the per project commands
      
      -- 🔍 List terminals - works with both telescope and fzf-lua
      vim.keymap.set('n', 'lf', tmux.list_terms, {}) -- List all terminals
      vim.keymap.set('n', 'll', tmux.list_open_terms, {}) -- List open terminals
      
      
      tmux.run_wk({ cmd = 'yarn add %1', name = 'Yarn Add', questions = { { question = 'package name: ', required = true } } })
      
      
      local tmux_term = require('tmux-awesome-manager.src.term')
      
      vim.keymap.set('n', 'rr', tmux_term.run({ name = 'Rails Console', name = 'console', open_as = 'pane' }), {}) -- Send text to a open terminal?
      
      
      local tmux_term = require('tmux-awesome-manager.src.term')
      local wk = require("which-key")
      
      wk.register({
        r = {
          name = "+rails",
          R = tmux_term.run_wk({ cmd = 'rails s', name = 'Rails Server', visit_first_call = false, open_as = 'separated_session', session_name = 'My Terms' }),
          r = tmux_term.run_wk({ cmd = 'rails s', name = 'Rails Console', open_as = 'window' }),
          b = tmux_term.run_wk({ cmd = 'bundle install', name = 'Bundle Install', open_as = 'pane', close_on_timer = 2, visit_first_call = false, focus_when_call = false }),
          g = tmux_term.run_wk({ cmd = 'rails generate %1', name = 'Rails Generate',
            questions = { { question = "Rails generate: ", required = true, open_as = 'pane', close_on_timer = 4,
              visit_first_call = false, focus_when_call = false } } }),
          d = tmux_term.run_wk({ cmd = 'rails destroy %1', name = 'Rails Destroy',
            questions = { { question = "Rails destroy: ", required = true, open_as = 'pane', close_on_timer = 4,
              visit_first_call = false, focus_when_call = false } } }),
        },
      }, { prefix = "<leader>", silent = true })
      
      
      local tmux_term = require('tmux-awesome-manager.src.term')
      
      tmux_term.run({ cmd = 'yarn add %1', name = 'Yarn Add', questions = { { question = 'package name: ', required = true } } })
      
      
      -- Status with icons:
      require('tmux-awesome-manager.src.integrations.status').status_with_icons()
      
      -- Status without icons:
      require('tmux-awesome-manager.src.integrations.status').status_no_icons()
      
      -- List of open terms
      require('tmux-awesome-manager.src.integrations.status').open_terms()
      
      -- Example for lualine:
      ins_right {
        function()
          return require('tmux-awesome-manager.src.integrations.status').open_terms()
        end,
        color = { fg = colors.green },
      }
      
    end,
  },
  {
    "karshPrime/only-tmux.nvim",
    config = function()
      
      {  'karshPrime/only-tmux.nvim',
          event = 'VeryLazy',
          config = { new_window_name = "session" } -- optional
      },
      
      
      -- move nvim panes to buffer and close unfocused tmux panes
      vim.keymap.set('n', '<leader>o', ':TMUXonly close<CR>', { silent = true })
      
      -- move nvim panes to buffer and move unfocused tmux panes to new window
      vim.keymap.set('n', '<leader>O', ':TMUXonly move<CR>', { silent = true })
      
    end,
  },
  {
    "karshPrime/tmux-compile.nvim",
    config = function()
      
      { 'karshPrime/tmux-compile.nvim', event = 'VeryLazy' },
      
      
      require('tmux-compile').setup({
          -- Overriding Default Configurations. [OPTIONAL]
          save_session = false,             -- Save file before action (:wall)
          build_run_window_title = "build", -- Tmux window name for Build/Run
          local_config = "tmux-compile.lua",-- Set local commands file name
          ---- same window pane
          new_pane_everytime = false,       -- Use existing side panes for action, when false
          side_width_percent = 50,          -- Side pane width percentage
          bottom_height_percent = 30,       -- Bottom pane height percentage
          ---- overlay window
          overlay_width_percent = 80,       -- Overlay width percentage
          overlay_height_percent = 80,      -- Overlay height percentage
          overlay_sleep = 1,                -- Pause before overlay autoclose; seconds
                                            -- By default it sets value to -1,
                                            -- indicating not to autoclose overlay
      
          -- Languages' Run and Build actions.  [REQUIRED]
          build_run_config = {
              {
                  extension = {'c', 'cpp', 'h'},
                  build = 'make',
                  run   = 'make run',
                  debug = 'lldb',
              },
              {
                  extension = {'rs'},
                  build = 'cargo build',
                  run   = 'cargo run',
                  -- not all properties are required for all extensions
              },
              {
                  extension = {'go'},
                  run = 'go run .',
                  -- Run would work for golang
                  -- but Build and Debug will return errors informing configs are
                  -- missing
              }
          },
      
          -- Directory override config. [OPTIONAL] -- Set actions for a specific directory (per project basis)
          project_override_config = {
              {
                  project_base_dir = '/absolute/path/to/project',
                  build = 'make',
                  run   = 'make run',
                  debug = 'lldb',
              },
              {
                  project_base_dir = '~/Projects/ESP32/',
                  build = 'idf.py build',
                  run   = 'idf.py flash /dev/cu.usbmodem1101'
                  -- Only build will work for this path
              }
          }
      })
      
      
      return {
          build = "make",
          run = "make run"
      }
      
      
      vim.keymap.set('n', 'KEYBIND', 'COMMAND<CR>', {silent=true})
      
      
      vim.keymap.set('n','<F5>', ':TMUXcompile Run<CR>', {silent=true})
      
    end,
  },
  {
    "EvWilson/slimux.nvim",
    config = function()
      
      require("lazy").setup({
        {
          'EvWilson/slimux.nvim',
          config = function()
            local slimux = require('slimux')
            slimux.setup({
              target_socket = slimux.get_tmux_socket(),
              target_pane = string.format('%s.2', slimux.get_tmux_window()),
            })
            vim.keymap.set('v', '<leader>r', slimux.send_highlighted_text,
              { desc = 'Send currently highlighted text to configured tmux pane' })
            vim.keymap.set('n', '<leader>r', slimux.send_paragraph_text,
              { desc = 'Send paragraph under cursor to configured tmux pane' })
          end
        }
      })
      
    end,
  },
  {
    "juselara1/tmutils.nvim",
    config = function()
      
          {
              "juselara1/tmutils.nvim",
              dependencies = {
                  --NOTE: you can optionally add one of these dependencies if you
                  --want to use a custom selector different from the default vim.ui
                  --selector.
      
                  --"MunifTanjim/nui.nvim",
                  --"nvim-telescope/telescope.nvim"
                  --"vijaymarupudi/nvim-fzf"
              },
              config = function()
                  require("tmutils").setup({})
              end,
          }
          
      
              {
                  "echasnovski/mini.nvim",
                  config = function()
                      require("mini.ai").setup({
                          custom_textobjects = {
                              ---Code cell
                              x = { "
      
              local selectors = require("tmutils.selectors")
              require("tmutils").setup({
                  window = {
                      repls = {
                          --We configure here an IPython repl
                          ipython = {
                              syntax = "python",
                              commands = function()
                                  return {
                                      ("cd %s"):format(vim.fn.getcwd()),
                                      "ipython",
                                      "clear",
                                  }
                              end,
                          },
                      },
                  },
              })
              
      
              --<leader>r creates a repl
              vim.keymap.set("n", "<leader>r", ":TmutilsWindow repl<CR>", {
                  noremap = true,
                  silent = true,
                  desc = "Shows a menu to select and launch a repl",
              })
              --<leader>x sends a code cell to the repl
              vim.keymap.set("n", "<leader>x", function()
                  vim.cmd("norm vix")
                  local pos_l = vim.fn.getpos(".")
                  local pos_r = vim.fn.getpos("v")
                  vim.cmd(("%d,%dTmutilsSend"):format(pos_l[2], pos_r[2]))
                  vim.api.nvim_input("<Esc>")
              end, {
                  noremap = true,
                  silent = false,
                  desc = "Sends a code cell to a tmux pane",
              })
              
      
      {
          --Configuration for UI-based selection.
          selector = {
              --The backend used to select options.
              selector = [[
              fun(
                  opts: string[],
                  message: string,
                  callback: fun(selected_opt: string): nil
                  ): nil
              ]],
          },
          --Configuration for the scratch window.
          scratch = {
              --Scratch window width.
              width = "integer",
              --Scratch window height.
              height = "integer",
              --Scratch window center col.
              col = "integer",
              --Scratch window center row.
              row = "integer",
              --Scratch window border.
              border = "none" | "single" | "double" | "rounded" | "solid" | "shadow",
              --Scratch window title position.
              title_pos = "center" | "left" | "right",
          },
          --Configuration for window management commands.
          window = {
              --Configuration for the terminal pane.
              terminal = {
                  --Direction in which to split the terminal pane.
                  direction = '"vertical" | "horizontal"',
                  --Relative size (in percentage) for the terminal pane.
                  size = "number",
                  --Function that returns a list of commands to be executed
                  --when launching a new terminal pane.
                  commands = "fun(): string[]",
              },
              repls = {
                  --Assign a key to the repl
                  ["string"] = {
                      --Direction in which to split the repl pane.
                      direction = '"vertical" | "horizontal"',
                      --Syntax for this REPL.
                      syntax = "string",
                      --Relative size (in percentage) for the repl pane.
                      size = "number",
                      --Function that returns a list of commands to be executed
                      --when launching a new repl pane.
                      commands = "fun(): string[]",
                  },
              },
          },
      }
      
      
      {
          "juselara1/tmutils.nvim",
          dependencies = {
              "nvim-telescope/telescope.nvim",
          },
          config = function()
              local selectors = require("tmutils.selectors")
              require("tmutils").setup({
                  selector = {
                      selector = selectors.telescope_selector,
                  },
                  window = {
                      repls = {
                          python = {
                              syntax = "python",
                              commands = function()
                                  return {
                                      ("cd %s"):format(vim.fn.getcwd()),
                                      "clear",
                                      "python",
                                  }
                              end,
                          },
                          ipython = {
                              syntax = "python",
                              commands = function()
                                  return {
                                      ("cd %s"):format(vim.fn.getcwd()),
                                      "ipython",
                                      "clear",
                                  }
                              end,
                          },
                          compose = {
                              syntax = "sh",
                              commands = function()
                                  return {
                                      ("cd %s"):format(vim.fn.getcwd()),
                                      "docker compose up -d",
                                      "docker exec -it `docker compose config --services` bash",
                                      "clear",
                                  }
                              end,
                          },
                      },
                  },
              })
      
              vim.keymap.set("n", "<leader>tc", ":TmutilsConfig<CR>", {
                  noremap = true,
                  silent = true,
                  desc = "Setups the Tmutils pane.",
              })
              vim.keymap.set("n", "<leader>ta", ":TmutilsCapture newbuffer<CR>", {
                  noremap = true,
                  silent = true,
                  desc = "Captures the content of a Tmutils pane.",
              })
              vim.keymap.set("n", "<leader>tt", ":TmutilsWindow terminal<CR>", {
                  noremap = true,
                  silent = true,
                  desc = "Launches a Tmutils terminal.",
              })
              vim.keymap.set("n", "<leader>tr", ":TmutilsWindow repl<CR>", {
                  noremap = true,
                  silent = true,
                  desc = "Shows a menu to select and launch a Tmutils repl.",
              })
              vim.keymap.set("n", "<leader>td", ":TmutilsWindow delete<CR>", {
                  noremap = true,
                  silent = true,
                  desc = "Deletes the configured Tmutils pane.",
              })
              vim.keymap.set("n", "<leader>ts", ":TmutilsScratchToggle<CR>", {
                  noremap = true,
                  silent = true,
                  desc = "Opens Tmutils Scratch",
              })
              vim.keymap.set("n", "<leader>tx", function()
                  vim.cmd("norm vix")
                  local pos_l = vim.fn.getpos(".")
                  local pos_r = vim.fn.getpos("v")
                  vim.cmd(("%d,%dTmutilsSend"):format(pos_l[2], pos_r[2]))
                  vim.api.nvim_input("<Esc>")
              end, {
                  noremap = true,
                  silent = true,
                  desc = "Sends a code cell to a Tmutils pane.",
              })
              vim.keymap.set("n", "<leader>tl", ":.TmutilsSend<CR>", {
                  noremap = true,
                  silent = true,
                  desc = "Sends a visual selection to a Tmutils pane.",
              })
              vim.keymap.set("v", "<leader>tv", ":TmutilsSend<CR>", {
                  noremap = true,
                  silent = true,
                  desc = "Sends a visual selection to a Tmutils pane.",
              })
          end,
      }
      
    end,
  },
  {
    "kiyoon/tmux-send.nvim",
    config = function()
      
        {
          "kiyoon/tmux-send.nvim",
          keys = {
            {
              "-",
              function()
                require("tmux_send").send_to_pane()
                -- (Optional) exit visual mode after sending
                vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<esc>", true, false, true), "x", true)
              end,
              mode = { "n", "x" },
              desc = "Send to tmux pane",
            },
            {
              "_",
              function()
                require("tmux_send").send_to_pane({ add_newline = false })
                vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<esc>", true, false, true), "x", true)
              end,
              mode = { "n", "x" },
              desc = "Send to tmux pane (plain)",
            },
            {
              "<space>-",
              function()
                require("tmux_send").send_to_pane({ count_is_uid = true })
                vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<esc>", true, false, true), "x", true)
              end,
              mode = { "n", "x" },
              desc = "Send to tmux pane w/ pane uid",
            },
            {
              "<space>_",
              function()
                require("tmux_send").send_to_pane({ count_is_uid = true, add_newline = false })
                vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<esc>", true, false, true), "x", true)
              end,
              mode = { "n", "x" },
              desc = "Send to tmux pane w/ pane uid (plain)",
            },
            {
              "<C-_>",
              function()
                require("tmux_send").save_to_tmux_buffer()
                vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes("<esc>", true, false, true), "x", true)
              end,
              mode = { "n", "x" },
              desc = "Save to tmux buffer",
            },
          },
        },
      
      
      local function nvim_tree_on_attach(bufnr)
        local api = require "nvim-tree.api"
        api.config.mappings.default_on_attach(bufnr)
      
        local function opts(desc)
          return { desc = "nvim-tree: " .. desc, buffer = bufnr, noremap = true, silent = true, nowait = true }
        end
      
        vim.keymap.set("n", "u", api.tree.change_root_to_parent, opts "Up")
        vim.keymap.set("n", "-", "", { buffer = bufnr })
        vim.keymap.del("n", "-", { buffer = bufnr })
      end
      
      require("nvim-tree").setup({
        on_attach = nvim_tree_on_attach,
        -- ...
      })
      
      
      require("oil").setup({
        keymaps = {
          -- ["-"] = "actions.parent",
          ["U"] = "actions.parent",
        },
      })
      
    end,
  },
  {
    "jkeresman01/tmux-switch.nvim",
    config = function()
      
      Plug 'nvim-lua/plenary.nvim'
      Plug 'nvim-telescope/telescope.nvim'
      Plug 'MunifTanjim/nui.nvim'
      
      Plug 'jkeresman01/tmux-switch.nvim'
      
      
      
      use {
        'nvim-telescope/telescope.nvim', tag = '0.1.8',
      -- or                            , branch = '0.1.x',
        requires = { {'nvim-lua/plenary.nvim'} }
      }
      
      use 'MunifTanjim/nui.nvim'
      
      use 'jkeresman01/tmux-switch.nvim'
      
      
      
      :TmuxSwitch             -- Lunch picker (select tmux session to switch to)
      :TmuxCreateSession      -- Create new session and give it a name
      :TmuxRenameSession      -- Rename current tmux session
      
      
      
      require('tmux-switch').setup({})
      
      vim.keymap.set("n", "<C-f>", "<CMD>TmuxSwitch<CR>")
      vim.keymap.set("n", "<leader>cs", "<CMD>TmuxCreateSession<CR>"
      vim.keymap.set("n", "<leader>rs", "<CMD>TmuxRenameSession<CR>"
      
      
    end,
  },
  {
    "ThePrimeagen/vim-be-good",
  },
  {
    "alec-gibson/nvim-tetris",
  },
  {
    "seandewar/nvimesweeper",
  },
  {
    "seandewar/killersheep.nvim",
    config = function()
      
      require("killersheep").setup {
        gore = true,           -- Enables/disables blood and gore.
        keymaps = {
          move_left = "h",     -- Keymap to move cannon to the left.
          move_right = "l",    -- Keymap to move cannon to the right.
          shoot = "<Space>",   -- Keymap to shoot the cannon.
        },
      }
      
    end,
  },
  {
    "rktjmp/playtime.nvim",
    config = function()
      
      PlaytimeNormal     -- NormalFloat.fg, "general" elements
      PlaytimeMuted      -- Comment.fg, disabled or "dim" elements
      PlaytimeBackground -- NormalFloat, window background
      PlaytimeMenu       -- PmenuSBar, "top menu" bar color
      PlaytimeWhite      -- NormalFloat.fg
      PlaytimeBlack      -- Comment.fg
      PlaytimeRed        -- DiagnosticError.fg
      PlaytimeGreen      -- DiagnosticOk.fg
      PlaytimeYellow     -- Defined manually
      PlaytimeOrange     -- DiagnosticWarn.fg
      PlaytimeBlue       -- DiagnosticInfo.fg
      PlaytimeMagenta    -- Defined manually
      PlaytimeCyan       -- Defined manually
      
    end,
  },
  {
    "Eandrju/cellular-automaton.nvim",
    config = function()
      
      vim.keymap.set("n", "<leader>fml", "<cmd>CellularAutomaton make_it_rain<CR>")
      
      
      local config = {
          fps = 50,
          name = 'slide',
      }
      
      -- init function is invoked only once at the start
      -- config.init = function (grid)
      --
      -- end
      
      -- update function
      config.update = function (grid)
          for i = 1, #grid do
              local prev = grid[i][#(grid[i])]
              for j = 1, #(grid[i]) do
                  grid[i][j], prev = prev, grid[i][j]
              end
          end
          return true
      end
      
      require("cellular-automaton").register_animation(config)
      
    end,
  },
  {
    "alanfortlink/blackjack.nvim",
    config = function()
      
      use {
        'alanfortlink/blackjack.nvim',
        requires = {'nvim-lua/plenary.nvim'},
      }
      
      
      Plug 'nvim-lua/plenary.nvim'
      Plug 'alanfortlink/blackjack.nvim'
      
      
      require("blackjack").setup({
        card_style = "mini", -- Can be "mini" or "large".
        suit_style = "black", -- Can be "black" or "white".
        scores_path = "/home/foo/blackjack_scores.json", -- Default location to store the scores.json file.
        keybindings = {
          ["next"] = "j",
          ["finish"] = "k",
          ["quit"] = "q",
        },
      })
      
    end,
  },
  {
    "jim-fx/sudoku.nvim",
    config = function()
      
      use {
        'jim-fx/sudoku.nvim',
        cmd = "Sudoku",
        config = function()
          require("sudoku").setup({
            -- configuration ...
          })
        end
      }
      
      
      {
        'jim-fx/sudoku.nvim',
        cmd = "Sudoku",
        config = function()
          require("sudoku").setup({
            -- configuration ...
          })
        end
      }
      
      
      -- These are the defaults for the settings
      require("sudoku").setup({
        persist_settings = true, -- safe the settings under vim.fn.stdpath("data"), usually ~/.local/share/nvim,
        persist_games = true, -- persist a history of all played games
        default_mappings = true, -- if set to false you need to set your own, like the following:
        mappings = {
            { key = "x",     action = "clear_cell" },
            { key = "r1",    action = "insert=1" },
            { key = "r2",    action = "insert=2" },
            { key = "r3",    action = "insert=3" },
            -- ...
            { key = "r9",    action = "insert=9" },
            { key = "gn",    action = "new_game" },
            { key = "gr",    action = "reset_game" },
            { key = "gs",    action = "view=settings" },
            { key = "gt",    action = "view=tip" },
            { key = "gz",    action = "view=zen" },
            { key = "gh",    action = "view=help" },
            { key = "u",     action = "undo" },
            { key = "<C-r>", action = "redo" },
            { key = "+",     action = "increment" },
            { key = "-",     action = "decrement" },
        },
        custom_highlights = {
            board = { fg = "#7d7d7d" },
            number = { fg = "white", bg = "black" },
            active_menu = { fg = "white", bg = "black", gui = "bold" },
            hint_cell = { fg = "white", bg = "yellow" },
            square = { bg = "#292b35", fg = "white" },
            column = { bg = "#14151a", fg = "#d5d5d5" },
            row = { bg = "#14151a", fg = "#d5d5d5" },
            settings_disabled = { fg = "#8e8e8e", gui = "italic" },
            same_number = { fg = "white", gui = "bold" },
            set_number = { fg = "white", gui = "italic" },
            error = { fg = "white", bg = "#843434" },
        }
      })
      
      
      require("sudoku").setup({
          mappings = {
              { key = "c", action = "clear_cell" }
          }
      })
      
      
      vim.keymap.set("n", "c", ":Sudoku clear_cell")
      -- or
      vim.keymap.set("n", "c", function() require("sudoku").setCell(0) end)
      
      
      > -- ftplugin/sudoku.lua
      > vim.keymap.set("n", "<C-l>", "8l")
      > vim.keymap.set("n", "<C-h>", "8h")
      > vim.keymap.set("n", "<C-k>", "4k")
      > vim.keymap.set("n", "<C-j>", "4j")
      > 
    end,
  },
  {
    "csessh/aoc.nvim",
  },
  {
    "seandewar/actually-doom.nvim",
  },
  {
    "p00f/cphelper.nvim",
  },
  {
    "xeluxee/competitest.nvim",
  },
  {
    "kawre/leetcode.nvim",
    config = function()
      
      {
          "kawre/leetcode.nvim",
          build = ":TSUpdate html", -- if you have `nvim-treesitter` installed
          dependencies = {
              -- include a picker of your choice, see picker section for more details
              "nvim-lua/plenary.nvim",
              "MunifTanjim/nui.nvim",
          },
          opts = {
              -- configuration goes here
          },
      }
      
      
      {
          ---@type string
          arg = "leetcode.nvim",
      
          ---@type lc.lang
          lang = "cpp",
      
          cn = { -- leetcode.cn
              enabled = false, ---@type boolean
              translator = true, ---@type boolean
              translate_problems = true, ---@type boolean
          },
      
          ---@type lc.storage
          storage = {
              home = vim.fn.stdpath("data") .. "/leetcode",
              cache = vim.fn.stdpath("cache") .. "/leetcode",
          },
      
          ---@type table<string, boolean>
          plugins = {
              non_standalone = false,
          },
      
          ---@type boolean
          logging = true,
      
          injector = {}, ---@type table<lc.lang, lc.inject>
      
          cache = {
              update_interval = 60 * 60 * 24 * 7, ---@type integer 7 days
          },
      
          editor = {
              reset_previous_code = true, ---@type boolean
              fold_imports = true, ---@type boolean
          },
      
          console = {
              open_on_runcode = true, ---@type boolean
      
              dir = "row", ---@type lc.direction
      
              size = { ---@type lc.size
                  width = "90%",
                  height = "75%",
              },
      
              result = {
                  size = "60%", ---@type lc.size
              },
      
              testcase = {
                  virt_text = true, ---@type boolean
      
                  size = "40%", ---@type lc.size
              },
          },
      
          description = {
              position = "left", ---@type lc.position
      
              width = "40%", ---@type lc.size
      
              show_stats = true, ---@type boolean
          },
      
          ---@type lc.picker
          picker = { provider = nil },
      
          hooks = {
              ---@type fun()[]
              ["enter"] = {},
      
              ---@type fun(question: lc.ui.Question)[]
              ["question_enter"] = {},
      
              ---@type fun()[]
              ["leave"] = {},
          },
      
          keys = {
              toggle = { "q" }, ---@type string|string[]
              confirm = { "<CR>" }, ---@type string|string[]
      
              reset_testcases = "r", ---@type string
              use_testcase = "U", ---@type string
              focus_testcases = "H", ---@type string
              focus_result = "L", ---@type string
          },
      
          ---@type lc.highlights
          theme = {},
      
          ---@type boolean
          image_support = false,
      }
      
      
      ---@type string
      arg = "leetcode.nvim"
      
      
      ---@type lc.lang
      lang = "cpp"
      
      
      cn = { -- leetcode.cn
          enabled = false, ---@type boolean
          translator = true, ---@type boolean
          translate_problems = true, ---@type boolean
      },
      
      
      ---@type lc.storage
      storage = {
          home = vim.fn.stdpath("data") .. "/leetcode",
          cache = vim.fn.stdpath("cache") .. "/leetcode",
      },
      
      
      ---@type table<string, boolean>
      plugins = {
          non_standalone = false,
      },
      
      
      ---@type boolean
      logging = true
      
      
      injector = { ---@type table<lc.lang, lc.inject>
          ["python3"] = {
              imports = function(default_imports)
                  vim.list_extend(default_imports, { "from .leetcode import *" })
                  return default_imports
              end,
              after = { "def test():", "    print('test')" },
          },
          ["cpp"] = {
              imports = function()
                  -- return a different list to omit default imports
                  return { "#include <bits/stdc++.h>", "using namespace std;" }
              end,
              after = "int main() {}",
          },
      },
      
      
      ---@type lc.picker
      picker = { provider = nil },
      
      
      hooks = {
          ---@type fun()[]
          ["enter"] = {},
      
          ---@type fun(question: lc.ui.Question)[]
          ["question_enter"] = {},
      
          ---@type fun()[]
          ["leave"] = {},
      },
      
      
      ---@type lc.highlights
      theme = {
          ["alt"] = {
              bg = "#FFFFFF",
          },
          ["normal"] = {
              fg = "#EA4AAA",
          },
      },
      
      
      ---@type boolean
      image_support = false,
      
      
        local leet_arg = "leetcode.nvim"
        
      
        {
            "kawre/leetcode.nvim",
            lazy = leet_arg ~= vim.fn.argv(0, -1),
            opts = { arg = leet_arg },
        }
        
      
        {
            "kawre/leetcode.nvim",
            cmd = "Leet",
        }
        
      
      plugins = {
          non_standalone = true,
      }
      
    end,
  },
  {
    "2KAbhishek/exercism.nvim",
    config = function()
      
      -- Lazy
      {
          '2kabhishek/exercism.nvim',
          cmd = { 'Exercism' },
          keys = { '<leader>exa', '<leader>exl', '<leader>exr' }, -- add your preferred keybindings
          dependencies = {
              '2kabhishek/utils.nvim', -- required, for utility functions
              '2kabhishek/termim.nvim', -- optional, better UX for running tests
          },
          -- Add your custom configs here, keep it blank for default configs (required)
          opts = {},
      },
      
      
      exercism.setup({
          exercism_workspace = '~/exercism', -- Default workspace for exercism exercises
          default_language = 'ruby', -- Default language for exercise list
          add_default_keybindings = true, -- Whether to add default keybindings
          max_recents = 30, -- Maximum number of recent exercises to keep
          icons = {
              concept = '', -- Icon for concept exercises
              practice = '', -- Icon for practice exercises
          },
      })
      
    end,
  },
  {
    "m4xshen/hardtime.nvim",
    config = function()
      
      {
         "m4xshen/hardtime.nvim",
         lazy = false,
         dependencies = { "MunifTanjim/nui.nvim" },
         opts = {},
      },
      
      
      require("hardtime").setup()
      
      
      disabled_keys = {
         ["<Up>"] = false, -- Allow <Up> key
         ["<Space>"] = { "n", "x" }, -- Disable <Space> key in normal and visual mode
      },
      
      
      disabled_filetypes = { 
         lazy = false, -- Enable Hardtime in lazy filetype
         ["dapui*"] = false, -- Enable Hardtime in filetype starting with dapui
      },
      
      
      hints = {
         ["k%^"] = {
            message = function()
               return "Use - instead of k^" -- return the hint message you want to display
            end,
            length = 2, -- the length of actual key strokes that matches this pattern
         },
         ["d[tTfF].i"] = { -- this matches d + {t/T/f/F} + {any character} + i
            message = function(keys) -- keys is a string of key strokes that matches the pattern
               return "Use " .. "c" .. keys:sub(2, 3) .. " instead of " .. keys
               -- example: Use ct( instead of dt(i
            end,
            length = 4,
         },
      }
      
    end,
  },
  {
    "antonk52/bad-practices.nvim",
  },
  {
    "saxon1964/neovim-tips",
    config = function()
      
      {
        "saxon1964/neovim-tips",
        version = "*", -- Only update on tagged releases
        dependencies = {
          "MunifTanjim/nui.nvim",
          "MeanderingProgrammer/render-markdown.nvim"
        },
        opts = {
          -- OPTIONAL: Location of user defined tips (default value shown below)
          user_file = vim.fn.stdpath("config") .. "/neovim_tips/user_tips.md",
          -- OPTIONAL: Prefix for user tips to avoid conflicts (default: "[User] ")
          user_tip_prefix = "[User] ",
          -- OPTIONAL: Show warnings when user tips conflict with builtin (default: true)
          warn_on_conflicts = true,
          -- OPTIONAL: Daily tip mode (default: 1)
          -- 0 = off, 1 = once per day, 2 = every startup
          daily_tip = 1,
        },
        init = function()
          -- OPTIONAL: Change to your liking or drop completely
          -- The plugin does not provide default key mappings, only commands
          local map = vim.keymap.set
          map("n", "<leader>nto", ":NeovimTips<CR>", { desc = "Neovim tips", noremap = true, silent = true })
          map("n", "<leader>nte", ":NeovimTipsEdit<CR>", { desc = "Edit your Neovim tips", noremap = true, silent = true })
          map("n", "<leader>nta", ":NeovimTipsAdd<CR>", { desc = "Add your Neovim tip", noremap = true, silent = true })
          map("n", "<leader>ntr", ":NeovimTipsRandom<CR>", { desc = "Show random tip", noremap = true, silent = true })
        end
      }
      
      
      use {
        "saxon1964/neovim-tips",
        tag = "*", -- Only update on tagged releases
        requires = {
          "MunifTanjim/nui.nvim",
          "MeanderingProgrammer/render-markdown.nvim"
        },
        config = function()
          require("neovim_tips").setup {
            user_file = vim.fn.stdpath("config") .. "/neovim_tips/user_tips.md",
            user_tip_prefix = "[User] ",  -- Prefix for user tips
            warn_on_conflicts = true,     -- Warn about title conflicts
            daily_tip = 1,                -- Daily tip: 0=off, 1=once per day, 2=every startup
          }
      
          local map = vim.keymap.set
          map("n", "<leader>nto", ":NeovimTips<CR>", { desc = "Neovim tips", noremap = true, silent = true })
          map("n", "<leader>nte", ":NeovimTipsEdit<CR>", { desc = "Edit your Neovim tips", noremap = true, silent = true })
          map("n", "<leader>nta", ":NeovimTipsAdd<CR>", { desc = "Add your Neovim tip", noremap = true, silent = true })
          map("n", "<leader>ntr", ":NeovimTipsRandom<CR>", { desc = "Show random tip", noremap = true, silent = true })
        end
      }
      
      
      require "paq" {
        "MunifTanjim/nui.nvim";
        "MeanderingProgrammer/render-markdown.nvim";
        { "saxon1964/neovim-tips", tag = "*" }; -- Only update on tagged releases
      }
      
      require("neovim_tips").setup {
        user_file = vim.fn.stdpath("config") .. "/neovim_tips/user_tips.md",
        daily_tip = 1,  -- Daily tip: 0=off, 1=once per day, 2=every startup
      }
      
      local map = vim.keymap.set
      map("n", "<leader>nto", ":NeovimTips<CR>", { desc = "Neovim tips", noremap = true, silent = true })
      map("n", "<leader>nte", ":NeovimTipsEdit<CR>", { desc = "Edit your Neovim tips", noremap = true, silent = true })
      map("n", "<leader>nta", ":NeovimTipsAdd<CR>", { desc = "Add your Neovim tip", noremap = true, silent = true })
      map("n", "<leader>ntr", ":NeovimTipsRandom<CR>", { desc = "Show random tip", noremap = true, silent = true })
      
      
      require("lazy").setup({
        {
          "saxon1964/neovim-tips",
          dependencies = {
          "MunifTanjim/nui.nvim",
          "MeanderingProgrammer/render-markdown.nvim"
        },
          opts = {
            user_file = vim.fn.stdpath("config") .. "/neovim_tips/user_tips.md",
          },
          init = function()
            local map = vim.keymap.set
            map("n", "<leader>nto", ":NeovimTips<CR>", { desc = "Neovim tips", noremap = true, silent = true })
            map("n", "<leader>nte", ":NeovimTipsEdit<CR>", { desc = "Edit your Neovim tips", noremap = true, silent = true })
            map("n", "<leader>nta", ":NeovimTipsAdd<CR>", { desc = "Add your Neovim tip", noremap = true, silent = true })
            map("n", "<leader>ntr", ":NeovimTipsRandom<CR>", { desc = "Show random tip", noremap = true, silent = true })
          end,
        },
      })
      
      
      return {
        {
          "saxon1964/neovim-tips",
          dependencies = {
          "MunifTanjim/nui.nvim",
          "MeanderingProgrammer/render-markdown.nvim"
        },
          opts = {
            user_file = vim.fn.stdpath("config") .. "/neovim_tips/user_tips.md",
          },
        },
      }
      
      
      return {
        n = {
          ["<leader>nto"] = { "<cmd>NeovimTips<cr>", desc = "Neovim tips" },
          ["<leader>nte"] = { "<cmd>NeovimTipsEdit<cr>", desc = "Edit your Neovim tips" },
          ["<leader>nta"] = { "<cmd>NeovimTipsAdd<cr>", desc = "Add your Neovim tip" },
          ["<leader>nth"] = { "<cmd>NeovimTipsHelp<cr>", desc = "Neovim tips user guide" },
          ["<leader>ntr"] = { "<cmd>NeovimTipsRandom<cr>", desc = "Random Neovim tip" },
        },
      }
      
      
      require("neovim_tips").setup({
        -- Path to user tips file
        user_file = vim.fn.stdpath("config") .. "/neovim_tips/user_tips.md",
      
        -- Prefix added to user tip titles to prevent conflicts
        user_tip_prefix = "[User] ",
      
        -- Show warnings when user tips have conflicting titles with builtin tips
        warn_on_conflicts = true,
      
        -- Daily tip mode: 0=off, 1=once per day, 2=every startup
        daily_tip = 1,
      })
      
      
      -- Default: [User] prefix
      user_tip_prefix = "[User] "     -- "Join lines" becomes "[User] Join lines"
      
      -- Custom emoji prefix
      user_tip_prefix = "🔧 "         -- "Join lines" becomes "🔧 Join lines"
      
      -- No prefix (not recommended, may cause conflicts)
      user_tip_prefix = ""            -- "Join lines" stays "Join lines"
      
      
      require('blink.cmp').setup({
        enabled = function()
          return vim.bo.filetype ~= "neovim-tips-search"
        end,
        -- ... rest of your config
      })
      
      
      require('cmp').setup({
        enabled = function()
          return vim.bo.filetype ~= "neovim-tips-search"
        end,
        -- ... rest of your config
      })
      
    end,
  },
  {
    "Cris-lml007/NeoPlus",
  },
  {
    "pgosar/CyberNvim",
  },
  {
    "sontungexpt/stinvim",
    config = function()
      
          ---@tparam table|string mode : Table mode used for applying the key map if only one mode you can use string
          ---@tparam string key : The key you wish to map.
          ---@tparam function|string map_to : The key or function to be executed by the keymap.
          ---@tparam table|number opts : Options to be applied in vim.keymap.set.
          --- - Default opts = 1.
          --- - opts = 1 for noremap and silent and nowait.
          --- - opts = 2 for not noremap and silent.
          --- - opts = 3 for noremap and not silent.
          --- - opts = 4 for not noremap and not silent.
          --- - opts = 5 for expr and noremap and silent.
          --- - opts = 6 for noremap and silent and wait.
          --- - opts = 7 for noremap and silent and nowait and expr.
          ---@tparam table extend_opts: Extension or overriding of opts if opts is a number.
          require("utils.mapper").map(mode, key, map_to, opts, extend_opts)
      
          --- Examples:
      	require("utils.mapper").map({ "n", "v" }, "gx", "<esc>:URLOpenUnderCursor<cr>", { desc = "Open URL under cursor" })
      	require("utils.mapper").map("n" }, "gx", "<esc>:URLOpenUnderCursor<cr>", 2, { desc = "Open URL under cursor" })
      
    end,
  },
  {
    "Abstract-IDE/Abstract",
  },
  {
    "CosmicNvim/CosmicNvim",
  },
  {
    "artart222/CodeArt",
  },
  {
    "LazyVim/LazyVim",
  },
  {
    "legobeat/l7-devenv",
  },
  {
    "crispybaccoon/chaivim",
    config = function()
      
      -- init.lua
      local rootpath = vim.fn.stdpath("data") .. "/ch"
      local chaipath = rootpath .. "/chai"
      
      if not vim.uv.fs_stat(chaipath) then
        vim.system({
          "git",
          "clone",
          "--filter=blob:none",
          "https://github.com/comfysage/chaivim.git",
          chaipath,
        }):wait()
      end
      
      vim.opt.rtp:prepend(chaipath)
      
      
      -- init.lua
      require 'ch'.setup('custom.config', 'custom.modules')
      
      -- lua/custom/config.lua
      return {
          ui = {
              colorscheme = 'evergarden',
              transparent_background = false,
          },
      }
      
      -- lua/custom/modules.lua
      return {
          ch = {
              {
                  'options',
                  opts = {
                      cursorline = false,
                      tab_width = 2,
                      scrolloff = 5,
                  },
              },
              {
                  'dash',
                  opts = {
                      open_on_startup = true,
                  },
              },
          },
          custom = {
              -- your custom modules (in `lua/custom/`)
          },
      }
      
      
      -- init.lua
      require 'ch'.setup 'custom'
      
      -- lua/custom/init.lua
      return {
          ui = {
              colorscheme = 'evergarden',
          },
          modules = {
              ch = {
                  { 'options' },
                  { 'base' },
              },
          },
      }
      
      
      ch.config.ui.colorscheme = 'tokyonight'
      
    end,
  },
  {
    "crivotz/nv-ide",
  },
  {
    "LunarVim/LunarVim",
  },
  {
    "hackorum/VapourNvim",
  },
  {
    "siduck76/NvChad",
  },
  {
    "nvoid-lua/nvoid",
  },
  {
    "cstsunfu/.sea.nvim",
  },
  {
    "shaeinst/roshnivim",
  },
  {
    "AstroNvim/AstroNvim",
    config = function()
      
      local lazypath = vim.fn.stdpath "data" .. "/lazy/lazy.nvim"
      if not vim.uv.fs_stat(lazypath) then
        -- stylua: ignore
        vim.fn.system({ "git", "clone", "--filter=blob:none", "https://github.com/folke/lazy.nvim.git", "--branch=stable", lazypath })
      end
      vim.opt.rtp:prepend(lazypath)
      
      require("lazy").setup { "AstroNvim/AstroNvim", version = "^5", import = "astronvim.plugins" }
      
    end,
  },
  {
    "shaunsingh/nyoom.nvim",
  },
  {
    "jrychn/ModuleVim",
  },
  {
    "imbacraft/dusk.nvim",
    config = function()
      
                  settings = {
                    java = {
                      configuration = {
                        runtimes = {
                           {
                            name = "JavaSE-1.8",
                            path = "/Library/Java/JavaVirtualMachines/jdk1.8.0_291.jdk/Contents/Home",
                           },
                           {
                            name = "JavaSE-11",
                            path = "/opt/homebrew/Cellar/openjdk@11/11.0.18/libexec/openjdk.jdk/Contents/Home",
                            default = true
                           },
                           {
                            name = "JavaSE-19",
                            path = "/opt/homebrew/Cellar/openjdk/19.0.2/libexec/openjdk.jdk/Contents/Home",
                           },
                        }
                      }
                    }
                  }
      
      
    end,
  },
  {
    "nvim-lua/kickstart.nvim",
    config = function()
      
      {'nvim-telescope/telescope-fzf-native.nvim', build = 'cmake -S. -Bbuild -DCMAKE_BUILD_TYPE=Release && cmake --build build --config Release && cmake --install build --prefix build' }
      
    end,
  },
  {
    "dam9000/kickstart-modular.nvim",
    config = function()
      
      {'nvim-telescope/telescope-fzf-native.nvim', build = 'cmake -S. -Bbuild -DCMAKE_BUILD_TYPE=Release && cmake --build build --config Release && cmake --install build --prefix build' }
      
    end,
  },
  {
    "cunderw/nvim",
  },
  {
    "otavioschwanck/mood-nvim",
  },
  {
    "ldelossa/nvim-ide",
    config = function()
      
      -- default components
      local bufferlist      = require('ide.components.bufferlist')
      local explorer        = require('ide.components.explorer')
      local outline         = require('ide.components.outline')
      local callhierarchy   = require('ide.components.callhierarchy')
      local timeline        = require('ide.components.timeline')
      local terminal        = require('ide.components.terminal')
      local terminalbrowser = require('ide.components.terminal.terminalbrowser')
      local changes         = require('ide.components.changes')
      local commits         = require('ide.components.commits')
      local branches        = require('ide.components.branches')
      local bookmarks       = require('ide.components.bookmarks')
      
      require('ide').setup({
          -- The global icon set to use.
          -- values: "nerd", "codicon", "default"
          icon_set = "default",
          -- Set the log level for nvim-ide's log. Log can be accessed with 
          -- 'Workspace OpenLog'. Values are 'debug', 'warn', 'info', 'error'
          log_level = "info",
          -- Component specific configurations and default config overrides.
          components = {
              -- The global keymap is applied to all Components before construction.
              -- It allows common keymaps such as "hide" to be overridden, without having
              -- to make an override entry for all Components.
              --
              -- If a more specific keymap override is defined for a specific Component
              -- this takes precedence.
              global_keymaps = {
                  -- example, change all Component's hide keymap to "h"
                  -- hide = h
              },
              -- example, prefer "x" for hide only for Explorer component.
              -- Explorer = {
              --     keymaps = {
              --         hide = "x",
              --     }
              -- }
          },
          -- default panel groups to display on left and right.
          panels = {
              left = "explorer",
              right = "git"
          },
          -- panels defined by groups of components, user is free to redefine the defaults
          -- and/or add additional.
          panel_groups = {
              explorer = { outline.Name, bufferlist.Name, explorer.Name, bookmarks.Name, callhierarchy.Name, terminalbrowser.Name },
              terminal = { terminal.Name },
              git = { changes.Name, commits.Name, timeline.Name, branches.Name }
          },
          -- workspaces config
          workspaces = {
              -- which panels to open by default, one of: 'left', 'right', 'both', 'none'
              auto_open = 'left',
          },
          -- default panel sizes for the different positions
          panel_sizes = {
              left = 30,
              right = 30,
              bottom = 15
          }
      })
      
    end,
  },
  {
    "jonathandion/web-dev.nvim",
  },
  {
    "linrongbin16/lin.nvim",
  },
  {
    "doctorfree/nvim-lazyman",
    config = function()
      
      local conf = {}
      
      -- Namespace to use, available namespaces are "ecovim", free", and "onno"
      -- Switching namespace changes to a completely different configuration
      -- This is an example of how to incorporate multiple Neovim configurations
      -- into a single configuration.
      conf.namespace = "ecovim"
      --
      -- THEME CONFIGURATION
      -- Available themes:
      --   nightfox, tokyonight, dracula, kanagawa, catppuccin,
      --   tundra, onedarkpro, everforest, monokai-pro
      -- A configuration file for each theme is in lua/themes/
      -- Use <F8> to step through themes
      conf.theme = "tokyonight"
      -- Available styles are:
      --   kanagawa:    wave, dragon, lotus
      --   tokyonight:  night, storm, day, moon
      --   onedarkpro:  onedark, onelight, onedark_vivid, onedark_dark
      --   catppuccin:  latte, frappe, macchiato, mocha, custom
      --   dracula:     blood, magic, soft, default
      --   nightfox:    carbonfox, dawnfox, dayfox, duskfox, nightfox, nordfox, terafox
      --   monokai-pro: classic, octagon, pro, machine, ristretto, spectrum
      conf.theme_style = "moon"
      -- enable transparency if the theme supports it
      conf.enable_transparent = true
      
      -- GLOBAL OPTIONS CONFIGURATION
      -- Some prefer space as the map leader, but why
      conf.mapleader = ","
      conf.maplocalleader = ","
      -- Toggle global status line
      conf.global_statusline = true
      -- set numbered lines
      conf.number = true
      -- enable mouse see :h mouse
      conf.mouse = "nv"
      -- set relative numbered lines
      conf.relative_number = true
      -- always show tabs; 0 never, 1 only if at least two tab pages, 2 always
      conf.showtabline = 2
      -- enable or disable listchars
      conf.list = true
      -- which list chars to show
      conf.listchars = {
        eol = "⤶",
        tab = ">.",
        trail = "~",
        extends = "◀",
        precedes = "▶",
      }
      -- use rg instead of grep
      conf.grepprg = "rg --hidden --vimgrep --smart-case --"
      
      -- ENABLE/DISABLE/SELECT PLUGINS
      --
      -- AI coding assistants - ChatGPT, Code Explain, Codeium, Copilot, NeoAI
      -- Enable Github Copilot if you have an account, it is superior
      --
      -- Enable ChatGPT (set OPENAI_API_KEY environment variable)
      conf.enable_chatgpt = false
      -- Enable Code Explain (requires 3.5GB model, uses GPT4ALL)
      conf.enable_codeexplain = false
      -- Enable Codeium
      conf.enable_codeium = false
      -- Enable Github Copilot
      conf.enable_copilot = false
      -- Enable Neoai, https://github.com/Bryley/neoai.nvim
      conf.enable_neoai = false
      -- Enable tabnine, https://github.com/Bryley/neoai.nvim
      conf.enable_tabnine = false
      --
      -- Enable display of ascii art
      conf.enable_asciiart = false
      -- Delete buffers and close files without closing your windows
      conf.enable_bbye = true
      -- Enable display of custom cheatsheets
      conf.enable_cheatsheet = true
      -- Enable coding plugins for diagnostics, debugging, and language servers
      conf.enable_coding = true
      -- Enable compile plugin to compile and run current file
      conf.enable_compile = false
      -- Enable dressing plugin for improved default vim.ui interfaces
      conf.enable_dressing = true
      -- Enable easy motions, can be one of "hop", "flash", "leap", or "none"
      conf.enable_motion = "leap"
      -- Enable note making using Markdown preview and Obsidian plugins
      conf.enable_notes = false
      -- If notes enabled, markdown preview to use (preview, peek, none)
      conf.markdown_preview = "peek"
      -- If notes enabled, Neorg notes folders, multiple folders supported
      conf.neorg_notes = {
        "~/Documents/Notes/Neorg", -- NEORG_NOTES
        -- "XXXXX", -- NEORG_NOTES
        -- "YYYYY", -- NEORG_NOTES
        -- "ZZZZZ", -- NEORG_NOTES
      }
      -- Enable note making using Obsidian
      conf.enable_obsidian = false
      -- If Obsidian enabled, Obsidian vault folder (relative to HOME)
      conf.obsidian_vault = "Documents/Notes/Obsidian"
      -- Enable renamer plugin for VS Code-like renaming UI
      conf.enable_renamer = true
      -- Enable ranger in a floating window
      conf.enable_ranger_float = true
      -- Highlight sections of code which might have security or quality issues
      conf.enable_securitree = false
      -- neovim session manager to use: persistence, possession, or none
      conf.session_manager = "persistence"
      -- File explorer tree plugin: neo-tree, nvim-tree, or none
      conf.file_tree = "neo-tree"
      -- Replace the UI for messages, cmdline and the popupmenu
      conf.enable_noice = true
      -- Enable smart column display
      conf.enable_smartcolumn = true
      -- Enable 'StartupTime' command
      conf.enable_startuptime = true
      -- Add/change/delete surrounding delimiter pairs with ease
      conf.enable_surround = true
      -- Enable the wilder plugin
      conf.enable_wilder = false
      --
      -- Lualine, Tabline, and Winbar configuration
      --
      -- The Lualine style can be "free" or "onno"
      conf.lualine_style = "free"
      -- Separator for 'onno' style lualine components, can be "bubble" or "arrow"
      conf.lualine_separator = "bubble"
      -- Enable fancy lualine components
      conf.enable_fancy = false
      -- The statusline (lualine), tabline, and winbar can each be enabled or disabled
      -- Enable statusline (lualine)
      conf.enable_statusline = true
      -- Enable status in tabline
      conf.enable_status_in_tab = false
      -- Enable winbar with navic location
      -- Can be one of "barbecue", "standard", or "none"
      -- Barbecue provides a clickable navic location, standard has more info
      conf.enable_winbar = "barbecue"
      -- Enable LSP progress in winbar
      conf.enable_lualine_lsp_progress = true
      -- Enable rebelot/terminal.nvim
      --
      conf.enable_terminal = true
      -- Enable toggleterm plugin
      conf.enable_toggleterm = true
      -- Enable window animations (mini.animate)
      conf.enable_animate = true
      -- Enable ducks, cats, dinosaurs, and other animals wandering around
      conf.enable_duck = true
      -- Enable window animations (flirt)
      conf.enable_flirt = false
      -- Enable playing games inside Neovim!
      conf.enable_games = true
      -- Enable the WakaTime metrics dashboard (requires API key)
      conf.enable_wakatime = false
      -- Enable zen mode distraction-free coding
      conf.enable_zenmode = true
      -- if zenmode enabled then enable terminal support as well
      conf.enable_kitty = false
      conf.enable_alacritty = false
      conf.enable_wezterm = false
      -- Enable a dashboard, can be one of "alpha", "dash", "mini", or "none"
      conf.dashboard = "alpha"
      -- Number of recent files, dashboard header and quick links settings
      -- only apply to the Alpha dashboard
      -- Number of recent files shown in dashboard
      -- 0 disables showing recent files
      conf.dashboard_recent_files = 3
      -- Enable the header of the dashboard
      conf.enable_dashboard_header = true
      -- Enable quick links of the dashboard
      conf.enable_dashboard_quick_links = true
      -- Enable either the Drop screensaver or the Zone screensaver
      -- Drop can be one of xmas, stars, leaves, snow, spring, summer, or drop
      -- Zone can be one of treadmill, matrix, epilepsy, vanish, or zone
      -- 'drop' indicates a random drop, 'zone' a random zone
      -- 'random' to randomly select between the two, 'none' to disable
      conf.enable_screensaver = "none"
      -- Screensaver timeout in minutes
      conf.screensaver_timeout = 15
      -- Enable the Neovim bookmarks plugin (https://github.com/ldelossa/nvim-ide)
      conf.enable_bookmarks = false
      -- Enable the Neovim IDE plugin (https://github.com/ldelossa/nvim-ide)
      conf.enable_ide = false
      -- Enable Navigator
      conf.enable_navigator = true
      -- Enable Project manager
      conf.enable_project = true
      -- Enable window picker
      conf.enable_picker = true
      -- Enable smooth scrolling with neoscroll plugin
      conf.enable_smooth_scrolling = true
      -- Enable the Neotest plugin
      conf.enable_neotest = false
      
      -- PLUGINS CONFIGURATION
      -- media backend, one of "ueberzug"|"viu"|"chafa"|"jp2a"|"catimg"|"none"
      conf.media_backend = "jp2a"
      -- Style of indentation, can be one of:
      -- 'background' colored' 'context' 'listchars' 'mini' 'simple' 'none'
      conf.indentline_style = "mini"
      -- treesitter parsers to be installed
      conf.treesitter_ensure_installed = {
        "bash",
        "c",
        "lua",
        "markdown",
        "markdown_inline",
        "query",
        "regex",
        "vim",
        "vimdoc",
      }
      -- Enable clangd or ccls for C/C++ diagnostics
      -- Note: if enabled then the tool must be installed and in the execution path
      conf.enable_ccls = true
      conf.enable_clangd = false
      -- Typescript language server. Can be "tsserver" "tools" or "none"
      conf.typescript_server = "tools"
      -- LSPs that should be installed by Mason-lspconfig
      -- Leave the 'LSP_SERVERS' trailing comment, it is used by lazyman
      conf.lsp_servers = {
        "bashls",        -- LSP_SERVERS
        "cssls",         -- LSP_SERVERS
        "cssmodules_ls", -- LSP_SERVERS
        "denols",        -- LSP_SERVERS
        "dockerls",      -- LSP_SERVERS
        "emmet_ls",      -- LSP_SERVERS
        -- "eslint",     -- LSP_SERVERS
        -- "gopls",      -- LSP_SERVERS
        "graphql",       -- LSP_SERVERS
        "html",          -- LSP_SERVERS
        "jdtls",         -- LSP_SERVERS
        "jsonls",        -- LSP_SERVERS
        "julials",       -- LSP_SERVERS
        "ltex",          -- LSP_SERVERS
        "lua_ls",        -- LSP_SERVERS
        "marksman",      -- LSP_SERVERS
        "prismals",      -- LSP_SERVERS
        "pylsp",         -- LSP_SERVERS
        "pyright",       -- LSP_SERVERS
        "sqlls",         -- LSP_SERVERS
        "tailwindcss",   -- LSP_SERVERS
        "texlab",        -- LSP_SERVERS
        "tsserver",      -- LSP_SERVERS
        "vimls",         -- LSP_SERVERS
        "vuels",         -- LSP_SERVERS
        "yamlls",        -- LSP_SERVERS
      }
      -- Formatters and linters installed by Mason
      conf.formatters_linters = {
        "actionlint",      -- FORMATTERS_LINTERS
        "gofumpt",         -- FORMATTERS_LINTERS
        "goimports",       -- FORMATTERS_LINTERS
        "golines",         -- FORMATTERS_LINTERS
        "golangci-lint",   -- FORMATTERS_LINTERS
        "google-java-format", -- FORMATTERS_LINTERS
        "latexindent",     -- FORMATTERS_LINTERS
        "markdownlint",    -- FORMATTERS_LINTERS
        "prettier",        -- FORMATTERS_LINTERS
        "sql-formatter",   -- FORMATTERS_LINTERS
        -- "shellcheck",   -- FORMATTERS_LINTERS
        "shfmt",           -- FORMATTERS_LINTERS
        "stylua",          -- FORMATTERS_LINTERS
        "tflint",          -- FORMATTERS_LINTERS
        "yamllint",        -- FORMATTERS_LINTERS
      }
      -- Formatters and linters installed externally
      conf.external_formatters = {
        "beautysh",        -- FORMATTERS_LINTERS
        "black",           -- FORMATTERS_LINTERS
        "flake8",          -- FORMATTERS_LINTERS
        "ruff",            -- FORMATTERS_LINTERS
      }
      -- enable greping in hidden files
      conf.telescope_grep_hidden = true
      -- Show diagnostics, can be one of "none", "icons", "popup". Default is "popup"
      --   "none":  diagnostics are disabled but still underlined
      --   "icons": only an icon will show, use ',de' to see the diagnostic
      --   "popup": an icon will show and a popup with the diagnostic will appear
      conf.show_diagnostics = "popup"
      -- Enable semantic highlighting
      conf.enable_semantic_highlighting = true
      -- Convert semantic highlights to treesitter highlights
      conf.convert_semantic_highlighting = true
      
      return conf
      
      
      -- Invoke with 'nvim -l get_conf.lua conf_name'
      -- Where 'conf_name' is:
      --   - one of the entries in lua/configuration.lua
      --   - the keyword 'config_home' to get configuration location info
      --   - an option/variable name to retrieve its value
      --
      -- For example, to retrieve the Lazyman configuration 'namespace' setting:
      --
      -- #!/bin/bash
      -- NVIM_APPNAME="nvim-Lazyman" \
      --   nvim -l ~/.config/nvim-Lazyman/scripts/get_conf.lua namespace
      --
      -- or, to retrieve the value of the 'mouse' option in the Webdev config:
      --
      -- #!/bin/bash
      -- NVIM_APPNAME="nvim-Webdev" \
      --   nvim -l ~/.config/nvim-Lazyman/scripts/get_conf.lua mouse
      
      local config = vim.inspect(_G.arg[1])
      local arg = string.gsub(config, '"', "")
      local app_name = os.getenv("NVIM_APPNAME") or ""
      
      local function get_var(var_name, default_value)
        local s, v = pcall(function()
          return vim.api.nvim_get_option(var_name)
        end)
        if s then
          return v
        else
          s, v = pcall(function()
            return vim.api.nvim_get_var(var_name)
          end)
          if s then
            return v
          else
            return default_value
          end
        end
      end
      
      local function print_var(entry)
        if type(entry) == "string" then
          io.write(entry .. "\n")
        elseif type(entry) == "table" then
          table.sort(entry)
          for _, val in ipairs(entry) do
            io.write(val .. "\n")
          end
        else
          io.write(tostring(entry) .. "\n")
        end
      end
      
      if arg == "config_home" then
        local config_home = vim.fn.stdpath("config")
        io.write("Neovim configuration location = " .. vim.fn.expand(config_home) .. "\n")
        io.write("NVIM_APPNAME = " .. app_name .. "\n")
      else
        local var_val = ""
        if app_name == "nvim-Lazyman" then
          local settings = require("configuration")
          local entry = settings[arg]
          if entry ~= nil then
            print_var(entry)
          else
            var_val = get_var(arg, "")
            print_var(var_val)
          end
        else
          var_val = get_var(arg, "")
          print_var(var_val)
        end
      end
      
    end,
  },
  {
    "NormalNvim/NormalNvim",
  },
  {
    "chrisgrieser/nvim-kickstart-python",
  },
  {
    "mrcjkb/kickstart-nix.nvim",
  },
  {
    "drybalka/clean.nvim",
  },
  {
    "StratOS-Linux/StratVIM",
  },
  {
    "Shaobin-Jiang/IceNvim",
  },
  {
    "ayamir/nvimdots",
  },
  {
    "adoyle-h/one.nvim",
    config = function()
      
      require('one').setup { plugins = { 'noice', disable = true } }
      
      
      require('one').setup {}
      
      
      require('one').setup {
        config = {
          pluginManager = { use = 'lazy' }, -- Default to 'lazy'. Available value: lazy' or 'local'
        },
      }
      
    end,
  },
  {
    "MordechaiHadad/bob",
  },
  {
    "NTBBloodbath/nvenv",
  },
  {
    "y3owk1n/nvs",
  },
  {
    "gennaro-tedesco/boilit",
  },
  {
    "m00qek/plugin-template.nvim",
  },
  {
    "ellisonleao/nvim-plugin-template",
  },
  {
    "2KAbhishek/template.nvim",
    config = function()
      
      -- Lazy
      {
          '2kabhishek/template.nvim',
          cmd = { 'Template' },
          keys = { '<leader>th', '<leader>tH', },
          -- Add your custom configs here, keep it blank for default configs (required)
          opts = {},
          -- Use this for local development
          -- dir = '~/path-to/template.nvim',
      },
      
      
      template.setup({
          name = 'template.nvim', -- Name to be greeted, 'World!' by default
          add_default_keybindings = true, -- Whether to add default keybindings
      })
      
    end,
  },
  {
    "jkeresman01/spring-initializr.nvim",
    config = function()
      
      use {
        'jkeresman01/spring-initializr.nvim',
        requires = {
          'nvim-lua/plenary.nvim',
          'MunifTanjim/nui.nvim',
          'nvim-telescope/telescope.nvim'
        }
      }
      
      
      {
        'jkeresman01/spring-initializr.nvim',
        dependencies = {
          'nvim-lua/plenary.nvim',
          'MunifTanjim/nui.nvim',
          'nvim-telescope/telescope.nvim',
        },
        config = function()
          require('spring-initializr').setup()
        end
      }
      
      
      require("spring-initializr").setup()
      
      vim.keymap.set("n", "<leader>si", "<CMD>SpringInitializr<CR>")
      vim.keymap.set("n", "<leader>sg", "<CMD>SpringGenerateProject<CR>")
      
    end,
  },
  {
    "chrisgrieser/alfred-neovim-utilities",
  },
  {
    "massix/termux.nvim",
    config = function()
      
      return {
        {
          "massix/termux.nvim",
          dependencies = {
            { "nvim-lua/plenary.nvim" },
          },
          opts = {},
          event = "VimEnter",
        },
      }
      
      
      {
        battery = {
          enabled = true,
          refresh_rate = 30, -- refresh rate in seconds
          -- The following settings are used to configure the statusline string,
          -- you can ignore them if you are building your own string.
          print_percentage = true,
          icons = {
            empty = "  ",
            oneq = "  ",
            half = "  ",
            threeq = "  ",
            full = "  ",
            charging = "󰉁 ",
            wireless = "󰠕  ",
          },
        },
        volume = {
          enabled = true,
          refresh_rate = 10, -- refresh rate in seconds
          -- The following settings are used to configure the statusline string,
          -- you can ignore them if you are building your own string.
          streams = { "music", "ring", "notification", "system", "call" },
          icons = {
            call = "󱡏  ",
            system = "  ",
            ring = "󱆫  ",
            music = "  ",
            alarm = "󰀠  ",
            notification = "  ",
          },
        },
      }
      
      
      require("termux").setup({ volume = { enabled = false }})
      
      
      _G.termux_values = {
        battery = {
          percentage = 0,
          status = "DISCHARGING",
          health = "GOOD",
          plugged = false,
          temperature = 25.5,
          wireless = false,
        },
        volumes = {
          call = {
            stream = "call",
            volume = 0,
            max_volume = 7,
          },
          system = {
            stream = "system",
            volume = 0,
            max_volume = 7,
          },
          ring = {
            stream = "ring",
            volume = 0,
            max_volume = 7,
          },
          music = {
            stream = "music",
            volume = 0,
            max_volume = 25,
          },
          alarm = {
            stream = "alarm",
            volume = 0,
            max_volume = 7,
          },
          notification = {
            stream = "notification",
            volume = 0,
            max_volume = 7,
          },
        },
      
      
        {
          "nvim-lualine/lualine.nvim",
          event = "VeryLazy",
          opts = {
            sections = {
              lualine_x = {
                -- Volume information
                {
                  function()
                    return require("termux").get_volume_statusline()
                  end,
                },
                -- Battery information
                {
                  function()
                    return require("termux").get_battery_statusline()
                  end,
                },
              },
            },
          },
        },
      
      
      local termux = require("termux")
      
    end,
  },
  {
    "m15a/flake-awesome-neovim-plugins",
  },
  {
    "nvim-lua/wishlist",
  },
  {
    "neovim/neovim/wiki/Related-projects#gui",
  },
  {
    "tokiory/neovim-boilerplate",
  },
  {
    "frans-johansson/lazy-nvim-starter",
  },
  {
    "akrawchyk/awesome-vim#tools",
  },
  {
    "altermo/vim-plugin-list",
  },
  {
    "Weyaaron/nvim-training",
  },
}

})
